<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="devops,"><meta name="description" content="¶一、简介Docker 是一个开源的应用容器引擎，它是由 Go 语言 开发实现的轻量级容器技术，它是基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。官网：https:&#x2F;&#x2F;www.docker.com中文网：https:&#x2F;&#x2F;doc"><meta property="og:type" content="article"><meta property="og:title" content="Docker学习笔记"><meta property="og:url" content="https://www.qcmoke.cn/devops/docker.html"><meta property="og:site_name" content="Qcmoke&#39;s Blog"><meta property="og:description" content="¶一、简介Docker 是一个开源的应用容器引擎，它是由 Go 语言 开发实现的轻量级容器技术，它是基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。官网：https:&#x2F;&#x2F;www.docker.com中文网：https:&#x2F;&#x2F;doc"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="og:image" content="https://www.qcmoke.cn/images/loading-post.gif"><meta property="article:published_time" content="2020-02-15T00:51:47.000Z"><meta property="article:modified_time" content="2024-07-29T14:00:48.232Z"><meta property="article:author" content="Qcmoke"><meta property="article:tag" content="devops"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.qcmoke.cn/images/loading-post.gif"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.qcmoke.cn/devops/docker.html"><title>Docker学习笔记 | Qcmoke's Blog</title><meta name="generator" content="Hexo 4.2.1"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Qcmoke's Blog</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Peace & Love ! Learning to think independently !</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-热文"><a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-fire"></i><br>热文</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br>友链</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.qcmoke.cn/devops/docker.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Qcmoke"><meta itemprop="description" content=""><meta itemprop="image" content="/images/logo.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Qcmoke's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Docker学习笔记</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-15T08:51:47+08:00">2020-02-15 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2024-07-29T22:00:48+08:00">2024-07-29 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/devops/" itemprop="url" rel="index"><span itemprop="name">devops</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/devops/docker.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/devops/docker.html" itemprop="commentCount"></span> </a></span><span id="/devops/docker.html" class="leancloud_visitors" data-flag-title="Docker学习笔记"><span class="post-meta-divider">|</span> <span class="lv-inline-block" style="display:inline-block"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">19.7k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">81</span></div></div></header><div class="post-body" itemprop="articleBody"><img src="/devops/../images/loading-post.gif" data-original="docker/Moby-logo.png" width="20%" align="middle"><h2 id="一-简介"><a class="header-anchor" href="#一-简介">¶</a>一、简介</h2><p><strong>Docker</strong> 是一个开源的应用容器引擎，它是由 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发实现的轻量级容器技术，它是基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。</p><blockquote><ul><li>官网：<a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a></li><li>中文网：<a href="https://dockerdocs.cn" target="_blank" rel="noopener">https://dockerdocs.cn</a></li><li>Docker Hub（Docker 镜像仓库）：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li></ul></blockquote><p><img src="/devops/../images/loading-post.gif" data-original="docker/docker-on-linux.png" alt="Docker 架构"></p><h2 id="二-概念"><a class="header-anchor" href="#二-概念">¶</a>二、概念</h2><h3 id="1-概要理解"><a class="header-anchor" href="#1-概要理解">¶</a>1. 概要理解</h3><p>Docker支持安装各种软件并做好配置后编译成镜像，最终可以直接运行镜像产生一个或多个运行于宿主机内核上的容器。为了形象的理解容器，可以简单的理解它为运行在操作系统上的独立沙箱系统，这些沙箱系统内部的文件系统和Linux的非常相似，事实上确是如此，因为Docker就是融合了Linux内核而实现的虚拟化技术，由于具有沙箱的特性，所以各个容器之间是隔离运行的、独立的、互不影响的，程序员甚至不用担心容器内部损坏或者崩溃导致宿主机出错，因为只要删除掉这些有问题的容器，而再运行相关的镜像又会得到全新的容器了，只要不进行数据挂载，整个过程甚至干净不留残余。</p><h3 id="2-核心内容"><a class="header-anchor" href="#2-核心内容">¶</a>2. 核心内容</h3><p>docker主机(Host)：或者称为docker宿主机，即安装了Docker程序的机器。</p><p>docker客户端(Client)：连接docker主机进行操作的程序。</p><p>docker镜像(Images)：是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>docker容器(Container)：运行镜像后产生的实例称为容器，实质是运行于独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>的进程。</p><p>docker仓库(Registry)：集中存储、分发镜像的仓库服务系统，作用是允许用户上传、下载并管理镜像，包括公有仓库和私有仓库。</p><p><img src="/devops/../images/loading-post.gif" data-original="docker/20180303165113.png" alt="20180303165113"></p><h3 id="3-对比传统虚拟机"><a class="header-anchor" href="#3-对比传统虚拟机">¶</a>3. 对比传统虚拟机</h3><table><thead><tr><th>特性</th><th>虚拟机的架构</th><th>容器的架构</th></tr></thead><tbody><tr><td>启动</td><td>分钟级</td><td>秒级</td></tr><tr><td>性能</td><td>弱于原生</td><td>接近原生</td></tr><tr><td>硬盘使用</td><td>一般为GB</td><td>一般为MB</td></tr><tr><td>系统支持量</td><td>一般几十个</td><td>单机上千个容器</td></tr></tbody></table><p><strong>虚拟机的架构：</strong> 每个虚拟机都包括应用程序、必要的二进制文件和库以及一个完整的客户操作系统(Guest OS)，尽管它们被分离，它们共享并利用主机的硬件资源，将近需要十几个 GB 的大小。</p><p><strong>容器的架构：</strong> 容器包括应用程序及其所有的依赖，但与其他容器共享内核。它们以独立的用户空间进程形式运行在宿主机操作系统上。他们也不依赖于任何特定的基础设施，Docker 容器可以运行在任何计算机上，任何基础设施和任何云上。</p><img src="/devops/../images/loading-post.gif" data-original="docker/virtualization.png"> <img src="/devops/../images/loading-post.gif" data-original="docker/docker.png"><h3 id="4-优势"><a class="header-anchor" href="#4-优势">¶</a>4. 优势</h3><p>（1）快速的启动时间</p><p>由于Docker容器直接运行于宿主内核，无需启动完整的操作系统即可运行，因此可以做到秒级、甚至毫秒级的启动时间，这大大的节约了开发、测试、部署的时间。</p><p>（2）一致的运行环境</p><p>开发过程中一个常见的问题是环境一致性问题。由于不同物理机的开发环境不一致，经常出现安装了相同的软件但却有不同的运行效果现象，甚至有的环境下还会出现bug。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，以至于不会再出现 “这段代码在我机器上没问题啊” 这类的问题。</p><p>（3）持续交付和部署</p><p>Docker可以一次创建或配置镜像，而可以在任意地方正常运行。即&quot;一处构建，到处运行&quot;。</p><p>（4）更方便的迁移</p><p><code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p>（5）更轻量的维护和扩展</p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="5-分层存储"><a class="header-anchor" href="#5-分层存储">¶</a>5. 分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="6-容器存储层"><a class="header-anchor" href="#6-容器存储层">¶</a>6. 容器存储层</h3><p>镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><h3 id="7-数据卷"><a class="header-anchor" href="#7-数据卷">¶</a>7. 数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，当容器内部的目录(文件)映射到宿主机的某目录(文件)时，那么就称这个宿主机的目录(文件)为数据卷。它绕过 UFS，可以提供很多有用的特性，如下：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="三-docker-安装和维护"><a class="header-anchor" href="#三-docker-安装和维护">¶</a>三、Docker 安装和维护</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版，EE 即企业版，强调安全，付费使用。</p><h3 id="1-包管理器安装-docker"><a class="header-anchor" href="#1-包管理器安装-docker">¶</a>1. 包管理器安装 Docker</h3><blockquote><p>说明：下面以使用 CentOS7 的 Yum 包管理器安装 Docker 为例进行讲解，其他 Linux 发行版包管理器的安装说明可参考：<a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/</a></p></blockquote><h4 id="1-安装旧版本-不推荐"><a class="header-anchor" href="#1-安装旧版本-不推荐">¶</a>1）安装旧版本（不推荐）</h4><p>CentOS7 从默认的 Yum 源中安装的 Docker 版本是旧版本，旧版本的 Docker 称为 docker 或 docker-engine ，由于目前官方不在维护，故建议跳过以下去安装新版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查内核版本，必须是3.10及以上</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">yum install docker -y</span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#开机启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment">#查看docker版本，验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><h4 id="2-安装新版本"><a class="header-anchor" href="#2-安装新版本">¶</a>2）安装新版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#卸载旧版本，如果已安装这些程序，请卸载它们以及相关的依赖项</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                                 </span><br><span class="line"><span class="comment">#安裝Docker源</span></span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="comment">#yum install yum-utils -y</span></span><br><span class="line"><span class="comment">#yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看可安装的docker版本</span></span><br><span class="line">yum list docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装docker-ce。</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"><span class="comment">#选择指定版本Docker安装</span></span><br><span class="line"><span class="comment">#yum install -y --setopt=obsoletes=0 docker-ce-&lt;version&gt;</span></span><br><span class="line"><span class="comment">#如：yum install -y --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看docker版本，验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动并加入开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><blockquote><p>更多内容：</p><p>查看所有仓库中所有docker版本：<code>yum list docker-ce --showduplicates | sort -r</code></p><p>安装指定版本：比如<code>yum install docker-ce-17.12.0.ce</code></p></blockquote><p>新版docker安装好后命令自动补全会有些缺失，所以可以选择安装命令补全依赖工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker自动补齐需要依赖工具bash-complete，安装好后会得到文件为 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">yum install -y bash-completion</span><br><span class="line"><span class="comment">#apt install -y bash-completion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#装好docker自动补齐依赖之后，要刷新下才能让其生效</span></span><br><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/bash_completion</span><br><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/completions/docker</span><br></pre></td></tr></table></figure><h4 id="3-内网环境集群安装"><a class="header-anchor" href="#3-内网环境集群安装">¶</a>3）内网环境集群安装</h4><h5 id="1-yum离线安装"><a class="header-anchor" href="#1-yum离线安装">¶</a>（1）yum离线安装</h5><p>如果内网中有一台服务器能够访问外网，可使用一下方式安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在内网中可访问外网的服务器中下载清华的镜像源文件（要求这台服务器依软件赖环境纯净，最好没有安装过任何软件。目的是这台服务器的所有软件依赖一定要在其他内网服务器中都存在。）</span></span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+'</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum list docker-ce --showduplicates|sort -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载docker安装的所有依赖到/tmp/docker-19.03目录</span></span><br><span class="line">yum install --downloadonly --downloaddir=/tmp/docker-19.03 docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制下载好的/tmp/docker-19.03到目标服务器(比如192.168.0.13)</span></span><br><span class="line">scp -r /tmp/docker-19.03/ root@192.168.0.13:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录进目标服务器之后进入文件夹安装</span></span><br><span class="line">ssh root@192.168.0.13</span><br><span class="line"><span class="built_in">cd</span> /tmp/docker-19.03/</span><br><span class="line">yum install *.rpm</span><br><span class="line"><span class="comment">#启动并加入开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h5 id="2-完全离线安装"><a class="header-anchor" href="#2-完全离线安装">¶</a>（2）完全离线安装</h5><p>如果内网中所有服务器都不能访问外网，可使用一下方式安装：</p><p><strong>下载安装包</strong></p><p>在客户机中访问docker官网下载安装包：</p><p>安装包各版本下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdownload.docker.com%2Flinux%2Fstatic%2Fstable%2Fx86_64%2F" target="_blank" rel="noopener">https://download.docker.com/linux/static/stable/x86_64/</a></p><p>这里下载的版本是：<a href="https://download.docker.com/linux/static/stable/x86_64/docker-19.03.5.tgz" target="_blank" rel="noopener">https://download.docker.com/linux/static/stable/x86_64/docker-19.03.5.tgz</a></p><p><strong>安装运行</strong></p><p>下载好安装包后通过ftp等客户端工具上传安装包到目标服务器，然后通过ssh客户端工具登录到该目标服务器执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压安装压缩包</span></span><br><span class="line">tar xzvf docker-19.03.5.tgz</span><br><span class="line"><span class="comment">#拷贝安装</span></span><br><span class="line">cp docker/* /usr/bin/</span><br><span class="line"><span class="comment">#运行服务</span></span><br><span class="line">dockerd &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止服务启动</span></span><br><span class="line">ps -ef|grep dockerd</span><br><span class="line"><span class="built_in">kill</span> -9 1958 <span class="comment">#这里的1958改成ps出来的pid</span></span><br></pre></td></tr></table></figure><p><strong>配置开机启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭selinux策略</span></span><br><span class="line">vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启系统</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>配置docker.socket</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/docker.socket</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=Docker Socket <span class="keyword">for</span> the API</span><br><span class="line"></span><br><span class="line">PartOf=docker.service</span><br><span class="line"></span><br><span class="line">[Socket]</span><br><span class="line"></span><br><span class="line"><span class="comment"># If /var/run is not implemented as a symlink to /run, you may need to</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specify ListenStream=/var/run/docker.sock instead.</span></span><br><span class="line"></span><br><span class="line">ListenStream=/run/docker.sock</span><br><span class="line"></span><br><span class="line">SocketMode=0660</span><br><span class="line"></span><br><span class="line">SocketUser=root</span><br><span class="line"></span><br><span class="line">SocketGroup=docker</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy=sockets.target</span><br></pre></td></tr></table></figure><p>配置docker.service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/docker.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line"></span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line"></span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line"></span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type=notify</span><br><span class="line"></span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line"></span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line"></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line"></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line"></span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment TasksMax if your systemd version supports it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only systemd 226 and above support this version.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TasksMax=infinity</span></span><br><span class="line"></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># set delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line"></span><br><span class="line">Delegate=yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># kill only the docker process, not all processes in the cgroup</span></span><br><span class="line"></span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line"><span class="comment"># restart the docker process if it exits prematurely</span></span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">StartLimitBurst=3</span><br><span class="line"></span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h4 id="4-参考"><a class="header-anchor" href="#4-参考">¶</a>4）参考</h4><blockquote><ul><li><a href="https://docs.docker.com/engine/install/centos" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos</a></li></ul></blockquote><h3 id="2-一键脚本安装-docker"><a class="header-anchor" href="#2-一键脚本安装-docker">¶</a>2. 一键脚本安装 Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用官方源安装（国内直接访问较慢）</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash</span><br><span class="line"><span class="comment">#使用阿里源安装</span></span><br><span class="line"><span class="comment">#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span></span><br><span class="line"><span class="comment">#使用中国区Azure源安装</span></span><br><span class="line"><span class="comment">#curl -fsSL https://get.docker.com | bash -s docker --mirror AzureChinaCloud</span></span><br><span class="line"><span class="comment">#指定特定版本安装</span></span><br><span class="line"><span class="comment">#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun --version 18.06.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment">#启动Docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><ul><li><a href="https://github.com/docker/docker-install" target="_blank" rel="noopener">https://github.com/docker/docker-install</a></li><li><a href="https://www.vps69.com/posts/install-docker/" target="_blank" rel="noopener">https://www.vps69.com/posts/install-docker/</a></li></ul></blockquote><h3 id="3-配置-docker-的镜像源"><a class="header-anchor" href="#3-配置-docker-的镜像源">¶</a>3. 配置 Docker 的镜像源</h3><p>鉴于国内网络问题，Docker 的默认镜像源拉取 Docker 镜像十分缓慢，我们可以配置国内的镜像源来加速镜像下载（可以配置多个镜像源）。</p><blockquote><ul><li><p><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></p></li><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></p></li><li><p><a href="https://www.163yun.com/help/documents/56918246390157312" target="_blank" rel="noopener">网易云加速器 <code>https://hub-mirror.c.163.com</code></a></p></li><li><p>Aliyun 的镜像（需要登录到阿里云后台获取，地址：<a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors%EF%BC%89" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors）</a></p><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216144500211.png" alt="image-20200216144500211"></p></li></ul><p>测速：<a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">https://github.com/docker-practice/docker-registry-cn-mirror-test/actions</a></p><p>Docker 的镜像源配置文件路径（如果文件不存则需要手动创建）：</p><ul><li>Linux： <code>/etc/docker/daemon.json</code></li><li>Windows：<code>%programdata%\docker\config\daemon.json</code></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span>,</span><br><span class="line">    <span class="string">"https://docker.mirrors.ustc.edu.cn"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启 docker 服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看 Docker 配置是否修改生效（其中 “Registry Mirrors” 即为 Docker 的镜像源）</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="4-配置-docker-的默认存储路径-可选"><a class="header-anchor" href="#4-配置-docker-的默认存储路径-可选">¶</a>4. 配置 Docker 的默认存储路径（可选）</h3><p>Docker 会使用 <code>/var/lib/docker/</code> 目录作为默认存储目录，用以存放拉取的镜像和创建容器等的相关文件。由于该目录通常都位于系统盘，如果系统盘比较小，而镜像和容器使用得越多就会占用越多的系统盘空间，当系统盘不够时就会比较尴尬了，故而可能需要通过数据盘来转移镜像和容器内容，这就可能需要修改 Docker 的默认存储目录。假设 <code>/data1</code> 目录挂载点的磁盘空间比较大，需要将其设置为 Docker 的默认存储路径，可如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data1/docker/lib</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://docker.mirrors.ustc.edu.cn"</span>,</span><br><span class="line">        <span class="string">"https://hub-mirror.c.163.com"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"data-root"</span>: <span class="string">"/data1/docker/lib"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启 Docker 服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看 Docker 配置是否修改生效（其中 “Docker Root Dir” 即为 Docker 的存储路径）</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="5-docker-服务管理"><a class="header-anchor" href="#5-docker-服务管理">¶</a>5. Docker 服务管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动docker服务（提示：docker即docker.service，启动服务后会自动启动docker网络套接字守护进程，即docker.socket）</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭docker服务</span></span><br><span class="line">	<span class="comment">#如果该命令无法停止服务（报错提示：Warning: Stopping docker.service, but it can still be activated by: docker.socket，这个问题通常是由于容器使用了 --restart always 等重启策略导致服务无法关闭，解决办法就是还需要关闭 docker.socket 网络套接字守护进程）</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment">#关闭docker网络套接字守护进程</span></span><br><span class="line">systemctl stop docker.socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启开机自启动docker服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment">#禁止开机自启动docker服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> docker</span><br></pre></td></tr></table></figure><h3 id="6-卸载-docker"><a class="header-anchor" href="#6-卸载-docker">¶</a>6. 卸载 Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##卸载准备（可选）</span></span><br><span class="line"><span class="comment">#停止并删除所有正在运行的 Docker 容器</span></span><br><span class="line">docker stop $(sudo docker ps -a -q)</span><br><span class="line">docker rm $(sudo docker ps -a -q)</span><br><span class="line"><span class="comment">#删除所有 Docker 镜像</span></span><br><span class="line">docker rmi $(sudo docker images -q)</span><br><span class="line"><span class="comment">#停止 Docker 服务</span></span><br><span class="line">systemctl stop docker.socket</span><br><span class="line">systemctl stop docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment">##（1）yum 卸载 Docker</span></span><br><span class="line"><span class="comment">#删除 Docker 安装包</span></span><br><span class="line">yum remove -y docker docker-ce docker-ce-cli containerd.io</span><br><span class="line">yum autoremove -y</span><br><span class="line"><span class="comment">#删除残余文件</span></span><br><span class="line">rm -rf /var/lib/docker <span class="comment">#含镜像、容器、配置文件等内容</span></span><br><span class="line">rm -rf /var/lib/containerd</span><br><span class="line">rm -rf /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#（2）apt 卸载 Docker</span></span><br><span class="line"><span class="comment">#删除 Docker 安装包</span></span><br><span class="line">apt purge -y docker docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#删除残余文件</span></span><br><span class="line">rm -rf /var/lib/docker <span class="comment">#含镜像、容器、配置文件等内容</span></span><br><span class="line">rm -rf /var/lib/containerd</span><br><span class="line">rm -rf /etc/docker</span><br></pre></td></tr></table></figure><h2 id="四-镜像管理"><a class="header-anchor" href="#四-镜像管理">¶</a>四、镜像管理</h2><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检索	(去https://hub.docker.com上查看镜像的详细信息。eg：docker search redis)</span></span><br><span class="line">docker  search 镜像关键字</span><br><span class="line"><span class="comment">#拉取	(name是镜像名，:tag是可选的，tag表示标签，多为软件的版本，默认是latest)</span></span><br><span class="line">docker pull name[:tag]</span><br><span class="line"><span class="comment">#列出	(查看所有本地镜像)</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#删除	(删除指定的本地镜像,image-id是镜像id)</span></span><br><span class="line">docker rmi image-id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器/镜像详细信息</span></span><br><span class="line">docker inspect image-name-or-id</span><br><span class="line"></span><br><span class="line"><span class="comment">#镜像导出</span></span><br><span class="line">docker save -o 打包文件名.tar 镜像id</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">docker save 镜像id &gt; 文件名.tar</span><br><span class="line"></span><br><span class="line"><span class="comment">#镜像导入</span></span><br><span class="line">docker load -i 打包文件名.tar</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">docker load &lt; 打包文件名.tar</span><br></pre></td></tr></table></figure><p>镜像导出并导入案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如，以下导出方式将会让docker load导入时的镜像没有名字(即&lt;none&gt;)</span></span><br><span class="line">docker save -o redis.tar 7864316753</span><br><span class="line"><span class="comment">#因此，推荐使用镜像的名字进行导出，此方式导入时就有镜像名称了</span></span><br><span class="line">docker save -o redis:5.0.2</span><br><span class="line"><span class="comment">#另外，如果已经是&lt;none&gt;的名称了，也可以通过以下命令重命名镜像名称</span></span><br><span class="line">docker tag [镜像id] [新镜像名称]:[新镜像标签]</span><br></pre></td></tr></table></figure><h2 id="五-容器管理"><a class="header-anchor" href="#五-容器管理">¶</a>五、容器管理</h2><h3 id="1-管理命令"><a class="header-anchor" href="#1-管理命令">¶</a>1. 管理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行并创建一个容器</span></span><br><span class="line">    <span class="comment">#-d：表示守护态运行，即后台状态运行</span></span><br><span class="line">    <span class="comment">#--name：给容器自定义命名</span></span><br><span class="line">    <span class="comment">#-p：表示端口映射</span></span><br><span class="line">    	<span class="comment">#格式：-p &lt;host&gt;:&lt;host_port&gt;:&lt;container_port&gt;/&lt;protocol&gt;</span></span><br><span class="line">            <span class="comment">#&lt;host&gt; 是指宿主机的IP地址（可以使用 0.0.0.0 表示监听所有网络接口）</span></span><br><span class="line">            <span class="comment">#&lt;host_port&gt; 是指宿主机上的端口，可指定为单个端口或者端口范围（如果不指定将自动映射到宿主机的一个随机端口）</span></span><br><span class="line">            <span class="comment">#&lt;container_port&gt; 是指容器内部的端口，可指定为单个端口或者端口范围</span></span><br><span class="line">            <span class="comment">#&lt;protocol&gt; 是要使用的传输协议，可指定为tcp或者udp（不指定默认为tcp）</span></span><br><span class="line">    	<span class="comment">#示例：-p 2222:22 -p 1194:1194/udp -p 127.0.0.1:8080:8080/tcp -p 9000-9100:9000:9100</span></span><br><span class="line">    <span class="comment">#--volume（-v）：数据卷或目录挂载，即挂载物理主机数据卷或者目录或文件到容器里</span></span><br><span class="line">    <span class="comment">#--restart：设置docker守护进程对容器的重启策略，可选值如下：</span></span><br><span class="line">    	<span class="comment">#no（默认）：容器退出后（无论是否正常退出），docker守护进程在重启时都不会自动启动该容器。</span></span><br><span class="line">    	<span class="comment">#always：容器退出后（无论是否正常退出），docker守护进程在重启时都会自动启动该容器。（提示：docker stop 关闭容器后并不会执行重启策略，仅是docker守护进程重启时，重启策略才会发挥作用）</span></span><br><span class="line">    	<span class="comment">#on-failure[:max-retries]：容器在非正常退出时（退出状态码不等于0，如：强制关机导致容器异常退出、手动关闭容器但容器且异常退出、容器内部程序执行错误导致异常退出等），docker守护进程在重启时会自动启动该容器。参数使用如：--restart=on-failure，可选地指定 max-retries 参数来限制最大重试次数。例如，--restart=on-failure:3 表示容器最多会重试 3 次，如果在重试次数耗尽之后容器仍然无法正常运行，它将停止。</span></span><br><span class="line">    	<span class="comment">#unless-stopped：容器在非正常退出时，除非手动关闭，docker守护进程将在重启时会自动启动该容器。</span></span><br><span class="line">    	<span class="comment">#补充说明：对于开机自启动的情况，可选 always 或 unless-stopped</span></span><br><span class="line">docker run -d --name 容器名称 -p 主机端口:容器端口 -v 主机目录路径:容器目录路径  镜像名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭容器</span></span><br><span class="line">docker stop 容器名称/容器id</span><br><span class="line"><span class="comment">#启动已经关掉的容器</span></span><br><span class="line">docker start 容器名称/容器id</span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart 容器名称/容器id</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除指定容器</span></span><br><span class="line">docker rm 容器名称/容器id</span><br><span class="line"><span class="comment">#强制删除当前所有容器</span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示容器列表（默认只显示运行中的容器）</span></span><br><span class="line">docker ps</span><br><span class="line">docker ps -s <span class="comment">#-s：显示容器占用磁盘空间大小</span></span><br><span class="line"><span class="comment">#显示容器列表（所有，包括运行中和已停止的容器）</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 Docker 容器里的环境变量</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name_or_id&gt; env</span><br><span class="line"><span class="comment">#查看 Docker 容器里的指定环境变量</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name_or_id&gt; sh -c <span class="string">'echo $ENV_VARIABLE_NAME'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行容器内命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称或容器id  命令</span><br><span class="line"><span class="comment">#如：docker exec -it nginx  ip iddr</span></span><br><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称或容器id  bash</span><br><span class="line"><span class="comment">#从容器内部退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从主机拷贝文件到容器</span></span><br><span class="line">docker cp 主机文件或目录 容器名称或容器id:容器文件或目录</span><br><span class="line"><span class="comment">#从容器拷贝文件到主机</span></span><br><span class="line">docker cp 容器名称或容器id:容器文件或目录 主机文件或目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器/镜像详细信息</span></span><br><span class="line">docker inspect 容器名称/容器id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器运行日志</span></span><br><span class="line">docker logs 容器名称/容器id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器资源的使用情况，包括：CPU、内存、网络I/O、磁盘I/O 等资源占用情况</span></span><br><span class="line">docker stats</span><br><span class="line"></span><br><span class="line"><span class="comment">##通过runlike去查看一个容器的docker run启动参数</span></span><br><span class="line"><span class="comment"># 安装runlike安装包</span></span><br><span class="line">pip install runlike</span><br><span class="line"><span class="comment"># 可能需要退出终端会话重新连接才能生效</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 查看容器运行命令</span></span><br><span class="line">runlike -p &lt;container_name&gt;  <span class="comment"># 后面可以是容器名和容器id，-p参数是显示自动换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器导出和导入</span></span><br><span class="line"><span class="comment">#将容器导出为镜像包</span></span><br><span class="line">docker <span class="built_in">export</span> -o 镜像包名称.tar 容器名称或容器id</span><br><span class="line"><span class="comment">#将镜像包导入为镜像</span></span><br><span class="line">docker import 镜像包名称.tar 新镜像名称:新镜像标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改容器配置</span></span><br><span class="line">	<span class="comment">#注意只能修改一些配置项，并非所有配置都能修改，如数据卷、目录挂载等就修改不了</span></span><br><span class="line">	<span class="comment">#常见参数如下：</span></span><br><span class="line">        <span class="comment"># --cpu-shares=&lt;权重&gt;: 设置容器的 CPU 权重，影响 CPU 时间片的分配。（默认值为 1024，数值越高表示容器获得的 CPU 时间片越多）</span></span><br><span class="line">        <span class="comment"># --cpu-period=&lt;周期&gt;: 设置 CPU 周期，用于控制 CPU 时间片的周期。</span></span><br><span class="line">        <span class="comment"># --cpu-quota=&lt;配额&gt;: 设置 CPU 配额，限制 CPU 的使用。</span></span><br><span class="line">        <span class="comment"># --blkio-weight=&lt;权重&gt;: 设置块 I/O 权重，用于限制容器的磁盘 I/O。</span></span><br><span class="line">        <span class="comment"># --memory=&lt;内存限制&gt;: --memory可缩写-m，设置容器的内存限制。</span></span><br><span class="line">        <span class="comment"># --memory-swap=&lt;内存+交换限制&gt;: 设置内存加交换限制，控制内存和交换空间的使用。</span></span><br><span class="line">        <span class="comment"># --kernel-memory=&lt;内核内存限制&gt;: 设置容器可以使用的内核内存限制。</span></span><br><span class="line">        <span class="comment"># --restart=&lt;策略&gt;: 配置容器的重启策略。可选策略包括 no、on-failure、always、unless-stopped 等。</span></span><br><span class="line">docker update [OPTIONS] &lt;容器名称或ID&gt;</span><br><span class="line">    <span class="comment">#docker update --restart always &lt;容器名称或ID&gt;</span></span><br><span class="line">    <span class="comment">#docker update --restart=no &lt;容器名称或ID&gt;</span></span><br><span class="line">    <span class="comment">#docker update --cpu-shares 512 &lt;容器名称或ID&gt;</span></span><br><span class="line">    <span class="comment">#docker update -m 512M &lt;容器名称或ID&gt;</span></span><br></pre></td></tr></table></figure><p>容器导出和导入案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器</span></span><br><span class="line">docker run -itd --name centos7-test centos:centos7</span><br><span class="line"><span class="comment">#尝试修改容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7-test touch /tmp/<span class="built_in">test</span></span><br><span class="line"><span class="comment">#将容器导出为镜像包</span></span><br><span class="line">docker <span class="built_in">export</span> -o centos7-test.tar centos7-test</span><br><span class="line"><span class="comment">#将镜像包导入为镜像</span></span><br><span class="line">docker import centos7-test.tar centos7:centos7-test</span><br><span class="line"><span class="comment">#通过新镜像创建容器</span></span><br><span class="line">docker run -itd --name centos7-test2 centos7:centos7-test</span><br></pre></td></tr></table></figure><h3 id="2-设置容器与宿主机时间同步"><a class="header-anchor" href="#2-设置容器与宿主机时间同步">¶</a>2. 设置容器与宿主机时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##为了保证容器和宿主机之间的时间同步</span></span><br><span class="line"><span class="comment">#1、使用docker run运行容器时，添加如下参数-v /etc/localtime:/etc/localtime:ro  如下：</span></span><br><span class="line">docker run -it -v /etc/localtime:/etc/localtime:ro centos</span><br><span class="line"><span class="comment">#2、如果容器已经运行则可以如下操作：</span></span><br><span class="line">docker cp -L /usr/share/zoneinfo/Asia/Shanghai [容器名]:/etc/localtime</span><br></pre></td></tr></table></figure><h2 id="六-数据管理"><a class="header-anchor" href="#六-数据管理">¶</a>六、数据管理</h2><p>由于docker容器和宿主机系统是隔离的，这会带来下面几个问题：</p><ul><li>不能在宿主机上很方便地访问容器中的文件</li><li>无法在多个容器之间共享数据</li><li>当容器删除时，容器中产生的数据将丢失</li></ul><p>为了能够<strong>保存（持久化）<strong>数据以及</strong>共享</strong>容器间的数据，docker 引入了数据卷(volume) 机制。数据卷是存在于一个或多个容器中的特定文件或文件夹，它可以绕过默认的联合文件系统，以正常的文件或者目录的形式存在于宿主机上。生存周期独立于容器的生存周期的，所以删除容器后数据卷并不会丢失。</p><p>容器中主要有<strong>两种</strong>管理数据方式：<strong>数据卷(Data Volumes)</strong>，<strong>数据卷容器(Data Volume Containers)</strong>。</p><h3 id="1-数据卷"><a class="header-anchor" href="#1-数据卷">¶</a>1. 数据卷</h3><p>数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：</p><p>（1）<code>数据卷</code> 可以在容器之间共享和重用</p><p>（2）对 <code>数据卷</code> 的修改会立马生效</p><p>（3）对 <code>数据卷</code> 的更新，不会影响镜像</p><p>（4）<code>数据卷</code> 默认会一直存在，即使容器被删除</p><p>数据卷的使用类似 linux 下对目录或文件进行 mount 操作，目前Docker提供了<strong>三种</strong>不同的方式将数据卷从宿主机挂载到容器中：</p><ul><li>数据卷挂载：volume mount</li><li>绑定挂载：bind mount</li><li><strong>tmpfs mount</strong></li></ul><p>其中<code>volume</code>、<code>bind mount</code>比较常用，<code>tmpfs mount</code>基本不会用.</p><h4 id="1-1-数据卷挂载"><a class="header-anchor" href="#1-1-数据卷挂载">¶</a>1.1 数据卷挂载</h4><p>数据卷挂载即将特定数据卷挂载到容器内部，数据卷挂载需要提前创建volume数据卷，然后再提供给容器绑定，新建的数据卷位于宿主机的<code>/var/lib/docker/volumes</code>目录里。这种挂载方式就是不需要手动指定宿主机目录并且能够通过docker volume命令来维护数据卷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据卷</span></span><br><span class="line">docker volume create 数据卷名</span><br><span class="line"><span class="comment">#显示数据卷的详细信息</span></span><br><span class="line">docker volume inspect 数据卷名</span><br><span class="line"><span class="comment">#列出所有的数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="comment">#删除未使用的数据卷（正被容器使用的数据卷无法删除）。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令</span></span><br><span class="line">docker volume rm 数据卷名</span><br><span class="line"><span class="comment">#删除所有未使用的数据卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行容器并挂载数据卷</span></span><br><span class="line"><span class="comment">#type：挂载类型，包括volume（默认）和bind。source：数据卷名称（数据卷不存在则自动创建，如果不指定数据卷则自动创建随机数名称的数据卷）</span></span><br><span class="line"><span class="comment">#可以将多个数据卷挂载给一个容器；可以将一个数据卷挂载给多个容器，但是都共同使用同一个宿主机的数据卷目录</span></span><br><span class="line">docker run -d --name 容器名称 --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=数据卷名,target=容器内部目录或文件绝对路径 镜像名称或id</span><br><span class="line"><span class="comment">#可以使用-v(--volume)来简写，数据卷不存在则自动创建，如果不指定数据卷（如-v 容器内部目录或文件绝对路径）则自动创建随机数名称的数据卷</span></span><br><span class="line">docker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径 镜像名称或id</span><br><span class="line"></span><br><span class="line"><span class="comment">##数据卷权限</span></span><br><span class="line"><span class="comment">#Docker挂载数据卷的默认权限是可读写rw，可以通过ro标记指定为只读，这样可以防止容器修改文件</span></span><br><span class="line"><span class="comment">#使用--mount时设置数据卷权限。不指定readonly则为读写</span></span><br><span class="line">docker run -d --name 容器名称 --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=数据卷名,target=容器内部目录或文件绝对路径,<span class="built_in">readonly</span> 镜像名称或id</span><br><span class="line"><span class="comment">#使用-v(--volume)时设置数据卷权限</span></span><br><span class="line">docker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径:rw 镜像名称或id</span><br><span class="line">docker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径:ro 镜像名称或id</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line">docker volume inspect my-vol </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2022-08-26T11:11:08+08:00"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,	<span class="comment">#local表示宿主机。配置为vieux/sshfs（需要安装插件）可以把数据卷存储到其他云主机去，这里不做过多介绍。</span></span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>, <span class="comment">#数据卷所在宿主机位置</span></span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">docker run -d --name nginx --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html nginx:1.22.0-alpine</span><br><span class="line"><span class="comment">#可以使用-v(--volume)来简写，如下：</span></span><br><span class="line"><span class="comment">#docker run -d --name nginx -v my-vol:/usr/share/nginx/html nginx:1.22.0-alpine</span></span><br></pre></td></tr></table></figure><h4 id="1-2-绑定挂载"><a class="header-anchor" href="#1-2-绑定挂载">¶</a>1.2 绑定挂载</h4><p>绑定挂载即直接将主机文件系统中的目录或文件挂载到容器内部的方式，没有涉及到数据卷管理。当你使用绑定挂载时，主机上的目录或文件会直接映射到容器内部的路径，它们之间的更改会实时同步。注意这种方式不能使用 <code>docker volume</code> 命令来维护挂载目录或文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用source表示自定义数据卷路径，source必须是绝对路径，且路径必须已经存在，否则报错</span></span><br><span class="line">docker run -d --name 容器名称 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=宿主机目录或文件绝对路径,target=容器内部目录或文件绝对路径 镜像名称或id</span><br><span class="line"><span class="comment">#可以使用-v(--volume)来简写，如下：</span></span><br><span class="line"><span class="comment">#--mount和-v(--volume)有个区别，就是使用-v宿主机目录或文件不存在也能自动创建，而使用--mount不存在则会运行失败</span></span><br><span class="line">docker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径 镜像名称或id</span><br><span class="line"></span><br><span class="line"><span class="comment">##挂载目录或文件的权限</span></span><br><span class="line"><span class="comment">#Docker挂载目录或文件的默认权限是rw（即可读写），可以通过ro标记指定为只读，这样可以防止容器修改宿主机的目录或文件</span></span><br><span class="line"><span class="comment">#可使用--mount时设置挂载目录的权限，如只读（readonly）。</span></span><br><span class="line">docker run -d --name 容器名称 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=宿主机目录或文件绝对路径,target=容器内部目录或文件绝对路径,<span class="built_in">readonly</span> 镜像名称或id</span><br><span class="line"><span class="comment">#使用-v(--volume)时设置数据卷权限</span></span><br><span class="line">docker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径:rw 镜像名称或id</span><br><span class="line">docker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径:ro 镜像名称或id</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/nginx</span><br><span class="line">docker run -d --name nginx --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/opt/nginx,target=/usr/share/nginx/html nginx:1.22.0-alpine</span><br><span class="line"><span class="comment">#docker run -d --name nginx -v /opt/nginx:/usr/share/nginx/html nginx:1.22.0-alpine</span></span><br></pre></td></tr></table></figure><h3 id="2-数据卷容器"><a class="header-anchor" href="#2-数据卷容器">¶</a>2. 数据卷容器</h3><p>数据卷不仅可以设置在宿主机，同样也可以设置在其他容器中。这样即使容器挂掉或者被删除，也不会影响数据卷容器里已经同步的数据，同样的数据卷容器挂掉或者被删除也不会影响容器的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据卷容器</span></span><br><span class="line">docker run -d -v 数据卷名称或者宿主机目录或文件:容器目录或文件 --name=数据卷容器名称 镜像名称[:版本号]或ID</span><br><span class="line"><span class="comment">#挂载数据卷容器给其他容器</span></span><br><span class="line">docker run -d --name=容器名称 --volumes-from 数据卷容器名称或ID 镜像名称[:版本号]或ID</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-backup  -v /opt/data:/opt/data nginx:1.22.0-alpine</span><br><span class="line">docker run -d --name nginx --volumes-from nginx-backup  nginx:1.22.0-alpine</span><br><span class="line">docker <span class="built_in">exec</span> -it nginx touch /opt/data/test.txt</span><br><span class="line">docker rm -f nginx</span><br><span class="line">docker <span class="built_in">exec</span> -it nginx-backup ls /opt/data</span><br></pre></td></tr></table></figure><h2 id="七-docker-网络"><a class="header-anchor" href="#七-docker-网络">¶</a>七、Docker 网络</h2><p>Docker默认提供了3种网络模式，生成容器时不指定网络模式下默认使用bridge桥接模式。</p><h3 id="1-host-模式"><a class="header-anchor" href="#1-host-模式">¶</a>1. host 模式</h3><p>容器不会创建自己的网卡，配置 IP 等，而是使用宿主机的 IP 和端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name 容器名称 --net=host   镜像名称</span><br></pre></td></tr></table></figure><h3 id="2-container-模式"><a class="header-anchor" href="#2-container-模式">¶</a>2. container 模式</h3><p>容器不会创建自己的网卡，配置 IP 等，而是和一个指定的容器共享 IP和端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name 容器名称 --net=container:容器名称或容器id   镜像名称</span><br></pre></td></tr></table></figure><h3 id="3-none-模式"><a class="header-anchor" href="#3-none-模式">¶</a>3. none 模式</h3><p>关闭网络功能，不进行任何网络设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name 容器名称 --net=none   镜像名称</span><br></pre></td></tr></table></figure><h3 id="4-bridge-模式-默认模式"><a class="header-anchor" href="#4-bridge-模式-默认模式">¶</a>4. bridge 模式（默认模式）</h3><p>为每一个容器分配、设置 IP 等，并将容器连接到 <code>docker0</code> 虚拟网桥上，这是 <code>docker run</code> 创建容器时使用的默认模式。</p><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥（网卡/路由器），此主机上启动的Docker容器都会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>宿主机和Docker容器之间是可以进行网络连接的，同样的，Docker容器和容器之间只要是在一个虚拟网桥下，那么也可以直接进行网络连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过--net=bridge显示指定，默认就是bridge，也可以不设置</span></span><br><span class="line">docker run -d --name 容器名称 --net=bridge   镜像名称</span><br></pre></td></tr></table></figure><h3 id="5-自定义网络"><a class="header-anchor" href="#5-自定义网络">¶</a>5. 自定义网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##自定义创建名称为mynet的网络</span></span><br><span class="line"><span class="comment">#--driver bridge 桥接模式</span></span><br><span class="line"><span class="comment">#--subnet 192.168.0.0/16  子网掩码（网段）的主机IP可选范围为：192.168.0.1-192.168.255.254</span></span><br><span class="line"><span class="comment">#--gateway 192.168.0.1 网关</span></span><br><span class="line"><span class="comment">#其中192.168.0.1被设置为网关（即宿主机的虚拟网卡IP），故容器主机IP的可选范围为：192.168.0.2-192.168.255.254</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除网络</span></span><br><span class="line">docker network rm mynet</span><br><span class="line"><span class="comment">#删除主机上全部未使用的网络</span></span><br><span class="line">docker network prune</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前Docker所有的网络模式</span></span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看自定义网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过--net在启动容器时指定自定义网络</span></span><br><span class="line">docker run -d --name 容器名称 --net mynet   镜像名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#不同Docker网络之间的容器想要连接的话，需要把该容器注册到另一个容器所在的网络上</span></span><br><span class="line"><span class="comment">#如下假设centos01容器本来在默认的bridge（docker0）上，想要让其和mynet网络下的容器互通，则需要把centos01注册到mynet中。</span></span><br><span class="line"><span class="comment">#成功注册到mynet网络后，docker将会在centos01中创建一个网卡并且分配一个mynet网段内的IP，并且将新ip-主机名映射加入自己的hosts中</span></span><br><span class="line">docker network connect mynet centos01</span><br></pre></td></tr></table></figure><blockquote><ul><li>默认docker0是无法Ping通容器名，而自定义网络可以Ping通容器名。</li><li>在多个微服务部署到docker时，通过自定义网络方便统一的网络配置。</li></ul></blockquote><h3 id="6-多个容器之间通过容器名称互相访问"><a class="header-anchor" href="#6-多个容器之间通过容器名称互相访问">¶</a>6. 多个容器之间通过容器名称互相访问</h3><p><code>docker run</code> 创建容器时默认使用的是 docker0 网络，容器可以通过另一个容器的 ip 来访问其他容器主机，但是没法通过容器 id 或者主机名来访问，因为容器的 hosts 文件中默认只有容器自己的 <code>ip-主机名</code>映射，而没有其他容器的。为了能够通过容器名称来访问其他容器，可以在容器的 hosts 文件中配置其他容器的 <code>ip-主机名</code>映射，这个过程可以使用 <code>docker exec</code> 命令进入容器内手动修改 hosts 文件实现，但这种方式会有点麻烦。还有另一解决方式是在 <code>docker run</code> 创建容器的时候通过指定 <code>--link</code> 参数来配置其他容器的<code>ip-主机名</code>映射。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建centos02容器，并在其内部hosts中加入centos01容器的ip-主机名映射。</span></span><br><span class="line">docker run -d  -it --name centos02 --link centos01容器的 centos:centos7</span><br></pre></td></tr></table></figure><blockquote><p><code>docker run</code> 创建容器时会自动把分配到的的 ip 和 hostname（即主机名，默认为容器id）写入到容器的hosts文件中。其中 主机名可以在 <code>docker run</code> 时指定 <code>--hostname</code> 来修改。</p></blockquote><p>如上配置后就能让 centos02 能够访问到 centos01，但是 centos01 却不能访问 centos02，这是因为 centos01 的hosts 文件中没有加入 centos02 的 <code>ip - hostname</code>映射，除非使用 <code>docker exec</code> 命令进入 centos01 容器内修改其 hosts 文件，可见使用<code>--link</code> 参数配置的方式操作也很麻烦。</p><p>为了更加简便地实现 docker 中多个容器之间的互相访问，有一种更好的解决方案，那就是使用“docker自定义网络”，docker 自定义网络可以理解为“网卡”，docker 允许用户将多个容器配置到同一个自定义网络中，容器之间通过容器名称互相访问的时候，docker 将会根据自定义网络中的容器配置信息解析容器名称得到对应的 ip ，进而实现访问。</p><p>可以通过 <code>docker inspect 自定义网络名称</code> 命令来查看自定义网络中的容器配置信息，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"><span class="comment">#查看自定义网络配置</span></span><br><span class="line">docker inspect 自定义网络名称</span><br><span class="line"><span class="comment">#自定义网络中多个容器的配置信息如下：</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mynet"</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"0a348b84901337546e60bfcc7cd8592a81e244339337f1ceea9b578bba09d9dd"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"nginx2"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"867176b7354f17095eff8f5a047bbae062d3f80b4ad150f1711a13f0543ed549"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.4/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"6bfc4ad47e7f878f14b5fa1c3a59029fc6b50a1e04cdb946bd45de4e052a7416"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"nginx1"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"4498313ad280f9e15c86f5c756a66dbdb39982f8469be50c2761e058b333bb31"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.3/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"a29f5b6558b22bf557a2b997c3c03284f013bc75da89065a983a2452f27bee0c"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"nginx3"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"85e61dc0d27a7d2a7be14c11e6566656817693981ee22b277328ee3116aafef4"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将多个容器配置到同一个自定义网络中的操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个名称为mynet的自定义网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"><span class="comment">#使用默认bridge（docker0）网络创建centos01</span></span><br><span class="line">docker run -d --name centos01 centos:centos7</span><br><span class="line"><span class="comment">#使用自定义网络mynet创建centos02</span></span><br><span class="line">docker run -d --name centos02 --net mynet centos:centos7</span><br><span class="line">docker run -d --name centos01 centos:centos7</span><br><span class="line"><span class="comment">#使用自定义网络mynet创建centos03</span></span><br><span class="line">docker run -d --name centos03 --net mynet centos:centos7</span><br><span class="line"><span class="comment">#测试centos01是否连通到centos03情况（发现连通成功）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos01 ping centos03</span><br><span class="line"><span class="comment">#测试centos03是否连通到centos01情况（发现连通成功）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos03 ping centos01</span><br><span class="line"><span class="comment">#测试centos01是否连通到centos02情况（发现不通）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos01 ping centos02</span><br><span class="line"><span class="comment">#把该centos01注册到centos02所在的mynet网络上。</span></span><br><span class="line">docker network connect mynet centos01</span><br><span class="line"><span class="comment">#测试centos01是否连通到centos02情况（发现连通成功）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos01 ping centos02</span><br></pre></td></tr></table></figure><h3 id="7-查看容器ip"><a class="header-anchor" href="#7-查看容器ip">¶</a>7. 查看容器ip</h3><p>两种方式：</p><p>1、由于docker run创建容器时就会给容器分配ip等信息了，所以可以直接使用docker inspect命令来过滤数据获取。</p><p>2、通过docker exec命令进入容器内部在使用如ifconfig等方式查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##通过docker inspect查看容器ip</span></span><br><span class="line"><span class="comment">#查看容器ip</span></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> 容器名称或容器id</span><br><span class="line"><span class="comment">#显示所有容器 IP 地址</span></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment">##通过docker exec查看容器ip</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称或容器id  ifconfig</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称或容器id  ip iddr</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称或容器id cat /etc/hosts</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/CSDN1csdn1/article/details/123961079" target="_blank" rel="noopener">https://blog.csdn.net/CSDN1csdn1/article/details/123961079</a></p><h3 id="8-docker与防火墙"><a class="header-anchor" href="#8-docker与防火墙">¶</a>8. Docker与防火墙</h3><h4 id="1-bridge-网络模式的防火墙配置"><a class="header-anchor" href="#1-bridge-网络模式的防火墙配置">¶</a>1）bridge 网络模式的防火墙配置</h4><p>Docker 默认使用的是 bridge 网络模式，在创建容器时会自动为容器配置 iptables 规则以进行网络安全控制。具体来说，Docker 会在主机上创建一个名为 <code>docker0</code> 的虚拟网桥，并将容器连接到该网桥中。同时，它还会为每个容器分配一个随机的 IP 地址，并通过 NAT 的方式将容器和宿主机的 IP 地址进行映射。</p><blockquote><p>说明：</p><p>bridge 网络模式下，启动或停止 docker 容器时，docker 都会在 <code>iptables</code> 防火墙配置中自动创建或删除和容器相关的规则策略，而不需要人为手动进行配置。</p><p>由于 docker 使用的是<code>iptables</code> 命令维护防火墙配置，所以用户只能通过<code>iptables</code> 命令来查看 docker 相关的防火墙规则策略，而使用<code>firewall</code>、<code>ufw</code> 等上层防火墙工具则无法查看。</p></blockquote><h4 id="2-host-网络模式的防火墙配置"><a class="header-anchor" href="#2-host-网络模式的防火墙配置">¶</a>2）host 网络模式的防火墙配置</h4><p>当 Docker 使用 host 网络模式时，Docker 容器将直接使用宿主机的网络环境，包括 IP 和端口。此时 Docker 不会再为容器自动进行 iptables 配置，而是直接使用宿主机的防火墙规则。</p><h3 id="9-反向代理到容器"><a class="header-anchor" href="#9-反向代理到容器">¶</a>9. 反向代理到容器</h3><h4 id="1-简要概述"><a class="header-anchor" href="#1-简要概述">¶</a>1）简要概述</h4><p>使用一些反向代理服务（如：Nginx）可以将用户请求代理到容器内部的端口监听服务上，从而可以给 docker 容器做负载均衡、网络安全防护等，这些都是常见的运维需求。其中网络安全防护的一些具体需求如下：</p><blockquote><ul><li>（1）通过限制外网访问 docker 容器从而实现多个 docker 微服务容器之间可以在内网中互相访问，但不允许外网直接访问。</li><li>（2） docker 中的 HTTP 服务容器未进行 SSL 加密而直接提供外网访问是非常不安全的，一般做法是先配置 docker 容器禁止外网访问而只允许内网访问，再使用 nginx 通过反向代理转发外网的 HTTPS 请求给 docker 容器中的 HTTP 服务。</li></ul></blockquote><p>下面是以上需求的具体实现方案：</p><h4 id="2-限制外网访问-docker-容器"><a class="header-anchor" href="#2-限制外网访问-docker-容器">¶</a>2）限制外网访问 docker 容器</h4><p>方式1：使用默认的 bridge 网络模式创建 docker 容器并指定端口映射时限制访问 IP。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name 容器名称 -p 127.0.0.1:宿主机端口:容器端口  镜像名称</span><br></pre></td></tr></table></figure><blockquote><p>注意：docker会自动维护防火墙配置，通常不设置 ip 则容器对应的宿主机端口默认对所有 IP 访问不限制。</p><p>这种方式运行容器，容器程序的监听端口会占用宿主机的端口。</p></blockquote><p>方式2：使用 host 网络模式创建 docker 容器，让容器监听端口直接使用宿主机端口。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name 容器名称 --net=host  镜像名称</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用 host 网络模式创建 docker 容器时， docker 不会进行 iptables 自动配置，而是直接使用宿主机的防火墙规则。</p><p>这种方式运行容器，容器程序的监听端口会占用宿主机的端口。</p></blockquote><p>方式3：创建 docker 容器时不进行端口映射，而通过容器 IP 进行访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1：使用默认的bridge网络自动分配IP给容器（默认的bridge网络IP网段为172.17.0.0/16）</span></span><br><span class="line">docker run -d --name 容器名称 镜像名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2：手动指定一个自定义网络的固定IP给容器</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">docker run -d --name 容器名称 --net=mynet --ip 192.168.0.100 镜像名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器的ip</span></span><br><span class="line">docker inspect 容器名称或ID | grep IPAddress</span><br><span class="line"><span class="comment">#或者：docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' 容器名称或ID</span></span><br><span class="line"><span class="comment">#查看默认的bridge网络的ip网段</span></span><br><span class="line">docker network inspect bridge | grep Subnet</span><br></pre></td></tr></table></figure><blockquote><p>这种方式运行容器，容器程序的监听端口不会占用宿主机的端口。</p><p>注意：不能使用默认的 bridge 网络模式指定自定义 IP，否则会报错或设置无效。</p></blockquote><h4 id="3-通过nginx反向代理到docker的http服务容器"><a class="header-anchor" href="#3-通过nginx反向代理到docker的http服务容器">¶</a>3）通过nginx反向代理到docker的HTTP服务容器</h4><p>（1）配置 nginx SSL证书和反向代理，如下：</p><blockquote><p>配置nginx SSL证书并监听一个对外网访问的端口，并反向代理到docker容器的监听端口（设端口为：8080）</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment">#此处端口为nginx对外网暴露的端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/key.pem;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080; <span class="comment">#此处端口为docker的HTTP服务容器的监听端口</span></span><br><span class="line">        <span class="comment">#proxy_pass http://172.17.0.100:8080;</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">client_max_body_size</span> <span class="number">100m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>假设<code>docker run</code> 运行 http 容器时限制 ip 映射端口为 <code>-p 127.0.0.1:宿主机端口:容器端口</code>，那么可以代理到 <code>http://127.0.0.1:8080</code>。</li><li>而如果不进行端口映射，则可以通过命令 <code>docker inspect 容器名称或ID | grep IPAddress</code> 查看容器的 ip ，然后反向代理到对应的地址，如：<code>http://172.17.0.100:8080</code></li></ul></blockquote><p>（2）配置防火墙放行nginx对外网暴露的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##宿主机配置防火墙</span></span><br><span class="line"><span class="comment">#对于 UFW 防火墙：</span></span><br><span class="line">ufw allow 443/tcp</span><br><span class="line"><span class="comment">#对于 FirewallD 防火墙：</span></span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>最后外网访问的地址为：<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a>（即：<a href="https://example.com:443" target="_blank" rel="noopener">https://example.com:443</a>）</p></blockquote><h2 id="八-构建自定义镜像"><a class="header-anchor" href="#八-构建自定义镜像">¶</a>八、构建自定义镜像</h2><h3 id="方式1：上传程序到vps后构建"><a class="header-anchor" href="#方式1：上传程序到vps后构建">¶</a>方式1：上传程序到vps后构建</h3><p>需求：构建一个能在tomcat容器里运行的war包程序镜像，并通过镜像创建一个实例容器。</p><p>由于依赖于tomcat容器，故需要先拉去tomcat镜像到本地。tomcat镜像主页：<a href="https://c.163yun.com/hub#/library/repository/info?repoId=3105" target="_blank" rel="noopener">https://c.163yun.com/hub#/library/repository/info?repoId=3105</a></p><h4 id="1-拉取tomcat镜像到宿主机"><a class="header-anchor" href="#1-拉取tomcat镜像到宿主机">¶</a>（1）拉取tomcat镜像到宿主机</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/tomcat:latest</span><br></pre></td></tr></table></figure><h4 id="2-上传war包"><a class="header-anchor" href="#2-上传war包">¶</a>（2）上传war包</h4><p>创建一个webdemo项目，并在这个<code>webdemo</code>项目的资源路径里添加一个index.jsp页面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>然后打包得到<code>webdemo.war</code>文件。并上传这个<code>webdemo.war</code>文件到vps的<code>/root/project</code>目录</p><h4 id="3-编写dockerfile文件"><a class="header-anchor" href="#3-编写dockerfile文件">¶</a>（3）编写<code>Dockerfile</code>文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在/root/project下编写一个Dockerfile文件</span></span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#继承于某个镜像</span></span><br><span class="line"><span class="keyword">from</span> hub.c.<span class="number">163</span>.com/library/tomcat</span><br><span class="line"><span class="comment">#镜像所有者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> qcmoke qcmoke@gmail.com</span><br><span class="line"><span class="comment">#把程序copy到容器镜像当中，前面的参数是本地路径，后面的参数是容器镜像路径(可以到镜像主页得到tomcat的webapp路径)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /root/project /usr/<span class="built_in">local</span>/tomcat/webapps</span></span><br></pre></td></tr></table></figure><h4 id="4-构建生成镜像"><a class="header-anchor" href="#4-构建生成镜像">¶</a>（4）构建生成镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Dockerfile文件所在的目录，即/root/project里执行如下命令</span></span><br><span class="line">docker build -t webdemo:latest .</span><br></pre></td></tr></table></figure><h4 id="5-查看本地镜像仓库是否构建成功"><a class="header-anchor" href="#5-查看本地镜像仓库是否构建成功">¶</a>（5）查看本地镜像仓库是否构建成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED                  SIZE</span><br><span class="line">docker.io/tomcat               latest              aeea3708743f        Less than a second ago   529 MB</span><br><span class="line">webdemo                        latest              10f75818641a        46 seconds ago           310 MB</span><br></pre></td></tr></table></figure><h4 id="6-通过构建的镜像实例化一个容器并运行"><a class="header-anchor" href="#6-通过构建的镜像实例化一个容器并运行">¶</a>（6）通过构建的镜像实例化一个容器并运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 webdemo:latest</span><br></pre></td></tr></table></figure><h4 id="7-访问测试"><a class="header-anchor" href="#7-访问测试">¶</a>（7）访问测试</h4><p>访问index.jsp：<a href="http://192.168.222.131:8080/webdemo/index.jsp" target="_blank" rel="noopener">http://192.168.222.131:8080/webdemo/index.jsp</a></p><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200215111413522.png" alt="image-20200215111413522"></p><h4 id="8-其他"><a class="header-anchor" href="#8-其他">¶</a>（8）其他</h4><p>在用<code>-d</code>指定为后台启动的情况下，可以使用以下命令查看容器实时的日志情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器名称或者容器id</span><br></pre></td></tr></table></figure><h3 id="方式2：通过idea插件连接vps构建"><a class="header-anchor" href="#方式2：通过idea插件连接vps构建">¶</a>方式2：通过idea插件连接vps构建</h3><h4 id="1-配置docker允许外网访问"><a class="header-anchor" href="#1-配置docker允许外网访问">¶</a>（1）配置docker允许外网访问</h4><p>在vps中配置docker允许外网访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>在<code>ExecStart</code>属性原来值的最后追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>新版Docker CE配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">....</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>旧版Docker配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">ExecStart=/usr/bin/dockerd-current \</span><br><span class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \</span><br><span class="line">          --default-runtime=docker-runc \</span><br><span class="line">          --<span class="built_in">exec</span>-opt native.cgroupdriver=systemd \</span><br><span class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \</span><br><span class="line">          --init-path=/usr/libexec/docker/docker-init-current \</span><br><span class="line">          --seccomp-profile=/etc/docker/seccomp.json \</span><br><span class="line">          <span class="variable">$OPTIONS</span> \</span><br><span class="line">          <span class="variable">$DOCKER_STORAGE_OPTIONS</span> \</span><br><span class="line">          <span class="variable">$DOCKER_NETWORK_OPTIONS</span> \</span><br><span class="line">          <span class="variable">$ADD_REGISTRY</span> \</span><br><span class="line">          <span class="variable">$BLOCK_REGISTRY</span> \</span><br><span class="line">          <span class="variable">$INSECURE_REGISTRY</span> \</span><br><span class="line">          <span class="variable">$REGISTRIES</span> \</span><br><span class="line">          -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h4 id="2-重新加载配置并重启docker"><a class="header-anchor" href="#2-重新加载配置并重启docker">¶</a>（2）重新加载配置并重启Docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="3-启动防火墙并开放2375端口"><a class="header-anchor" href="#3-启动防火墙并开放2375端口">¶</a>（3）启动防火墙并开放2375端口</h4><p>开放了防火墙2375端口用于远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service firewalld start</span><br><span class="line">firewall-cmd --permanent --add-port=2375/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><ul><li>不需要另外开放容器映射到宿主机的端口。</li><li>经操作发现，如果使用vmware的linux作为vps，不能直接关闭防火墙，开放相应的端口即可。</li></ul></blockquote><h4 id="4-创建一个springboot项目"><a class="header-anchor" href="#4-创建一个springboot项目">¶</a>（4）创建一个springboot项目</h4><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216133115274.png" alt="image-20200216133115274"></p><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--将其他模块的依赖一起打包生成可执行jar--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DemoApplication.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qcmoke</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello docker!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p><strong>Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>u212-jre</span><br><span class="line"><span class="comment">#存放持久化数据的目录</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="comment">#要复制到容器中的问件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/demo-boot-0.0.1-SNAPSHOT.jar /demo-boot.jar</span></span><br><span class="line"><span class="comment">#docker容器启动时执行的命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/demo-boot.jar"</span>]</span></span><br><span class="line"><span class="comment">#启动端口号(容器中的)</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="5-编译项目生成jar包"><a class="header-anchor" href="#5-编译项目生成jar包">¶</a>（5）编译项目生成jar包</h4><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216134810561.png" alt="image-20200216134810561"></p><h4 id="6-配置远程docker插件连接"><a class="header-anchor" href="#6-配置远程docker插件连接">¶</a>（6）配置远程docker插件连接</h4><blockquote><p>默认新版的idea自带有这个插件，如果没有直接到插件中心安装即可。</p></blockquote><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216133850397.png" alt="image-20200216133850397"></p><h4 id="7-然后配置dockerfile"><a class="header-anchor" href="#7-然后配置dockerfile">¶</a>（7）然后配置DockerFile</h4><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216132351344.png" alt="image-20200216132351344"></p><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216134320278.png" alt="image-20200216134320278"></p><h4 id="8-运行docker插件"><a class="header-anchor" href="#8-运行docker插件">¶</a>（8）运行docker插件</h4><p>运行插件部署镜像到vps，并通过镜像创建一个实例容器</p><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216140432811.png" alt="image-20200216140432811"></p><h4 id="9-访问测试"><a class="header-anchor" href="#9-访问测试">¶</a>（9）访问测试</h4><p>最后访问: <a href="http://192.168.222.132:8080/hello" target="_blank" rel="noopener">http://192.168.222.132:8080/hello</a></p><p><img src="/devops/../images/loading-post.gif" data-original="docker/image-20200216141102237.png" alt="image-20200216141102237"></p><h2 id="九-docker-compose"><a class="header-anchor" href="#九-docker-compose">¶</a>九、Docker Compose</h2><h3 id="1-简介"><a class="header-anchor" href="#1-简介">¶</a>1. 简介</h3><p>Compose项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p><p>地址：<a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p><p>使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。<code>Compose</code> 允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件来定义一组相关联的应用容器为一个项目。</p><h3 id="2-安装"><a class="header-anchor" href="#2-安装">¶</a>2. 安装</h3><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#旧版：curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><blockquote><p>因为 Docker Compose 存放在 GitHub，可能网络不太稳定。可以想办法下载后再上传到服务器，操作如下：</p><p>（1）手动下载 docker-compose 文件，下载地址：<a href="https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</a></p><p>（2）复制并重命名下载的文件为docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mv docker-compose-Linux-x86_64 /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-卸载"><a class="header-anchor" href="#3-卸载">¶</a>3. 卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="4-编排文件"><a class="header-anchor" href="#4-编排文件">¶</a>4. 编排文件</h3><p>下面以编排 mysql、redis、nacos 容器为示例，配置如下：</p><p>在任意目录创建compose编排配置文件：docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 编排文件的版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span>                     <span class="comment"># compose管理的服务</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span>              <span class="comment"># 指定镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-1</span>   <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>           <span class="comment"># 开机自动启动</span></span><br><span class="line">    <span class="attr">ports:</span>                    <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span>                  <span class="comment"># 目录映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/redis/conf:/usr/local/etc/redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/redis/data:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--requirepass</span> <span class="string">qcmoke123456</span> <span class="string">--appendonly</span> <span class="literal">yes</span> <span class="comment">#执行的命令; requirepass来指定远程登录密码; appendonly来指定是否开启持久化策略</span></span><br><span class="line">    <span class="comment">#command: redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql-1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span>                          <span class="comment"># 环境变量</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">qcmoke123456</span>   <span class="comment"># 设置数据库root密码</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="comment">#当 MySQL 服务启动时会以/etc/mysql/my.cnf为配置文件，而该文件会导入/etc/mysql/conf.d目录中所有以.cnf为后缀的文件。</span></span><br><span class="line">      <span class="comment">#这些文件会拓展或覆盖 /etc/mysql/my.cnf 文件中的配置。因此创建以.cnf结尾的配置文件并挂载至MySQL容器中的/etc/mysql/conf.d目录即可。</span></span><br><span class="line">      <span class="comment">#在本项目中只要在docker-compose up前上传my.cnf文件到宿主机的/opt/mysql/conf.d/my.cnf目录即可。如果在docker-compose up后的话，需要重启mysql容器才能重新加载到自定义的配置文件。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/mysql/conf.d:/etc/mysql/conf.d</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-standalone</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8848</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>如果编排文件没有显式指定网络，则 Docker Compose 在默认情况下会自动创建一个新的 “bridge”（桥接）网络，并将Compose文件中的所有容器服务连接到该网络。这个默认的&quot;bridge&quot;网络在Compose文件中的每个服务之间提供了连接和通信的能力。通过这个网络，服务可以通过它们的服务名称相互访问，并使用容器的IP地址进行通信。</li><li>如果在Compose文件中显式指定了网络，那么服务将连接到指定的网络。</li></ul></blockquote><p>下面是以上编排文件中使用到的 mysql 配置文件：<code>/opt/mysql/conf.d</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="string">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="comment"># basedir=/var/lib/mysql</span></span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=/var/lib/mysql/data</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="meta">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="meta">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure><h3 id="5-操作命令"><a class="header-anchor" href="#5-操作命令">¶</a>5. 操作命令</h3><p>在<code>docker-compose.yml</code>所在的目录执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看正在运行的容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">	<span class="comment">#尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。相关的服务都将会被自动启动，除非已经处于运行状态。</span></span><br><span class="line">    <span class="comment">#注意：如果不指定SERVICE，则默认运行配置文件的所有容器服务</span></span><br><span class="line">    <span class="comment">#以守护进程模式运行加-d选项</span></span><br><span class="line">    <span class="comment">#添加--build表示启动前构建镜像（如果已经存在镜像则强制重新构建）</span></span><br><span class="line">docker-compose up -d [SERVICE...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停容器</span></span><br><span class="line">docker-compose pause [SERVICE...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#恢复暂停的容器</span></span><br><span class="line">docker-compose unpause [SERVICE...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止并移除所有相关容器（此命令将会停止并移除up命令所启动的容器，并移除网络，但不会移除卷，如需移除卷，则需要加--volumes参数）</span></span><br><span class="line">docker-compose down</span><br><span class="line"><span class="comment">#docker-compose down --volumes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目中的服务。</span></span><br><span class="line">docker-compose restart [options] [SERVICE...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行容器内部命令</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> &lt;service_name&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器日志</span></span><br><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><h2 id="十-docker-swarm"><a class="header-anchor" href="#十-docker-swarm">¶</a>十、Docker Swarm</h2><p>Docker Swarm 是 Docker 的集群管理工具，或者说是资源管理工具。swarm 集群由管理节点（manager）和工作节点（work node）构成。</p><blockquote><p><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</p><p><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p></blockquote><p><strong>注意</strong>：跟集群管理有关的任何操作，都是在管理节点上操作的。</p><p>准备6台linux服务器</p><blockquote><p>manager-1：192.168.99.101</p><p>manager-2：192.168.99.102</p><p>manager-3：192.168.99.103</p><p>worker-1：192.168.99.201</p><p>worker-2：192.168.99.202</p><p>worker-3：192.168.99.203</p></blockquote><h3 id="1-关闭所有服务器的防火墙"><a class="header-anchor" href="#1-关闭所有服务器的防火墙">¶</a>1. 关闭所有服务器的防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service firewalld stop</span><br></pre></td></tr></table></figure><h3 id="2-初始化-swarm-集群"><a class="header-anchor" href="#2-初始化-swarm-集群">¶</a>2. 初始化 swarm 集群</h3><p>进行初始化的这台机器，就是集群的管理节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.68.101</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker swarm init --advertise-addr 192.168.68.101</span></span><br><span class="line">Swarm initialized: current node (w7xdf6see52t2t24x1ykedg5o) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \</span><br><span class="line">    192.168.68.101:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br></pre></td></tr></table></figure><h3 id="3-添加worker节点"><a class="header-anchor" href="#3-添加worker节点">¶</a>3. 添加worker节点</h3><p>在manager节点下生成worker令牌，以让其他worker服务器加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker swarm join-token worker</span></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \</span><br><span class="line">    192.168.68.101:2377</span><br></pre></td></tr></table></figure><p>然后在三台worker节点运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join \</span><br><span class="line">    --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \</span><br><span class="line">    192.168.68.101:2377</span><br></pre></td></tr></table></figure><h3 id="4-添加manager节点"><a class="header-anchor" href="#4-添加manager节点">¶</a>4. 添加manager节点</h3><p>在manager节点下生成manager令牌，以让其他manager服务器加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker swarm join-token manager</span></span><br><span class="line">To add a manager to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-4nbcolan6w4akrs3zsbvrkqxe \</span><br><span class="line">    192.168.68.101:2377</span><br></pre></td></tr></table></figure><p>然后在三台manager节点运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join \</span><br><span class="line">    --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-4nbcolan6w4akrs3zsbvrkqxe \</span><br><span class="line">    192.168.68.101:2377</span><br></pre></td></tr></table></figure><h3 id="5-查看所有管理的节点"><a class="header-anchor" href="#5-查看所有管理的节点">¶</a>5. 查看所有管理的节点</h3><p>manager-1运行命令查看所有管理的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker node ls</span></span><br><span class="line">ID                           HOSTNAME               STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">dif8w8hp6pevz9k0owqkg6hjl    localhost.localdomain  Ready   Active        </span><br><span class="line">j9jqdioy91olyxd8dfghgm8qc    localhost.localdomain  Ready   Active        </span><br><span class="line">mfv24dim85bi7sd9wl589rhdf    localhost.localdomain  Ready   Active        Reachable</span><br><span class="line">q1qayx19ebfg7oi8dv7e3mzyh    localhost.localdomain  Ready   Active        </span><br><span class="line">rbeb5mykx83qpr6u8afriqx9z    localhost.localdomain  Ready   Active        Reachable</span><br><span class="line">w7xdf6see52t2t24x1ykedg5o *  localhost.localdomain  Ready   Active        Leader</span><br></pre></td></tr></table></figure><h3 id="6-创建集群服务"><a class="header-anchor" href="#6-创建集群服务">¶</a>6. 创建集群服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create -p 80:80 --name my-nginx nginx</span><br></pre></td></tr></table></figure><p>这时候将会在任意节点中选择一台通过docker创建nginx服务。我们可以在集群下任意一台服务器（manager或者worker节点）访问nginx服务都能访问到，因为swarm创建的服务使用的是swarm集群网络。</p><h3 id="7-查看服务集群情况"><a class="header-anchor" href="#7-查看服务集群情况">¶</a>7. 查看服务集群情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID            NAME      MODE        REPLICAS  IMAGE</span><br><span class="line">v1hn945nmyds  my-nginx  replicated  1/1       nginx:latest</span><br></pre></td></tr></table></figure><blockquote><p>REPLICAS：副本数量</p></blockquote><h3 id="8-集群服务扩容"><a class="header-anchor" href="#8-集群服务扩容">¶</a>8. 集群服务扩容</h3><p>对my-nginx服务扩容为5个</p><p>第一种方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update --replicas 5 my-nginx</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker service update --replicas 5 my-nginx</span></span><br><span class="line">my-nginx</span><br><span class="line">[root@localhost ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID            NAME      MODE        REPLICAS  IMAGE</span><br><span class="line">v1hn945nmyds  my-nginx  replicated  5/5       nginx:latest</span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-nginx=5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker service scale my-nginx=5</span></span><br><span class="line">my-nginx scaled to 5</span><br><span class="line">[root@localhost ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID            NAME      MODE        REPLICAS  IMAGE</span><br><span class="line">v1hn945nmyds  my-nginx  replicated  5/5       nginx:latest</span><br></pre></td></tr></table></figure><blockquote><p>update更多的应用场景在于image的升级导致的运行中的服务需要更新等等</p></blockquote><h3 id="9-删除集群服务"><a class="header-anchor" href="#9-删除集群服务">¶</a>9. 删除集群服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm my-nginx</span><br></pre></td></tr></table></figure><p>这时候所有副本都会被删除</p><h3 id="10-修改服务"><a class="header-anchor" href="#10-修改服务">¶</a>10. 修改服务</h3><p>比如修改nginx服务镜像版本为1.9.5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service update --image nginx:1.9.5 my-nginx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker service ps my-nginx</span></span><br><span class="line">ID            NAME            IMAGE         NODE                   DESIRED STATE  CURRENT STATE                ERROR  PORTS</span><br><span class="line">kzg8qncaal9a  my-nginx.1      nginx:1.9.5   localhost.localdomain  Running        Running about a minute ago          </span><br><span class="line">er55pvmd8fn6   \_ my-nginx.1  nginx:latest  localhost.localdomain  Shutdown       Shutdown about a minute ago         </span><br><span class="line">kv3t6poxh3rb  my-nginx.2      nginx:1.9.5   localhost.localdomain  Running        Running about a minute ago          </span><br><span class="line">tuzkxmb0th6x   \_ my-nginx.2  nginx:latest  localhost.localdomain  Shutdown       Shutdown about a minute ago         </span><br><span class="line">edt0tg6tg120  my-nginx.3      nginx:1.9.5   localhost.localdomain  Running        Running about a minute ago          </span><br><span class="line">qfwlzj8hb3gl   \_ my-nginx.3  nginx:latest  localhost.localdomain  Shutdown       Shutdown about a minute ago         </span><br><span class="line">bb9kjj3n81yx  my-nginx.4      nginx:1.9.5   localhost.localdomain  Running        Running about a minute ago          </span><br><span class="line">spx8ybz9wlph   \_ my-nginx.4  nginx:latest  localhost.localdomain  Shutdown       Shutdown about a minute ago         </span><br><span class="line">vs4akco7zpls  my-nginx.5      nginx:1.9.5   localhost.localdomain  Running        Running about a minute ago          </span><br><span class="line">qtaqq0jout6k   \_ my-nginx.5  nginx:latest  localhost.localdomain  Shutdown       Shutdown about a minute ago</span><br></pre></td></tr></table></figure><h3 id="11-服务回滚"><a class="header-anchor" href="#11-服务回滚">¶</a>11. 服务回滚</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update --rollback</span><br></pre></td></tr></table></figure><h2 id="十一-运行常用-docker-容器示例"><a class="header-anchor" href="#十一-运行常用-docker-容器示例">¶</a>十一、运行常用 Docker 容器示例</h2><p>步骤：软件镜像（安装程序）—&gt; 运行镜像 —&gt; 产生一个容器（正在运行的软件）。</p><h3 id="1-安装-nginx"><a class="header-anchor" href="#1-安装-nginx">¶</a>1. 安装 nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拉取(下载)镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="comment">#首先简单运行一个nginx临时容器，用于复制容器内部的一些nginx相关重要文件到宿主机</span></span><br><span class="line">docker run -d --name nginx nginx:latest</span><br><span class="line"><span class="comment">#创建映射目录</span></span><br><span class="line">mkdir -p  /opt/nginx/&#123;conf,html,logs&#125;</span><br><span class="line"><span class="comment">#复制容器内部的一些nginx相关重要文件到映射目录中(注意命令中的末尾的点，它表示复制目录中的所有内容而不是整个目录本身)</span></span><br><span class="line">docker cp nginx:/etc/nginx/. /opt/nginx/conf</span><br><span class="line">docker cp nginx:/usr/share/nginx/html/. /opt/nginx/html</span><br><span class="line">docker cp nginx:/var/<span class="built_in">log</span>/nginx/. /opt/nginx/logs</span><br><span class="line"><span class="comment">#删除nginx临时容器</span></span><br><span class="line">docker rm -f nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#生产环境下运行nginx容器</span></span><br><span class="line"><span class="comment">#（1）使用host网络模式直接使用宿主机网络IP地址和端口（可以避免每次配置新的监听端口都需要重新docker run映射端口）</span></span><br><span class="line"><span class="comment">#（2）限制内存上限为200MB</span></span><br><span class="line"><span class="comment">#（3）指定时区并同步宿主机和容器的时间</span></span><br><span class="line"><span class="comment">#（4）映射几个主要的nginx相关目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">--restart always \</span><br><span class="line">--name nginx \</span><br><span class="line">--net=host \</span><br><span class="line">-m 200m \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-v /etc/localtime:/etc/localtime:ro \</span><br><span class="line">-v /opt/nginx/conf:/etc/nginx \</span><br><span class="line">-v /opt/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /opt/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/cache:/opt/cache:rw \</span><br><span class="line">-v /opt/ssl-certs:/opt/ssl-certs:rw \</span><br><span class="line">nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#防火墙设置（开放nginx默认配置的80端口）</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>访问地址如：<a href="http://192.168.60.201" target="_blank" rel="noopener">http://192.168.60.201</a></p><p>提示：Docker 安装的 nginx 容器里的默认路径下的日志文件都只是符号链接，如下：</p><ul><li><code>access.log -&gt; /dev/stdout</code></li><li><code>error.log -&gt; /dev/stderr</code></li></ul><p>这样做是方便通过 <code>docker logs nginx</code> 查看。如需修改为真实文件，只需修改日志路径或者文件名称即可，当然更建议针对不同网站使用不同的日志路径。</p></blockquote><h3 id="2-安装-tomcat"><a class="header-anchor" href="#2-安装-tomcat">¶</a>2. 安装 tomcat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、搜索镜像</span></span><br><span class="line">docker search tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、拉取(下载)镜像</span></span><br><span class="line"><span class="comment">#docker pull tomcat</span></span><br><span class="line"><span class="comment">#这里使用的是网易镜像站的，网址：https://c.163yun.com/hub#/home</span></span><br><span class="line">docker pull hub.c.163.com/library/tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、根据镜像实例化一个容器并运行</span></span><br><span class="line"><span class="comment"># 选项：-d：表示后台运行；-p: 表示将主机的端口映射到容器的一个端口，如-p 主机端口:容器内部的端口。</span></span><br><span class="line"><span class="comment"># 启动一个做了端口映射的tomcat,假设虚拟机ip为192.168.222.132,那么启动容器后访问http://192.168.222.132:8080</span></span><br><span class="line">docker run -d --name mytomcat -p 8080:8080 hub.c.163.com/library/tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、查看当前所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#6、 停止运行中的容器</span></span><br><span class="line">docker stop mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#7、启动容器</span></span><br><span class="line">docker start mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#8、删除一个容器(需要先停止运行中的容器)</span></span><br><span class="line">docker rm mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment">#9、查看容器的日志 docker logs container-name或者container-id</span></span><br><span class="line">docker logs mytomcat</span><br></pre></td></tr></table></figure><p><em>更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档</em></p><h3 id="3-安装-mysql"><a class="header-anchor" href="#3-安装-mysql">¶</a>3. 安装 mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取镜像</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="comment">#docker pull mysql:5.7 #指定版本用	:标签（版本号）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行容器</span></span><br><span class="line">docker run -d -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br><span class="line"><span class="comment">#docker run -d -p 3306:3306 --name mysql5_7 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span></span><br></pre></td></tr></table></figure><p>指定 mysql 配置文件运行 mysql 容器案例示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line">mkdir /opt/mysql/conf -p</span><br><span class="line">mkdir /opt/mysql/data -p</span><br><span class="line">vim /opt/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## my.cnf</span></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="string">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="comment"># basedir=/var/lib/mysql</span></span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">/var/lib/mysql/data</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="meta">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="meta">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行mysql实例</span></span><br><span class="line">docker run -d --name mysql  -p 3306:3306 -v /opt/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br><span class="line">docker run -d --name mysql  -p 3306:3306 -v /opt/mysql/conf:/etc/mysql/conf.d -v /opt/mysql/data:/var/lib/mysql/data -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="4-安装-rabbitmq"><a class="header-anchor" href="#4-安装-rabbitmq">¶</a>4. 安装 rabbitmq</h3><p>（1）获取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该版本包含了web控制页面</span></span><br><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>（2）运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式一：默认用户名和密码都是guest</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式二：设置用户名和密码</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>（3）访问rabbitmq管理页面页面 <a href="http://ip:15672" target="_blank" rel="noopener">http://ip:15672</a></p><h3 id="5-安装-redis"><a class="header-anchor" href="#5-安装-redis">¶</a>5. 安装 redis</h3><p>创建redis配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/redis/&#123;conf,data&#125;/</span><br><span class="line">cat &gt; /opt/redis/conf/redis.conf &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line"><span class="comment">#节点端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">#访问认证密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment">#如果主节点开启了访问认证，从节点访问主节点需要认证的密码</span></span><br><span class="line">masterauth 123456</span><br><span class="line"><span class="comment">#日志文件和序列化文件等默认存当前目录，可修改到指定目录</span></span><br><span class="line"><span class="comment">#dir ./</span></span><br><span class="line"><span class="comment">#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment">#是否以守护线程的方式启动（后台启动），默认 no；</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="comment">#是否开启 AOF 持久化模式，默认 no；</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment">#是否开启集群模式，默认 no；</span></span><br><span class="line">cluster-enabled no</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>该原始文件可从<a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">官网下载</a></p><ul><li><code>bind 127.0.0.1</code> 注释掉这部分，这是限制redis只能本地访问</li><li><code>protected-mode no</code> 默认yes，开启保护模式，限制为本地访问</li><li><code>daemonize no#默认no</code> 改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败</li><li><code>databases 16</code> 数据库个数（可选），我修改了这个只是查看是否生效。。</li><li><code>dir ./</code> 输入本地 redis 数据库存放文件夹（可选）</li><li><code>appendonly yes</code> redis持久化（可选）</li><li><code>requirepass 123456</code> 配置redis访问密码</li></ul></blockquote><p>运行redis镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis \</span><br><span class="line">-v /opt/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /opt/redis/data:/data \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:6.2.7  redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure><p>配置防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6379/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><h3 id="6-安装-zookeeper"><a class="header-anchor" href="#6-安装-zookeeper">¶</a>6. 安装 zookeeper</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-Xmx指定应用程能够使用的最大内存数</span></span><br><span class="line">docker run -d --name zookeeper --restart always -e JVMFLAGS=<span class="string">"-Xmx1024m"</span> -p 2181:2181 zookeeper</span><br><span class="line">docker <span class="built_in">exec</span> -it zookeeper /bin/bash</span><br><span class="line">/apache-zookeeper-3.6.2-bin/bin/zkCli.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://hub.docker.com/r/wurstmeister/kafka/" target="_blank" rel="noopener">https://hub.docker.com/r/wurstmeister/kafka/</a></p></blockquote><h3 id="7-安装-kafka"><a class="header-anchor" href="#7-安装-kafka">¶</a>7. 安装 kafka</h3><p>提前安装并启动zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KAFKA_BROKER_ID：kafka集群节点id（唯一）</span></span><br><span class="line"><span class="comment"># KAFKA_ZOOKEEPER_CONNECT：zookeeper连接地址</span></span><br><span class="line"><span class="comment"># KAFKA_ADVERTISED_LISTENERS：广播地址端口，即客户端访问的具体地址（会把这个地址端口注册给zookeeper，以备消费者获取）</span></span><br><span class="line"><span class="comment"># KAFKA_LISTENERS：外部代理地址和监听端口(限制访问ip以及服务端运行的端口)</span></span><br><span class="line"><span class="comment"># KAFKA_LOG_RETENTION_HOURS: 数据文件保留时间(非必选。缺省168小时，即7天)</span></span><br><span class="line"><span class="comment"># KAFKA_NUM_PARTITIONS：topic的分区数(非必选)</span></span><br><span class="line"><span class="comment"># KAFKA_DEFAULT_REPLICATION_FACTOR：分区的副本数(非必选)</span></span><br><span class="line">docker run --name kafka \</span><br><span class="line">-p 9092:9092 \</span><br><span class="line">-v /opt/kafka:/kafka \</span><br><span class="line">-v /etc/localtime:/etc/localtime:ro \</span><br><span class="line">-e KAFKA_BROKER_ID=0 \</span><br><span class="line">-e KAFKA_ZOOKEEPER_CONNECT=39.106.195.202:2181 \</span><br><span class="line">-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://39.106.195.202:9092 \</span><br><span class="line">-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">-d  wurstmeister/kafka</span><br></pre></td></tr></table></figure><h3 id="8-安装-linux-系统"><a class="header-anchor" href="#8-安装-linux-系统">¶</a>8. 安装 Linux 系统</h3><h4 id="安装-centos-容器"><a class="header-anchor" href="#安装-centos-容器">¶</a>安装 centos 容器</h4><h5 id="简单用法"><a class="header-anchor" href="#简单用法">¶</a>简单用法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行容器</span></span><br><span class="line">    <span class="comment">#-d 这个参数表示的是在后台运行，即 –deamon。</span></span><br><span class="line">    <span class="comment">#-i 表示 interactive 可交互的，让容器的标准输入（stdin）保持打开</span></span><br><span class="line">    <span class="comment">#-t 表示给容器分配一个伪终端。</span></span><br><span class="line">    <span class="comment">#注意：运行容器时注意加-it参数，否则运行失败</span></span><br><span class="line">docker run -itd --name centos7-test centos:centos7</span><br><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7-test bash</span><br></pre></td></tr></table></figure><h5 id="使用-ssh-服务并支持简体中文"><a class="header-anchor" href="#使用-ssh-服务并支持简体中文">¶</a>使用 ssh 服务并支持简体中文</h5><h6 id="容器内部修改的方式"><a class="header-anchor" href="#容器内部修改的方式">¶</a>容器内部修改的方式</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##创建容器</span></span><br><span class="line"><span class="comment">#无服务初始化方式系统（可以不加 --privileged）</span></span><br><span class="line">	<span class="comment">#保持后台运行通过supervisor、runit、dumb-init和s6-overlay等解决，而不是用Systemd</span></span><br><span class="line">docker run -itd --name centos7-test  centos:centos7</span><br><span class="line">	<span class="comment">#host网络模式运行容器：</span></span><br><span class="line">		<span class="comment">#docker run -itd --restart always --name centos7-test --net=host  centos:centos7</span></span><br><span class="line">	<span class="comment">#bridge 网络模式运行容器并映射端口：</span></span><br><span class="line">		<span class="comment">#docker run -itd --restart always --name centos7-test -p 53371:22 -p 53372-53379:53372-53379  centos:centos7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 Systemd 初始化系统方式管理服务（可选）</span></span><br><span class="line">	<span class="comment">#使用 Systemd 管理服需要同时加 --privileged 和 /usr/sbin/init，否则报错：Failed to get D-Bus connection: Operation not permitted</span></span><br><span class="line">docker run --privileged -itd --name centos7-test  centos:centos7 /usr/sbin/init</span><br><span class="line">	<span class="comment">#docker run --privileged -itd --restart always --name centos7-test -p 53371:22 -p 53372-53379:53372-53379  centos:centos7 /usr/sbin/init</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7-test bash</span><br><span class="line"><span class="comment">#安装常用命令</span></span><br><span class="line">yum install telnet net-tools curl wget vim -y</span><br><span class="line"><span class="comment">#安装openssh</span></span><br><span class="line">yum install openssh openssh-clients openssh-server -y</span><br><span class="line"><span class="comment">#修改 sshd_config 配置文件</span></span><br><span class="line">	<span class="comment">#找到 PermitRootLogin 并将其值修改为 yes，表示允许 root 管理员登录系统。将 PasswordAuthentication 的值改为 yes 表示使用帐号密码方式登录系统。</span></span><br><span class="line">	<span class="comment">#注意：如果使用 host 网络模式创建容器，则需要将容器 ssh 程序的端口改为其他宿主机未被占用的端口，否则端口冲突导致 ssh 程序无法运行</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#给容器的root用户设置密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment">##如果是无服务方式初始化系统，则如下操作：</span></span><br><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span><br><span class="line">/usr/sbin/sshd	<span class="comment">#每次重启容器时需要手动执行这条命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##如果是使用 Systemd 初始化系统方式管理服务（可选），则如下操作：</span></span><br><span class="line"><span class="comment">#systemctl 相关命令：systemctl restart|stop|start|status sshd</span></span><br><span class="line"><span class="comment">#service 相关命令：service ssh restart|stop|start|status</span></span><br><span class="line"><span class="comment">#启动服务（通常安装后默认都已启动）</span></span><br><span class="line">systemctl start sshd</span><br><span class="line"><span class="comment">#service sshd start #如果命令不存在，可安装相关依赖：yum install -y initscripts</span></span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">systemctl restart sshd</span><br><span class="line"><span class="comment">#或：service sshd restart</span></span><br><span class="line"><span class="comment">#开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"><span class="comment">#或：chkconfig sshd on</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过ifconfig查看docker容器的ip，然后在宿主机上进行ssh登录。如果要在宿主机外的其他机器登录，则需要docker run时映射端口到容器的22端口，如-p 2222:22</span></span><br><span class="line">ssh root@172.18.0.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装简体中文语言包并修改配置以支持简体中文（CentOS官方的Docker镜像默认不支持简体中文）</span></span><br><span class="line">	<span class="comment">#查看系统支持的语言：locale -a</span></span><br><span class="line">	<span class="comment">#查看当前使用的语言包：locale</span></span><br><span class="line">	<span class="comment">#参考：https://blog.51cto.com/u_8877512/2483145</span></span><br><span class="line">yum install -y kde-l10n-Chinese glibc-common</span><br><span class="line"><span class="comment">#修改配置支持简体中文</span></span><br><span class="line">	<span class="comment">#在 /etc/bashrc 文件末尾配置 export LC_ALL=en_US.UTF-8</span></span><br><span class="line">	<span class="comment">#下面写那么复复杂主要是防止执行多次重复添加</span></span><br><span class="line">	<span class="comment">#注意 en_US.UTF-8 只是支持解析简体中文，而如果希望将系统信息都使用特定地区的日期、时间格式或货币格式，则可以将 en_US.UTF-8 改为 zh_CN.UTF-8 ，而如果不需要这些与地区相关的设置，那么 en_US.UTF-8 就足够了。</span></span><br><span class="line">	<span class="comment">#虽然按道理也可以改 /etc/locale.conf 配置文件实现，但实测仅改这个文件无法解决 ping 命令含中文字符的域名时会报错的问题</span></span><br><span class="line">text_str=<span class="string">'export LC_ALL="en_US.UTF-8"'</span> ;\</span><br><span class="line">file_str=<span class="string">'/etc/bashrc'</span> ;\</span><br><span class="line">grep -v <span class="string">'^#'</span> <span class="string">"<span class="variable">$file_str</span>"</span> | grep -q <span class="string">"<span class="variable">$text_str</span>"</span> || <span class="built_in">echo</span> <span class="string">"<span class="variable">$text_str</span>"</span> &gt;&gt; <span class="string">"<span class="variable">$file_str</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置</span></span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br><span class="line"><span class="comment">#退出容器并重新进入即可生效</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7-test bash</span><br></pre></td></tr></table></figure><h6 id="编写-dockerfile-封装镜像的方式"><a class="header-anchor" href="#编写-dockerfile-封装镜像的方式">¶</a>编写 <code>Dockerfile</code> 封装镜像的方式</h6><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/liuguangrong/article/details/82464139" target="_blank" rel="noopener">https://blog.csdn.net/liuguangrong/article/details/82464139</a></li><li><a href="https://blog.csdn.net/kakaops_qing/article/details/109089858" target="_blank" rel="noopener">https://blog.csdn.net/kakaops_qing/article/details/109089858</a></li></ul></blockquote><h5 id="高特权用法"><a class="header-anchor" href="#高特权用法">¶</a>高特权用法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建具有更高特权容器</span></span><br><span class="line">	<span class="comment">#--privileged（或 --privileged=true）：表示开启特权</span></span><br><span class="line">        <span class="comment">#使用该选项和参数，带有 --privileged 时，这个容器内的进程实质上就像直接运行在主机上一样，它会拥更高的权限，包括直接访问宿主机的硬件。</span></span><br><span class="line">        <span class="comment">#否则执行高权限，如修改内核参数（只是可以修改内核参数而不是修改内核，如果修改宿主机的内核参数也会受到影响）、创建文件系统、创建分区、挂载分区、更改网络配置等时会报错（相关命令包括：如：sysctl、fdisk、mount 等）</span></span><br><span class="line">        <span class="comment">##注意在使用官方的 centos 镜像创建容器使用 --privileged 时需要加在命令最后加 /usr/sbin/init，表示使用 systemd 作为第一启动程序，不加会报错。</span></span><br><span class="line">docker run --privileged -itd --name centos7-test centos:centos7 /usr/sbin/init</span><br></pre></td></tr></table></figure><h4 id="安装-ubuntu-容器"><a class="header-anchor" href="#安装-ubuntu-容器">¶</a>安装 ubuntu 容器</h4><h5 id="简单用法-v2"><a class="header-anchor" href="#简单用法-v2">¶</a>简单用法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行容器（运行容器时注意加-it参数，否则运行失败）</span></span><br><span class="line">    <span class="comment">#-d 这个参数表示的是在后台运行，即 –deamon。</span></span><br><span class="line">    <span class="comment">#-i 表示 interactive 可交互的，以便可以从标准输入与容器交互。</span></span><br><span class="line">    <span class="comment">#-t 表示给容器分配一个虚拟终端。</span></span><br><span class="line">docker run -itd --name ubuntu-test ubuntu:20.04</span><br><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ubuntu-test bash</span><br></pre></td></tr></table></figure><h5 id="使用-ssh-服务并支持简体中文-v2"><a class="header-anchor" href="#使用-ssh-服务并支持简体中文-v2">¶</a>使用 ssh 服务并支持简体中文</h5><h6 id="容器内部修改的方式-v2"><a class="header-anchor" href="#容器内部修改的方式-v2">¶</a>容器内部修改的方式</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行容器（运行容器时注意加-it参数，否则运行失败）</span></span><br><span class="line">    <span class="comment">#-d 这个参数表示的是在后台运行，即 –deamon。</span></span><br><span class="line">    <span class="comment">#-i 表示 interactive 可交互的，以便可以从标准输入与容器交互。</span></span><br><span class="line">    <span class="comment">#-t 表示给容器分配一个虚拟终端。</span></span><br><span class="line">docker run -itd --name ubuntu-test ubuntu:20.04</span><br><span class="line">	<span class="comment">#docker run -itd --restart always --name ubuntu-test -p 53371:22 -p 53372-53379:53372-53379 ubuntu:20.04</span></span><br><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ubuntu-test bash</span><br><span class="line"><span class="comment">#更新软件源，这个步骤优先级最高，因为不更新很多组件安装不了</span></span><br><span class="line">apt update</span><br><span class="line"><span class="comment">#安装常用工具</span></span><br><span class="line">apt install -y telnet iputils-ping net-tools curl wget vim</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装openssh</span></span><br><span class="line">apt install -y openssh-server</span><br><span class="line"><span class="comment">#修改 sshd_config 配置文件</span></span><br><span class="line">	<span class="comment">#找到 PermitRootLogin 并将其值修改为 yes，表示允许 root 管理员登录系统。将 PasswordAuthentication 的值改为 yes 表示使用帐号密码方式登录系统。</span></span><br><span class="line">	<span class="comment">#注意：如果使用 host 网络模式创建容器，则需要将容器 ssh 程序的端口改为其他宿主机未被占用的端口，否则端口冲突导致 ssh 程序无法运行</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#给容器的root用户设置密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动ssh</span></span><br><span class="line">/usr/sbin/ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">##服务管理方式（按道理以上方式在这里无效，但在Ubuntu中service命令启动和停止可以管理ssh进程运行，具体可看/etc/init.d/ssh脚本逻辑）</span></span><br><span class="line"><span class="comment">#service 相关命令：service ssh restart|stop|start|status</span></span><br><span class="line"><span class="comment">#启动服务（通常安装后默认都已启动）</span></span><br><span class="line"><span class="comment">#service ssh start</span></span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line"><span class="comment">#service ssh restart</span></span><br><span class="line"><span class="comment">#启用开机自启动</span></span><br><span class="line"><span class="comment">#update-rc.d ssh defaults</span></span><br><span class="line"><span class="comment">#禁止开机自启动（如需）</span></span><br><span class="line"><span class="comment">#update-rc.d -f ssh remove</span></span><br><span class="line"><span class="comment">#通过ifconfig查看docker容器的ip，然后在宿主机上进行ssh登录。如果要在宿主机外的其他机器登录，则需要docker run时映射端口到容器的22端口，如-p 2222:22</span></span><br><span class="line">ssh root@172.18.0.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装简体中文语言包并修改配置以支持简体中文（Ubuntu官方的Docker镜像默认不支持简体中文）</span></span><br><span class="line">	<span class="comment">#查看系统支持的语言：locale -a</span></span><br><span class="line">	<span class="comment">#查看当前使用的语言包：locale</span></span><br><span class="line">apt install -y language-pack-zh-hans</span><br><span class="line"><span class="comment">#修改配置支持简体中文</span></span><br><span class="line">	<span class="comment">#在 /etc/bash.bashrc 文件末尾配置 export LC_ALL="C.UTF-8"</span></span><br><span class="line">	<span class="comment">#下面写那么复复杂主要是防止执行多次重复添加</span></span><br><span class="line">	<span class="comment">#注意 C.UTF-8 只是支持解析简体中文，而如果希望将系统信息都使用特定地区的日期、时间格式或货币格式，则可以将 C.UTF-8 改为 zh_CN.UTF-8 ，而如果不需要这些与地区相关的设置，那么 C.UTF-8 就足够了。</span></span><br><span class="line">text_str=<span class="string">'export LC_ALL="C.UTF-8"'</span> ;\</span><br><span class="line">file_str=<span class="string">'/etc/bash.bashrc'</span> ;\</span><br><span class="line">grep -v <span class="string">'^#'</span> <span class="string">"<span class="variable">$file_str</span>"</span> | grep -q <span class="string">"<span class="variable">$text_str</span>"</span> || <span class="built_in">echo</span> <span class="string">"<span class="variable">$text_str</span>"</span> &gt;&gt; <span class="string">"<span class="variable">$file_str</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc</span><br><span class="line"><span class="comment">#退出容器并重新进入即可生效</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ubuntu-test bash</span><br></pre></td></tr></table></figure><h6 id="编写-dockerfile-封装镜像的方式-v2"><a class="header-anchor" href="#编写-dockerfile-封装镜像的方式-v2">¶</a>编写 <code>Dockerfile</code> 封装镜像的方式</h6><blockquote><p>说明：由于官方的 Ubuntu 镜像没有内置 systemd 相关依赖包，所以默认无法使用 systemd 来管理 ssh 服务，但可以使用默认的 SysVinit 启动，简单来说就是使用 <code>service</code> 命令来管理 ssh 服务器（如：<code>service ssh start</code>）。</p><p>当然如果非要用 systemd 来管理 ssh 服务，官方的 Ubuntu 官方的镜像来创建容器并使之支持，操作过程会比较麻烦，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker run -itd --name ubuntu-test ubuntu:20.04</span><br><span class="line">&gt;docker <span class="built_in">exec</span> -it ubuntu-test bash</span><br><span class="line">&gt;apt update</span><br><span class="line">&gt;apt install -y systemd	<span class="comment">#安装失败，可以修改 apt 的软件源为国内源再重试</span></span><br><span class="line">&gt;ln -sf /lib/systemd/systemd /usr/sbin/init</span><br></pre></td></tr></table></figure><p>但此时容器已经创建，没法再指定 <code>/usr/sbin/init</code> 为第一启动程序了，当然可以通过提交容器为新镜像的方式来重新运行，并在 <code>docker run</code> 命令最后加上 <code>/usr/sbin/init</code>，表示使用 systemd 作为第一启动程序，然后就能使用 systemd 了，但很明显这一系列操作太麻烦，所以不推荐。更推荐编写 <code>Dockerfile</code> 封装镜像的方式，参考：</p><ul><li><a href="https://github.com/robertdebock/docker-ubuntu-systemd" target="_blank" rel="noopener">https://github.com/robertdebock/docker-ubuntu-systemd</a></li><li><a href="https://github.com/eniocarboni/docker-ubuntu-systemd" target="_blank" rel="noopener">https://github.com/eniocarboni/docker-ubuntu-systemd</a></li><li><a href="https://luckfu.com/post/ampere_a1_docker/" target="_blank" rel="noopener">https://luckfu.com/post/ampere_a1_docker/</a> （手动封装）</li></ul></blockquote><h5 id="高特权用法-v2"><a class="header-anchor" href="#高特权用法-v2">¶</a>高特权用法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建具有更高特权容器</span></span><br><span class="line">	<span class="comment">#--privileged（或 --privileged=true）：表示开启特权</span></span><br><span class="line">        <span class="comment">#使用该选项和参数，带有 --privileged 时，这个容器内的进程实质上就像直接运行在主机上一样，它会拥更高的权限，包括直接访问宿主机的硬件。</span></span><br><span class="line">        <span class="comment">#否则执行高权限，如修改内核参数（只是可以修改内核参数而不是修改内核，如果修改宿主机的内核参数也会受到影响）、创建文件系统、创建分区、挂载分区、更改网络配置等时会报错（相关命令包括：如：sysctl、fdisk、mount 等）</span></span><br><span class="line">docker run --privileged -itd --name ubuntu-test ubuntu:20.04</span><br></pre></td></tr></table></figure><h4 id="更多-linux-系统参考"><a class="header-anchor" href="#更多-linux-系统参考">¶</a>更多 Linux 系统参考</h4><blockquote><ul><li><a href="https://virt.spiritlhl.net/guide/docker/docker_build.html" target="_blank" rel="noopener">https://virt.spiritlhl.net/guide/docker/docker_build.html</a> （一键脚本开设含 Systemd 和 SSH 服务的 Linux 系统，支持 alpine、debian、ubuntu、almalinux）</li></ul></blockquote><h2 id="十二-问题排错"><a class="header-anchor" href="#十二-问题排错">¶</a>十二、问题排错</h2><p>(1)出现 <code>Error response from daemon: oci runtime error: container_linux.go:247: start....</code> 报错提示。</p><p>原因是系统和docker版本不兼容。解决办法：执行<code>yum update</code></p><p>(2)<code>rying to pull repository docker.io/library/mysql ... Get https://registry-1.</code>。</p><p>解决办法：执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install <span class="built_in">bind</span>-utils     <span class="comment">#安装dig工具</span></span><br><span class="line">$ dig @114.114.114.114 registry-1.docker.io</span><br><span class="line">$ vi /etc/hosts</span><br><span class="line">52.54.155.177 registry-1.docker.io</span><br></pre></td></tr></table></figure><p>(3)<code>[root@izuf6dskn3b7v2sly08bqtz ~]# docker pull mysql Using default tag: latest Trying to pull repository docker.io/library/mysql ... Get https://registry-1.docker.io/v2/: x509: certificate is valid for *.theranest.com, theranest.com, not registry-1.docker.io</code></p><p>解决办法：镜像加速解决</p><p>(3)执行<code>docker-compose up -d</code>后出现错误：<code>ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule: (iptables failed: iptables --wait -t nat -I DOCKER -i br-950144d461c2 -j RETURN: iptables: No chain/target/match by that name. (exit status 1))</code></p><p>解决办法：重启docker试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>（4）<code>service network restart</code> 重启网络后导致 docker 容器端口无法访问</p><p>解决办法：重启 Docker 服务并重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">docker restart 容器名称/容器id</span><br></pre></td></tr></table></figure><h2 id="十三-参考"><a class="header-anchor" href="#十三-参考">¶</a>十三、参考</h2><p>📚<a href="https://yeasy.gitbooks.io/docker_practice" target="_blank" rel="noopener">《Docker — 从入门到实践》</a></p></div><div><div><br><br><div style="text-align:center;color:#ccc;font-size:14px">----------- 本文结束 -----------</div><br><br><br><br></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>如果你觉得我的文章对你有帮助，你可以打赏我哦~</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="../images/loading-post.gif" data-original="/images/wechatpay.png" alt="Qcmoke 微信支付"><p>微信支付</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/devops/" rel="tag"><i class="fa fa-tag"></i> devops</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/tools/ngrok_git.html" rel="prev" title="ngrok反向代理内网git仓库"><i class="fa fa-chevron-left"></i> ngrok反向代理内网git仓库</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/tools/bypy.html" rel="next" title="一个python编写的百度网盘命令行客户端">一个python编写的百度网盘命令行客户端 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div class="tablink-li"><button class="tablink" onclick='openPage("tabs-gitalk",this)' id="defaultOpen">Gitalk</button> <button class="tablink" onclick='openPage("tabs-valine",this)'>Valine</button></div><div class="tabcontent-li"><div id="tabs-gitalk" class="tabcontent"><div id="gitalk-container"></div></div><div id="tabs-valine" class="tabcontent"><div id="comments-valine"></div></div></div></div><script>function openPage(e,t){for(var n=document.getElementsByClassName("tabcontent"),l=0;l<n.length;l++)n[l].style.display="none";for(tablinks=document.getElementsByClassName("tablink"),l=0;l<tablinks.length;l++)tablinks[l].classList.remove("currentTabcontent");document.getElementById(e).style.display="block",t.classList.add("currentTabcontent")}document.getElementById("defaultOpen").click()</script></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="../images/loading-post.gif" data-original="/images/logo.jpg" alt="Qcmoke"></a><p class="site-author-name" itemprop="name">Qcmoke</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">91</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:qcmoke@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://github.com/qcmoke" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/5469824288" target="_blank" title="weibo"><i class="fa fa-fw fa-weibo"></i>weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li class="recent_posts_li"><a href="/windows/clean_c_drive.html" title="Windows系统C盘清理" target="_blank">Windows系统C盘清理</a></li><li class="recent_posts_li"><a href="/devops/lvs.html" title="lvs学习笔记" target="_blank">lvs学习笔记</a></li><li class="recent_posts_li"><a href="/devops/mysql_ha.html" title="Keepalived+MySQL实现高可用" target="_blank">Keepalived+MySQL实现高可用</a></li><li class="recent_posts_li"><a href="/devops/keepalived.html" title="keepalived学习笔记" target="_blank">keepalived学习笔记</a></li><li class="recent_posts_li"><a href="/tools/pyenv.html" title="python版本管理工具pyenv" target="_blank">python版本管理工具pyenv</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-简介"><span class="nav-text">一、简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-概念"><span class="nav-text">二、概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概要理解"><span class="nav-text">1. 概要理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-核心内容"><span class="nav-text">2. 核心内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-对比传统虚拟机"><span class="nav-text">3. 对比传统虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-优势"><span class="nav-text">4. 优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-分层存储"><span class="nav-text">5. 分层存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-容器存储层"><span class="nav-text">6. 容器存储层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-数据卷"><span class="nav-text">7. 数据卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-docker-安装和维护"><span class="nav-text">三、Docker 安装和维护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-包管理器安装-docker"><span class="nav-text">1. 包管理器安装 Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-安装旧版本-不推荐"><span class="nav-text">1）安装旧版本（不推荐）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-安装新版本"><span class="nav-text">2）安装新版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-内网环境集群安装"><span class="nav-text">3）内网环境集群安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-yum离线安装"><span class="nav-text">（1）yum离线安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-完全离线安装"><span class="nav-text">（2）完全离线安装</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-参考"><span class="nav-text">4）参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-一键脚本安装-docker"><span class="nav-text">2. 一键脚本安装 Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-配置-docker-的镜像源"><span class="nav-text">3. 配置 Docker 的镜像源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-配置-docker-的默认存储路径-可选"><span class="nav-text">4. 配置 Docker 的默认存储路径（可选）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-docker-服务管理"><span class="nav-text">5. Docker 服务管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-卸载-docker"><span class="nav-text">6. 卸载 Docker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-镜像管理"><span class="nav-text">四、镜像管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-容器管理"><span class="nav-text">五、容器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-管理命令"><span class="nav-text">1. 管理命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-设置容器与宿主机时间同步"><span class="nav-text">2. 设置容器与宿主机时间同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-数据管理"><span class="nav-text">六、数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数据卷"><span class="nav-text">1. 数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-数据卷挂载"><span class="nav-text">1.1 数据卷挂载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-绑定挂载"><span class="nav-text">1.2 绑定挂载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数据卷容器"><span class="nav-text">2. 数据卷容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-docker-网络"><span class="nav-text">七、Docker 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-host-模式"><span class="nav-text">1. host 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-container-模式"><span class="nav-text">2. container 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-none-模式"><span class="nav-text">3. none 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-bridge-模式-默认模式"><span class="nav-text">4. bridge 模式（默认模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-自定义网络"><span class="nav-text">5. 自定义网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-多个容器之间通过容器名称互相访问"><span class="nav-text">6. 多个容器之间通过容器名称互相访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-查看容器ip"><span class="nav-text">7. 查看容器ip</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-docker与防火墙"><span class="nav-text">8. Docker与防火墙</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-bridge-网络模式的防火墙配置"><span class="nav-text">1）bridge 网络模式的防火墙配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-host-网络模式的防火墙配置"><span class="nav-text">2）host 网络模式的防火墙配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-反向代理到容器"><span class="nav-text">9. 反向代理到容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-简要概述"><span class="nav-text">1）简要概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-限制外网访问-docker-容器"><span class="nav-text">2）限制外网访问 docker 容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-通过nginx反向代理到docker的http服务容器"><span class="nav-text">3）通过nginx反向代理到docker的HTTP服务容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-构建自定义镜像"><span class="nav-text">八、构建自定义镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方式1：上传程序到vps后构建"><span class="nav-text">方式1：上传程序到vps后构建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-拉取tomcat镜像到宿主机"><span class="nav-text">（1）拉取tomcat镜像到宿主机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-上传war包"><span class="nav-text">（2）上传war包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-编写dockerfile文件"><span class="nav-text">（3）编写Dockerfile文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-构建生成镜像"><span class="nav-text">（4）构建生成镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-查看本地镜像仓库是否构建成功"><span class="nav-text">（5）查看本地镜像仓库是否构建成功</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-通过构建的镜像实例化一个容器并运行"><span class="nav-text">（6）通过构建的镜像实例化一个容器并运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-访问测试"><span class="nav-text">（7）访问测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-其他"><span class="nav-text">（8）其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方式2：通过idea插件连接vps构建"><span class="nav-text">方式2：通过idea插件连接vps构建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-配置docker允许外网访问"><span class="nav-text">（1）配置docker允许外网访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-重新加载配置并重启docker"><span class="nav-text">（2）重新加载配置并重启Docker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-启动防火墙并开放2375端口"><span class="nav-text">（3）启动防火墙并开放2375端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-创建一个springboot项目"><span class="nav-text">（4）创建一个springboot项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-编译项目生成jar包"><span class="nav-text">（5）编译项目生成jar包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-配置远程docker插件连接"><span class="nav-text">（6）配置远程docker插件连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-然后配置dockerfile"><span class="nav-text">（7）然后配置DockerFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-运行docker插件"><span class="nav-text">（8）运行docker插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-访问测试"><span class="nav-text">（9）访问测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-docker-compose"><span class="nav-text">九、Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-简介"><span class="nav-text">1. 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-安装"><span class="nav-text">2. 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-卸载"><span class="nav-text">3. 卸载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-编排文件"><span class="nav-text">4. 编排文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-操作命令"><span class="nav-text">5. 操作命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十-docker-swarm"><span class="nav-text">十、Docker Swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-关闭所有服务器的防火墙"><span class="nav-text">1. 关闭所有服务器的防火墙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-初始化-swarm-集群"><span class="nav-text">2. 初始化 swarm 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-添加worker节点"><span class="nav-text">3. 添加worker节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-添加manager节点"><span class="nav-text">4. 添加manager节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-查看所有管理的节点"><span class="nav-text">5. 查看所有管理的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-创建集群服务"><span class="nav-text">6. 创建集群服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-查看服务集群情况"><span class="nav-text">7. 查看服务集群情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-集群服务扩容"><span class="nav-text">8. 集群服务扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-删除集群服务"><span class="nav-text">9. 删除集群服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-修改服务"><span class="nav-text">10. 修改服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-服务回滚"><span class="nav-text">11. 服务回滚</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一-运行常用-docker-容器示例"><span class="nav-text">十一、运行常用 Docker 容器示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-安装-nginx"><span class="nav-text">1. 安装 nginx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-安装-tomcat"><span class="nav-text">2. 安装 tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-安装-mysql"><span class="nav-text">3. 安装 mysql</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-安装-rabbitmq"><span class="nav-text">4. 安装 rabbitmq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-安装-redis"><span class="nav-text">5. 安装 redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-安装-zookeeper"><span class="nav-text">6. 安装 zookeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-安装-kafka"><span class="nav-text">7. 安装 kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-安装-linux-系统"><span class="nav-text">8. 安装 Linux 系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装-centos-容器"><span class="nav-text">安装 centos 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单用法"><span class="nav-text">简单用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-ssh-服务并支持简体中文"><span class="nav-text">使用 ssh 服务并支持简体中文</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#容器内部修改的方式"><span class="nav-text">容器内部修改的方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#编写-dockerfile-封装镜像的方式"><span class="nav-text">编写 Dockerfile 封装镜像的方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高特权用法"><span class="nav-text">高特权用法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装-ubuntu-容器"><span class="nav-text">安装 ubuntu 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单用法-v2"><span class="nav-text">简单用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-ssh-服务并支持简体中文-v2"><span class="nav-text">使用 ssh 服务并支持简体中文</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#容器内部修改的方式-v2"><span class="nav-text">容器内部修改的方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#编写-dockerfile-封装镜像的方式-v2"><span class="nav-text">编写 Dockerfile 封装镜像的方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高特权用法-v2"><span class="nav-text">高特权用法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多-linux-系统参考"><span class="nav-text">更多 Linux 系统参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二-问题排错"><span class="nav-text">十二、问题排错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三-参考"><span class="nav-text">十三、参考</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Qcmoke</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">本站访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次 </span><span class="site-pv">本站总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div><a href="https://beian.miit.gov.cn/" target="_blank">黔ICP备20002951号-1</a></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><i id="darkmode" class="fa fa-lightbulb-o" aria-hidden="true"></i><script>var body=$("body"),darkmode=$("#darkmode");!matchMedia("(prefers-color-scheme: dark)").matches&&"1"!==localStorage.getItem("darkmode")||"1"===localStorage.getItem("noDark")||body.addClass("dark"),body.hasClass("dark")?darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o"):darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o"),darkmode.click(function(){body.hasClass("dark")?(darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o"),body.removeClass("dark"),localStorage.setItem("darkmode","0"),localStorage.setItem("noDark","1")):(darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o"),body.addClass("dark"),localStorage.setItem("darkmode","1"),localStorage.setItem("noDark","0"))})</script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/clipboard.min.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/highlight-wrap.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="/js/src/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">for(var emoticonList=[],i=1;i<=164;i++)emoticonList.push("aru ("+i+").png");new Valine({lang:"zh-cn",admin_email:"qcmoke@gmail.com",el:"#comments-valine",appId:"6LNbUERxbG0OAnWfmJSbmXiW-MdYXbMMI",appKey:"d2FLy9fmXOTiM8TrokuIuDWx",placeholder:"留下你的小爪印吧~",serverURLs:"https://leancloud.qcmoke.cn"})</script><script>var checkExist;window.location.hash&&(checkExist=setInterval(function(){$(window.location.hash).length&&($("html, body").animate({scrollTop:$(window.location.hash).offset().top-90},1e3),clearInterval(checkExist))},100))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script type="text/javascript">const gitalk=new Gitalk({clientID:"d933e443cdfe503ce05a",clientSecret:"149d163f4b10cedf7a68993289da9c0f0836bd34",repo:"mygitalk",owner:"qcmoke",admin:"qcmoke".split(","),id:location.pathname,distractionFreeMode:"true",createIssueManually:"true"});gitalk.render("gitalk-container")</script><script type="text/javascript">var isfetched=!1,isXml=!0,search_path="search.xml",path=(0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1),"/"+search_path),onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")};function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var searchFunc=function(t,s,a){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");function e(){var e,m=n.value.trim().toLowerCase(),x=m.split(/[\s\-]+/),w=(1<x.length&&x.push(m),[]);0<m.length&&o.forEach(function(t){var e=!1,o=0,h=0,n=t.title.trim(),r=n.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),a=s.toLowerCase(),i=decodeURIComponent(t.url),c=[],l=[];if(""!=n&&(x.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r,s=0,a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(r=e.indexOf(t,s));)a.push({position:r,word:t}),s=r+n;return a}c=c.concat(e(t,r,!1)),l=l.concat(e(t,a,!1))}),0<c.length||0<l.length)&&(e=!0,o=c.length+l.length),e){function p(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===m&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}[c,l].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});for(var t=[],u=(0!=c.length&&t.push(p(0,0,n.length,c)),[]);0!=l.length;){var f=l[l.length-1],d=f.position,f=f.word,g=d-20,v=d+80;g<0&&(g=0),(v=v<d+f.length?d+f.length:v)>s.length&&(v=s.length),u.push(p(0,g,v,l))}u.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});e=parseInt("1");function $(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}0<=e&&(u=u.slice(0,e));var C="";C+=0!=t.length?"<li><a href='"+i+"' class='search-result-title'>"+$(n,t[0])+"</a>":"<li><a href='"+i+"' class='search-result-title'>"+n+"</a>",u.forEach(function(t){C+="<a href='"+i+'\'><p class="search-result">'+$(s,t)+"...</p></a>"}),C+="</li>",w.push({item:C,searchTextCount:h,hitCount:o,id:w.length})}}),1===x.length&&""===x[0]?r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>':0===w.length?r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>':(w.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id}),e='<ul class="search-result-list">',w.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e)}var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(s),r=document.getElementById(a);n.addEventListener("input",e),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script>function addCount(n){var t=$(".leancloud_visitors"),o=t.attr("id").trim(),i=t.attr("data-flag-title").trim();n("get","/classes/Counter",{where:JSON.stringify({url:o})}).done(function({results:t}){var e;0<t.length?(e=t[0],n("put","/classes/Counter/"+e.objectId,JSON.stringify({time:{__op:"Increment",amount:1}})).done(function(){$(document.getElementById(o)).find(".leancloud-visitors-count").text(e.time+1)}).fail(function({responseJSON:t}){console.log("Failed to save Visitor num, with error message: "+t.error)})):n("post","/classes/Counter",JSON.stringify({title:i,url:o,time:1})).done(function(){$(document.getElementById(o)).find(".leancloud-visitors-count").text(1)}).fail(function(){console.log("Failed to create")})}).fail(function({responseJSON:t}){console.log("LeanCloud Counter Error: "+t.code+" "+t.error)})}$(function(){$.get("https://app-router.leancloud.cn/2/route?appId=6LNbUERxbG0OAnWfmJSbmXiW-MdYXbMMI").done(function({}){/http:\/\/(localhost|127.0.0.1|0.0.0.0)/.test(document.URL)||addCount(function(t,e,n){return $.ajax({method:t,url:"https://leancloud.qcmoke.cn/1.1"+e,headers:{"X-LC-Id":"6LNbUERxbG0OAnWfmJSbmXiW-MdYXbMMI","X-LC-Key":"d2FLy9fmXOTiM8TrokuIuDWx","Content-Type":"application/json"},data:n})})})})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={iconStyle:"default",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script type="text/javascript">(wpac_init=window.wpac_init||[]).push({widget:"Rating",id:23769,el:"wpac-rating",color:"fc6423"}),function(){var e,t;"WIDGETPACK_LOADED"in window||(WIDGETPACK_LOADED=!0,(e=document.createElement("script")).type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js",(t=document.getElementsByTagName("script")[0]).parentNode.insertBefore(e,t.nextSibling))}()</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":80,"height":130},"mobile":{"show":false},"log":false});</script></body></html>