<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows系统C盘清理]]></title>
    <url>%2Fwindows%2Fclean_c_drive.html</url>
    <content type="text"><![CDATA[¶概述随着使用时间的增长，Windows系统C盘上会产生大量的临时文件、软件缓存、日志文件等，这些文件会占用越来越多的磁盘空间，从而导致系统运行缓慢、响应迟钝等问题。如果及时清理这些无关紧要的文件，就可以为计算机腾出更多的磁盘空间，提高系统性能和响应速度。我们可以通过 SpaceSniffer 等磁盘空间分析软件可以分析出C盘中占用空间比较大的目录或文件。通常安装的应用程序都会将运行时的数据、缓存、日志、临时文件等存到C盘的 C:\Users\%username%\AppData 目录下，所以这个目录一般会比较占用空间。Windows系统的AppData目录是用于存储应用程序数据的文件夹，它位于每个用户的个人文件夹中。通常情况下，这个文件夹是隐藏的，需要在文件夹选项中选择“显示隐藏的文件、文件夹和驱动器”才能看到。AppData目录包含三个子目录：Local、Roaming和LocalLow。其中：Local：存储应用程序无需跨多设备同步的数据，包括本地应用程序数据，包括缓存、日志、临时文件等。例如：编译器构建缓存，浏览器缓存等。Roaming：存储用户配置文件和跨多设备同步的数据。例如：vscode配置、QQ聊天记录、浏览器书签等。LocalLow：存储低权限访问数据，例如：在受保护模式下运行时浏览器的临时文件。一般Local目录是下的文件都是可以删除的，因为这些文件通常不会影响到操作系统的正常运行。但是对于用户安装的应用程序，如果删除到这些程序的数据文件，则可能会影响应用程序的正常运行。缓存、日志、临时文件等都是可以删除的，但是由于这个目录存放了太多程序的数据，以至于很难找到它们，另外应用程序的数据文件又不知道该不该删除，所以删除这个目录里的文件就会变得很棘手。特别说明的是C:\Users\%username%\AppData\Local\Temp里的文件是可以放心删除的，不会影响到应用程序的正常运行。为了应用程序的正常运行，一般对于Roaming目录下的文件都不建议删除。为了解决以上问题，这里给出两种处理方案：¶定期清理方案第一种就是总结C盘垃圾清理经验给出的Windows批处理脚本，只需双击执行这个脚本就能清除大部分不影响操作系统和应用程序运行的垃圾，不过这种方式只能一次性清理，需要定期执行清理脚本。脚本如下：创建脚本文件：C盘垃圾清理.bat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@echo off::------------------------------ 自动提升运行权限 ------------------------------:::BatchGetAdmin&gt;nul 2&gt;&amp;1 "%Windir%\System32\cacls.exe" "%Windir%\System32\config\system"if '%ERRORLEVEL%' NEQ '0' (echo 正在获取管理员权限...goto UACPrompt) else ( goto gotAdmin ):UACPromptecho Set UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\getAdmin.vbs"echo UAC.ShellExecute "%~s0", "", "", "runas", 1 &gt;&gt; "%TEMP%\getAdmin.vbs""%TEMP%\getAdmin.vbs"exit:gotAdminif exist "%TEMP%\getadmin.vbs" ( del "%TEMP%\getadmin.vbs" )pushd "%cd%"cd /d "%~dp0"::------------------------------------------------------------------------------::echo 正在清除系统垃圾文件，请稍等......goto han**********这里是（liulangzhehwm）注释************************参考：https://blog.csdn.net/xiaiming0/article/details/123843813del DOS下的删除命令/f 加个参数/f表示强制删除只读文件/s 这个表示包括所有子目录中的文件/q 这个表示不需要删除确认*.tmp 所有的临时文件，*是通配符，tmp是临时文件的扩展名。LOG 曰志文件BAK 备份文件CHK 由Windows磁盘碎片整理器或磁盘扫描保存的文件碎片recycled 这就是回收站。prefetch 预读取文件夹。用来存放系统已访问过的文件的预读信息，扩展名为PF。之所以自动创建Prefetch文件夹，是为了加快系统启动的进程.temp 是临时文件夹cookies 是IE浏览器下的文件夹，主要记录你浏览网页信息，包括：网址、缩略图、ID等。当你再次浏览这些网页时，就不再需要下载某些图片、输入ID、密码等，可以提高网页打开的速度，提高浏览速度。local settings 文件夹是Windows操作系统中一个隐藏文件夹，我们在上网中产生的历史记录缓存都存放在local settings这个文件夹中。Recent 是系统文件夹，里面存放着你最近使用的文档的快捷方式，以方便你再次访问。不推荐删除，因为这些文件都是快捷方式，不会占用你多少内存空间的。%USERPROFILE% =C:\Users\用户名%SystemRoot% =C:\WINDOWS%SystemDrive% =C:%APPDATA% =C:\Users\用户名\AppData\Roaming%LOCALAPPDATA% =C:\Users\用户名\AppData\Local%windir% =C:\WINDOWS%Path% =C:\Windows\system32;C:\Windows; %ProgramData% =C:\ProgramData%ProgramFiles% =C:\Program Files%ProgramFiles(x86)% =C:\Program Files (x86)************************注释结束**********************:handel /f /s /q %systemdrive%\*.tmpdel /f /s /q %systemdrive%\*._mpdel /f /s /q %systemdrive%\*.logdel /f /s /q %systemdrive%\*.giddel /f /s /q %systemdrive%\*.chkdel /f /s /q %systemdrive%\*.olddel /f /s /q %systemdrive%\recycled\*.*del /f /s /q %windir%\*.bakdel /f /s /q %windir%\prefetch\*.*rd /s /q %windir%\temp &amp; md %windir%\tempdel /f /q %userprofile%\cookies\*.*del /f /q %userprofile%\recent\*.*del /f /s /q "%userprofile%\Local Settings\Temporary Internet Files\*.*"del /f /s /q "%userprofile%\Local Settings\Temp\*.*"del /f /s /q "%userprofile%\recent\*.*"echo 清除系统LJ完成！echo. &amp; pause¶通过软链接迁移目录方案¶1. 概述第二种方案是针对于不能删除或者不清楚是否可以删除的情况，即通过将C盘中的目录移动到其他盘的目录，然后再在C盘原目录下建立同名的软链接指向新目录，软链接本身几乎不占用存储空间（几个字节），这种方式即能节省C盘空间又不影响操作系统和应用程序的运行。另外这种方式的优点就是比较省心，不用定期清理C盘。¶2. 迁移目录并创建软链接¶方式1：cmd命令迁移管理员身份运行cmd命令执行：12345678910#创建目录mkdir 新目录路径#复制原目录文件到新目录（由于Windows11上move命令无法跨盘符移动，故改用xcopy+rd实现）xcopy /s /e /h /y 原目录路径 新目录路径#删除原目录rd /s /q 原目录路径#创建软链接（原目录）mklink /D 原目录路径 新目录路径可以通过 SpaceSniffer 工具查找出C:/Users/%username%目录里空间占用比较大的目录，然后通过选择性的进行处理。建议原目录和新目录里的子目录保持一致，这样也更好维护一点，也能原目录和新目录的子目录相对路径一致，查找起来也比较方便。💁‍♂ 提示：请务必确保所操作的目录没有被程序占用，一定注意要把相关目录占用的程序关掉（比如QQ、Chrome等），否则迁移失败。📑 示例：通过软链接迁移腾讯软件（QQ、微信等）的数据和缓存目录1234mkdir E:\Cache\SymlinkData\AppData\Local\Googlexcopy /s /e /h /y C:\Users\%username%\AppData\Roaming\Tencent E:\Cache\SymlinkData\AppData\Roaming\Tencentrd /s /q C:\Users\%username%\AppData\Roaming\Tencentmklink /D C:\Users\%username%\AppData\Roaming\Tencent E:\Cache\SymlinkData\AppData\Roaming\Tencent🔖 常见的需要迁移的目录如下：123456789101112131415##（1）Chrome数据和缓存目录：C:\Users\%username%\AppData\Local\Google #可迁移至：E:\Cache\SymlinkData\AppData\Local\Google##（2）腾讯软件（QQ、微信等）的数据和缓存目录：C:\Users\%username%\AppData\Roaming\Tencent #可迁移至：E:\Cache\SymlinkData\AppData\Roaming\Tencent##（3）vscode#vscode插件目录：C:\Users\%username%\.vscode #可迁移至：E:\Cache\SymlinkData\.vscode#vscode数据目录：C:\Users\%username%\AppData\Roaming\Code #可迁移至：E:\Cache\SymlinkData\AppData\Roaming\Code#vscode缓存目录（C盘没有数据的话可以不迁移）：C:\Users\%username%\AppData\Local\Programs\Microsoft VS Code #可迁移至：E:\Cache\SymlinkData\AppData\Local\Programs\Microsoft VS Code#vscode C/C++编译缓存目录：C:\Users\%username%\AppData\Local\Microsoft\vscode-cpptools #可迁移至：E:\Cache\SymlinkData\AppData\Local\Microsoft\vscode-cpptools¶方式2：批处理脚本迁移如果以上操作比较麻烦也可以将这些命令写成脚本执行，如下：创建脚本文件：通过软链接迁移目录.bat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165@echo offsetlocal enabledelayedexpansion::------------------------------ 自动提升运行权限 ------------------------------:::BatchGetAdmin&gt;nul 2&gt;&amp;1 "%Windir%\System32\cacls.exe" "%Windir%\System32\config\system"if '%ERRORLEVEL%' NEQ '0' (echo 正在获取管理员权限...goto UACPrompt) else ( goto gotAdmin ):UACPromptecho Set UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\getAdmin.vbs"echo UAC.ShellExecute "%~s0", "", "", "runas", 1 &gt;&gt; "%TEMP%\getAdmin.vbs""%TEMP%\getAdmin.vbs"exit:gotAdminif exist "%TEMP%\getadmin.vbs" ( del "%TEMP%\getadmin.vbs" )pushd "%cd%"cd /d "%~dp0"::------------------------------------------------------------------------------:::menuclsecho. ------------------------------------------------------------echo. 指令菜单： echo. 1.开始迁移目录 echo. 2.只创建软链接 echo. 3.退出 echo. ------------------------------------------------------------set choose=""set /p choose= 请输入指令[1/2/3]:if /i "%choose%"=="1" (goto:start)if /i "%choose%"=="2" (goto:tolink)if /i "%choose%"=="3" (goto:exit) else ( goto:menu ):start@REM goto横行的代码中，最好重置一下变量的值，否则可能会变量污染set old_path_dir=""@REM 需要迁移的原目录路径set /p old_path_dir=需要迁移的原目录路径：for /f "delims=" %%i in ('echo %old_path_dir%') do set old_path_dir_value=%%iif not exist "%old_path_dir_value%" ( cls &amp; echo. &amp;&amp; echo 原目录不存在！ pause goto:menu)@REM 需要迁移的新目录路径set new_path_dir=""set /p new_path_dir=需要迁移的新目录路径：for /f "delims=" %%i in ('echo %new_path_dir%') do set new_path_dir_value=%%iif "%new_path_dir_value%"=="" ( cls &amp; echo. &amp;&amp; echo 输入非法，请重试！ pause goto:menu)if exist "%new_path_dir_value%" ( cls &amp; echo. &amp;&amp; echo %new_path_dir_value% 目录已存在！ pause goto:menu):confirmset is_confirm=""set /p is_confirm=请务必确保所操作的目录没有被程序占用，确认输入y 否输入n：if /i not "%is_confirm%" == "y" if /i not "%is_confirm%" == "n" ( echo 请输入 y 或 n goto:confirm) else if /i "%is_confirm%" == "n" ( goto:menu)@REM 创建新目录mkdir "%new_path_dir_value%"echo 创建新目录%new_path_dir_value%完成@REM 移动原目录到新目录，由于Windows11上move命令无法跨盘符移动，故改用xcopy+del实现xcopy /s /e /h /y "%old_path_dir_value%" "%new_path_dir_value%"@REM echo "====%ERRORLEVEL%====="if %ERRORLEVEL% NEQ 0 ( cls &amp; echo. &amp;&amp; echo 复制目录文件失败！请排查是否有程序占用%old_path_dir_value%目录的文件！ pause goto:menu)@REM 删除原目录rd /s /q "%old_path_dir_value%"if exist "%old_path_dir_value%" ( cls &amp; echo. &amp;&amp; echo 删除原目录失败,请排查是否有程序占用相关目录内的文件！ set is_confirm_rd="" set /p is_confirm_rd=是否需要删除已复制的新目录，确认输入y 否输入n： if /i "!is_confirm_rd!" == "y" ( echo "删除中...." rd /s /q "!new_path_dir_value!" ) else ( echo "您未删除已复制的新目录，如需重试则需要自行手动删除！" ) pause goto:menu)echo 移动原目录到新目录完成goto:dolink:tolink@REM 设置软链接路径set old_path_dir=""set /p old_path_dir=设置软链接路径：for /f "delims=" %%i in ('echo %old_path_dir%') do set old_path_dir_value=%%iif "%old_path_dir_value%"=="" ( cls &amp; echo. &amp;&amp; echo 输入非法，请重试！ pause goto:menu)@REM 设置软链接的目标目录路径set new_path_dir=""set /p new_path_dir=设置目标目录路径：for /f "delims=" %%i in ('echo %new_path_dir%') do set new_path_dir_value=%%iif "%new_path_dir_value%"=="" ( cls &amp; echo. &amp;&amp; echo 输入非法，请重试！ pause goto:menu):dolink@REM 创建软链接if exist "%old_path_dir_value%" ( cls &amp; echo. &amp;&amp; echo %old_path_dir_value% 目录已存在，不允许在已存在的目录创建链接！ pause goto:menu)if not exist "%new_path_dir_value%" ( cls &amp; echo. &amp;&amp; echo 目标目录：%new_path_dir_value% 不存在！ pause goto:menu)mklink /D "%old_path_dir_value%" "%new_path_dir_value%"if %ERRORLEVEL% NEQ 0 ( cls &amp; echo. &amp;&amp; echo 创建软链接失败！！ pause goto:menu )set "tip= 创建软链接完成：%old_path_dir_value% ==》 %new_path_dir_value%"cls &amp; echo. &amp;&amp; echo %tip%pausegoto:menu::--------------------------------- 倒计时退出 ---------------------------------:::exitfor /l %%t in (3,-1,0) do ( echo. &amp; echo %%t 秒后退出... choice.exe /t 1 /d y /n &gt;nul)Exit¶3. 查找创建的软链接在后期的维护中创建的软链接越来越多，需要找出创建的软链接和其指向路径就会变得很麻烦。下面给出几种查找已创建软链接的方式。¶方式1：cmd命令查找可以通过如下cmd命令查找已创建软链接，操作如下：1234#查看某目录及其子目录下的所有软软链接dir /a:l /s#如果打印的内容比较多还可以进一步过滤dir /a:l /s | findstr /r "SYMLINKD"¶方式2：python脚本查找如果上面的cmd命令查找不理想，还可以通过执行python脚本来查找，操作如下：创建脚本文件：get_symlinks.py1234567891011121314151617181920212223242526import osimport tkinterfrom tkinter import filedialogdef get_symlinks(path): count = 0 for root, dirs, files in os.walk(path): for name in dirs + files: fullpath = os.path.join(root, name) if os.path.islink(fullpath): print(f"&#123;fullpath&#125; -&gt; &#123;os.readlink(fullpath)&#125;") count += 1 if count == 0: print("该目录下没有软链接！")if __name__ == '__main__': tk = tkinter.Tk() tk.withdraw() directory = filedialog.askdirectory( initialdir='C:\\Users\\'+os.environ.get("username")) if len(directory) == 0: exit(1) get_symlinks(directory)¶4. 其他说明（1）关于快捷方式和软链接的说明快捷方式(shortcut)：实际上是一个后缀.link的文件，删除快捷方式文件不影响原始文件，删除原始文件则快捷方式文件将变成无效文件。这个文件只有在windows图形界面下点击才能到达目标文件路径，在命令行下仅是一个文件，程序不会将其当作链接。软链接(symbolic link)：也称符号链接，本质是一个指向文件或目录的指针文件，删除软链接文件不影响原始文件，删除原始文件则软链接文件将变成无效文件。这个文件在图形界面与快捷方式无异，但在命令行下程序会把它当做一个链接。]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lvs学习笔记]]></title>
    <url>%2Fdevops%2Flvs.html</url>
    <content type="text"><![CDATA[¶一、简要概述LVS（Linux Virtual Server）是在 LInux 中的一种基于网络层的高性能负载均衡技术。LVS 的核心模块（即 ipvs）已被集成到 Linux 内核中。LVS 是章文嵩博士主导的开源的负载均衡项目。注意：LVS 是基于网络层的负载均衡解决方案，通过 IP 数据包转发实现负载均衡。HAProxy 和 Nginx 是基于应用层的负载均衡解决方案，通过代理请求和响应来实现负载均衡。LVS 由于是基于网络层的且直接在内核层进行操作的，故相对于对于 Nginx 具有更佳的性能和吞吐量。但由于其基于网络层无法处理数据报文以导致无法像 Nginx 那样基于 URL 做负载均衡，故在实际生产环境下通常同时使用 LVS + Nginx 共同实现负载均衡需求（即 LVS 负责 IP 流量分流到 Nginx，Nginx 负责根据数据报文（如：URL等）进行连接分流），这样的组合架构充分发挥了LVS的性能优势和Nginx的高级功能，满足了不同层次的负载均衡需求。¶二、LVS 工作模式LVS（Linux Virtual Server）是一个开源的负载均衡解决方案，它提供了多种工作模式来实现负载均衡和高可用性。LVS有三种主要工作模式，即：NAT 模式、TUN 模式、DR 模式。每种工作模式都有其适用的场景和特点，选择合适的模式取决于具体的需求和环境。，通常 NAT 模式、尤其是 DR 模式是应用比较多的两种模式。提示：一般而言，NAT模式和DR模式下的LVS工作在网络层，而TUN模式下的LVS工作在传输层¶NAT 模式NAT（Network Address Translation）模式：也称网络地址转换模式。在NAT模式下，LVS作为一个网络层的负载均衡器，将客户端请求的数据包的目标IP地址和端口修改为后端服务器的IP地址和端口，然后将数据包转发给后端服务器。当后端服务器返回响应时，LVS再将响应的数据包的源IP地址和端口修改为负载均衡器的IP地址和端口，再将响应发送给客户端。NAT模式适用于负载均衡和网络地址转换的场景。NAT 模式集群网络拓扑类似于 Nginx。但 LVS 和 Nginx 的实现原理不同，Nginx 的实现原理是代理，而 LVS NAT模式的实现原理是流量（数据包）转发，可以理解 LVS 为路由器。代理和数据包转发的区别：代理和数据包转发是两种不同的网络通信方式，它们在实现原理和功能上有一些区别。（1）概念：代理是一种通过中间服务器来转发网络请求和响应的方式。当客户端发送请求时，请求首先发送给代理服务器，然后代理服务器再将请求发送到目标服务器，并将响应返回给客户端。代理服务器在请求和响应的传递过程中可以对数据进行修改、过滤或缓存，还可以实现负载均衡和内容路由等功能。代理通常工作在应用层，例如 HTTP 代理（如 Nginx、Apache）、反向代理等。数据包转发是一种直接将网络数据包从源地址转发到目标地址的方式。数据包转发通常在网络层进行，通过路由器或交换机等网络设备进行数据包的转发。数据包转发是基于 IP 地址和端口号来决定转发路径的，它不会修改请求和响应的内容，只负责将数据包从源设备转发到目标设备。常见的数据包转发技术包括 IP 路由、网络地址转换（NAT）等。（2）区别：代理是在应用层工作，可以对数据进行处理和修改，可以实现更灵活的功能，如负载均衡、缓存、安全过滤等。数据包转发是在网络层工作，主要负责将数据包从源地址转发到目标地址，不会对数据包进行修改。代理通常需要对请求进行解析和重新封装，因此会有一定的性能开销。数据包转发则更加直接和高效，因为它只涉及数据包的转发。代理通常工作在边缘节点，直接与客户端和服务器交互，可以在两者之间起到中间层的作用。数据包转发通常在网络设备上进行，作用于整个网络中的数据包转发过程。（3）适用场景：选择使用代理还是数据包转发取决于具体的需求和场景。代理适合需要对请求和响应进行处理和修改的场景，而数据包转发适合需要直接转发网络数据包的场景。¶TUN 模式TUN（Tunneling）模式：也称 IP 隧道模式。 在TUN模式下，LVS将客户端请求的数据包封装成IP隧道，在传输层（TCP/UDP）上进行负载均衡。LVS将隧道数据包转发给后端服务器，后端服务器进行解封装并处理请求。后端服务器将响应的数据包返回给LVS，LVS再将响应封装成隧道数据包发送给客户端。TUN模式适用于需要在传输层进行负载均衡的场景。TUN 模式有个硬性的要求是真实服务器需要暴露在公网环境下（即网卡 IP 需要暴露在公网环境），这样会存在比较大的安全隐患，故而真实生产环境下用的比较少。¶DR 模式DR（Direct Routing）模式： 也称直接路由模式。在DR模式下，LVS作为一个二层负载均衡器，客户端请求的数据包到达负载均衡器后，负载均衡器会直接将数据包转发给后端服务器，不对数据包的IP地址和端口进行修改。后端服务器将响应直接发送给客户端，绕过了负载均衡器。DR模式适用于高性能的负载均衡需求。DR 模式下真实服务器可以在私网环境，而不需要暴露在公网环境下，真实服务器响应时只需经路由器返回给客户端即可（多个真实服务器可以统一使用一个路由器，但为了提升响应吞吐性能也可以考虑为每个真实服务器配置单独的路由器，具体实现待研究学习（TODO）…）。提示：如果仅是实验测试，客户端、LVS、真实服务器网络连通，可以不为真实服务器配置路由器而是直接返回给客户端。¶三、LVS NAT 模式集群¶1. 准备环境（1）LVS 服务器：DIP：192.168.60.101VIP：192.168.17.101（提供给客户端访问的 IP）（2）Real Server1：RIP：192.168.60.201（必须配置网关为 DIP）（2）Real Server2：RIP：192.168.60.202（必须配置网关为 DIP）注意：如以上环境为 Vmware 虚拟机，DIP 、VIP、RIP 的 Vmware 网卡网络连接方式可为任意网络模式，但需要注意，DIP 和 RIP 需要是同一网段（即同一网卡），而 VIP 需要是另一网段（即另一个网卡）。本次实验对几个虚拟机的网卡设定为：DIP 和 RIP 使用 VMnet8 网卡（NAT模式），而 VIP 使用新增的 VMnet1 网卡（仅主机模式）。Vmware 虚拟机配置如下：¶2. 真实服务器配置¶1）网络配置Real Server1 网络配置：12345678910111213141516171819202122232425#配置RIP并设置网关为DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.201"GATEWAY="192.168.60.101"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restart注意：以上 GATEWAY 需要配置为 DIP 的值。Real Server2 网络配置：12345678910111213141516171819202122232425#配置RIP并设置网关为DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.202"GATEWAY="192.168.60.101"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restart¶2）部署web服务（Nginx）在 Real Server1 和 Real Server2 两台真实服务器上执行以下步骤操作：12345678910111213141516171819202122232425262728293031323334353637#拉取(下载)镜像docker pull nginx:latest#首先简单运行一个nginx临时容器，用于复制容器内部的一些nginx相关重要文件到宿主机docker run -d --name nginx nginx:latest#创建映射目录mkdir -p /opt/nginx/&#123;conf,html,logs&#125;#复制容器内部的一些nginx相关重要文件到映射目录中(注意命令中的末尾的点，它表示复制目录中的所有内容而不是整个目录本身)docker cp nginx:/etc/nginx/. /opt/nginx/confdocker cp nginx:/usr/share/nginx/html/. /opt/nginx/htmldocker cp nginx:/var/log/nginx/. /opt/nginx/logs#删除nginx临时容器docker rm -f nginx#生产环境下运行nginx容器#（1）使用host网络模式直接使用宿主机网络IP地址和端口（可以避免每次配置新的监听端口都需要重新docker run映射端口）#（2）限制内存上限为200MB#（3）指定时区并同步宿主机和容器的时间#（4）映射几个主要的nginx相关目录docker run -d --name nginx \--net=host \-m 200m \-e TZ=Asia/Shanghai \-v /etc/localtime:/etc/localtime:ro \-v /opt/nginx/conf:/etc/nginx \-v /opt/nginx/html:/usr/share/nginx/html \-v /opt/nginx/logs:/var/log/nginx \nginx:latest#防火墙设置（开放nginx默认配置的80端口）firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload#备份nginx访问首页文件cp /opt/nginx/html/index.html /opt/nginx/html/index.old.html#将宿主机默认网卡的IP写到nginx访问首页文件ip route get 8.8.8.8 | grep -oP 'src\s+\K\S+' &gt; /opt/nginx/html/index.html¶3. LVS 服务器配置¶1）网络配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#配置DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.101"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#配置VIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens36 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens36"UUID="73c77ea7-8794-4f1b-8773-88ccd2348a8b"DEVICE="ens36"ONBOOT="yes"IPADDR="192.168.17.101"GATEWAY="192.168.17.1"NETMASK="255.255.255.0"DNS1="8.8.8.8"EOF#重启网络service network restart提示：以上配置 DIP 的 GATEWAY 值为 VMnet8 网卡的默认网关 IP（可以在 vmware 的“虚拟网络编辑器”中查看）。配置 VIP 的 GATEWAY 值为 VMnet8 网卡在物理机分配的 IP。新增的 VMware 网卡后，Linux 会自动多出一个网络接口，可通过 ip addr 或者 ls /sys/class/net 查看新增的网卡名称（如：ens36）¶2）配置服务器允许路由转发功能12345678#修改内核参数，配置LVS服务器允许路由转发功能，1为开启，0为关闭（默认）cat &gt;&gt; /etc/sysctl.conf &lt;&lt; 'EOF'net.ipv4.ip_forward = 1EOF#使sysctl.conf配置修改生效sysctl -p#查看配置是否生效cat /proc/sys/net/ipv4/ip_forward #注意不要直接修改这个文件的值，因为这个文件时临时文件，重启系统后将会被还原，所以应该是修改sysctl.conf来实现永久生效¶3）配置LVS-NAT集群¶（1）安装LVS集群管理工具1yum install -y ipvsadm¶（2）配置NAT集群1234567891011121314151617181920212223242526272829#操作前最好清空所有集群规则（防止操作过影响实验结果）ipvsadm -C#创建集群 -t 指定VIP地址和端口作为集群ID标识，-s指定负载均衡策略（rr表示轮询）ipvsadm -A -t 192.168.60.101:80 -s rr#添加真实服务器 -r指定RIP；-m指定LVS工作模式为NAT模式ipvsadm -a -t 192.168.60.101:80 -r 192.168.17.201 -mipvsadm -a -t 192.168.60.101:80 -r 192.168.17.202 -m#查看集群规则 #-L：参数表示列出当前的 IPVS 配置。 #-n：参数表示以数字形式显示 IP 地址和端口号，而不进行 DNS 解析。 #-c：参数表示连续显示 IPVS 的状态信息，而不进行分页显示。ipvsadm -Ln#查看集群连接状态ipvsadm -Lnc#防火墙设置##方式1：关闭防火墙#关闭firewalld防火墙systemctl stop firewalldsystemctl disable firewalld#清空当前的iptables规则，使防火墙恢复到默认状态。即：允许所有的网络流量通过，不进行任何过滤或限制#iptables -F##方式2：配置防火墙规则（TODO：未成功，尚未找到解决办法）#firewall-cmd --permanent --add-port=80/tcp#firewall-cmd --reload注意：VIP 和 RIP 一定不能是一个网段，否则NAT转发失败。¶4. 客户端测试1curl http://192.168.60.101:80¶四、LVS DR 模式集群¶1. 准备环境（1）LVS 服务器：DIP：192.168.60.101VIP：192.168.60.100（提供给客户端访问的 IP）（2）Real Server1：RIP：192.168.60.201VIP：192.168.60.100（响应客户端请求的 IP）（2）Real Server2：RIP：192.168.60.202VIP：192.168.60.100（响应客户端请求的 IP）说明：DIP（Director IP）：即 LVS 负载均衡器的 IP 地址RIP（Real IP）：即后端真实服务器的 IP 地址VIP（Virtual IP）：即 LVS 集群的虚拟 IP 地址LVS 的 VIP 是用于接收客户端的请求，LVS 通过自身的 DIP 将请求负载均衡转发到后端真实服务器（Real Server）的 RIP 上，响应则是通过 Real Server 的 VIP 返回给客户端。注意：如以上环境为 Vmware 虚拟机，DIP 、VIP、RIP 的 Vmware 网卡网络连接方式可为任意网络模式，但需要注意，DIP 和 RIP 需要是同一网段（即同一网卡），而 VIP 则通过网卡子接口的方式配置，无需增加网卡。本次实验对几个虚拟机的网卡设定为：DIP 和 RIP 使用 VMnet8 网卡（NAT模式），而 VIP 通过网卡子接口的方式配置。Vmware 虚拟机配置如下：¶2. 真实服务器配置¶1）网络配置Real Server1 网络配置：12345678910111213141516171819202122232425#配置RIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.201"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restartReal Server2 网络配置：12345678910111213141516171819202122232425#配置RIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.202"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restart在 Real Server1 和 Real Server2 两台真实服务器上都执行以下步骤操作：12345678910111213141516171819202122232425262728#配置VIP（通过配置lo回环网卡子接口设置VIP）cat &gt; /etc/sysconfig/network-scripts/ifcfg-lo:1 &lt;&lt; 'EOF'DEVICE=lo:1IPADDR=192.168.60.100NETMASK=255.255.255.255NETWORK=192.168.60.100BROADCAST=127.255.255.255ONBOOT=yesNAME=loopbackEOF#由于LVS服务器和两台真实服务器存在相同的VIP，会产生IP地址冲突，解决办法是修改内核参数。如下：#arp_ignore为1表示：当有arp广播问谁是VIP时，本机忽略掉ARP广播，不做任何回应#arp_announce为2表示：本机不要向外宣告自己的lo回环地址是VIPcat &gt;&gt; /etc/sysctl.conf &lt;&lt; 'EOF'net.ipv4.conf.all.arp_ignore = 1net.ipv4.conf.lo.arp_ignore = 1net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2EOF#使sysctl.conf配置修改生效sysctl -p#重启网络service network restart#查看IP配置是否生效ip addr¶2）部署web服务（Nginx）12345678910111213141516171819202122232425262728293031323334353637#拉取(下载)镜像docker pull nginx:latest#首先简单运行一个nginx临时容器，用于复制容器内部的一些nginx相关重要文件到宿主机docker run -d --name nginx nginx:latest#创建映射目录mkdir -p /opt/nginx/&#123;conf,html,logs&#125;#复制容器内部的一些nginx相关重要文件到映射目录中(注意命令中的末尾的点，它表示复制目录中的所有内容而不是整个目录本身)docker cp nginx:/etc/nginx/. /opt/nginx/confdocker cp nginx:/usr/share/nginx/html/. /opt/nginx/htmldocker cp nginx:/var/log/nginx/. /opt/nginx/logs#删除nginx临时容器docker rm -f nginx#生产环境下运行nginx容器#（1）使用host网络模式直接使用宿主机网络IP地址和端口（可以避免每次配置新的监听端口都需要重新docker run映射端口）#（2）限制内存上限为200MB#（3）指定时区并同步宿主机和容器的时间#（4）映射几个主要的nginx相关目录docker run -d --name nginx \--net=host \-m 200m \-e TZ=Asia/Shanghai \-v /etc/localtime:/etc/localtime:ro \-v /opt/nginx/conf:/etc/nginx \-v /opt/nginx/html:/usr/share/nginx/html \-v /opt/nginx/logs:/var/log/nginx \nginx:latest#防火墙设置（开放nginx默认配置的80端口）firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload#备份nginx访问首页文件cp /opt/nginx/html/index.html /opt/nginx/html/index.old.html#将宿主机默认网卡的IP写到nginx访问首页文件ip route get 8.8.8.8 | grep -oP 'src\s+\K\S+' &gt; /opt/nginx/html/index.html¶3. LVS 服务器配置在 LVS 服务器上执行以下步骤操作：¶1）网络配置123456789101112131415161718192021222324252627282930313233343536#配置DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.101"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#配置VIP（通过配置网卡子接口设置VIP）cat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33:1 &lt;&lt; 'EOF'BOOTPROTO="static"DEVICE="ens33:1"ONBOOT="yes"IPADDR="192.168.60.100"NETMASK="255.255.255.0"EOF#重启网络service network restart#查看IP配置是否生效ip addr¶2）配置LVS-DR集群¶（1）安装LVS集群管理工具1yum install -y ipvsadm提示：ipvsadm 并不是 LVS，ipvs 作为 LVS 的核心模块已经内置在了 Linux 内核中，但是由于不能直接操作内核，故才需要使用到 ipvsadm 作为 ipvs 的管理工具。¶（2）配置DR集群12345678910111213141516171819#操作前最好清空所有集群规则（防止操作过影响实验结果）ipvsadm -C#创建集群 -t 指定VIP地址和端口作为集群ID标识，-s指定负载均衡策略（rr表示轮询）ipvsadm -A -t 192.168.60.100:80 -s rr#添加真实服务器 -r指定RIP；-g指定LVS工作模式为DR模式（DR为默认模式，可以不指定）ipvsadm -a -t 192.168.60.100:80 -r 192.168.60.201 -gipvsadm -a -t 192.168.60.100:80 -r 192.168.60.202 -g#存配置或规则（以上添加的集群配置在系统重启后将会丢失，如需持久化可如下操作：）ipvsadm -S #或者：ipvsadm --save &gt; /etc/sysconfig/ipvsadm#查看集群规则ipvsadm -Ln#防火墙设置firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload¶4. 客户端测试1curl http://192.168.60.100:80参考https://www.jianshu.com/p/2ed85a5204cc¶五、Keepalived + LVS（DR 模式）+ Nginx 实现高可用负载均衡架构Keepalived 默认就支持 LVS 集群规则自动化配置功能（而不需要使用 ipvsadm 来手动创建 LVS 集群规则），此外 Keepalived 还支持对真实服务器进行健康检查的，另外使用 Keepalived 配置虚拟 IP（VIP） 还能自动添加到系统网卡配置里，而无需再通过配置网卡子接口设置VIP。由于 Keepalived 对 LVS 的极佳支持，故而生产环境上更推荐使用 Keepalived 来完成 LVS 的集群配置。提示：ipvsadm 手动创建的 LVS 集群规则默认是不支持对真实服务器进行健康检查的，只能借助脚本来间接实现健康检查。¶1. 准备环境（1）LVS1 服务器：DIP：192.168.60.101VIP：192.168.60.100（keepalived 的 master节点，提供给客户端访问的 IP）（2）LVS2 服务器：DIP：192.168.60.102VIP：192.168.60.100（keepalived 的 backup 节点，提供给客户端访问的 IP）（3）Real Server1：RIP：192.168.60.201VIP：192.168.60.100（响应客户端请求的 IP）（4）Real Server2：RIP：192.168.60.202VIP：192.168.60.100（响应客户端请求的 IP）注意：如以上环境为 Vmware 虚拟机，配置可参考上文“LVS DR 模式集群”。¶2. 真实服务器配置¶1）网络配置Real Server1 网络配置：12345678910111213141516171819202122232425#配置RIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.201"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restartReal Server2 网络配置：12345678910111213141516171819202122232425#配置RIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.202"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restart在 Real Server1 和 Real Server2 两台真实服务器上都执行以下步骤操作：12345678910111213141516171819202122232425262728#配置VIP（通过配置lo回环网卡子接口设置VIP）cat &gt; /etc/sysconfig/network-scripts/ifcfg-lo:1 &lt;&lt; 'EOF'DEVICE=lo:1IPADDR=192.168.60.100NETMASK=255.255.255.255NETWORK=192.168.60.100BROADCAST=127.255.255.255ONBOOT=yesNAME=loopbackEOF#由于LVS服务器和两台真实服务器存在相同的VIP，会产生IP地址冲突，解决办法是修改内核参数。如下：#arp_ignore为1表示：当有arp广播问谁是VIP时，本机忽略掉ARP广播，不做任何回应#arp_announce为2表示：本机不要向外宣告自己的lo回环地址是VIPcat &gt;&gt; /etc/sysctl.conf &lt;&lt; 'EOF'net.ipv4.conf.all.arp_ignore = 1net.ipv4.conf.lo.arp_ignore = 1net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2EOF#使sysctl.conf配置修改生效sysctl -p#重启网络service network restart#查看IP配置是否生效ip addr¶2）部署web服务（Nginx）12345678910111213141516171819202122232425262728293031323334353637#拉取(下载)镜像docker pull nginx:latest#首先简单运行一个nginx临时容器，用于复制容器内部的一些nginx相关重要文件到宿主机docker run -d --name nginx nginx:latest#创建映射目录mkdir -p /opt/nginx/&#123;conf,html,logs&#125;#复制容器内部的一些nginx相关重要文件到映射目录中(注意命令中的末尾的点，它表示复制目录中的所有内容而不是整个目录本身)docker cp nginx:/etc/nginx/. /opt/nginx/confdocker cp nginx:/usr/share/nginx/html/. /opt/nginx/htmldocker cp nginx:/var/log/nginx/. /opt/nginx/logs#删除nginx临时容器docker rm -f nginx#生产环境下运行nginx容器#（1）使用host网络模式直接使用宿主机网络IP地址和端口（可以避免每次配置新的监听端口都需要重新docker run映射端口）#（2）限制内存上限为200MB#（3）指定时区并同步宿主机和容器的时间#（4）映射几个主要的nginx相关目录docker run -d --name nginx \--net=host \-m 200m \-e TZ=Asia/Shanghai \-v /etc/localtime:/etc/localtime:ro \-v /opt/nginx/conf:/etc/nginx \-v /opt/nginx/html:/usr/share/nginx/html \-v /opt/nginx/logs:/var/log/nginx \nginx:latest#防火墙设置（开放nginx默认配置的80端口）firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload#备份nginx访问首页文件cp /opt/nginx/html/index.html /opt/nginx/html/index.old.html#将宿主机默认网卡的IP写到nginx访问首页文件ip route get 8.8.8.8 | grep -oP 'src\s+\K\S+' &gt; /opt/nginx/html/index.html¶3. LVS 服务器配置¶1）网络配置LVS1 网络配置：12345678910111213141516171819202122232425#配置DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.101"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restartLVS2 网络配置：12345678910111213141516171819202122232425#配置DIPcat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; 'EOF'TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.60.102"GATEWAY="192.168.60.2"NETMASK="255.255.255.0"#DNS1="8.8.8.8"EOF#重启网络service network restart¶2）安装 LVS 集群管理工具在 LVS1 和 LVS2 两台服务器上都执行以下步骤操作：1yum install -y ipvsadm这里安装 ipvsadm 的目的主要是用于清空 LVS 集群配置规则以及查看 LVS 集群规则，而不需要使用来创建 LVS 集群规则。¶3）清空 LVS 集群配置规则12#操作前最好清空所有集群规则（防止操作过影响实验结果）ipvsadm -C¶4）通过 Keepalived 配置 VIP 和 LVS 的 DR 模式集群在 LVS1 和 LVS2 两台服务器上都执行以下步骤操作：¶（1）安装 Keepalived12345678910111213#安装编译依赖yum -y install gcc curl openssl-devel libnl3-devel net-snmp-devel#下载keepalived源码包wget https://keepalived.org/software/keepalived-2.0.20.tar.gz#解压源码包tar -zxvf keepalived-2.0.20.tar.gz#进入源码包解压目录cd keepalived-2.0.20#生成Makefile文件./configure --prefix=/opt/keepalived#可以通过指定--sysconf来指定配置文件的安装路径，如：./configure --prefix=/opt/keepalived --sysconf=/etc#编译并安装make &amp;&amp; make install¶（2）配置 Keepalived1vim /opt/keepalived/etc/keepalived/keepalived.confLVS1 服务器配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364global_defs &#123; #运行keepalived服务器的一个标识(每个服务的不一样)，可以用作发送邮件的主题信息 router_id lvs1&#125;vrrp_instance VI_1 &#123; #初始化当前节点的默认主备类型，有两个值可选MASTER主 BACKUP备(可以都设置为BACKUP，让keepalived自己根据priority值大小自己选举MASTER) state MASTER #vrrp实例绑定的网卡接口名称（可以通过ifconfig命令查看），用于发送VRRP interface ens33 #指定VRRP实例ID(相同虚拟ip的多个服务该值要相同)，范围是0-255 virtual_router_id 51 #指定优先级，优先级高的将成为MASTER（注意：BACKUP节点的优先级应该要比MASTER的小） priority 100 #指定发送VRRP通告的间隔，单位是秒 advert_int 1 authentication &#123; #指定认证方式。PASS简单密码认证(推荐) auth_type PASS #指定认证使用的密码，最多8位 auth_pass 1111 &#125; #虚拟IP地址设置虚拟IP地址（需要和以上interface网卡接口的真实ip在同一网段），供用户访问使用，可设置多个，一行一个 virtual_ipaddress &#123; 192.168.60.100 &#125;&#125;##配置LVS的VIP规则virtual_server 192.168.60.100 80 &#123; #健康检查的时间 delay_loop 6 #设置LVS调度算法为RR lb_algo rr #设置LVS的模式为DR lb_kind DR #开启后，客户端在一定时间内始终访问相同服务器 #persistence_timeout 50 #使用的协议 protocol TCP #设置Real Server1的RIP real_server 192.168.60.201 80 &#123; #设置权重为1 weight 1 #对后台real_server做健康检查 TCP_CHECK &#123; #每次连接的超时时间3s connect_timeout 3 #失败以后，重复检查多少次 nb_get_retry 3 #每隔3s检查一下 delay_before_retry 3 &#125; &#125; #设置Real Server2的RIP real_server 192.168.60.202 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125;&#125;LVS2 服务器配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364global_defs &#123; #运行keepalived服务器的一个标识(每个服务的不一样)，可以用作发送邮件的主题信息 router_id lvs2&#125;vrrp_instance VI_1 &#123; #初始化当前节点的默认主备类型，有两个值可选MASTER主 BACKUP备(可以都设置为BACKUP，让keepalived自己根据priority值大小自己选举MASTER) state BACKUP #vrrp实例绑定的网卡接口名称（可以通过ifconfig命令查看），用于发送VRRP interface ens33 #指定VRRP实例ID(相同虚拟ip的多个服务该值要相同)，范围是0-255 virtual_router_id 51 #指定优先级，优先级高的将成为MASTER（注意：BACKUP节点的优先级应该要比MASTER的小） priority 50 #指定发送VRRP通告的间隔，单位是秒 advert_int 1 authentication &#123; #指定认证方式。PASS简单密码认证(推荐) auth_type PASS #指定认证使用的密码，最多8位 auth_pass 1111 &#125; #虚拟IP地址设置虚拟IP地址（需要和以上interface网卡接口的真实ip在同一网段），供用户访问使用，可设置多个，一行一个 virtual_ipaddress &#123; 192.168.60.100 &#125;&#125;##配置LVS的VIP规则virtual_server 192.168.60.100 80 &#123; #健康检查的时间 delay_loop 6 #设置LVS调度算法为RR lb_algo rr #设置LVS的模式为DR lb_kind DR #开启后，客户端在一定时间内始终访问相同服务器 #persistence_timeout 50 #使用的协议 protocol TCP #设置Real Server1的RIP real_server 192.168.60.201 80 &#123; #设置权重为1 weight 1 #对后台real_server做健康检查 TCP_CHECK &#123; #每次连接的超时时间3s connect_timeout 3 #失败以后，重复检查多少次 nb_get_retry 3 #每隔3s检查一下 delay_before_retry 3 &#125; &#125; #设置Real Server2的RIP real_server 192.168.60.202 80 &#123; weight 1 TCP_CHECK &#123; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125;&#125;keepalived 备节点配置和主节点差不多，只需要修改router_id、state、priority 即可。¶（3）运行 keepalived12345678910111213#启动运行keepalived（通过-f指定配置文件，如果不指定则默认使用的配置文件路径为：/etc/keepalived/keepalived.conf）/opt/keepalived/sbin/keepalived -f /opt/keepalived/etc/keepalived/keepalived.conf##防火墙配置#放行keepalived主备检测firewall-cmd --permanent --add-protocol=vrrpfirewall-cmd --reload#放行LVS处理转发的端口firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload#运行keepalived后，keepalived会自动添加LVS集群规则，可以通过如下命令验证查看集群规则ipvsadm -Ln¶4. 集群测试¶1）负载均衡测试客户端访问 VIP 观测是否实现负载均衡1curl http://192.168.60.100:80¶2）LVS 服务器故障恢复主备切换测试把 LVS1 的 keepalived 停掉后观测是否还能正常访问12ps -ef | grep keepalivedkill -9 进程号然后在 LVS2 上通过 ip addr 命令查看是否发生 VIP “飘移”¶3）真实服务器健康检查测试关闭 Real Server1 的 Nginx 后观测是否不再转发到 Real Server1，再启动 Real Server1 的 Nginx 观测是否恢复转发到 Real Server1。123456789#在Real Server1上关闭nginxdocker stop nginx#在任意一台LVS服务器上（如LVS1）执行如下命令查看是否自动移除Real Server1真实服务器配置规则ipvsadm -Ln#在Real Server1上启动nginxdocker start nginx#在任意一台LVS服务器上（如LVS1）执行如下命令查看是否自动增加Real Server1真实服务器配置规则ipvsadm -Ln]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived+MySQL实现高可用]]></title>
    <url>%2Fdevops%2Fmysql_ha.html</url>
    <content type="text"><![CDATA[¶一、环境规划主机名IP地址备注服务器Ahosta192.168.60.101keepalive主节点、Mysql主节点1服务器Bhostb192.168.60.102keepalive备节点、Mysql主节点2192.168.60.222keepalive虚拟IP，会在keepalive启动后分配到上面2台机器的主节点上¶二、Mysql安装配置为了简化mysql安装过程，这里使用docker来进行安装配置。1234docker pull mysql:5.7mkdir /opt/mysql/conf -pmkdir /opt/mysql/data -pvim /opt/mysql/conf/my.cnf服务器A配置：1234567891011121314151617181920212223242526272829## my.cnf[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录# basedir=/var/lib/mysql# 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错datadir=/var/lib/mysql/data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 最大连接数max_connections=500server_id = 1 #服务编号（集群中每个节点的服务编号需要唯一）binlog_format=ROWlog_bin=/var/lib/mysql/binlogauto-increment-increment = 2 #主键递增的步长【由于数双主，如果是自动递增的主键的话，会出现主键冲突的问题】auto-increment-offset = 1 #主键自动递增的初始值【双主的起始值设置的时候需要错开】slave-skip-errors = all #忽略所有复制产生的错误gtid_mode=ONenforce-gtid-consistency=ON服务器B配置：1234567891011121314151617181920212223242526272829## my.cnf[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录# basedir=/var/lib/mysql# 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错datadir=/var/lib/mysql/data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 最大连接数max_connections=500server_id = 2 #服务编号（集群中每个节点的服务编号需要唯一）binlog_format=ROWlog_bin=/var/lib/mysql/binlogauto-increment-increment = 2 #主键递增的步长【由于数双主，如果是自动递增的主键的话，会出现主键冲突的问题】auto-increment-offset = 2 #主键自动递增的初始值【双主的起始值设置的时候需要错开】slave-skip-errors = all #忽略所有复制产生的错误gtid_mode=ONenforce-gtid-consistency=ON123456789#运行mysql实例docker run -d --name mysql -p 3306:3306 -v /opt/mysql/conf:/etc/mysql/conf.d -v /opt/mysql/data:/var/lib/mysql/data -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7#进入mysql容器内docker exec -it mysql bash#创建复制用户，2个数据库上都要创建mysql -uroot -p123456grant replication slave on *.* to 'rep'@'%' identified by '123';将服务器A数据库数据导出并导入到数据库B中。在服务器B上进行如下操作：12mysqldump -uroot -p123456 -h 192.168.60.101 --single-transaction --all-databases --master-data=2 &gt; hosta.sqlmysql -uroot -p123456 &lt; hosta.sql在服务器B上开启数据库复制1mysql -uroot -p123456123456789101112131415161718192021222324252627282930-- 配置复制mysql&gt; CHANGE MASTER TO -&gt; master_host='192.168.60.101', -&gt; master_port=3306, -&gt; master_user='rep', -&gt; master_password='123', -&gt; MASTER_AUTO_POSITION = 1;Query OK, 0 rows affected, 2 warnings (0.01 sec)-- 开启复制mysql&gt; start slave; Query OK, 0 rows affected (0.00 sec)-- 查看复制状态mysql&gt; show slave status \G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.60.101 Master_User: rep Master_Port: 3306 Connect_Retry: 60 Master_Log_File: binlog.000001 Read_Master_Log_Pos: 611 Relay_Log_File: a8bb67ca2607-relay-bin.000011 Relay_Log_Pos: 445 Relay_Master_Log_File: binlog.000001 #下面出现两个Yes就表示连接服务器A成功 Slave_IO_Running: Yes Slave_SQL_Running: Yes在服务器A上开启数据库复制1mysql -uroot -p1234561234567891011121314151617181920212223242526272829-- 配置复制mysql&gt; CHANGE MASTER TO -&gt; master_host='192.168.60.102', -&gt; master_port=3306, -&gt; master_user='rep', -&gt; master_password='123', -&gt; MASTER_AUTO_POSITION = 1;Query OK, 0 rows affected, 2 warnings (0.01 sec)-- 开启复制mysql&gt; start slave; Query OK, 0 rows affected (0.00 sec)-- 查看复制状态mysql&gt; show slave status \G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.60.102 Master_User: rep Master_Port: 3306 Connect_Retry: 60 Master_Log_File: binlog.000001 Read_Master_Log_Pos: 614 Relay_Log_File: 85921dd2dd0a-relay-bin.000011 Relay_Log_Pos: 445 Relay_Master_Log_File: binlog.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes测试双主复制123456789--在服务器A上创建数据库create database testa;--在服务器B上查看数据库show databases;--在服务器B上创建数据库create database testb;--在服务器A上查看数据库show databases;¶三、Keepalived安装配置安装过程以及使用请看《keepalived学习笔记》一文。在本次案例中Keepalived配置如下：服务器A：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263! Configuration File for keepalivedglobal_defs &#123; #通知邮件，当keepalived发生切换时需要发email给具体的邮箱地址 notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; #设置发件人的邮箱信息 notification_email_from Alexandre.Cassen@firewall.loc #指定smpt服务地址 smtp_server 192.168.200.1 #指定smpt服务连接超时时间 smtp_connect_timeout 30 #运行keepalived服务器的一个标识(每个服务的不一样)，可以用作发送邮件的主题信息 router_id keepalived1 #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查) vrrp_skip_check_adv_addr #注释掉严格遵守VRRP协议，否则无法正常使用虚拟ip，如ping #vrrp_strict #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0 vrrp_garp_interval 0 #在一个网卡上每组na消息之间的延迟时间，默认为0 vrrp_gna_interval 0&#125;#加入以下vrrp_scriptvrrp_script chk_mysql_port &#123; #执行脚本的位置 script "/etc/keepalived/chk_mysql_port" #执行脚本的周期，秒为单位 interval 2 #权重的计算方式 weight -20&#125;vrrp_instance VI_1 &#123; #有两个值可选MASTER主 BACKUP备(可以都设置为BACKUP，让keepalived自己根据priority值大小自己选举MASTER) state MASTER #vrrp实例绑定的网卡接口名称（可以通过ifconfig命令查看），用于发送VRRP interface ens33 #指定VRRP实例ID(相同虚拟ip的多个服务该值要相同)，范围是0-255 virtual_router_id 51 #指定优先级，优先级高的将成为MASTER priority 100 #指定发送VRRP通告的间隔，单位是秒 advert_int 1 authentication &#123; #指定认证方式。PASS简单密码认证(推荐) auth_type PASS #指定认证使用的密码，最多8位 auth_pass 1111 &#125; #虚拟IP地址设置虚拟IP地址（需要和以上网卡接口的真实ip在同一网段），供用户访问使用，可设置多个，一行一个 virtual_ipaddress &#123; 192.168.60.222 &#125; #加入以下track_script track_script &#123; chk_mysql_port &#125;&#125;服务器B：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263! Configuration File for keepalivedglobal_defs &#123; #通知邮件，当keepalived发生切换时需要发email给具体的邮箱地址 notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; #设置发件人的邮箱信息 notification_email_from Alexandre.Cassen@firewall.loc #指定smpt服务地址 smtp_server 192.168.200.1 #指定smpt服务连接超时时间 smtp_connect_timeout 30 #运行keepalived服务器的一个标识(每个服务的不一样)，可以用作发送邮件的主题信息 router_id keepalived2 #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查) vrrp_skip_check_adv_addr #注释掉严格遵守VRRP协议，否则无法正常使用虚拟ip，如ping #vrrp_strict #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0 vrrp_garp_interval 0 #在一个网卡上每组na消息之间的延迟时间，默认为0 vrrp_gna_interval 0&#125;#加入以下vrrp_scriptvrrp_script chk_mysql_port &#123; #执行脚本的位置 script "/etc/keepalived/chk_mysql_port" #执行脚本的周期，秒为单位 interval 2 #权重的计算方式 weight -20&#125;vrrp_instance VI_1 &#123; #有两个值可选MASTER主 BACKUP备(可以都设置为BACKUP，让keepalived自己根据priority值大小自己选举MASTER) state BACKUP #vrrp实例绑定的网卡接口名称（可以通过ifconfig命令查看），用于发送VRRP interface ens33 #指定VRRP实例ID(相同虚拟ip的多个服务该值要相同)，范围是0-255 virtual_router_id 51 #指定优先级，优先级高的将成为MASTER priority 90 #指定发送VRRP通告的间隔，单位是秒 advert_int 1 authentication &#123; #指定认证方式。PASS简单密码认证(推荐) auth_type PASS #指定认证使用的密码，最多8位 auth_pass 1111 &#125; #虚拟IP地址设置虚拟IP地址（需要和以上网卡接口的真实ip在同一网段），供用户访问使用，可设置多个，一行一个 virtual_ipaddress &#123; 192.168.60.222 &#125; #加入以下track_script track_script &#123; chk_mysql_port &#125;&#125;1vim /etc/keepalived/chk_mysql_port12345#!/bin/bashcounter=$(netstat -na|grep "LISTEN"|grep "3306"|wc -l)if [ "$&#123;counter&#125;" -eq 0 ]; then killall keepalivedfi¶四、测试在客户端通过虚拟ip：192.168.60.222连接mysql。然后尝试关闭服务器A的mysql看是否客户端还能正常使用（虚拟ip指向服务器B）。12#在服务器A上关闭mysqldocker stop mysql参考：https://www.cnblogs.com/lijiaman/p/13430668.htmlhttps://zhuanlan.zhihu.com/p/70820683http://t.zoukankan.com/twodog-p-12139262.html]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keepalived学习笔记]]></title>
    <url>%2Fdevops%2Fkeepalived.html</url>
    <content type="text"><![CDATA[Keepalived是一个用于实现虚拟路由冗余协议（Virtual Router Redundancy Protocol，VRRP）的开源软件。它旨在提供高可用性和故障恢复能力，用于确保在主服务器发生故障时自动将流量切换到备份服务器。“高可用”（High Availability，HA）是指系统或服务能够在面对硬件故障、软件故障、网络故障或其他不可预见的事件时，仍能够持续提供正常的运行和可用性。在一个高可用系统中，故障的部分可以被无缝地替代，用户不会感知到服务中断或降级。Keepalived通过创建一个冗余的虚拟IP（Virtual IP，VIP）地址，使多个服务器共享同一个VIP地址。这些服务器中的一个被配置为主服务器（Master），负责接收和处理所有流量，而其他服务器则处于备份状态（Backup）。主服务器负责将流量传递给后端的真实服务器（Real Servers），备份服务器监控主服务器的状态，并在主服务器发生故障时接管流量。Keepalived使用VRRP协议来协调主备服务器之间的状态。VRRP是一种网络协议，定义了主服务器的选举和状态转换过程，以及客户端请求的转发。主服务器通过周期性的VRRP广播来宣告自己的存在和状态，并通过VRRP消息协议与备份服务器进行通信，以确保一致性和可靠性。VRRP（Virtual Route Redundancy Protocol）协议，翻译过来为虚拟路由冗余协议。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP，而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER，MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP，除了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master（如果有多个BACKUP，那么会选举其中一个优先级高的作为MASTER）。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态。如上图Keepalived实现Nginx负载均衡的原理就是在两个Nginx节点中引入虚拟IP的概念（每台Nginx都安装Keepalived并都配置同一个虚拟IP），其中一台Nginx宕机，那么虚拟Ip将会飘移到另一台Nginx上去，而客户端就是通过这个虚拟IP来访问Nginx的。¶一、安装12345678910111213#安装编译依赖yum -y install gcc curl openssl-devel libnl3-devel net-snmp-devel#下载keepalived源码包wget https://keepalived.org/software/keepalived-2.0.20.tar.gz#解压源码包tar -zxvf keepalived-2.0.20.tar.gz#进入源码包解压目录cd keepalived-2.0.20#生成Makefile文件./configure --prefix=/opt/keepalived#可以通过指定--sysconf来指定配置文件的安装路径，如：./configure --prefix=/opt/keepalived --sysconf=/etc#编译并安装make &amp;&amp; make install¶二、配置12#编辑keepalived配置文件vim /opt/keepalived/etc/keepalived/keepalived.conf服务器1配置123456789101112131415161718192021222324252627global_defs &#123; #运行keepalived服务器的一个标识(每个服务的不一样)，可以用作发送邮件的主题信息 router_id keepalived1&#125;vrrp_instance VI_1 &#123; #初始化当前节点的默认主备类型，有两个值可选MASTER主 BACKUP备(可以都设置为BACKUP，让keepalived自己根据priority值大小自己选举MASTER) state MASTER #vrrp实例绑定的网卡接口名称（可以通过ifconfig命令查看），用于发送VRRP interface ens33 #指定VRRP实例ID(相同虚拟ip的多个服务该值要相同)，范围是0-255 virtual_router_id 51 #指定优先级，优先级高的将成为MASTER（注意：BACKUP节点的优先级应该要比MASTER的小） priority 100 #指定发送VRRP通告的间隔，单位是秒 advert_int 1 authentication &#123; #指定认证方式。PASS简单密码认证(推荐) auth_type PASS #指定认证使用的密码，最多8位 auth_pass 1111 &#125; #虚拟IP地址设置虚拟IP地址（需要和以上interface网卡接口的真实ip在同一网段），供用户访问使用，可设置多个，一行一个 virtual_ipaddress &#123; 192.168.60.222 &#125;&#125;以上配置中没有特别需求的话，最简单就是修改router_id、vrrp_strict、state、interface、priority、virtual_ipaddress三处地方即可。服务器2配置123456789101112131415161718global_defs &#123; router_id keepalived2&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 51 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.60.222 &#125;&#125;keepalived 备节点配置和主节点差不多，只需要修改router_id、state、priority 即可。¶三、使用¶1. 启动123456#启动运行keepalived（通过-f指定配置文件，如果不指定则默认使用的配置文件路径为：/etc/keepalived/keepalived.conf）/opt/keepalived/sbin/keepalived -f /opt/keepalived/etc/keepalived/keepalived.conf#防火墙配置firewall-cmd --permanent --add-protocol=vrrpfirewall-cmd --reload¶2. 测试测试效果如下：通过查看MASTER节点服务器的所有ip时，能够发现在MASTER节点的网卡接口ens33中多出了192.168.60.222这个虚拟ip地址。123456789101112131415$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:34:1d:18 brd ff:ff:ff:ff:ff:ff inet 192.168.60.101/24 brd 192.168.60.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.60.222/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe34:1d18/64 scope link noprefixroute valid_lft forever preferred_lft forever而通过查看BACKUP节点服务器的所有ip时，不会出现虚拟ip地址。12345678910111213$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:be:9b:55 brd ff:ff:ff:ff:ff:ff inet 192.168.60.102/24 brd 192.168.60.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:febe:9b55/64 scope link noprefixroute valid_lft forever preferred_lft forever¶3. 关闭验证情景： MASTER 节点宕机或者出现故障时，原本的 MASTER 节点会自动失去虚拟ip，而在 BACKUP 节点上将自动获得虚拟 IP（发生了 IP 飘移）。操作方式：在原本的MASTER节点中关闭 keepalived，然后查看 MASTER 和 BACKUP 节点的虚拟 IP 情况。1234567#关闭ps -ef | grep keepalivedkill -9 进程号#使用killall来杀掉进程会更方便yum install psmisc -ykillall keepalived¶4. 脚本keepalived的作用其实也就是给多个服务器中加入唯一的虚拟IP，但关注到具体业务的话，还存在许多问题，比如做Nginx高可用的情况下，假设有两个Nginx节点，其中一台Nginx出现故障不可用，而其所在的服务器还在正常运行，所以其对应的keepalived程序也正常运行，很显然这是不会发生了IP飘移的。而我们的目的是Nginx出现故障不可用时其对应的keepalived也应该要跟着关掉，这样虚拟ip才会飘移到BACKUP节点。keepalived允许我们通过编写脚本对业务进程进行检测监控。1vim /opt/keepalived/etc/keepalived/ck_nginx.sh内容如下：1234567891011#!/bin/bashnum=`ps -C nginx --no-header | wc -l`if [ $num -eq 0 ];then #注意nginx的安装路径 /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then #需要安装psmisc：yum install psmisc -y killall keepalived fifi12#为脚本文件设置执行权限chmod 755 /opt/keepalived/etc/keepalived/ck_nginx.sh将脚本添加到keepalived配置文件中1vim /opt/keepalived/etc/keepalived/keepalived.conf1234567891011121314151617181920212223#加入以下vrrp_scriptvrrp_script ck_nginx &#123; #执行脚本的位置 script "/etc/keepalived/ck_nginx.sh" #执行脚本的周期，秒为单位 interval 2 #权重的计算方式 weight -20&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 ... ... virtual_ipaddress &#123; 192.168.200.111 &#125; #加入以下track_script track_script &#123; ck_nginx &#125;&#125;¶6. 日志1tail -f /var/log/messages]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python版本管理工具pyenv]]></title>
    <url>%2Ftools%2Fpyenv.html</url>
    <content type="text"><![CDATA[由于在日常办公电脑中或者服务器上都有 python 多版本同时使用需求，比如 python2 和 python3。使用 python版本管理工具 pyenv 或者 anaconda 就能够方便随意切换 python 版本。¶一、pyenv¶1、Linux项目地址：https://github.com/pyenv/pyenv¶1）安装依赖12345678#CentOS/Fedora 21 and belowyum install -y gcc make patch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel openssl-devel tk-devel libffi-devel xz-devel#Ubuntu/Debian/Mintapt updateapt install build-essential libssl-dev zlib1g-dev \libbz2-dev libreadline-dev libsqlite3-dev curl \libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev更多 Linux 发行版系统安装依赖参考：https://github.com/pyenv/pyenv/wiki#suggested-build-environment¶2）安装pyenv1234567#自动化安装方式（推荐，会同时安装pyenv和pyenv-doctor、pyenv-update、pyenv-virtualenv等插件）curl https://pyenv.run | bash##指定版本安装方式（仅会安装pyenv，不会自动安装pyenv-doctor、pyenv-update、pyenv-virtualenv等插件，如需插件要自行安装）wget -O pyenv-2.3.17.tar.gz https://github.com/pyenv/pyenv/archive/refs/tags/v2.3.17.tar.gztar -zxvf pyenv-2.3.17.tar.gzmv pyenv-2.3.17 ~/.pyenv¶3）配置环境变量123456789101112#添加环境变量。cat后的&gt;&gt;表示追加，&gt;则表示覆盖。&lt;&lt; 后的EOF用引号可以避免$赋值，如果希望赋值则不加引号cat &gt;&gt; ~/.bashrc &lt;&lt; 'EOF'export PYENV_ROOT="$HOME/.pyenv"export PATH="$PYENV_ROOT/bin:$PATH"if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval "$(pyenv init -)"fiEOF#使环境变量生效source ~/.bashrc¶4）安装python版本12345678#指定版本安装pythonpyenv install 3.7.10pyenv install 2.7.16pyenv install 3.10.10#设置当前全局python版本pyenv global 3.7.10 #全局使用python3.7.10#pyenv global 2.7.16 #全局使用python2.7.16#pyenv global system #使用操作系统原本自带的python版本提示：与 Windows 平台上的 pyenv-win 不同，pyenv-win 是二进制包安装，而 pyenv 则是对指定版本的 python 源码包进行编译安装，所以安装会比较久。经测试 Python 3.7.0 在 WSL Ubuntu 22.04 中会编译失败，暂不清楚原因。¶5）常用命令123456789101112pyenv commands 查看pyenv命令pyenv install --list #查看可安装的python版本pyenv versions #查看已安装版本pyenv version #查看当前使用的python版本pyenv update #更新pyenv及其插件（依赖pyenv-update插件，参考：https://github.com/pyenv/pyenv/tree/master?tab=readme-ov-file#upgrading-with-installer-or-git-checkout，这里该命令和 Windows 版本不一样，并非更新本地python版本配置）pyenv install -v 版本号 #指定版本安装python，-v 可省略pyenv rehash #刷新python已安装列表pyenv uninstall 版本号 #删除pythonpyenv virtualenv 已有版本环境名名 新版本环境名 #按已有版创建新的python环境（调用virtualenv,python3 自带了virtualenv,py2要自行装）pyenv global 版本号 #设置当前全局python版本pyenv local 版本号 #设置当前目录局部python版本，以后进入目录就会自动切换到这个版本pyenv local --unset #取消局部python版本设置,或者删除当前目录下的.python-version文件¶6）pyenv-virtualenv 命令使用1234567891011121314#创建虚拟环境（使用特定的Python版本创建虚拟环境）pyenv virtualenv 3.7.10 env-name#列出创建的所有虚拟环境pyenv virtualenvs# 激活虚拟环境pyenv activate env-name#退出虚拟环境，回到系统环境pyenv deactivate#删除虚拟环境pyenv uninstall env-name # 或者删除其真实目录 rm -rf ~/.pyenv/versions/env-name说明：pyenv-virtualenv 插件相比于 Python 默认的 Virtualenv，其能够集中管理虚拟环境，例如可以列出创建的所有虚拟环境，但 Virtualenv 不可以。pyenv-virtualenv 插件使用参考：https://github.com/pyenv/pyenv-virtualenvhttps://einverne.github.io/post/2017/04/pyenv.htmlhttps://zhuanlan.zhihu.com/p/36402791¶7）卸载1234#删除所有已编译的 Python 版本源码和相关日志（提示：Python 版本编译成功时会自动删除源码，但会保留日志，编译失败则不会删除源码）rm -rf /tmp/python-build* -rf#删除 pyenv（包括已安装的 Python 版本）rm -rf ~/.pyenv然后删除~/.bashrc中的环境变量配置即可¶8）参考https://juejin.cn/post/7167731442418941983¶2、windows¶1）手动安装¶（1）安装pyenv如果没有安装过则可以下载源码压缩包解压到自定义安装目录，如：E:/Cache/pyenv/.pyenv下载地址：https://github.com/pyenv-win/pyenv-win/archive/refs/tags/v3.1.1.zip说明：如果本地已经有python环境也可以直接使用pip来安装，安装完成后再把原来python和其环境变量（如果有配置的话）删除掉即可。1&gt;pip install pyenv-win --target E:/Cache/pyenv/.pyenv¶（2）配置环境变量先加环境变量 PYENV ：E:\Cache\pyenv\.pyenv\pyenv-win然后再在 Path 中加入：%PYENV%\bin%PYENV%\shims¶2）自动安装打开 PowerShell 并执行如下命令：12345678#允许 PowerShell 执行脚本（需要管理员身份运行 PowerShell）Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine#安装Invoke-WebRequest -UseBasicParsing -Uri "https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1" -OutFile "./install-pyenv-win.ps1"; &amp;"./install-pyenv-win.ps1"#卸载Invoke-WebRequest -UseBasicParsing -Uri "https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1" -OutFile "./install-pyenv-win.ps1"; &amp;"./install-pyenv-win.ps1" -UNINSTALL说明：自动安装默认安装目录为：C:\Users\%username%\.pyenv。如需自定义安装目录，需在执行脚本前，修改 install-pyenv-win.ps1 里的 $PyEnvDi 变量值（默认为：&quot;${env:USERPROFILE}\.pyenv&quot;），可改为如：E:\Cache\pyenv\.pyenv安装过程会自动添加所需的系统环境变量。¶3）优化下载镜像方式1：添加系统环境变量：PYTHON_BUILD_MIRROR_URL，可选值如下：https://www.python.org/ftp/python/ （默认值）https://mirrors.huaweicloud.com/python/ （推荐）http://mirrors.sohu.com/python/http://npm.taobao.org/mirrors/python/方式2：在 pyenv-win/libexec/libs/pyenv-install-lib.vbs 中找到If mirror = &quot;&quot; Then mirror = &quot;https://www.python.org/ftp/python&quot;，然后将地址改成如下：https://www.python.org/ftp/python/ （默认值）https://mirrors.huaweicloud.com/python/ （推荐）http://mirrors.sohu.com/python/https://npm.taobao.org/mirrors/python/ （目前发现在 pyenv 中不可用，不清楚原因）参考：https://github.com/pyenv-win/pyenv-win/issues/398¶4）测试123456pyenv --version #PowerShell执行pyenv失败可以通过管理员方式PowerShell执行命令解决：Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachinepyenv install 3.7.10pyenv install 2.7.16pyenv install 3.10.10pyenv global 3.7.10python3 --version #这一步可能会启动Microsoft Store。这是由于环境变量产生了问题。两种方法解决：1、菜单搜索【管理应用执行别名】关闭两个按钮【应用安装程序】；2、可以同时将系统和用户的环境变量中的%USERPROFILE%\AppData\Local\Microsoft\WindowsApps删除掉💁‍♂环境变量配置好后需要重新打开终端。¶5）常用命令123456789101112pyenv commands 查看pyenv命令pyenv install --list #查看可安装的python版本pyenv versions #查看已安装版本pyenv version #查看当前使用的python版本pyenv update #更新本地python版本配置（更新.versions_cache.xml文件，该文件记录版本和其对应下载地址）pyenv install -v 版本号 #指定版本安装python，-v 可省略pyenv rehash #刷新python已安装列表pyenv uninstall 版本号 #删除pythonpyenv virtualenv 已有版本环境名名 新版本环境名 #按已有版创建新的python环境（调用virtualenv,python3 自带了virtualenv,py2要自行装）pyenv global 版本号 #设置当前全局python版本pyenv local 版本号 #设置当前目录局部python版本，以后进入目录就会自动切换到这个版本pyenv local --unset #取消局部python版本设置,或者删除当前目录下的.python-version文件¶6）安装vitualenv1234567891011121314# 安装python -m pip install --user virtualenv# 在powershell中，这样安装虚拟环境会出错# virtualenv venv# 正确的安装虚拟环境方式python -m virtualenv venv#或者执行 pyenv exec virtualenv venv #这种需要全局安装的方式python -m pip install virtualenv# 激活虚拟环境.\venv\Scripts\activate# 查看当前虚拟环境已安装的packagepip list# 退出虚拟环境deactivate¶7）卸载删除掉E:/Cache/pyenv/.pyenv目录，删除对应环境变量即可。参考：https://blog.csdn.net/weixin_45027467/article/details/123137457https://www.bilibili.com/read/cv12982089https://blog.csdn.net/weixin_43982238/article/details/108289616¶二、anaconda¶1、centos7¶1）安装1234#下载安装脚本wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.11-Linux-x86_64.sh#安装（不断回车或yes即可）sh Anaconda3-2021.11-Linux-x86_64.sh¶2）配置123456789101112131415161718192021222324252627#添加环境变量。cat后的&gt;&gt;表示追加，&gt;则表示覆盖。&lt;&lt; 后的EOF用引号可以避免$赋值，如果希望赋值则不加引号cat &gt;&gt; ~/.bashrc &lt;&lt; 'EOF'# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;# !! Contents within this block are managed by 'conda init' !!__conda_setup="$('/root/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)"if [ $? -eq 0 ]; then eval "$__conda_setup"else if [ -f "/root/anaconda3/etc/profile.d/conda.sh" ]; then . "/root/anaconda3/etc/profile.d/conda.sh" else export PATH="/root/anaconda3/bin:$PATH" fifiunset __conda_setup# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;EOF#使环境变量生效source ~/.bashrc#测试安装配置是否成功conda -v#安装好anaconda后，默认系统全局就会自动默认使用anaconda自带的python版本，如果希望保持原来系统版本可如下设置conda config --set auto_activate_base false¶3）使用12345678910#创建一个项目的虚拟环境，并指定虚拟环境名称为py38，使用python3.8版本conda create -n py38 python=3.8#查看当前创建的所有虚拟环境conda env list#激活当前环境为py38，如此在当前登录会话过程全局就会使用用python3.8版本conda activate py38# 退出当前虚拟环境conda deactivate#删除一个项目的虚拟环境conda remove -n py38 *--all*¶2、windows¶1）安装下载安装包：https://www.anaconda.com/download/#windows安装过程一直下一步即可。¶2）配置Path中加入如下环境变量（假设anaconda安装到D:\Development\Anaconda3）：12345D:\Development\Anaconda3D:\Development\Anaconda3\condabinD:\Development\Anaconda3\ScriptsD:\Development\Anaconda3\Library\binD:\Development\Anaconda3\Library\mingw-w64💁‍♂官方建议使用Anaconda Prompt 终端执行conda或者python等命令。¶3）使用安装后会有Anaconda Prompt (Anaconda3)终端，打开执行conda或者python等命令即可。¶参考https://zhuanlan.zhihu.com/p/32925500]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 acme.sh 脚本申请免费的 SSL 证书]]></title>
    <url>%2Ftools%2Facme.sh.html</url>
    <content type="text"><![CDATA[¶一、简要概述acme.sh 是一个免费、开源、自动化的 ACME 客户端工具，可用于申请免费的 SSL 证书。它可以帮助网站管理员轻松地实现 HTTPS 等功能，提高网站的安全性和可靠性。项目开源地址：https://github.com/acmesh-official/acme.sh中文说明文档：https://github.com/acmesh-official/acme.sh/wiki/说明官方完整文档：https://github.com/acmesh-official/acme.sh/wikiACME 协议的说明：该协议定义了客户端（通常是证书申请者或服务器管理员）和证书颁发机构之间的交互过程。ACME 客户端使用 ACME 协议与证书颁发机构的 ACME 服务端进行通信，实现自动申请证书、证明域名所有权、获取证书、以及在证书到期前续订证书等功能。提示：acme.sh 和 Certbot 都是 ACME 客户端工具，虽然它们和 ACME 服务端的交互逻辑都是相似的，但它们由不同团队维护，所以使用上会有很多不同的地方（例如：不同的命令参数、不同的证书生成路径、不同的插件支持等）。相比 Certbot 而言，acme.sh 具有如下优势：acme.sh 更加轻量和易于安装（acme.sh 是 Shell 脚本程序，默认就能在各种 Linux 系统上运行，且没有其他依赖关系，而 Certbot 是 Python 脚本程序，依赖 Python 环境）；acme.sh 支持更多的 CA（Certbot 默认只支持 Let’s Encrypt，但 acme.sh 可同时支持 Let’s Encrypt、ZeroSSL、Buypass、Google、SSL.com 等 CA 机构，参考：https://github.com/acmesh-official/acme.sh/wiki/CA）acme.sh 官方文档对于中文支持更友好；acme.sh 对于 DNS API 的支持更完善（如：阿里云、腾讯云、华为云等，具体 DNS API 支持参考：https://github.com/acmesh-official/acme.sh/wiki/dnsapi），而 Certbot 默认对阿里云、腾讯云、华为云等不支持。¶二、安装1234567891011#acme.sh依赖一些工具包（如果系统没有则需要安装相关依赖包） #socat工具包：acme.sh用其实现自动启动临时的Web服务进行HTTP验证（仅 --standalone） #cron工具包：acme.sh用其实现自动化续期证书（可通过命令：crontab -l 检查是否安装有cron服务）apt install -y socat cron#yum install -y socat cronie#安装acme.sh #普通用户和 root 用户都可以安装使用，默认安装到~/.acme.sh/目录里 #为了方便使用，安装后，安装脚本会自定在~/.bashrc里通过alias设置环境变量，只需要执行source ~/.bashrc命令或者重新打开终端即可使用curl https://get.acme.sh | shsource ~/.bashrc¶三、卸载12acme.sh --uninstall #自动删除alias环境变量等rm -rf ~/.acme.sh¶四、更新1234567#手动更新acme.sh --upgrade#开启自动升级（如需）acme.sh --upgrade --auto-upgrade#关闭自动更新acme.sh --upgrade --auto-upgrade 0¶五、使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172##修改默认CA（可选） #acme.sh之前使用Let’s Encrypt作为默认CA，但v3.0版本后使用ZeroSSL作为默认CA #CA可选配置值：letsencrypt、zerossl、buypass、google、ssl.com（简单来说，如果没有特殊需求，免费使用建议选择letsencrypt和zerossl，如果愿意付费则可选择buypass、ssl.com） #如果默认CA无法颁发，可选修改 CAacme.sh --set-default-ca --server &lt;CA&gt;#示例：acme.sh --set-default-ca --server letsencrypt##注册账号（需改成自己的邮箱） #--email EMAIL（简写：-m EMAIL）：账号邮箱地址。可用于自动注册 ACME 账号，还可用于证书到期前 20 天、10 天和 1 天时接收到到期通知邮件（对于letsencrypt）。如：--email user@example.comacme.sh --register-account -m user@example.com##方式1：自动HTTP验证方式申请证书 #使用条件：（1）需要公网 IP；（2）开启 HTTP 验证端口（默认 80，可通过 --httpport 选项自定义监听端口，但仍然会通过 80 端口进行验证，当使用 --httpport 时，需要反向代理 80 端口到自定义端口，参考：https://github.com/acmesh-official/acme.sh/issues/1230#issuecomment-362177631） #需要本地运行一个监听80端口的web服务用来给acme服务器验证域名所有权（如果没有启动web服务监听该端口，则acme.sh会自动临时启动一个监听80端口的web服务，用来完成验证） #ACME 客户端会在Web服务器的根目录（以下-w指定的目录路径）下自动创建一个特定的临时文件（即：.well-known/acme-challenge/&lt;random_token&gt;），然后CA的ACME服务端会通过HTTP协议请求访问此文件（其中访问的url地址为：http://example.com/.well-known/acme-challenge/&lt;random_token&gt;），访问到该文件则说明用户对域名具有控制权，通过用户的控制权情况间接确定用户是否是域名的拥有者（即所有权）。 #-d（--domain）：指定域名，如：-d example.com，支持指定多个域名，如：-d example.com -d www.example.com #-w（--webroot）：指定Web服务的根目录路径（需要根据Web服务的相关配置来设置，如：-w /opt/nginx/html） #--apache 或 --nginx：如果本地运行有apache或nginx等已运行80端口的服务器，可加参数：--apache 或 --nginx，以从其相关配置文件中自动获取80端口的网站根目录，而不需要指定网站根目录。提示：指定--apache 或 --nginx要求nginx或apache是通过标准化安装的（即软件包的安装路径和配置文件路径要和在线包管理器安装方式的路径相同） #--standalone：如果本地没有运行任何Web服务, 80端口是空闲的, 那么可以指定--standalone以临时运行一个webserver, 临时听在80端口, 完成验证: #-k（--keylength）：指定申请的证书类型（ECC证书或者RSA证书），可选值：ECC证书：ec-256（默认）、ec-384、ec-521；RSA证书：2048、3072、4096。示例：申请ECC证书：--keylength ec-256，申请RSA证书：--keylength 2048（提示：ECC证书通常比RSA证书更推荐，因为它提供了更高的安全性和更小的密钥长度）#申请证书前需要开放防火墙的 tcp 80 端口，如下：#（1）对于 UFW 防火墙ufw allow 80/tcp#（2）对于 FirewallD 防火墙：firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload#使用示例：#通过 --standalone 自动开启一个 80 端口用于 HTTP 验证并自动生成证书（要求 80 端口不能被占用）acme.sh --issue \-d example.com \-d www.example.com \--standalone#使用系统中的任意 HTTP 服务自动生成证书（通过 -w 指定访问 HTTP 服务 80 端口时的 Web 根目录路径）acme.sh --issue \-d example.com \-d www.example.com \-w /opt/nginx/html#通过 --nginx 指定根据系统中的 nginx 配置自动生成证书 #提示：指定--nginx要求nginx是通过标准化安装的（即软件包的安装路径和配置文件路径要和在线包管理器安装方式的路径相同）acme.sh --issue \-d example.com \-d www.example.com \--nginx##方式2：手动DNS验证方式申请证书 #使用条件：需要手动在域名托管服务商的面板上解析给定的txt记录用来验证域名所有权 #优势：不需要公网 IP，不需要开放 HTTP 验证端口acme.sh --issue \--dns \-d example.com \-d www.example.com \--yes-I-know-dns-manual-mode-enough-go-ahead-please#执行以上命令后acme.sh会生成相应的txt记录显示出来, 只需要手动在域名托管商的管理面板中添加这条txt记录即可 # 解析示例如下： # _acme-challenge.example.com -&gt; cVe1Jgrp2BE3zLcLrDuJpckdAV9fHhJbe7XpO7rhiXo # _acme-challenge.www.example.com（注意对于层级较多的域名一定要填写正确）-&gt; rPe1Jgrp2BE3zLcLrDuJpckdAV9fHhJbe7XpO7rhi # 可执行如下命令来验证txt记录是否解析成功 # dig TXT _acme-challenge.example.com # dig TXT _acme-challenge.www.example.com#等待解析完成之后, 最后只需要指定选项：--renew 再执行如下命令即重新生成证书即可:acme.sh --renew \-d example.com \-d www.example.com \--yes-I-know-dns-manual-mode-enough-go-ahead-please##方式3：自动dns验证方式申请证书 #需要使用到DNS API，并需要配置域名解析商的 API 认证信息 #当 acme.sh --issue --dns &lt;dns-name&gt; 生成证书时，会自动更新一些配置文件 #（1）设置的 API 认证信息会被自动记录在/root/.acme.sh/account.conf配置文件中, 后续再使用该 DNS 插件时, 就不需要指定了，当然，如果重新指定，那么会覆盖account.conf配置文件中原来的配置 #（2）设置的 DNS 插件类型会记录在~/.acme.sh/example.com/example.com.conf配置文件中，如果重新指定，那么会覆盖account.conf配置文件中原来的配置 #不同的域名解析商的DNS API使用方式相似，但有些许区别，可参考：https://github.com/acmesh-official/acme.sh/wiki/dnsapi#以DNSPod DNS为例，操作如下： #先访问 https://console.dnspod.cn/account/token/token 创建“DNSPod Token”（注意不是“腾讯云 API 密钥”），然后进行如下设置：#设置 DNS 插件的 API 认证信息export DP_Id="xxxxx"export DP_Key="xxxxx"#通过指定DNS API类型自动进行dns验证并申请证书acme.sh --issue --dns dns_dp -d example.com -d *.example.com#以Cloudflare DNS为例，操作如下： #使用参考：https://github.com/acmesh-official/acme.sh/wiki/dnsapi#dns_cf #先访问：https://dash.cloudflare.com/profile/api-tokens 创建获得 “API Tokens” 或者查看使用 “Global API Key”（选其一即可），推荐使用 API Tokens，因为其权限相对较小，更安全，注意：API Tokens 创建后只能查看一次，如果忘记了只能重新创建#设置 DNS 插件的 API 认证信息#使用 API Tokens 时（可选）export CF_Token="xxxxx"#使用 Global API Key 时（可选）export CF_Key="xxxxx"export CF_Email="user@example.com"##通过指定DNS API类型自动进行dns验证并申请证书acme.sh --issue --dns dns_cf -d example.com -d *.example.com##安装证书 #注意：默认生成的证书都会放在 ~/.acme.sh/example.com 目录里，请不要直接使用此目录下的文件，因为这里面的文件都是 acme.sh 内部使用的，该目录结构可能会发生变化，故建议把证书安装复制到真正需要用它的地方。安装命令将一些重要的命令参数（如：证书、私钥等文件的安装路径、reloadcmd 等 hook 命令脚本等，其中 hook 命令会经 base64 编码）记录在 ~/.acme.sh/example.com/example.com.conf 配置文件中，当证书更新（如续期更新证书）时，将会重新安装复制最新证书到配置文件所指定的路径中，并执行 reloadcmd 等 hook 命令脚本（如：重载 nginx 配置文件等）。 #安装证书后，就可以到 web 服务器（如：Nginx）配置使用证书了 #提示： #（1）重复执行时，如果路径或 hook 等内容有变化会自动修改 example.com.conf 配置文件； #（2）执行该命令候会立即执行 --reloadcmd 对应的 hook 命令 #（3）对于多域名证书，安装时只要指定用于命名证书的域名即可（默认为申请证书时的第一个指定域名），不需要指定全部域名acme.sh --install-cert \-d example.com \--key-file /path/example.com-key.pem \--fullchain-file /path/example.com-fullchain.pem \--reloadcmd "nginx -s reload"##查看已申请的证书#列出已申请的所有证书acme.sh --list#查看已申请的指定证书配置信息acme.sh --info -d example.com##吊销指定证书acme.sh --revoke -d example.com##从证书生成目录中删除指定证书acme.sh --remove -d example.com #逻辑删除，只是改文件后缀，实际并不会删除掉文件rm -rf ~/.acme.sh/example.com #实际删除（提示：如果为ECC证书，则目录为：example.com_ecc）##续期证书#申请证书后acme.sh会自动将续期任务添加到系统的用户定时任务中。(目前默认每60天会自动更新，今后有可能会缩短这个时间)#列出系统的定时任务（可查看acme.sh自动添加的定时任务）crontab -l#续期指定证书（如需手动需求） #默认证书未到期，不会成功续期（即重新颁发新的证书），但可指定 --force 来强制重新颁发证书，但不建议，因为申请颁发太多次会触发申请次数限制acme.sh --renew -d example.com#acme.sh --renew --force -d example.com #强制重新颁发证书#续期所有证书（如需手动需求）acme.sh --renew-all##修改已生证书的 DNS 插件（设之前使用 DNSPod，现在改为 Cloudflare）#（1）编辑账号配置文件（~/.acme.sh/account.conf），添加或修改相应 DNS 插件的 API 认证信息（如果没有则需要添加，如果之前已经配置存在可以自行选择是否需要修改，其中认证变量名前需要加 “SAVED_” 前缀），如下：SAVED_CF_Key='xxxxx'SAVED_CF_Email='user@example.com'#（2）编辑指定证书的配置文件（~/.acme.sh/example.com/example.com.conf），可修改 Le_Webroot（DNS 插件名称）。也可根据自己调整情况选择修改 Le_RealKeyPath（证书秘钥文件安装路径）、Le_RealFullChainPath（证书链文件安装路径，其中证书链文件含证书）、Le_ReloadCmd（证书安装完成后重新加载执行的 hook 命令，Le_ReloadCmd 的值的格式为 __ACME_BASE64__START_&lt;经 Base64 编码的命令&gt;__ACME_BASE64__END_），如下：Le_Webroot='dns_cf'Le_RealKeyPath='/opt/ssl-certs/acme.sh-qcmoke.link-key.pem'Le_ReloadCmd='__ACME_BASE64__START_L29wdC9uZ2lueC9zYmluL25naW54IC1zIHJlbG9hZA==__ACME_BASE64__END_'Le_RealFullChainPath='/opt/ssl-certs/acme.sh-qcmoke.link-fullchain.pem'#（3）如果不放心修改正不正确，可以强制重新生成证书（可选，没必要，因为申请颁发太多次会触发申请次数限制），如下：acme.sh --renew --force -d example.com#（4）或者强制重新重头申请生成证书（可选，没必要，因为申请颁发太多次会触发申请次数限制），如下：#设置 DNS 插件的 API 认证信息（以 Global API Key 为例）export CF_Key="xxxxx"export CF_Email="user@example.com"#重新生成证书（会同步更新example.com.conf配置文件） #提示：acme.sh --renew 只能使用之前存储的配置信息来重新生成证书，但不能指定参数来修改 DNS 插件类型、DNS 插件对应 API 认证信息、证书、密钥安装路径等的配置内容。所以需要指定 --issue --force 来重新生成证书并重修改配置文件（其中指定 --force 表示强制重新颁发证书）acme.sh --issue --force --dns dns_cf -d example.com -d *.example.com#重新安装证书acme.sh --install-cert \-d example.com \--key-file /path/example.com-key.pem \--fullchain-file /path/example.com-fullchain.pem \--reloadcmd "nginx -s reload"申请证书后，会将证书保存的目录为：~/.acme.sh/example.com（提示：如果为 ECC 证书，则目录为：example.com_ecc），包含一下文件：ca.cer：CA 证书文件fullchain.cer：证书链文件（中间证书）example.com.cer：证书文件example.com.key：私钥文件example.com.conf：指定证书的配置文件example.com.csr：证书请求文件example.com.csr.conf：acme.sh 对于特定证书请求文件的配置文件关于 Let’s Encrypt 证书申请次数限制：生产环境限制每个域名/证书每周最多只能签发 5 次每个 IP 地址每小时最多能提交 300 个证书申请请求测试环境限制（指定 --staging 或 --test 选项时）测试环境下颁发的证书无法被浏览器或操作系统信任测试环境下每个域名/证书每周最多可签发 50 次测试环境下每个 IP 地址每小时最多能提交 300 个请求测试环境下没有通过 HSTS 预载的域名（生产环境支持通过 HSTS 预载的域名）¶六、备份还原备份（在原服务器上进行）12345678##备份acme.sh的脚本、证书、配置文件cd /root/#打包备份目录tar -zcvf acme.sh.tgz .acme.sh/# 使用 sz 下载备份包并删除备份包（可选）# sz -y acme.sh.tgz# rm -f acme.sh.tgz .acme.sh/acme.sh.cron.tmp还原（在新服务器上进行）12345678910111213141516171819202122#使用 rz 上传备份包到 /root 目录（可选）# rz -y##还原 acme.sh 的脚本、证书、配置文件cd /root/#删除目录（如有）# rm -rf .acme.sh/#解包还原目录tar xf acme.sh.tgz#删除备份包（可选）# rm -f acme.sh.tgz#还原 acme.sh 的定时任务#删除 acme.sh 有关的定时任务（如有）# acme.sh --uninstall-cronjob#安装 acme.sh 有关的定时任务acme.sh --install-cronjob#还可通过 crontab -e 命令来手动编辑来追加定时任务#或者（RedHat 系列系统）：echo '35 0 * * * "/root/.acme.sh"/acme.sh --cron --home "/root/.acme.sh" &gt; /dev/null' &gt;&gt; /var/spool/cron/root#或者（Debian 系列系统）：echo '35 0 * * * "/root/.acme.sh"/acme.sh --cron --home "/root/.acme.sh" &gt; /dev/null' &gt;&gt; /var/spool/cron/crontabs/root#或者：(crontab -l ; echo '35 0 * * * "/root/.acme.sh"/acme.sh --cron --home "/root/.acme.sh" &gt; /dev/null') | crontab -参考：https://www.cnblogs.com/tssc/p/17428657.html¶七、参考https://blog.misaka.rest/2023/04/02/acme-ssl-cert/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetBrains系列开发工具使用文档]]></title>
    <url>%2Ftools%2Fjetbrains.html</url>
    <content type="text"><![CDATA[¶一、安装JetBrains系列开发工具到 jetbrains官网 下载需要的开发工具。比如选择下载IntelliJ IDEA，安装就是傻瓜式的下一步即可。¶二、JetBrains系列开发工具激活¶1、旧版 - 2021.3版本（不含）之前版本有效插件市场安装：在Settings/Preferences... -&gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io搜索：IDE Eval Reset插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？插件会提示安装成功。下载安装：下载 ide-eval-resetter 插件。通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&gt; Plugins 里手动安装插件（Install Plugin From Disk...）插件会提示安装成功。如果IDE已经过了试用打不开，可以运行试用到期重置脚本（注意选择对应系统版本），它可以让你暂时进入IDE进行上述操作。参考：https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html¶2、新版 - 2021.3版本之后有效激活下列以JetBrains系列中的IDEA为例讲解，其他JetBrains开发工具也适用。1、下载ja-netfilter插件：https://gitee.com/ja-netfilter/ja-netfilter/releases/download/2022.2.0/ja-netfilter-2022.2.0.zip2、解压下载的压缩包到本机上的任意目录，如：D:\Development\JetBrains\ja-netfilter3、修改插件ja-netfilter/config目录下配置文件修改dns.conf123[DNS]EQUAL,jetbrains.comEQUAL,plugin.obroom.com修改power.conf1234567[Result]; Suit 220801EQUAL,108391492724719606277191711676038310454333436786970899072879934267610324870870961974305689698304529291751931883693569275416671653649715395540162187908455880751887548211257780817773830153477469379663893839249632010489688404104740814832791608983255964373246023808678041003248593298915323068020141515280275870731964298697511434302901212533563571472947179437111243030002421474283363073021442715554541318313064598900684758246291687123240210640543678544269324094608551763049140564128299834843381841274260516105408318037686490277144538983963856617365418526798235932271319705894170543971766101775628884107261100637290512593943587295268337137890353216997114446658051251047509442298463526766678103653729776506979657957966027949436493606289520405331110453990512846697802196701678785414928082416405650857741201229183421400567636999723106788808933737428330992184832395299929033666381663232693108552887968738513151493044369308652310586803160326722967115451573652070286501044484503083240302303438554529551204609089966636092666792347623413483134664670641246129954999815529917163967761617333572567787618346281658716181608204191963817312534492517480248086896060880038259592723773361709406277837609546030729611710076711450268767610513506889086815865283,65537,860106576952879101192782278876319243486072481962999610484027161162448933268423045647258145695082284265933019120714643752088997312766689988016808929265129401027490891810902278465065056686129972085119605237470899952751915070244375173428976413406363879128531449407795115913715863867259163957682164040613505040314747660800424242248055421184038777878268502955477482203711835548014501087778959157112423823275878824729132393281517778742463067583320091009916141454657614089600126948087954465055321987012989937065785013284988096504657892738536613208311013047138019418152103262155848541574327484510025594166239784429845180875774012229784878903603491426732347994359380330103328705981064044872334790365894924494923595382470094461546336020961505275530597716457288511366082299255537762891238136381924520749228412559219346777184174219999640906007205260040707839706131662149325151230558316068068139406816080119906833578907759960298749494098180107991752250725928647349597506532778539709852254478061194098069801549845163358315116260915270480057699929968468068015735162890213859113563672040630687357054902747438421559817252127187138838514773245413540030800888215961904267348727206110582505606182944023582459006406137831940959195566364811905585377246353-&gt;31872219281407242025505148642475109331663948030010491344733687844358944945421064967310388547820970408352359213697487269225694990179009814674781374751323403257628081559561462351695605167675284372388551941279783515209238245831229026662363729380633136520288327292047232179909791526492877475417113579821717193807584807644097527647305469671333646868883650312280989663788656507661713409911267085806708237966730821529702498972114194166091819277582149433578383639532136271637219758962252614390071122773223025154710411681628917523557526099053858210363406122853294409830276270946292893988830514538950951686480580886602618927728470029090747400687617046511462665469446846624685614084264191213318074804549715573780408305977947238915527798680393538207482620648181504876534152430149355791756374642327623133843473947861771150672096834149014464956451480803326284417202116346454345929350148770746553056995922154382822307758515805142704373984019252210715650875853634697920708113806880196144197384637328982263167395073688501517286678083973976140696077590122053014085412828620051470085033364773099146103525313018873319293728800442101520384088109603555959893639842091339193857485407672132882577840295039058621747654642202620767068924079813640067442975EQUAL,17430805040661904960217142128786500464864043257152786846745016761637330023130385628907046448630022920796670427977354189343808215815509511917604813946812068613694491683253995133209152077919891234968182248857838898199644443355241219225726139665337883043072574125580003765750846684062985504854965420309681346496007525845855594591340548416511522780366831902271789348331613580937547169576595371827264137623285493327295900285658920185041209960394118635722087939857728650109349728410946091579960723986601084785767630072314151995336592750869439606211427735380846313426999664229383327948871862419128418990267247800060898233458,65537,24521566609765666164947017540032021599255701751860227819512057581863724253675446227963662825786216373422117712052647819939094618512591273903731385388945941620956494535886991119537555521717683289574562412249381695575366776196301290570457146763799416784211789775179394339350479765228864277544252534115220169733628333836919758657866915165201332480467127194998195481209996470680276955438320553419743409285076366446411459237915876713514676197204668785300100857270615348770478845912795954436677863461158442534283102154396294509903255539003316675136070586165787963286744036831353098283719024130881707718857451774498022915819-&gt;986236757547332986472011617696226561292849812918563355472727826767720188564083584387121625107510786855734801053524719833194566624465665316622563244215340671405971599343902468620306327831715457360719532421388780770165778156818229863337344187575566725786793391480600129482653072861971002459947277805295727097226389568776499707662505334062639449916265137796823793276300221537201727072401742985542559596685092673521228140822200236743113743661549252453726123450722876929538747702356573783116366629850199080495560991841329893037291900147497007197055572787780928474439122050029863368156328679013185403585508633386797793[Args]EQUAL,65537,24773058818499217187577663886010908531303294206336895556072197892590450942803807164562754911175164262596715237551312004078542654996496301487027034803410086499747369353221485073240039340641397198525027728751956658900801359887190562885573922317930300068615009483578963467556425525328780085523172495307229112069939166202511721671904748968934606589702999279663332403655662225374084460291376706916679151764149324177444374590606643838366605181996272409014933080082205048098737253668016260658830645459388519595314928290853199112791333551144805347785109465401055719331231478162870216035573012645710763533896540021550083104281-&gt;3,24773058818499217187577663886010908531303294206336895556072197892590450942803807164562754911175164262596715237551312004078542654996496301487027034803410086499747369353221485073240039340641397198525027728751956658900801359887190562885573922317930300068615009483578963467556425525328780085523172495307229112069939166202511721671904748968934606589702999279663332403655662225374084460291376706916679151764149324177444374590606643838366605181996272409014933080082205048098737253668016260658830645459388519595314928290853199112791333551144805347785109465401055719331231478162870216035573012645710763533896540021550083104281修改url.conf12[URL]PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action4、打开IDEA安装目录里的bin目录，然后修改 idea64.exe.vmoptions 文件。添加如下参数：123-javaagent:D:\\Development\\JetBrains\\ja-netfilter\\ja-netfilter.jar--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED💁‍♂ 备注说明：路径中的斜杠使用\\或者/，建议路径中不要包含空格。懒人配置方式：如果不想以上配置那么麻烦，也可以用别人对ja-netfilter配置好的懒人版，打开 https://3.jetbra.in 然后选择页面刷新的任意一个可用的网址点击进入神K网站，下载页面上方的jetbra.zip文件。5、打开这个网站 https://3.jetbra.in 等待片刻，选择一个可以访问的网站，然后找到对应系列的卡片选择复制激活码。更多激活码获取：http://jets.idejihuo.com/6、启动IDEA，然后复制以上获取的激活码进行激活即可。如下：IntelliJ IDEA 的激活码：16G5NXCPJZB-eyJsaWNlbnNlSWQiOiI2RzVOWENQSlpCIiwibGljZW5zZWVOYW1lIjoic2lnbnVwIHNjb290ZXIiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUEMiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA5MDJQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi0xMDc4MzkwNTY4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-SnRVlQQR1&#x2F;9nxZ2AXsQ0seYwU5OjaiUMXrnQIIdNRvykzqQ0Q+vjXlmO7iAUwhwlsyfoMrLuvmLYwoD7fV8Mpz9Gs2gsTR8DfSHuAdvZlFENlIuFoIqyO8BneM9paD0yLxiqxy&#x2F;WWuOqW6c1v9ubbfdT6z9UnzSUjPKlsjXfq9J2gcDALrv9E0RPTOZqKfnsg7PF0wNQ0&#x2F;d00dy1k3zI+zJyTRpDxkCaGgijlY&#x2F;LZ&#x2F;wqd&#x2F;kRfcbQuRzdJ&#x2F;JXa3nj26rACqykKXaBH5thuvkTyySOpZwZMJVJyW7B7ro&#x2F;hkFCljZug3K+bTw5VwySzJtDcQ9tDYuu0zSAeXrcv2qrOg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU&#x2F;Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8&#x2F;COMrxRlZW5mfzo0xsK0dQGNH3UoG&#x2F;9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE&#x2F;BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5&#x2F;FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB&#x2F;R5oUlebwaTE6WZNBs+TA&#x2F;qPj+5&#x2F;we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329&#x2F;WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V&#x2F;0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ&#x2F;c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0&#x2F;&#x2F;lOmVya&#x2F;PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0&#x2F;WFPl1aw5VV&#x2F;VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH&#x2F;0onDWebStorm 的激活码：18R927DG13X-eyJsaWNlbnNlSWQiOiI4UjkyN0RHMTNYIiwibGljZW5zZWVOYW1lIjoic2lnbnVwIHNjb290ZXIiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUFdTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA5MDJQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOjIwMTEzMjMwMjYiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-Jev3eIT6wPDh59rzeBG67oHD8GcYHifz9+OkIePP3Qo49dGX1DqLTGJgOxSClHrshRzjOktdBYwkwpeTrDMwgeGu+cy0OhzvtQMeh7R3HrEQkhGbNBjfpbW6nq6Mhv8k6Duoiw3XiU434V5iM6DgRN3Yzo8VKxU7Kb4u&#x2F;SQnPTd+PR64hYJjblVXUzGHZUX4w8RBej3T0EREccs36bfnnPC2X91K&#x2F;qbvr9C0uY&#x2F;feHAMpuekMks0v4qApbInpw5O+elLE3l8txlNWhWSC8m&#x2F;O&#x2F;S7iydf27hV5mgePM5422Rpvm4dmA2DIQcq7xxdt4X67DmVGMC2yIFiH4hfkqySWg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU&#x2F;Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8&#x2F;COMrxRlZW5mfzo0xsK0dQGNH3UoG&#x2F;9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE&#x2F;BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5&#x2F;FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB&#x2F;R5oUlebwaTE6WZNBs+TA&#x2F;qPj+5&#x2F;we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329&#x2F;WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V&#x2F;0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ&#x2F;c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0&#x2F;&#x2F;lOmVya&#x2F;PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0&#x2F;WFPl1aw5VV&#x2F;VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH&#x2F;0onD如果不想以上配置那么麻烦，也可以用别人对ja-netfilter配置好的懒人版，打开 https://3.jetbra.in 然后选择页面刷新的任意一个可用的网址点击进入神K网站，下载页面上方的jetbra.zip文件。需要注意，从这个网站下载的懒人包在配置-javaagent参数时要注意在后面加参数=jetbrains（这个很坑！ 😢 ），否则在激活时会提示Key is invalid且无法激活，加这个参数的原因是因为懒人包配置文件在config-jetbrains目录里而不是config目录里（如果不加这个参数则会从config目录里找配置文件）。加参数后的配置如下：123-javaagent:D:\\Development\\JetBrains\\jetbra\\ja-netfilter.jar=jetbrains--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED参考：https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html#more-1https://www.cnblogs.com/yanglang/p/16818245.htmlhttps://www.quanxiaoha.com/webstorm-pojie/webstorm-pojie-20231.html¶三、解决JetBrains软件对C盘占用问题下列以JetBrains系列中的IDEA为例讲解，其他JetBrains开发工具也适用。默认IDEA下载的插件和缓存都会存到C盘的用户目录里，如果想改到其他盘符，只要打开IDEA安装目录里的bin目录，然后修改 idea.properties文件，添加如下配置：1234idea.config.path=E:/Cache/JetBrains/.IntelliJIdea/configidea.system.path=E:/Cache/JetBrains/.IntelliJIdea/systemidea.plugins.path=$&#123;idea.config.path&#125;/pluginsidea.log.path=$&#123;idea.system.path&#125;/log¶四、IDEA开发工具¶1、创建java工程设置jdk设置项目名称和项目存放路径添加工具栏和工具按钮创建java文件输入psvm快速自动补全生成public static void main(String[] args) {}输入sout快速自动补全生成System.out.println();完整代码如下：1234567package com.qcmoke;public class Hello &#123; public static void main(String[] args) &#123; System.out.println("hello world !"); &#125;&#125;编译运行Hello.java ，有三种方式。方式1：方式2：方式3：也可以按快捷键ctrl+shift+F10完成编译运行。运行结果：¶2、创建web工程第一步 创建工程指定项目名称和存放位置，然后点击Finish如果发现这里是空的没有tomcat，可以点击配置tomcat服务器第二步 补全目录在web目录下创建classes和lib文件夹，名字不可改接下来给classes和lib赋予IDEA目录特性，在File中找到Project Structure点击Modules ,选择Paths,选中Use module compile output path ,把路径改成刚刚创建的classes文件夹applay后再点旁边的Dependencies,点击&quot;+&quot;号，选择1 JARs or directories ，选择你刚刚创建的lib文件夹，OK选中jar Directory。第三步 额外配置第四步 编写测试代码（1）放置mysql-connector-java-5.1.28-bin.jar到lib目录里（2）在src目录下创建DBServlet.java文件1234567891011121314151617181920212223242526272829303132333435package com.qcmoke.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;@WebServlet(name = "DBServlet",urlPatterns = "/DBServlet")public class DBServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); try &#123; Class.forName("com.mysql.jdbc.Driver");// 注册 JDBC 驱动 Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/ssm", "root", "123456");// 获取连接 if(conn !=null)&#123; System.out.println("db conn ok !"); response.getWriter().print("db conn success !"); &#125;else&#123; response.getWriter().print("db conn fail !"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); response.getWriter().print("db conn fail !"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;第四步 运行测试¶3、创建maven javase工程步骤1 设置本地安装好的maven（IDEA默认也有maven，但是一般开发时还是使用自己安装配置的maven）步骤2 创建工程步骤3 导入依赖1234567&lt;!-- MySql-connector 数据库驱动 --&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt;步骤5 编写代码并运行测试1234567891011121314151617181920212223242526package com.qcmoke;import java.sql.Connection;import java.sql.DriverManager;/** * Hello world! * */public class App &#123; public static void main( String[] args ) &#123; try &#123; Class.forName("com.mysql.jdbc.Driver");// 注册 JDBC 驱动 Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/ssm", "root", "123456");// 获取连接 if(conn !=null)&#123; System.out.println("db conn ok !"); &#125;else&#123; System.out.println("db conn fail !"); &#125; &#125; catch (Exception e) &#123; System.out.println("db conn fail !"); &#125; &#125;&#125;¶4、创建maven web工程步骤1 设置本地安装好的maven（IDEA默认也有maven，但是一般开发时还是使用自己安装配置的maven）步骤2 创建工程步骤3 补全目录给目录赋予IDEA目录特性。步骤4 配置pom.xmlpom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;mavenWeb&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;mavenWeb Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySql-connector 数据库驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;mavenWeb&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- tomcat插件(部署到tomcat中运行) 在Goals中输入： clean tomcat7:redeploy 或 clean tomcat7:run，点击 Apply 保存设置 ，然后run 或 debug。 http://localhost:8080/qcmoke/***.html --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;步骤5 编写测试代码DBServlet.java12345678910111213141516171819202122232425262728293031package com.qcmoke.servlet;import javax.servlet.annotation.WebServlet;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;@WebServlet(name = "DBServlet",urlPatterns = "/DBServlet")public class DBServlet extends javax.servlet.http.HttpServlet &#123; protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); try &#123; Class.forName("com.mysql.jdbc.Driver");// 注册 JDBC 驱动 Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/ssm", "root", "123456");// 获取连接 if(conn !=null)&#123; System.out.println("db conn ok !"); response.getWriter().print("db conn success !"); &#125;else&#123; response.getWriter().print("db conn fail !"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); response.getWriter().print("db conn fail !"); &#125; &#125; protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123; doPost(request,response); &#125;&#125;步骤6 运行测试¶5、优化jvm参数默认IDEA给的JVM参数比较低，我们可以修改这些参数来提升IDEA的运行速度和性能。默认为：根据电脑配置做修改，比如系统64位，内存8g。那么配置为以下：123456789101112# custom IntelliJ IDEA VM options-Xms1024m-Xmx2048m-XX:ReservedCodeCacheSize=500m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow¶6、进入idea设置面板从开启页面进入配置主页（对全局起作用）如果在工作区里，可以通过Close Project回到开启页面开启页面：¶7、调试先设置断点然后点击调试按钮开始调试按F7从断点处一行一行往下继续,会进入断点所在的函数体里其他调用方法的方法体里。按F8从断点处一行一行往下继续，不会进入断点所在的函数体里其他调用方法的方法体里。按F9从当前断点处直接跳到下一个断点处执行。查看变量值变化¶8、解决启动后直接进入之前工程的问题¶9、常用快捷键快捷键功能Ctrl+Shift+Space自动补全代码Ctrl+Alt+L格式化代码alt+enter导包Shift+F6重命名Ctrl+Alt+V可以引入变量。例如：String string=new String();Ctrl+O无参构造函数Ctrl+Shift+U大小写转化Ctrl+Y删除当前行Alt+Inserts生成get/set等Shift+Enter向下插入新行Ctrl+Enter在行首前上插一行Ctrl+R替换Ctrl+Q查看JavaDocAlt+left/right切换代码视图Alt+Up/Down在方法间快速移动定位Ctrl+Shift+E最近更改的文件Ctrl+Alt+Space类名或接口名提示Ctrl＋E可以显示最近编辑的文件列表Ctrl＋Shift＋Backspace跳转到上次编辑的地方Ctrl＋F12显示当前文件的结构参考：http://idea.lanyus.com/help/help.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 Certbot 工具申请 Let's Encrypt SSL 证书]]></title>
    <url>%2Ftools%2Fcertbot.html</url>
    <content type="text"><![CDATA[¶一、简要概述Certbot 是一个免费、开源、自动化的 ACME 客户端工具，可用于申请 Let’s Encrypt SSL 证书。它可以帮助网站管理员轻松地实现 HTTPS 等功能，提高网站的安全性和可靠性。ACME 协议：定义了客户端（通常是证书申请者或服务器管理员）和证书颁发机构之间的交互过程。ACME 客户端使用 ACME 协议与证书颁发机构的 ACME 服务端进行通信，实现自动申请证书、证明域名所有权、获取证书、以及在证书到期前续订证书等功能。Let’s Encrypt：一个免费的证书颁发机构，支持 ACME 协议进行证书申请和维护。Let’s Encrypt SSL 证书：由 Let’s Encrypt 颁发机构颁发的 SSL 证书，使用了 SHA-256 签名算法，并支持最新版本的 TLS 协议，因此可以提供强大的加密和认证保护，保障网站和用户数据的安全。同时，Let’s Encrypt 证书的根证书已被所有主流浏览器信任，这意味着用户不需要手动添加任何信任条目或 CA 证书到浏览器中。提示：Certbot 是使用 Python 编写的，因此在使用之前需要确保系统上已经安装了 Python 解释器和相关依赖库（一般 Linux 服务器都默认安装有 Python）。官方文档：https://certbot.eff.org/docs¶二、安装 certbot¶1. 通过系统默认包管理器安装旧版 certbot通过系统默认包管理器安装的版本通常是 certbot v1 的旧版，虽然不同使用没有什么问题，但是在使用一些高级功能（如：DNS 插件）等可能会出现版本不支持的问题。123456789101112131415#apt安装certbotapt install -y certbot#yum安装certbotyum install -y epel-releaseyum install -y certbot#通过查看certbot版本验证安装是否成功certbot --version##卸载certbot（如需要）yum remove -y certbot #yum卸载apt remove -y certbot #apt卸载#删除残余目录或文件（包括证书）rm -rf /var/lib/letsencrypt /etc/letsencrypt💁‍♂ 提示：certbot-auto 是较旧的版本，官方已不再支持。¶2. 通过 pip 包管理器安装最新版 certbot1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#通过 pip 安装最新版 certbot，要求 python 3.6+，故需要在系统中安装版本高于 3.6 的 python 版本。可以借助 pyenv 来安装任意版本的 python。#（1）安装依赖yum install -y gcc make patch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel openssl-devel tk-devel libffi-devel xz-devel#（2）安装pyenvwget -O pyenv-2.3.17.tar.gz https://github.com/pyenv/pyenv/archive/refs/tags/v2.3.17.tar.gztar -zxvf pyenv-2.3.17.tar.gzmv pyenv-2.3.17 ~/.pyenv#（3）配置环境变量#添加环境变量。cat后的&gt;&gt;表示追加，&gt;则表示覆盖。&lt;&lt; 后的EOF用引号可以避免$赋值，如果希望赋值则不加引号cat &gt;&gt; ~/.bashrc &lt;&lt; 'EOF'export PYENV_ROOT="$HOME/.pyenv"export PATH="$PYENV_ROOT/bin:$PATH"if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval "$(pyenv init -)"fiEOF#（4）使环境变量生效source ~/.bashrc#（5）安装python版本pyenv install 3.7.0#（6）设置全局python版本（系统全局环境使用的版本）pyenv global 3.7.0#（6）升级指定python版本的pip版本pip install --upgrade pip#（7）通过指定python版本的pip安装certbotpip install certbot#（8）安装指定版本的urllib，防止certbot运行报错pip install 'urllib3&lt;2.0'#（9）链接certbot到系统/usr/bin目录里ln -s /root/.pyenv/versions/3.7.0/bin/certbot /usr/bin/certbot#（10）查看certbot版本certbot --version#（11）升级certbot版本（如需要）pip install --upgrade certbot#（12）改回系统原本自带的python版本（如需要）pyenv global system参考：https://certbot.eff.org/instructions?ws=nginx&amp;os=pip¶3. 通过 snap 包管理器安装最新版 certbot提示：通过 snap 包管理器可以安装最新版的 certbot，这也是 certbot 官方推荐的安装方式，但相对于系统默认包管理器的安装方式， snap 的安装包文件占用更大，如果服务器磁盘空间不够的话并不建议使用，另外snap 的管理命令也需要有一定的学习成本，其实目前系统默认包管理器安装的旧版 certbot 已经足够日常使用了，不一定非要使用 snap。¶卸载旧版 certbot（如有）1234#apt卸载apt remove -y certbot#yum卸载yum remove -y certbot¶安装 snap1234567891011121314151617181920212223242526##（1）安装snapd# apt安装（提示：ubuntu16.04之后的版本已经内置了snap，在debian系统上则需要手动安装）apt updateapt install -y snapd# yum安装（操作命令相对会多一些）yum install -y epel-releaseyum install -y snapd##（2）启动snad的套接字单元# 启动snapd套接字单元（注意套接字单元是snapd.socket，而不是snapd.service，其中snapd.service可简写为snapd）systemctl enable --now snapd.socket #等同于 sudo systemctl enable snapd.socket &amp;&amp; sudo systemctl start snapd.socket# 查看是否成功启动snapdsystemctl status snapd.socket##（3）需要注销并重新登录（重新打开终端即可）或重新启动系统以确保正确更新snap的路径exit##（4）安装snap核心包# 安装snap核心包snap install coresnap refresh core##（5）配置支持snap经典模式安装（仅yum安装snap时需要）# 说明：由于snap经典模式安装需要操作/snap目录。通过yum安装snapd时，snap所安装的经典包存放在/var/lib/snapd/snap目录中而非/snap目录，所以需要创建一个符号链接/snap指向到/var/lib/snapd/snap，否则snap只能安装标准包而无法安装经典包。而使用apt安装snapd时，snap所安装的经典包就存放在/snap目录中，故而不需要创建符号链接。ln -s /var/lib/snapd/snap /snapsnap 安装参考：https://snapcraft.io/docs/installing-snapd报错解决：（1）snap install core 时如果报错提示：error: system does not fully support snapd: open /tmp/syscheck-squashfs-1411954570: no such file or directory，只需重启系统重试即可解决。¶安装 certbot123456#通过snap安装certbotsnap install --classic certbotln -s /snap/bin/certbot /usr/bin/certbot#通过查看certbot版本验证安装是否成功certbot --versioncertbot 安装参考：https://certbot.eff.org¶卸载 certbot（如需要）1234#卸载certbotsnap remove certbot#删除残余目录或文件（包括证书）rm -rf /var/lib/letsencrypt /etc/letsencrypt /usr/bin/certbot¶卸载 snap12345678910111213#关闭snapd套接字单元（卸载前先停掉snapd套接字单元，否则卸载失败）systemctl stop snapd.socket##卸载snap#1、yum卸载yum remove -y snapd#删除残余目录或文件rm -rf /var/lib/snapd /snap ~/snap#2、apt卸载apt remove --purge -y snapd #如果不加--purge则需要手动删除/var/lib/snapd和/snap#删除残余目录或文件rm -rf ~/snap¶三、申请签发证书¶1. 简要概述需要说明的是：在 Certbot 申请证书时，证书是由 Let’s Encrypt 官方 ACME 服务器生成的，而不是由本地服务器生成的。Certbot 将向 Let’s Encrypt CA（证书颁发机构）发出签发请求，并将验证域名的控制权。一旦验证通过，Let’s Encrypt 将向 Certbot 返回 SSL 证书，以便在您的 Web 服务器上部署和使用。¶2. certbot 常用的选项和参数--webroot：使用自动 HTTP 验证方式方式（默认模式）。在 .well-known/acme-challenge/ 路径下创建一个临时文件，并通过 HTTP 获取该文件来验证域名所有权。--manual：手动模式，该模式需要您手动执行一些步骤，例如在 DNS 记录中添加 TXT 记录以验证域名所有权。--nginx：使用 Nginx Web 服务器插件。该模式允许 Certbot 自动配置 Nginx Web 服务器，以便验证域名所有权并部署证书。--apache：使用 Apache Web 服务器插件。该模式允许 Certbot 自动配置 Apache Web 服务器，以便验证域名所有权并部署证书。--standalone：使用独立 Web 服务器插件。该模式允许 Certbot 在自己的 Web 服务器（standalone）上运行，以验证域名所有权和颁发证书--server： ACME 服务器地址。默认为 Let’s Encrypt 官方 ACME 服务器地址，即：https://acme-v02.api.letsencrypt.org/directory。--domains DOMAIN（简写：-d DOMAIN）：要签发证书的域名。如：-d example.com--staging：签发测试环境证书。--cert-name CERTNAME：为证书命名。--expand：更新现有证书以包括新的子域名。--duplicate：复制现有证书。--reinstall：重新安装现有证书。--force-renewal：在有效期内强制更新证书。--email EMAIL（简写：-m EMAIL）：账号邮箱地址。可用于自动注册 ACME 账号，还可用于证书到期前 20 天、10 天和 1 天时接收到到期通知邮件。如：--email user@example.com--agree-tos：同意 Let’s Encrypt 的服务条款，并接受由 Let’s Encrypt 颁发的 SSL/TLS 证书。如果您不同意服务条款，则无法使用 Let’s Encrypt 颁发的证书。--preferred-challenges PREF_CHALLENGES：首选的域名所有权验证类型。如：--preferred-challenges dns-01支持的验证类型如下：（1）http-01：默认验证方法，将向公开在 HTTP 上运行的 Web 服务器发送请求，在 .well-known/acme-challenge/ 路径下创建一个临时文件，并通过 HTTP 获取该文件来验证您拥有该域名。（2）dns-01：使用 DNS 记录验证域名所有权。此方法需要您手动更新相应的 DNS 记录。在 DNS 记录更新后，Let’s Encrypt 将使用 DNS 查找该记录以验证您拥有该域名。（3）tls-sni-01：已弃用，不再使用。原本是在 HTTPS 连接的 SNI 扩展中发送验证信息，但由于安全问题而被弃用。（4）tls-alpn-01：一种基于 TLS 的验证方法，它使用新的 ALPN 协议扩展来发送验证信息。与 tls-sni-01 不同，它不会公开任何信息，因此更加安全。--non-interactive：禁用交互式模式。（默认certonly 命令是交互式的）--no-eff-email：禁止发生统计信息邮件给EFF。（默认情况下，Certbot 在生成 SSL/TLS 证书时会向 EFF 发送电子邮件，以便收集有关证书使用情况的统计信息）--dry-run：测试证书颁发流程，但不实际签发证书。-h：获取帮助信息。--version：查看 Certbot 版本号。--config-dir CONFIG_DIR：指定配置文件目录。--work-dir WORK_DIR：指定工作目录。--logs-dir LOGS_DIR：指定日志目录。💁‍♂ 说明：如果不指定选项和参数，则一些必要的选项参数将会在交互式命令中要求指定。¶3. Let’s Encrypt 证书申请请求限制生产环境限制每个域名/证书每周最多只能签发 5 次每个 IP 地址每小时最多能提交 300 个证书申请请求测试环境限制（certbot 使用 --staging 选项时）测试环境下颁发的证书无法被浏览器或操作系统信任测试环境下每个域名/证书每周最多可签发 50 次测试环境下每个 IP 地址每小时最多能提交 300 个请求测试环境下没有通过 HSTS 预载的域名（生产环境支持通过 HSTS 预载的域名）¶4. 申请证书方式Let’s Encrypt CA（ACME 服务器）判断是否允许用户申请域名对应的证书，需要验证用户是否为域名的拥有者，只有确定用户为域名拥有者才能签发证书。¶方式1：自动 HTTP 验证方式申请证书简要概述：（1）certbot（ACME 客户端）会在 Web 服务器的根目录下自动创建一个特定的临时文件（即：.well-known/acme-challenge/&lt;random_token&gt; ），然后 Let’s Encrypt CA（ACME 服务器）通过 HTTP 协议请求访问此文件（访问地址：http://example.com/.well-known/acme-challenge/&lt;random_token&gt;），访问到该文件则说明用户对域名具有控制权，通过用户的控制权情况间接确定用户是否是域名的拥有者。（2）如果验证确定用户是域名的拥有者，则允许为其签发生成 SSL 证书，否则申请失败。（3）验证完成并签发生成证书后，certbot 会自动删除 Web 服务器根目录下的.well-known临时目录文件。¶1）单域名证书准备工作：（1）需要有一个需要申请证书的域名。如：example.com（2）需要有一台拥有公网 IP 的服务器，并且公网服务器里运行有 Web 服务（如：nginx，tomcat等）（3）需要提前在 DNS 服务提供商的管理后台里把需要申请证书的域名解析到服务器的公网 IP 上123456#自动 HTTP 验证方式申请签发单域名证书（模板）（可加 --staging 选项来申请签发测试环境的证书）certbot certonly \--agree-tos --no-eff-email \--webroot -w /opt/nginx/html \-m user@example.com \-d example.com💁‍♂ 说明：--webroot：指定 certbot 创建临时文件所在的 Web 服务器根目录路径。除了通过指定--webroot选项使用自动 HTTP 验证方式外，还可以仅使用 --preferred-challenges http-01 (或都不指定，因为 http-01 是默认值)，但这种方式需要手动创建.well-known/acme-challenge/&lt;random_token&gt; 临时文件，并根据提示给文件写入内容，明显会比较麻烦，故不推荐。¶2）多域名证书（推荐）准备工作：（1）需要有多个需要申请证书的域名。如下：example.comwww.example.com（2）需要有一台拥有公网 IP 的服务器，并且公网服务器里运行有 Web 服务（如：nginx，tomcat等）。（3）需要提前在 DNS 服务提供商的管理后台里把所有需要申请证书的域名解析到到服务器的公网 IP上。多域名证书可以通过类似 -d example.com -d www.example.com 的指定方式申请签发。1234567#自动 HTTP 验证方式申请签发多域名证书（模板）（可加 --staging 选项来申请签发测试环境的证书）certbot certonly \--agree-tos --no-eff-email \--webroot -w /opt/nginx/html \-m user@example.com \-d example.com \-d www.example.com说明：多域名证书如果不指定名称，将会以第一个域名作为证书名称。Let’s Encrypt CA（ACME 服务器）会根据指定的多个域名依次发起 HTTP 请求访问 Web 服务器根目录下的临时文件以确定申请用户对每个域名的所有权。注意：多域名证书是一个 SSL 证书，该证书可以包含多个域名的信息，故一个证书可以同时用于多个域名的 SSL 验证。¶3）通配符域名证书（不支持）使用自动 HTTP 验证方式不支持通配符域名证书申请，Let’s Encrypt 只允许使用 DNS-01 验证模式来获取通配符域名证书。💁‍♂ 关于“使用自动 HTTP 验证方式不支持申请通配符域名证书”的说明：申请通配符域名（如：*.example.com）证书时，Let’s Encrypt CA（ACME 服务器）需要验证用户是否为通配符域名的父级域名（如：example.com）的拥有者，只有确定用户为域名拥有者才能签发证书。使用自动 HTTP 验证方式验证用户是否为域名的拥有者时，ACME 客户端会在 Web 服务器上放置一个特定的临时文件，ACME 服务器通过 HTTP 协议请求访问此文件是否存在来证明用户对该域名的控制权，再通过域名控制权验证结果来间接确定用户是否是域名的拥有者，由于其验证是间接的，不能直接确定用户就是域名的拥有者，所以使用自动 HTTP 验证方式不支持申请通配符域名证书。而使用 DNS 验证模式验证用户是否是域名的拥有者是可以直接确定的，因为拥有 DNS 域名解析权限的用户那肯定可以理解为域名的拥有者。所以使用 DNS 验证模式支持申请通配符域名证书。如下测试在自动 HTTP 验证方式下申请通配符域名证书会提示不支持。12345678910111213141516$ certbot certonly \--staging \--agree-tos --no-eff-email \--webroot -w /opt/nginx/html \-m user@example.com \-d example.com \-d *.example.com#如下是申请失败提示内容：Saving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator webroot, Installer NoneStarting new HTTPS connection (1): acme-staging-v02.api.letsencrypt.orgRequesting a certificate for example.com and *.example.comPerforming the following challenges:Client with the currently selected authenticator does not support any combination of challenges that will satisfy the CA. You may need to use an authenticator plugin that can do challenges over DNS.Client with the currently selected authenticator does not support any combination of challenges that will satisfy the CA. You may need to use an authenticator plugin that can do challenges over DNS.¶4）Web 服务器配置注意事项对于自动 HTTP 验证方式进行证书申请的情况下，如果这个域名对应 80 端口做了重定向、反向代理等配置导致 Let’s Encrypt CA（ACME 服务器）无法获取.well-known/acme-challenge目录下的临时文件，那么会导致自动续期失败。所以需要注意对于 /.well-known/acme-challenge/ 这个访问路径（访问地址：http://example.com/.well-known/acme-challenge/&lt;random_token&gt;）需要确保一定能够访问到临时文件，在域名的 80 端口配置里添加如下配置（以 Nginx 为例）：1234# certbot 自动 HTTP 验证方式申请证书，临时文件访问验证配置location /.well-known/acme-challenge &#123; root /opt/nginx/html; # 该路径应该为certbot certonly命令申请证书时 --webroot -w 指定的路径参数。&#125;示例：12345678910111213server &#123; listen 80 default_server; listen [::]:80 default_server; # certbot 自动 HTTP 验证方式申请证书，临时文件访问验证配置 location /.well-known/acme-challenge &#123; root /opt/nginx/html; # 该路径应该为certbot certonly命令申请证书时 --webroot -w 指定的路径参数。 &#125; location / &#123; return 301 https://$host$request_uri; &#125;&#125;提示：只有在自动 HTTP 验证方式申请域名证书才需要该配置。一般安装了 SSL 以后很多用户选择将 http 跳转到 https，可以通过配置default_server，表示作为默认服务器配置，即当 Nginx 接收到请求时，如果请求的域名与服务器块的监听地址（listen）中的域名都不匹配时，Nginx 将会选择配置了 default_server 的服务器块作为默认的服务器块进行处理。比如进行重定向到 https 地址处理，这样做就可以让一处配置就能同时支持多个域名访问 http 请求时都自动跳转到 https。¶方式2：手动 DNS 验证方式申请证书简要概述：（1）certbot（ACME 客户端）会生成一串随机字符串，并要求用户将这个字符串作为域名的 TXT 记录值设置到DNS域名托管平台的对应域名解析设置里。等用户设置完成后，certbot 将会请求域名地址，通过判断是否能获取有效且与生成字符串相等的记录值来确定用户是否是域名的拥有者。这个过程中添加 TXT 记录情况如下：记录类型：TXT主机记录：_acme-challenge.example.com记录值： certbot 工具生成的随机字符串（如：vrZwcxxxxxx5k42XUr025UWRNl4）（2）如果验证确定用户是域名的拥有者，则允许为其签发生成 SSL 证书，否则申请失败。说明：手动 DNS 域名验证即需要通过在 DNS 服务器手动添加 TXT 记录来使让 certbot 确定用户对域名的持有权。¶1）单域名证书准备工作：（1）需要有一台能访问互联网的主机（可为内网主机）。（2）需要有一个需要申请证书的域名。如：example.com（3）需要在 DNS 服务提供商的管理后台里添加域名的 TXT 记录。如下：_acme-challenge.example.com - &gt; vrZwcxxxxxx5k42XUr025UWRNl4提示：TXT 记录值由下方执行certbot命令获得。123456#DNS 验证模式申请签发单域名证书（模板）（可加 --staging 选项来申请签发测试环境的证书）certbot certonly \--manual --preferred-challenges dns-01 \--agree-tos --no-eff-email \-m user@example.com \-d example.com当申请完成后即在 DNS 服务提供商的管理后台删除掉这个临时的 TXT 记录。¶2）多域名证书准备工作：（1）需要有一台能访问互联网的主机（可为内网主机）。（2）需要准备多个需要申请证书的域名。如下：example.comwww.example.com（3）需要在 DNS 服务提供商的管理后台里为每个域名添加 TXT 记录。如下：_acme-challenge.example.com - &gt; vrZwcxxxxxx5k42XUr025UWRNl4_acme-challenge.www.example.com - &gt; fr5wcxxxxxx7ko2PUr025UWRGo5提示：TXT 记录值由下方执行certbot命令获得。1234567#DNS 验证模式申请签发多域名证书（模板）（可加 --staging 选项来申请签发测试环境的证书）certbot certonly \--manual --preferred-challenges dns-01 \--agree-tos --no-eff-email \-m user@example.com \-d example.com \-d www.example.com多域名证书可以通过类似 -d example.com -d www.example.com 的指定方式申请签发。多域名证书申请过程中，需要给每个域名添加 TXT 记录，Let’s Encrypt CA（ACME 服务器）会依次校验每个域名的 TXT 记录以确定每个域名的所有权。¶3）通配符域名证书准备工作：（1）需要有一台能访问互联网的主机（可为内网主机）。（2）需要有一个需要申请证书的域名。如：example.com（3）需要在 DNS 服务提供商的管理后台里添加域名的 TXT 记录。如下：_acme-challenge.example.com - &gt; vrZwcxxxxxx5k42XUr025UWRNl4提示：TXT 记录值由下方执行certbot命令获得。1234567#DNS 验证模式申请签发通配符证书（模板）（可加 --staging 选项来申请签发测试环境的证书）certbot certonly \--manual --preferred-challenges dns-01 \--agree-tos --no-eff-email \-m user@example.com \-d example.com \-d *.example.comDNS-01 验证模式是支持通配符域名证书申请的。通配符域名证书可以通过类似-d *.example.com的指定方式来申请签发。通配符域名证书申请过程中，对于通配符域名，只需要给除去通配符后剩下的域名添加一条 TXT 记录即可完成验证。这种验证方式不需要为通配符中的每个子域名添加记录，这也是 DNS-01 验证模式比 HTTP-01 更加灵活和安全的重要原因。通常做三级通配符域名证书时，为了支持其父级域名，申请证书时都会加上其父级域名（即二级域名），如：-d example.com。*.example.com表示的通配符域名证书表示只支持三级域名证书（如：www.example.com、blog.example.com、mail.example.com 等），但这个通配符不支持其父级域名（如：example.com），也不支持四级域名（如：dev.www.example.com）¶四、列出拥有的证书信息12345#列出拥有的证书及其有效期等信息certbot certificates#查看证书有效期openssl x509 -noout -dates -in cert.pem¶五、配置使用证书certbot 申请签发的证书默认存储在 /etc/letsencrypt/live/example.com 和 /etc/letsencrypt/archive/example.com 目录下。/etc/letsencrypt/live/example.com 目录：包含当前使用的 SSL/TLS 证书的符号链接，指向 /etc/letsencrypt/archive 目录中相应的证书文件。/etc/letsencrypt/archive/example.com 目录：包含按域名和时间戳命名的 SSL/TLS 证书文件。使用 certbot 申请签发证书时，会得到以下几个文件：服务端证书 (cert.pem)：该文件主要包含有域名和公钥，由证书颁发机构（CA）签发，用于客户端验证服务器上域名的身份。中间证书 (chain.pem)：该文件包含 CA 的证书链，其中可能包含一个或多个中间证书和根证书。中间证书由 CA 签发，用于将 CA 根证书和服务端证书连接起来，以能够使客户端验证服务端证书的真实性。全链证书 (fullchain.pem)：也称证书链文件，该文件包含了服务端证书以及所有中间证书和根证书，包含了完整的 SSL 证书链。用于客户端验证服务端证书的真实性。私钥文件 (privkey.pem)：该文件包含私钥内容。用于解密请求的数据以及加密响应的数据。证书的定义：证书是一种用于验证身份和加密通信的电子文件。通常包含了身份信息、公钥、有效期限、颁发机构信息等内容。（注意：一般证书都是不包含私钥内容的）常见的 Web 服务器软件有 nginx、apache、tomcat等。在这些 Web 服务器软件中配置 SSL 证书的方式不经相同，但它们都是支持使用 Let’s Encrypt SSL 证书的。nginx 配置 SSL 证书可参考《nginx学习笔记》apache配置 SSL 证书可参考《apache配置ssl证书》¶六、吊销证书吊销证书是一种在证书到期之前废止其有效性的方法。如果您认为您的 SSL/TLS 证书已经被盗用或不再需要使用，则应该立即将其吊销。通过吊销证书，您可以确保不会有人再使用该证书来进行恶意活动。12345678#吊销指定域名的证书certbot revoke --cert-name example.com#吊销指定文件路径的证书（此命令将吊销存储在 /etc/letsencrypt/live/example.com/cert.pem 中的证书）certbot revoke --cert-path /etc/letsencrypt/live/example.com/cert.pem#吊销指定域名相关的所有证书（此命令将吊销 /etc/letsencrypt/archive/ 目录中与 example.com 域名相关的所有证书）certbot revoke --cert-path /etc/letsencrypt/archive/ -d example.com提示：使用 Certbot 或其他工具吊销了 Let’s Encrypt 发放的 SSL/TLS 证书，Let’s Encrypt 在证书到期之前仍然会发送到期提醒邮件。吊销证书并不会阻止 Let’s Encrypt 发送到期提醒。（感觉有点坑啊~）¶七、删除证书123456#删除指定域名的证书certbot delete --cert-name example.com#或者：（certbot delete操作同下）rm -rf /etc/letsencrypt/live/example.comrm -rf /etc/letsencrypt/archive/example.com💁‍♂ 如果仅仅删除证书，但原本证书没有注销或过期，那么再次申请签发生成新的证书时，默认生成的新证书与旧证书的一些基本信息（如私钥、公钥和有效期等）会保持相同，仅到期日期和其他元数据（例如序列号、版本号和指纹）不同。¶八、证书续期申请¶1. 简要概述Let’s Encrypt 证书的有效期是 90 天，证书到期前 20 天、10 天和 1 天时将会接收到到期通知邮件，提醒用户进行证书续期申请操作。用户可以通过 certbot renew 命令来给即将过期的证书续期，续期会生成新的证书并自动替换掉原来的证书。💁‍♂ 说明：certbot renew 命令会默认根据申请各证书时的参数对所有证书进行续期。申请各证书时的参数会被用作续订参数记录在 /etc/letsencrypt/renewal/example.com.conf 配置文件里（该文件是用户在申请证书完成后根据申请的参数自动生成的）。用户可以修改续期配置文件以调整默认的续订策略（如：修改验证插件、修改手动验证的 hook 脚本等）。如果不修改续期配置文件，也可以在执行 certbot renew 命令时指定参数来自定义续订策略。如果证书已经过期或者被吊销，则 certbot 将无法对其进行续期，对于这种情况只能重新申请签发新的证书。证书到期前 30 天内才可以续订，多于30天则不允许续订。通过 certbot renew 命令来续订，默认生成的新证书与旧证书的一些基本信息（如私钥、公钥和有效期等）会保持相同，仅到期日期和其他元数据（例如序列号、版本号和指纹）不同。如果希望通过旧的证书信息强制重新申请签发新的证书并替换则需要加选项 --force-renewal。如果续期的是测试环境的证书则需要加选项：--break-my-certs 。¶2. 自动 HTTP 验证方式续期证书¶1）手动续期123456#证书续期（使用续期配置文件的参数作为续订策略） #可以指定 -v（--verbose）选项查看更详细的日志信息certbot renew#重新加载nginx配置nginx -s reload💁‍♂ 注意：自动 HTTP 验证方式下只支持单域名证书和多域名证书的续期，不支持通配符域名证书。¶2）自动续期可以通过Linux的定时任务来完成自动续期的需求，操作如下：12345678910#创建日志保存目录mkdir -p /opt/certbot/logs#设置系统的定时任务crontab -e#在最后添加如下定时规则（在每个月的第一天凌晨3点0分0秒时执行定时任务）0 3 1 * * certbot renew --deploy-hook "nginx -s reload" &gt;&gt; /opt/certbot/logs/renew.log#列出系统的定时任务crontab -l定时任务规则中 certbot renew 的 --deploy-hook 选项用于指定证书续期更新完成后自动触发执行某自定义脚本或命令，这里填写的是命令是重新加载 nginx 配置以使得新的 SSL 证书生效。¶3. 自动 DNS 域名验证续期证书参考下文：自动 DNS 验证方式申请和续期证书¶九. 自动 DNS 验证方式申请和续期证书实现原理：通过使用 DNS 插件或者自定义 hook 脚本来调用 DNS 服务器的 API 更新 DNS TXT 记录以实现自动 DNS 验证方式申请和续期证书。¶1. 简要概述对于手动dns验证方式申请证书的情况，通过 certbot renew 命令进行证书续期时默认是会失败的。原因是 certbot 默认无法自动更新 DNS 服务器的 TXT 记录，从而无法通过 DNS 验证。如果需要在这种模式下通过 DNS 验证，则需要安装 DNS 插件或者自定义 hook 脚本并且配置 DNS 服务器访问令牌等来调用 DNS 服务器的 API 来自动更新 DNS 的 TXT 记录，另外使用 DNS 插件或者自定义 hook 脚本后，申请申请证书也不需要再手动添加 DNS TXT 记录了，维护上会更加便利。💁‍♂ 对于 DNS 验证模式申请的域名证书，执行certbot renew命令续期，不指定 DNS 插件或者 hook 脚本选项时会提示如下报错信息：Failed to renew certificate example.com with error: The manual plugin is not working; there may be problems with your existing configuration. The error was: PluginError('An authentication script must be provided with --manual-auth-hook when using the manual plugin non-interactively.注意：不论是单域名证书、多域名证书、还是通配符证书，都是需要指定自动更新 DNS 记录的方式，否则无法成功续期。💁‍♂ 关于域名注册商和 DNS 服务提供商的说明：通常情况下，域名注册商和 DNS 服务提供商可以是同一个公司，也可以是不同的公司。一些常见的域名注册商和 DNS 服务提供商包括：AliDNS（阿里云 DNS，万网 DNS）DNSPod（腾讯云 DNS）CloudflareGoDaddyNameSiloNamecheap其他¶2. DNS 插件自动更新 DNS 记录方式¶1）安装并配置 DNS 插件默认支持的 DNS 插件：certbot-dns-cloudflarecertbot-dns-digitaloceancertbot-dns-dnsimplecertbot-dns-dnsmadeeasycertbot-dns-gehirncertbot-dns-googlecertbot-dns-linodecertbot-dns-luadnscertbot-dns-nsonecertbot-dns-ovhcertbot-dns-rfc2136certbot-dns-route53certbot-dns-sakuracloud非默认支持的 DNS 插件：certbot-dns-aliyun（TODO：测试未成功，待研究）certbot-dns-dnspod具体使用可参考：官方文档 DNS-Plugins💁‍♂ 说明：这些插件不包含在默认的 Certbot 安装中，必须单独安装。certbot 默认只支持常见的 DNS 服务提供商相关 DNS 插件进行自动验证，但如果用户的 DNS 服务器不在支持列表中，则需要编写插件（可在 Github 上查找）或者使用自定义 hook 脚本来进行手动验证（更新 DNS TXT 记录）。¶（1）安装 Certbot DNS 插件说明：以 Cloudflare 的 DNS 插件为例¶（1.1）通过系统包管理器安装 Certbot DNS 插件1234567#yum 安装 Certbot DNS 插件yum install -y epel-releaseyum install -y python2-certbot-dns-cloudflare#apt 安装 Certbot DNS 插件apt updateapt install -y python3-certbot-dns-cloudflare¶（1.2）通过 snap 包管理器安装 Certbot DNS 插件123456#通过 snap 安装 DNS 插件snap set certbot trust-plugin-with-root=oksnap install certbot-dns-cloudflare#snap connect certbot:plugin certbot-dns-cloudflare#查看插件是否成功安装到certbot（看有没有多出dns-aliyun的一条记录）certbot plugins¶（1.3）通过 pip 包管理器安装 Certbot DNS 插件1pip install certbot-dns-cloudflare¶（2）配置 Certbot DNS 插件12345678#配置DNS服务提供商认证凭证mkdir -p /opt/certbot/dns-pluginscat &gt; /opt/certbot/dns-plugins/cloudflare-credentials.ini &lt;&lt; 'EOF'dns_cloudflare_api_token = 0123xxxxxx4567EOF#设置配置文件权限chmod 600 /opt/certbot/dns-plugins/cloudflare-credentials.ini创建并获得 Cloudflare 的 API 令牌的访问链接：https://dash.cloudflare.com/profile/api-tokens¶2）申请证书123456certbot certonly \--dns-cloudflare \--dns-cloudflare-credentials /opt/certbot/dns-plugins/cloudflare-credentials.ini \-m user@example.com \-d example.com \-d *.example.com¶3）手动续期1234567891011#证书续期（使用续期配置文件的参数作为续订策略） #可以指定 -v（--verbose）选项查看更详细的日志信息certbot renew#证书续期（指定参数以自定义续订策略，可选）certbot renew \--dns-cloudflare \--dns-cloudflare-credentials /opt/certbot/dns-plugins/cloudflare-credentials.ini#重新加载nginx配置nginx -s reload¶4）自动续期可以配置 Linux 的定时任务来完成自动续期的需求，操作如下：12345678910#创建日志保存目录mkdir -p /opt/certbot/logs#设置系统的定时任务crontab -e#在最后添加如下定时规则（在每个月的第一天凌晨3点0分0秒时执行定时任务）0 3 1 * * certbot renew --deploy-hook "nginx -s reload" &gt;&gt; /opt/certbot/logs/renew.log#列出系统的定时任务crontab -l¶3. 自定义 hook 脚本手动更新 DNS 记录方式certbot 申请证书或者续期可通过指定 hook 选项来执行一些命令或者脚本从而实现更新 DNS 记录等，涉及的 hook 选项包括：--manual-auth-hook 和 --manual-cleanup-hook。hook 选项说明：--manual-auth-hook 在 certbot 进行 TXT 验证前执行，验证完成后还可以通过指定--manual-cleanup-hook来删除已经验证完的 TXT 临时记录。通过 hook 脚本更新 DNS TXT 记录一般是调用对应域名托管服务商的 API 来实现。对于不同的域名托管服务商 API 的具体调用方式也不一样。下面主要以更新阿里云 DNS 的域名解析记录为例：¶1）编写 hook 脚本¶脚本1（支持多家 DNS 服务提供商，推荐）12345678910111213141516171819202122232425262728293031323334##（1）下载并安装脚本（该脚本同时支持阿里云、腾讯云、华为云、GoDaddy 的 DNS 解析记录更新）mkdir -p /opt/certbot/dns-hooksgit clone https://github.com/yangrongzhou/certbot-letencrypt-wildcardcertificates-alydns-au /opt/certbot/dns-hooks/auchmod 0777 /opt/certbot/dns-hooks/au/au.sh##（2）配置根域名#查看是否有对应的根域名（如要测试的域名为：example.site，则根域名为：site）cat /opt/certbot/dns-hooks/au/domain.ini | grep "site"#如果以上cat命令没有查到，则可以通过如下命令进行添加（如果已经有则不需要添加）echo "site" &gt;&gt; /opt/certbot/dns-hooks/au/domain.ini##（3）配置阿里云DNS的 API key 和 Secrec vim /opt/certbot/dns-hooks/au/au.sh #通过vim命令编辑脚本文件，然后修改对应域名托管服务商的KEY和TOKEN变量值，（如阿里云为：ALY_KEY 和 ALY_TOKEN，而腾讯云为：TXY_KEY 和 TXY_TOKEN）#创建certbot手动添加dns txt记录的hook脚本cat &gt; /opt/certbot/dns-hooks/manual-auth-hook.sh &lt;&lt; 'EOF'#阿里云/opt/certbot/dns-hooks/au/au.sh python aly add#腾讯云#/opt/certbot/dns-hooks/au/au.sh python txy addEOF#创建certbot手动删除dns txt记录的hook脚本cat &gt; /opt/certbot/dns-hooks/manual-cleanup-hook.sh &lt;&lt; 'EOF'#阿里云/opt/certbot/dns-hooks/au/au.sh python aly clean#腾讯云#/opt/certbot/dns-hooks/au/au.sh python txy cleanEOF#给脚本赋予执行权限chmod +x /opt/certbot/dns-hooks/manual-auth-hook.shchmod +x /opt/certbot/dns-hooks/manual-cleanup-hook.shALY_KEY 和 ALY_TOKEN：阿里云 API key 和 Secrec 官方申请文档。TXY_KEY 和 TXY_TOKEN：腾讯云 API 密钥官方申请文档。HWY_KEY 和 HWY_TOKEN: 华为云 API 密钥官方申请文档GODADDY_KEY 和 GODADDY_TOKEN：GoDaddy API 密钥官方申请文档。原项目脚本说明参考：https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au腾讯云解析升级至 API 3.0，脚本更新参考：https://github.com/yangrongzhou/certbot-letencrypt-wildcardcertificates-alydns-au¶脚本2（仅支持阿里云 DNS）实现方式：编写 shell 脚本调用阿里云 CLI 工具来更新的阿里云域名云解析（1）需要先安装并配置阿里云 CLI 工具1234567891011121314151617181920212223242526#安装阿里云 CLI 工具#pip install aliyuncliwget https://aliyuncli.alicdn.com/aliyun-cli-linux-3.0.16-amd64.tgztar xzvf aliyun-cli-linux-3.0.16-amd64.tgzmv aliyun /usr/local/binchown root:root /usr/local/bin/aliyun#配置（配置调用阿里云资源所需的凭证信息、地域、语言等），配置保存在~/.aliyun/config.json文件里aliyun configure set \--profile akProfile \--mode AK \--region cn-hangzhou \--access-key-id LTAxxxxxxxx9x7a \--access-key-secret oNYXxxxxxxxxvFcz8F #查看配置aliyun configure get#测试 CLI 工具是否能成功更新记录#aliyun alidns AddDomainRecord --DomainName example.com --Type Txt --RR _txt-test --Line default --Value txt000 --TTL 600#卸载（如果需要）rm -rf /usr/local/bin/aliyunrm -rf ~/.aliyun阿里云 CLI 工具使用说明可参考：阿里云CLI、CLI 工具 DNS 解析、CLI工具项目阿里云 API key 和 Secrec 可在阿里云管理后台 AccessKey 管理 页面创建获取。阿里云 API key 和 Secrec 官方申请文档（2）创建 shell 脚本文件12mkdir -p /opt/certbot/dns-hooksvim /opt/certbot/dns-hooks/alidns.sh内容如下：1234567891011121314151617181920212223242526272829303132333435#!/bin/bashif ! command -v aliyun &gt;/dev/null; then echo "错误: 你需要先安装 aliyun 命令行工具 https://help.aliyun.com/document_detail/121541.html。" 1&gt;&amp;2 exit 1fiDOMAIN=$(expr match "$CERTBOT_DOMAIN" '.*\.\(.*\..*\)')SUB_DOMAIN=$(expr match "$CERTBOT_DOMAIN" '\(.*\)\..*\..*')if [ -z $DOMAIN ]; then DOMAIN=$CERTBOT_DOMAINfiif [ ! -z $SUB_DOMAIN ]; then SUB_DOMAIN=.$SUB_DOMAINfiif [ $# -eq 0 ]; then aliyun alidns AddDomainRecord \ --DomainName $DOMAIN \ --RR "_acme-challenge"$SUB_DOMAIN \ --Type "TXT" \ --Value $CERTBOT_VALIDATION /bin/sleep 20else RecordId=$(aliyun alidns DescribeDomainRecords \ --DomainName $DOMAIN \ --RRKeyWord "_acme-challenge"$SUB_DOMAIN \ --Type "TXT" \ --ValueKeyWord $CERTBOT_VALIDATION \ | grep "RecordId" \ | grep -Eo "[0-9]+") aliyun alidns DeleteDomainRecord \ --RecordId $RecordIdfi脚本来源：https://github.com/justjavac/certbot-dns-aliyun12345678910111213#创建certbot手动添加dns txt记录的hook脚本cat &gt; /opt/certbot/dns-hooks/manual-auth-hook.sh &lt;&lt; 'EOF'/opt/certbot/dns-hooks/alidns.shEOF#创建certbot手动删除dns txt记录的hook脚本cat &gt; /opt/certbot/dns-hooks/manual-cleanup-hook.sh &lt;&lt; 'EOF'/opt/certbot/dns-hooks/alidns.sh cleanEOF#给脚本赋予执行权限chmod +x /opt/certbot/dns-hooks/alidns.shchmod +x /opt/certbot/dns-hooks/manual-auth-hook.shchmod +x /opt/certbot/dns-hooks/manual-cleanup-hook.sh¶2）申请证书12345678certbot certonly \--manual --preferred-challenges dns-01 \--agree-tos --no-eff-email \--manual-auth-hook "/opt/certbot/dns-hooks/manual-auth-hook.sh" \--manual-cleanup-hook "/opt/certbot/dns-hooks/manual-cleanup-hook.sh" \-m user@example.com \-d example.site \-d *.example.site¶3）手动续期123456789101112#证书续期（使用续期配置文件的参数作为续订策略） #可以指定 -v（--verbose）选项查看更详细的日志信息certbot renew#证书续期（指定参数以自定义续订策略，可选）certbot renew \--manual --preferred-challenges dns-01 \--manual-auth-hook "/opt/certbot/dns-hooks/manual-auth-hook.sh" \--manual-cleanup-hook "/opt/certbot/dns-hooks/manual-cleanup-hook.sh"#重新加载nginx配置nginx -s reload¶4）自动续期可以配置 Linux 的定时任务来完成自动续期的需求，操作如下：12345678910#创建日志保存目录mkdir -p /opt/certbot/logs#设置系统的定时任务crontab -e#在最后添加如下定时规则（在每个月的第一天凌晨3点0分0秒时执行定时任务）0 3 1 * * certbot renew --deploy-hook "nginx -s reload" &gt;&gt; /opt/certbot/logs/renew.log#列出系统的定时任务crontab -l]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows包管理工具scoop]]></title>
    <url>%2Fwindows%2Fscoop.html</url>
    <content type="text"><![CDATA[在平常生活中如果要安装像git、java、node这些环境的时都需要先去官网下载安装程序，点击安装，之后还需要配置，不仅过程麻烦，而且工具多了之后整理起来也相当不容易，配置也很杂，整个电脑就像被污染了一样。而scoop可以很好地解决这一问题，安装scoop后，只需要在命令行输入简单的一串命令即可安装你想要的软件。Scoop 是一款适用于 Windows 平台的命令行软件（包）管理工具，可以通过命令行工具（PowerShell、CMD等）实现软件（包）的安装管理等需求，通过简单的一行代码实现软件的下载、安装、卸载、更新等操作。Scoop 没有提供任何注册发布应用的仓库，Scoop 的“Bucket仓库”提供了应用的下载地址、安装、卸载方式以及依赖等信息。官方网址：https://scoop.sh¶安装 scoop¶配置环境变量以管理员身份打开 PowerShell 终端：123456# 设置系统用户环境变量，配置所有用户软件（包括scoop软件）安装路径（不设置则默认安装到C:\Users\&#123;username&#125;\scoop）$env:SCOOP='D:\Programs\Scoop\LocalApps'[Environment]::SetEnvironmentVariable('SCOOP',$env:SCOOP,'User')# 设置系统全局环境变量，配置所有全局软件安装路径（不设置则默认安装到C:\ProgramData\scoop）$env:SCOOP_GLOBAL='D:\Programs\Scoop\GlobalApps'[Environment]::SetEnvironmentVariable('SCOOP_GLOBAL', $env:SCOOP_GLOBAL, 'Machine')¶安装关闭以上终端，以非管理员身份重新打开一个新的 PowerShell 终端。注意是非管理员身份，否则会提示默认不能以管理员身份运行脚本安装。123456# 设置当前用户的执行策略：为了计算机安全，设置只允许在本地计算机上运行本地脚本，但不允许从远程计算机运行未签名的脚本Set-ExecutionPolicy RemoteSigned -scope CurrentUser# 安装scoop命令iex (new-object net.webclient).downloadstring('https://get.scoop.sh')# 安装完成后，输入下面命令验证是否成功（常见的命令可以通过此方法来查看）scoop help💁‍♂ 访问 github 不畅时以上安装可能会失败。解决办法就是自行想办法开代理或者配置 hosts 以确保能够顺利访问 github ，然后重新执行安装命令即可。开代理的方式是最推荐的，但由于不可描述的原因就不多介绍了，这里主要介绍下配置hosts的方式：（1）然后访问 https://raw.hellogithub.com/hosts 获取最新访问 github 相关的 hosts 配置（2）通过记事本打开系统的 hosts 文件，复制获取到的配置内容追加 hosts 文件里。1notepad "C:\Windows\System32\drivers\etc\hosts"（3）大部分情况下是直接生效，如未生效可尝试下面的办法，可通过如下命令刷新 DNS：1ipconfig /flushdns获取 hosts 配置的方式可能会失效，可以关注这个链接来源的github项目：https://github.com/521xueweihan/GitHub520¶卸载 scoop12#卸载scoop（注意这会除了卸载scoop本身外，还会卸载所有通过scoop安装的软件）scoop uninstall scoop¶常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#帮助scoop help#搜索包含指定关键字的所有可用应用程序。scoop search [keyword]#查看应用程序的描述信息scoop info [app]#安装指定的应用程序，例如scoop install gitscoop install [app]#安装指定版本的应用程序，例如scoop install nodejs@14.17.6scoop install [app]@[version]#安装指定仓库下应用程序scoop install [bucket]/[app]#使用该命令卸载指定的应用程序，例如scoop uninstall gitscoop uninstall [app]#卸载指定版本的应用程序，例如scoop uninstall nodejs@14.17.6scoop uninstall [app]@[version]#切换当前app到另一个版本，例如：设当前版本是python3，需要切换到python2.7，只需要执行：scoop reset python27scoop reset [other-app]#更新所有已安装的应用程序，但不包括scoopscoop update#更新所有已安装的应用程序和scoopscoop update *#查看指定app已经安装的版本scoop list [app]#列出当前已安装的所有应用程序。scoop list#显示已安装的应用程序的状态信息（否需要更新或是已经损坏）。输出为“Everything is ok!”，则表示所有已安装的应用程序都是最新版本，且没有任何损坏或不完整的文件scoop status#显示指定已安装应用程序的信息scoop status [app]#查看官方推荐存储库scoop bucket known#列出所有已添加的存储库scoop bucket list#添加新的Scoop存储库，例如scoop bucket add extrasscoop bucket add [bucket]#添加新的Scoop存储库，并指定存储库的地址（如果没有指定bucket的地址，则默认为github的地址），例如：scoop bucket add extras https://github.com/ScoopInstaller/Extras.gitscoop bucket add [bucket-name] [bucket-url]#删除指定的Scoop存储库，例如scoop bucket rm extras。scoop bucket rm [bucket]#删除指定软件在缓存目录中的安装包scoop cache rm [app]#删除Scoop缓存目录中的所有安装包scoop cache rm *#删除Scoop缓存目录中所有旧版本（不再需要）的安装包scoop cache clear#删除Scoop安装的应用程序中旧版本（不再需要）的文件和资源scoop cleanup [app]#检查正在运行的Scoop系统和已安装的应用程序的健康状况。（列出不再使用的Scoop桶、检测应用程序需要更新或是已经损坏、检测应用程序是否缺少某些必需的文件、检查应用程序是否有任何依赖项缺失、检查Scoop是否需要更新，以及是否存在其他潜在问题）scoop checkup#将当前的应用程序列表导出到JSON格式的文件中。scoop export##设置scoop全局代理（包括git操作和软件下载的代理）scoop config proxy 127.0.0.1:7890#取消scoop全局代理scoop config rm proxy#查看scoop配置scoop config#设置系统代理set http_proxy=socks5://127.0.0.1:7890set https_proxy=socks5://127.0.0.1:7890#取消系统代理unset http_proxyunset https_proxy##设置git代理（包括git操作的代理）git config --global http.proxy 'socks5://127.0.0.1:7890' git config --global https.proxy 'socks5://127.0.0.1:7890'#查看全局git配置git config -l --global#取消git代理git config --global --unset http.proxygit config --global --unset https.proxy这些是一些常用的Scoop命令，但还有很多其他命令和选项可以使用。可以使用--help选项查看每个命令的帮助文档，例如scoop install --help。¶配置存储库Scoop 中的 bucket 是指一组Scoop应用程序的存储库。其提供了应用的下载地址、安装、卸载方式以及依赖等信息。可以通过添加 bucket 来安装更多的软件， bucket通常都是存储在Git仓库里（比如：github）。scoop 安装好后默认的存储库就只有main这一个bucket，可以加入一些其他的存储库来满足获取更多软件的需求。相关命令：12345678910#查看官方推荐存储库scoop bucket known#列出所有已添加的存储库scoop bucket list#添加新的Scoop存储库，例如scoop bucket add extrasscoop bucket add [bucket]#添加新的Scoop存储库，并指定存储库的地址（如果没有指定bucket的地址，则默认为github的地址），例如：scoop bucket add extras https://github.com/ScoopInstaller/Extras.gitscoop bucket add [bucket-name] [bucket-url]#删除指定的Scoop存储库，例如scoop bucket rm extras。scoop bucket rm [bucket]添加存储库示例：123456#安装git（添加存储库即下载Git仓库的存储库，下载功能依赖git）scoop install git#添加存储库scoop bucket add extrasscoop bucket add versions常见的bucket有如下：main：Scoop默认的官方存储库，包含常见的应用程序和工具。extras：官方的补充存储库，包含非标准的应用程序和工具。versions：官方存储库的历史版本存档。nirsoft：由NirSoft提供的存储库，包含一系列小型Windows实用工具。sysinternals：由Microsoft Sysinternals提供的存储库，包含Windows管理和诊断工具。php：由PHP社区提供的存储库，包含PHP编程语言及其扩展。nerd-fonts：由社区维护的存储库，包含专为程序员设计的字体。nonportable：由社区维护的存储库，包含不需要安装即可使用的绿色软件包。java：由Java社区提供的存储库，包含Java开发相关的应用程序和工具。games：由社区维护的存储库，包含多个游戏相关的应用程序和工具。更多 Buckets 参见：buckets¶配置国内存储库只要国内的git仓库gitcode上有scoop的官方 bucket 镜像存储库，能够用于替换 github 上的 bucket ，这样就不用担心 github 访问的网络问题了。123456789101112131415161718#替换main存储库scoop bucket rm mainscoop bucket add main https://gitcode.net/mirrors/ScoopInstaller/Main.git#替换extras存储库scoop bucket rm extrasscoop bucket add extras https://gitcode.net/mirrors/ScoopInstaller/Extras.git#替换versions存储库scoop bucket rm versionsscoop bucket add versions https://gitcode.net/mirrors/ScoopInstaller/Versions.git#类似的替换其他s存储库......scoop update¶安装常用软件1234567scoop install sudoscoop install git 7zip opensshscoop install aria2scoop install ffmpegscoop install nodejsscoop install pythonscoop install python@3.6.8¶多线程加速下载1234# 安装aria2，加速下载scoop install aria2# 配置是否使用aria2下载，false为禁用，true为启用scoop config aria2-enabled true可对 scoop 使用 aria2 的配置参数（可选）：1234scoop config aria2-retry-wait 4scoop config aria2-split 16scoop config aria2-max-connection-per-server 16scoop config aria2-min-split-size 4M关于以下参数的作用，详见 aria2 的相关资料¶常见问题¶scoop 安装 git 问题scoop 默认安装的 git 默认不会像常规安装那样会在右键菜单里添加 git bash 和 git gui 按钮。如果需要则可以通过修改注册表配置来实现，具体如下：以管理员身份打开 PowerShell 终端：123456789101112131415161718192021222324252627282930313233##右键菜单添加 git bash 和 git gui 按钮，只需在注册表增加相关信息即可$env:GIT_HOME = $env:SCOOP + '\apps\git\current'New-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_shell' ` -Name '' ` -Value 'Git Ba&amp;sh Here' ` -Force New-ItemProperty -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_shell' ` -Name 'Icon' ` -Value "$env:GIT_HOME\mingw64\share\git\git-for-windows.ico" ` -Force # '"ab" "cd"ef' = "ab `"$env:tmp_str`"efg" 通过$env:取变量值只有在双引号里有才有作用，如果双引字符串里还有双引号的话，需要使用 ` 符号来转义。New-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_shell\command' ` -Name '' ` -Value "`"$env:GIT_HOME\git-bash.exe`" `"--cd=%v.`"" ` -ForceNew-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_gui' ` -Name '' ` -Value 'Git &amp;GUI Here' ` -Force New-ItemProperty -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_gui' ` -Name 'Icon' ` -Value "$env:GIT_HOME\mingw64\share\git\git-for-windows.ico" ` -Force New-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_gui\command' ` -Name '' ` -Value "`"$env:GIT_HOME\cmd\git-gui.exe`" `"--working-dir`" `"%v.`"" ` -Force如果卸载 git 后，或者不想要这两个按钮了则需要手动删除注册表的相关信息，操作如下：以管理员身份打开 PowerShell 终端：123##删除右键菜单的 git bash 和 git gui 按钮，只需删除注册表相关信息即可Remove-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_shell' -Recurse -ForceRemove-Item -Path 'HKLM:\SOFTWARE\Classes\Directory\Background\shell\git_gui' -Recurse -Force如果想在注册表里查看右键菜单配置，可如下操作：按 Win + R 组合键，然后输入命令regedit来打开“注册表编辑器”，在“注册表编辑器”的输入栏里填写路径值计算机\HKEY_CLASSES_ROOT\Directory\Background\shell进行查找。可通过按 F5 键刷新“注册表编辑器”内容展示。¶应用缓存数据和注册表问题常规安装的应用程序都会将运行时的数据、缓存、日志、临时文件等存到C盘的 C:\Users\%username%\AppData 目录下。在 scoop 的管理中，scoop 根据 bucket 里软件安装规则进行处理，规则一般会将这些数据存到%Scoop%\LocalApps\persist目录里。但bucket也有一些软件没有这样的规则，这样就会按照程序原本的处理进行。scoop 卸载软件时也是按照bucke里对应软件的卸载配置规则进行处理，如果配置里有删除应用程序运行时产生的数据文件和注册表项的规则，那么就会清理。否则就会按照程序原本的卸载逻辑，有可能清理也有可能不清理，这决定于应用程序本身。所以说 scoop 在不自动删除应用程序运行时产生的数据文件和注册表项时，但又想完全卸载干净包括数据文件和注册表项等在内的数据，就需要手动或者借助 geek、CCleaner 等工具进行处理，当然 scoop 也支持在应用程序的 bucket 中自行添加或者修改卸载脚本来进行相关处理，但这就需要对应用程序内部数据缓存有所了解，也需要有一定的技术能力。¶参考https://www.cnblogs.com/sleepyocean/p/17017084.htmlhttps://dyphire.github.io/undefined/198c7fc6.htmlhttps://zhuanlan.zhihu.com/p/412417957?utm_id=0https://ericzong.github.io/posts/tool-scoop-get-start.html]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows包管理工具winget]]></title>
    <url>%2Fwindows%2Fwinget.html</url>
    <content type="text"><![CDATA[¶概述winget 是微软公司推出的软件包管理工具。该工具支持Windows10系统1809以上版本使用，具备搜索、显示安装包信息、下载、安装、更新、卸载、显示已经安装软件列表等功能。官方文档：https://learn.microsoft.com/zh-cn/windows/package-manager/winget¶安装¶方式1应用商店搜索 “winget” 或 “应用安装程序” 进行安装，安装好后打开 cmd 或者 powershell 终端输入如下命令进行验证：1winget -v¶方式2到 winget 的 github 仓库下载安装包进行安装，这种方式不会从 Microsoft Store 中启用自动更新。下载地址：https://github.com/microsoft/winget-cli/releases¶常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647## 1、搜索应用程序包winget search &lt;keyword&gt;#例如：winget search git## 2、显示包的相关信息（信息包括名称、版本、作者、说明、发布日期等）winget show &lt;app_id&gt;#例如：winget show firefox## 3、安装应用程序包。-v 指定版本号（可选，默认最新版），-l 指定安装路径（可选，默认%ProgramFiles%\WindowsApps）winget install &lt;app_id&gt;winget install &lt;app_id&gt; -v &lt;version&gt; -l &lt;app_path&gt;#例如：winget install firefox## 4、显示已安装应用程序列表winget list## 5、升级已安装的应用程序winget upgrade## 6、卸载应用程序winget uninstall &lt;app_id&gt;#例如：winget uninstall firefox## 7、显示有关特定应用程序包的详细信息winget show &lt;app_id&gt;#例如：winget show firefox## 8、导出已安装的应用程序列表到文件winget export -o &lt;file_path&gt;#例如：winget export -o C:\Users\&lt;user&gt;\Desktop\installed_apps.txt## 9、从导出的文件中导入应用程序列表并安装它们winget import -i &lt;file_path&gt;#例如：winget import -i C:\Users\&lt;user&gt;\Desktop\installed_apps.txt## 10、存储库（源）管理#显示已添加的源列表winget source list#显示源的详细信息，包括名称、源类型、地址、更新时间等，例如：winget source list wingetwinget source list &lt;repo_name&gt; #添加源winget source add -n &lt;repo_name&gt; -a &lt;repo_url&gt;#更新本地源winget source update #更新所有源winget source update -n &lt;repo_name&gt; #更新单个源#删除源winget source remove -n &lt;repo_name&gt;¶winget设置¶编辑设置配置文件1winget settings¶配置默认安装位置通过winget settings命令打开配置文件后进行如下修改12345678&#123; "installBehavior": &#123; //设置用户程序安装目录，默认：%LOCALAPPDATA%/Microsoft/WinGet/Packages/ "portablePackageUserRoot": "D:/Programs/WingetPrograms/LocalApps", //设置全局程序安装目录，默认：%PROGRAMFILES%/WinGet/Packages/ "portablePackageMachineRoot": "D:/Programs/WingetPrograms/GlobalApps" &#125;&#125;portablePackageUserRoot 和 portablePackageMachineRoot 设置仅适用于具有 portable 安装程序类型的包¶设置安装包缓存目录存储路径为：C:\Users\&lt;user&gt;\AppData\Local\Temp\WinGet缓存存储目录路径目前还不支持更改。¶参考使用winget快速安装常用软件]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox组建内网服务器集群]]></title>
    <url>%2Flinux%2Fvm.html</url>
    <content type="text"><![CDATA[¶一、环境准备首先通过VirtualBox安装好一个linux系统虚拟机，比如这台虚拟机为centos7x64-docke。现在希望通过这台虚拟机快速克隆复制出另外几台虚拟机，比如下面三台虚拟机。box-centos7x64-docker-1box-centos7x64-docker-2box-centos7x64-docker-3下面以克隆出box-centos7x64-docker-1为例，另外两台虚拟机的克隆的方式一样。¶二、组网配置然后通过这三台虚拟机配置出一个内网组网环境。下面是大体组网清单：box-centos7x64-docker-1（网络连接方式：桥接网卡+内网网络，桥接网卡：目的是内网中有一台服务器有能力和外网交互，内网网络：目的是和另外两台服务器在同一个局域网中）box-centos7x64-docker-2（网络连接方式：内网网络）box-centos7x64-docker-3（网络连接方式：内网网络）¶1. 桥接网卡+内网网络通过VirtualBox对box-centos7x64-docker-1配置网络连接方式为“桥接网卡+内网网络”。配置内网网络ip12345678910111213141516171819$ vim /etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"IPADDR=192.168.0.11NETMASK=255.255.255.0NM_CONTROLLED="no"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="enp0s3"UUID="66341b0a-99fb-4c89-87e1-e01aef46acf3"DEVICE="enp0s3"ONBOOT="yes"1234#重启网络服务$ service network restart#配置主机名(可选)，需要退出终端，命令行里才会显示出来$ hostnamectl set-hostname box-centos7x64-docker-1由于VirtualBox另外设置了“桥接网卡”的连接方式，所以有“内网网络ip”和“桥接网卡的ip”1234567891011121314151617181920212223242526#查看网卡ip$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 08:00:27:88:16:bf brd ff:ff:ff:ff:ff:ff #内网网络ip是192.168.0.11（如果以上配置配置，这里是没有ip的） inet 192.168.0.11/24 brd 192.168.0.255 scope global noprefixroute enp0s3 valid_lft forever preferred_lft forever inet6 fe80::cfe1:d02:cbcf:e72c/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::990d:e102:fe45:9979/64 scope link noprefixroute valid_lft forever preferred_lft forever3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 08:00:27:75:13:8f brd ff:ff:ff:ff:ff:ff #这里桥接网卡的ip是192.168.1.21 inet 192.168.1.21/24 brd 192.168.1.255 scope global noprefixroute dynamic enp0s8 valid_lft 85995sec preferred_lft 85995sec inet6 2409:8a34:143:3320:c387:4e42:9af0:aba/64 scope global noprefixroute dynamic valid_lft 86243sec preferred_lft 86243sec inet6 fe80::56cc:38:49bb:6c18/64 scope link noprefixroute valid_lft forever preferred_lft forever问题解决：SSH登录太慢(等很久才提示输入密码)的问题？123456#打开UseDNS注释并将值改成no$ vi /etc/ssh/sshd_configUseDNS no#重启sshd$ systemctl restart sshd参考：https://blog.csdn.net/odeng888/article/details/80523827¶2. 内网网络通过VirtualBox对box-centos7x64-docker-2和box-centos7x64-docker-3配置网络连接方式为“内网网络”。box-centos7x64-docker-2配置内网ip12345678910111213141516171819$ vi /etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"IPADDR=192.168.0.12NETMASK=255.255.255.0NM_CONTROLLED="no"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="enp0s3"UUID="66341b0a-99fb-4c89-87e1-e01aef46acf3"DEVICE="enp0s3"ONBOOT="yes"1234#重启网络服务$ service network restart#配置主机名(可选)，需要退出终端，命令行里才会显示出来$ hostnamectl set-hostname box-centos7x64-docker-2box-centos7x64-docker-3配置内网ip12345678910111213141516171819$ vi /etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="static"IPADDR=192.168.0.13NETMASK=255.255.255.0NM_CONTROLLED="no"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="enp0s3"UUID="66341b0a-99fb-4c89-87e1-e01aef46acf3"DEVICE="enp0s3"ONBOOT="yes"1234#重启网络服务$ service network restart#配置主机名(可选)，需要退出终端，命令行里才会显示出来$ hostnamectl set-hostname box-centos7x64-docker-3¶三、最终内网环境box-centos7x64-docker-1（内网ip：192.168.0.11 外网ip：192.168.1.21）这里的外网ip指的是可以和互联网连接的ipbox-centos7x64-docker-2（内网ip：192.168.0.12）box-centos7x64-docker-3 （内网ip：192.168.0.13）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>virtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native学习笔记]]></title>
    <url>%2Fmobile%2Freact-native.html</url>
    <content type="text"><![CDATA[¶一、环境搭建注意 Node 的版本应大于等于 12，Python 的版本必须为 2.x（不支持 3.x），而 JDK 的版本必须是 1.8（目前不支持 1.9 及更高版本，注意 1.8 版本官方也直接称 8 版本）。安装完 Node 后建议设置 npm 镜像（淘宝源）以加速后面的过程（或使用科学上网工具）。¶1.下载JDK选择适应自己的机型；官网地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html配置好java环境变量：JAVA_HOME：D:\Development\Java\jdk1.8.0_152CLASSPATH：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jarPath：%JAVA_HOME%\bin （追加进去即可）¶2.安装Python2下载Python2，下载地址：https://www.python.org/ftp/python/2.7.16/python-2.7.16.amd64.msi傻瓜式安装好后，配置以下环境变量：Path：D:\Development\Python27（追加进去即可）¶3.安装Android Studio下载地址：https://developer.android.google.cn/studio3.1配置sdk3.2配置ANDROID_HOME环境变量ANDROID_HOME：F:\Android\SdkPath的环境变量追加如下内容：1234%ANDROID_HOME%\platform-tools%ANDROID_HOME%\emulator%ANDROID_HOME%\tools%ANDROID_HOME%\tools\bin以上完成后，还要准备安卓真机或者安卓模拟器。参考：https://www.jianshu.com/p/be001734b7fd¶4.安装node建议通过nvm node版本管理工具来安装node，方便切换node版本，可参考：《node版本管理工具nvm》¶5.安装react-native脚手架1$ npm install -g react-native-cli¶6.安装安卓模拟器可自行选择可用的安卓模拟器安装。运行安卓模拟器后执行如下命令，如果能识别出&quot;device&quot;设备即可。123$ adb devicesList of devices attached192.168.108.101:5555 device本人这里安卓的是genymotion模拟器，运行端口是55555。不同的模拟器可能运行端口不一样。以下是不同模拟器对应的运行端口：1、木木： 75552、夜神： 620013、海马：530014、逍遥：215035、天天：65556、雷电、genymotion、谷歌原生：55557.配置gradle（1）如果不进行配置，默认项目会下载gradle以及gradle依赖到C盘里，我们可以修改下载的文件到其他目录里，只需配置如下环境变量：GRADLE_USER_HOME：F:\Download\myrepository（2）如果想配置gradle的版本，那么可以添加如下环境变量。不建议配置，因为react native项目自身就已经限定了gradle版本，在运行项目的时候会自动根据项目的gardle配置文件下载对应版本的gradle到%GRADLE_USER_HOME%\wrapper\dists目录里，如果非要配置可参考下面：GRADLE_HOME：D:\Development\Gradle\gradle-6.2¶二、创建新项目1234$ npx react-native init AwesomeProject$ cd AwesomeProject$ react-native run-android # npx react-native run-android]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记]]></title>
    <url>%2Ffront%2Freact.html</url>
    <content type="text"><![CDATA[¶一、简介React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。¶二、安装12#安装脚手架Create React App$ npm install -g create-react-app如果下载比较慢，建议替换淘宝源：1234#换源$ npm config set registry https://registry.npmmirror.com#配置后通过以下方法验证是否成功$ npm config get registry¶三、创建项目¶1. 脚手架创建react工程12#创建项目$ create-react-app my-app删除掉非必须的文件后，留下如下目录结构的文件：123456789.├── package-lock.json├── package.json├── public│ ├── index.html│ └── manifest.json└── src ├── App.js └── index.js¶2. 编辑相关文件manifest.json123456789&#123; "short_name": "React App", "name": "Create React App Sample", "icons": [], "start_url": ".", "display": "standalone", "theme_color": "#000000", "background_color": "#ffffff"&#125;index.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;index.js1234567import React from "react";import ReactDOM from "react-dom";import App from "./App";//将&lt;App /&gt;渲染到index.html的&lt;div id="root"&gt;&lt;/div&gt;里，其中&lt;App/&gt;就是jsx语法//解读jsx:遇到&lt;&gt;则安装html解析，遇到&#123;&#125;则按照js解析ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));App.js123456789101112131415import React from "react";const msg = "React";/** * 组件App */function App() &#123; return ( &lt;div&gt; &#123;/*注释...... */&#125; Hello &#123;msg&#125; &lt;/div&gt; );&#125;export default App;¶3. 运行项目12$ cd my-app$ npm start¶四、React组件Father.jsx组件文件后缀可以是.js,也可以是.jsx。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from "react";const msg = "React";/** * 函数式组件 */// eslint-disable-next-linefunction AppFunction() &#123; return &lt;div&gt;Hello &#123;msg&#125;&lt;/div&gt;;&#125;/** * 类组件 */// eslint-disable-next-lineclass AppClass extends React.Component &#123; //渲染函数 render() &#123; return &lt;div&gt;Hello &#123;msg&#125;&lt;/div&gt;; &#125;&#125;/** * 复合组件：组件中又有其他的组件，复合组件中既可以有类组件又可以有函数组件 */function ChildcomApp(props) &#123; console.log(props) let age = props.age return ( &lt;div style=&#123;childrencss&#125;&gt; &lt;h3&gt;Childcom组件&lt;/h3&gt; &#123;age&#125; &lt;/div&gt; )&#125;class FatherApp extends React.Component &#123; render() &#123; console.log(this) return ( &lt;div style=&#123;fathercss&#125;&gt; &lt;h3&gt;Father组件&lt;/h3&gt; &lt;h4&gt;hello:&#123;this.props.name&#125;&lt;/h4&gt; &lt;ChildcomApp age=&#123;this.props.age&#125; /&gt; &lt;/div&gt; ) &#125;&#125;/** * css样式 */let childrencss = &#123; width: "50%", backgroundColor: "red"&#125;let fathercss = &#123; width: "50%", backgroundColor: "skyblue"&#125;export default FatherApp;index.js12345import React from "react";import ReactDOM from "react-dom";import FatherApp from "./FatherApp";ReactDOM.render(&lt;FatherApp name="qcmoke" age="18" /&gt;, document.getElementById("root"));¶五、组件状态statestate 是组件的当前状态，可以把组件简单看成一个“状态机”，根据状态 state 呈现不同的 UI 展示。一旦状态（数据）更改，组件就会自动调用 render 重新渲染 UI，这个更改的动作会通过 this.setState 方法来触发。StateApp.jsx123456789101112131415161718192021222324252627282930313233343536import React from "react";export default class StateApp extends React.Component &#123; //组件的构造函数,如果要在构造函数中获取传值，可以在参数列表中加props constructor(props) &#123; super(props); //组件的状态（数据） this.state = &#123; count: 1 &#125;; &#125; clickEvent(e) &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123;/**state是私有属性，只能读取不能直接修改 state(直接去改变状态，组件将不会感知到，更不会因为状态的改变而重新渲染),但可通过组件的setState()方法修改 */&#125; &lt;h2&gt;It is &#123;this.state.count&#125;.&lt;/h2&gt; &#123;/*需要在事件中获取组件的this，需要bind(this) */&#125; &lt;button onClick=&#123;this.clickEvent.bind(this)&#125;&gt;click2&lt;/button&gt; &#123;/*如果不使用bind(this)，可以使用箭头函数解决 */&#125; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;click2&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;index.js12345import React from "react";import ReactDOM from "react-dom";import StateApp from "./StateApp";ReactDOM.render(&lt;StateApp /&gt;, document.getElementById("root"));¶六、生命周期LifeApp.jsx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React from "react";export default class LifeApp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 1 &#125;; &#125; //(1)组件将要挂载时触发的函数 componentWillUnmount() &#123; console.log("componentWillUnmount"); &#125; //(2)组件挂载完成时触发的函数 componentDidMount() &#123; console.log("componentDidMount"); &#125; //(3)是否要更新数据时触发的函数 shouldComponentUpdate() &#123; return true; &#125; //(4)数据在改变之前执行 componentWillUpdate() &#123; console.log("componentWillUpdate"); &#125; //(5)数据在改变之后执行 componentDidUpdate() &#123; console.log("componentDidUpdate"); &#125; //(6)组件将要销毁时触发的函数 componentWillUnmount() &#123; console.log("componentWillUnmount"); &#125; //(7)父组件中改变了props传值时触发的函数 componentWillReceiveProps() &#123; console.log("componentWillReceiveProps"); &#125; render() &#123; return ( &lt;div&gt; &#123;/**state是私有属性，只能读取不能直接修改 state(直接去改变状态，组件将不会感知到，更不会因为状态的改变而重新渲染),但可通过组件的setState()方法修改 */&#125; &lt;h2&gt;It is &#123;this.state.count&#125;.&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;index.js12345import React from "react";import ReactDOM from "react-dom";import LifeApp from "./LifeApp";ReactDOM.render(&lt;LifeApp /&gt;, document.getElementById("root"));¶七、组件传值以下示例包含组件间的父传子和子传父两种情况。FatherApp.jsx123456789101112131415161718192021222324252627282930313233import React from "react";import ChildcomApp from "./ChildcomApp"export default class FatherApp extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; childData: "child", fatherData: "father" &#125;; &#125; /** * 子传父的回调函数 */ callback = (data) =&gt; &#123; this.setState(&#123; fatherData: data &#125;) &#125; render() &#123; return ( &lt;div style=&#123;fathercss&#125;&gt; &lt;h3&gt;&#123;this.state.fatherData&#125;&lt;/h3&gt; &#123;/**使用子组件并传值或者函数给子组件 */&#125; &lt;ChildcomApp childData=&#123;this.state.childData&#125; callback=&#123;this.callback&#125; /&gt; &lt;/div&gt; ) &#125;&#125;let fathercss = &#123; width: "50%", backgroundColor: "skyblue"&#125;ChildcomApp.jsx123456789101112131415161718192021import React from "react";export default class ChildcomApp extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;childrencss&#125;&gt; &#123;/**获取父组件的传值 */&#125; &lt;div&gt;&#123;this.props.childData&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; &#123; //调用父组件的回调函数从而传值给父组件 this.props.callback("hi father") &#125;&#125;&gt;子传父&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;let childrencss = &#123; width: "50%", backgroundColor: "red"&#125;index.js12345import React from "react";import ReactDOM from "react-dom";import FatherApp from "./FatherApp";ReactDOM.render(&lt;FatherApp /&gt;, document.getElementById("root"));¶八、事件处理React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同:React 事件绑定属性的命名采用驼峰式写法，而不是小写。如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素的写法)HTML 通常写法是：1234&lt;!--此处的onclick是小写的,传入的函数写法是一个字符串--&gt;&lt;button onclick="activateLasers()"&gt; 激活按钮&lt;/button&gt;React 中写法为：1234&lt;!--此处的onClick是驼峰式,传入的函数写法是函数本身--&gt;&lt;button onClick=&#123;activateLasers&#125;&gt; 激活按钮&lt;/button&gt;事件处理案例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from "react";import ReactDOM from "react-dom";class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isToggleOn: true &#125;; // handleClick1绑定this是必要的，这样this才能在回调函数中使用 this.handleClick1 = this.handleClick1.bind(this); &#125; handleClick1() &#123; this.setState((prevState) =&gt; (&#123; isToggleOn: !prevState.isToggleOn, &#125;)); &#125; //使用箭头函数来定义事件的函数(e可省略) handleClick2 = (e) =&gt; &#123; console.log(e); &#125;; //事件对象e要放在最后(e可省略) handleClick3(msg, e) &#123; console.log(msg, e); &#125; render() &#123; return ( &lt;div&gt; &#123;/*事件的函数需要绑定当前组件的this(否则在事件函数中this的值会是 undefined)，可以直接在调用时直接绑定，也可以在组件的构造函数中绑定。 如果不想绑定this，那么也可以使用箭头函数来定义事件的函数。*/&#125; &lt;button onClick=&#123;this.handleClick1&#125;&gt; &#123;this.state.isToggleOn ? "ON" : "OFF"&#125; &lt;/button&gt; &lt;button onClick=&#123;this.handleClick2&#125;&gt;btn2&lt;/button&gt; &#123;/* 向事件处理程序传递参数(两种方式) */&#125; &lt;button onClick=&#123;this.handleClick3.bind(this, "hello")&#125;&gt;btn3_1&lt;/button&gt; &lt;button onClick=&#123;(e) =&gt; this.handleClick3("hello", e)&#125;&gt;btn3_2&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Toggle /&gt;, document.getElementById("root"));¶九、条件渲染React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。123456789101112131415161718192021222324252627282930313233343536373839404142import React from "react";import ReactDOM from "react-dom";function WarningBanner(props) &#123; if (!props.warn) &#123; //返回 null即可阻止组件渲染 return null; &#125; return &lt;div&gt;警告!&lt;/div&gt;;&#125;class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; active: true, showWarning: true, &#125;; &#125; render() &#123; return ( &lt;div&gt; &#123;/* true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false.如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它 */&#125; &#123;this.state.active &amp;&amp; &lt;div&gt;active&lt;/div&gt;&#125; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState((prevState) =&gt; (&#123; showWarning: !prevState.showWarning, &#125;)); &#125;&#125; &gt; &#123;/* 三元运算符 */&#125; &#123;this.state.showWarning ? &lt;span&gt;隐藏&lt;/span&gt; : &lt;span&gt;显示&lt;/span&gt;&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Toggle /&gt;, document.getElementById("root"));¶十、列表 &amp; Keys123456789101112131415161718192021import React from "react";import ReactDOM from "react-dom";const posts = [ &#123; id: 1, title: "Hello World", content: "Welcome to learning React!" &#125;, &#123; id: 2, title: "Installation", content: "You can install React from npm." &#125;,];function Blog(props) &#123; const content = props.posts.map((post) =&gt; ( /* 元素的 key 在他的兄弟元素之间应该唯一。 Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化 */ &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; )); return &lt;div&gt;&#123;content&#125;&lt;/div&gt;;&#125;ReactDOM.render(&lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById("root"));¶十一、组件插槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from "react";import ReactDOM from "react-dom";class Child extends React.Component &#123; render() &#123; let header, main, footer; this.props.children.forEach((item, index) =&gt; &#123; switch (item.props['data-position']) &#123; case "header": header = item break; case "main": main = item break; case "footer": footer = item break; default: break; &#125; &#125;) return ( &lt;div&gt; &lt;h2&gt;组件插槽&lt;/h2&gt; &lt;div&gt;&#123;header&#125;&lt;/div&gt; &lt;div&gt;&#123;main&#125;&lt;/div&gt; &lt;div&gt;&#123;footer&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;Child&gt; &#123;/* 传给子组件插槽的内容 */&#125; &lt;h1 data-position="header"&gt;header&lt;/h1&gt; &lt;h1 data-position="main"&gt;main&lt;/h1&gt; &lt;h1 data-position="footer"&gt;footer&lt;/h1&gt; &lt;/Child&gt; ) &#125;&#125;ReactDOM.render(&lt;Parent&gt;&lt;/Parent&gt;, document.getElementById("root"));¶十二、路由安装依赖1$ npm install react-router-dom --saveHome.jsx123456import React from "react";export default class Home extends React.Component &#123; render() &#123; return &lt;div&gt;欢迎来到主页&lt;/div&gt; &#125;&#125;About.jsx123456import React from "react";export default class About extends React.Component &#123; render() &#123; return &lt;div&gt;关于我......&lt;/div&gt; &#125;&#125;index.js12345678910111213141516171819202122232425262728293031import React from "react";import ReactDOM from "react-dom";import Home from "./Home"import About from "./About"//hash模式// import &#123; HashRouter as Router, Link, Route &#125; from "react-router-dom";//history模式import &#123; BrowserRouter as Router, Link, Route &#125; from "react-router-dom";class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Router&gt; &#123;/* &lt;Router basename="/admin"&gt; basename可以设定所有路由前缀*/&#125; &lt;div className="nav"&gt; &lt;Link to="/"&gt;Home&lt;/Link&gt; &lt;Link to="/about"&gt;About&lt;/Link&gt; &lt;/div&gt; &lt;Route path="/" exact component=&#123;Home&#125;&gt;&lt;/Route&gt;&#123;/* exact表示严格匹配模式 */&#125; &lt;Route path="/about" exact component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;/Router&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById("root"));¶十三、状态管理Redux¶1. redux工作流程¶2. 核心概念action:标识要执行行为的对象(同步action)。它的值也可以是函数(异步action)，但需要引入redux-thunk。包含2个方面的属性：type: 标识属性, 值为字符串, 唯一, 必要属性xxx(一般起名为data): 数据属性, 值类型任意, 可选属性reducer为一个函数，根据老的state和指定的action, 返回一个新的state，不能修改老的state。store将state,action与reducer联系在一起的对象，是redux最核心的管理对象。内部管理着state和reducer，提供方法有：getState(): 得到statedispatch(action): 分发action, 触发reducer调用, 产生新的statesubscribe(listener): 注册监听, 当产生了新的state时, 自动调用¶3. 相关API123redux中包含: createStore(), applyMiddleware(), combineReducers()store对象: getState(), dispatch(), subscribe()react-redux: &lt;Provider&gt;, connect()()¶4. 安装依赖1$ npm install redux --save¶5. 使用案例action-types.js12345/*action对象的type常量名称模块 */export const INCREMENT = 'increment'export const DECREMENT = 'decrement'actions.js1234567/*action creator模块 */import &#123;INCREMENT, DECREMENT&#125; from './action-types'export const increment = number =&gt; (&#123;type: INCREMENT, number&#125;)export const decrement = number =&gt; (&#123;type: DECREMENT, number&#125;)reducers.js12345678910111213141516171819import &#123; INCREMENT, DECREMENT &#125; from "./action-types";/** * 定义一个reducer函数 * 根据老的state和指定action, 处理返回一个新的state * @param &#123;*&#125; state * @param &#123;Object&#125; action */export const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case INCREMENT: // 返回一个新的状态，不能修改原来的状态 return state + action.number; case DECREMENT: return state - action.number; default: return state; &#125;&#125;;App.jsx1234567891011121314151617181920import React from "react";import * as actions from "./redux/actions";export default class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt; &#123;/* getState(): 得到state */&#125; &#123;this.props.store.getState()&#125; &lt;/h1&gt; &lt;p&gt; &#123;/* dispatch(action)：分发action, 触发reducer调用, 产生新的state */&#125; &lt;button onClick=&#123;() =&gt; this.props.store.dispatch(actions.increment(1))&#125;&gt;increment&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.props.store.dispatch(actions.decrement(1))&#125;&gt;decrement&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ) &#125;&#125;index.js12345678910111213141516171819import React from "react";import ReactDOM from "react-dom";import &#123; createStore &#125; from "redux";import &#123; counter &#125; from "./redux/reducers";import App from "./App";//根据一个reducer创建store对象const store = createStore(counter);// 定义渲染根组件标签的函数const render = () =&gt; &#123; ReactDOM.render(&lt;App store=&#123;store&#125; /&gt;, document.getElementById("root"));&#125;;// 初始化渲染render();// 注册(订阅)监听, 一旦状态发生改变, 自动重新渲染store.subscribe(render);¶十四、react-redux专门用来简化react应用中使用redux的插件库。¶1. 为什么要使用react-redux？redux与react组件的代码耦合度太高编码不够简洁¶2. 组件分类React-Redux将所有组件分成两大类：UI组件a. 只负责 UI 的呈现，不带有任何业务逻辑b. 通过props接收数据(一般数据和函数)c. 不使用任何 Redux 的 API容器组件a. 负责管理数据和业务逻辑，不负责UI的呈现b. 使用 Redux 的 API通过React-Redux的使用可以让UI组件中屏蔽redux依赖，从而实现解耦的效果。¶3. 安装依赖1$ npm install --save react-redux¶4. 使用案例action-types.js12345/*action对象的type常量名称模块 */export const INCREMENT = 'increment'export const DECREMENT = 'decrement'actions.js1234567/*action creator模块 */import &#123;INCREMENT, DECREMENT&#125; from './action-types'export const increment = number =&gt; (&#123;type: INCREMENT, number&#125;)export const decrement = number =&gt; (&#123;type: DECREMENT, number&#125;)reducers.js12345678910111213141516171819import &#123; INCREMENT, DECREMENT &#125; from "./action-types";/** * 定义一个reducer函数 * 根据老的state和指定action, 处理返回一个新的state * @param &#123;*&#125; state * @param &#123;Object&#125; action */export const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case INCREMENT: // 返回一个新的状态，不能修改原来的状态 return state + action.number; case DECREMENT: return state - action.number; default: return state; &#125;&#125;;components/counter.jsx1234567891011121314151617181920212223242526272829303132/* UI组件: 不包含任何redux API a.只负责 UI 的呈现，不带有任何业务逻辑 b.通过props接收数据(一般数据和函数) c.不使用任何 Redux 的 API */import React from 'react'import PropTypes from 'prop-types'export default class Counter extends React.Component &#123; //声明store管理的状态和action函数，此处接收的内容要和容器组件App中connect()中定义的状态属性名和action函数名一致。 static propTypes = &#123; count: PropTypes.number.isRequired, increment: PropTypes.func.isRequired, decrement: PropTypes.func.isRequired &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt; &#123;this.props.count&#125; &lt;/h1&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; this.props.increment(1)&#125;&gt;increment&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.props.decrement(1)&#125;&gt;decrement&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ) &#125;&#125;containters/App.jsx12345678910111213141516171819202122232425/* 包含Counter组件的容器组件 a.负责管理数据和业务逻辑，不负责UI的呈现 b.使用 Redux 的 API */// 引入连接函数import &#123; connect &#125; from 'react-redux'import &#123; increment, decrement &#125; from "../redux/actions";import Counter from '../components/counter'/** connect()：用于包装UI组件从而生成容器组件 由于store是绑定在&lt;Provider/&gt;中的，而不是&lt;Counter/&gt;中，要在Counter组件中接收store里的内容，则需要让store和Counter组件进行关联， connect()函数就起到了关联的作用。原理就是将Provider中store里的内容解析放到Counter组件中去。 */export default connect( state =&gt; (&#123; count: state &#125;), &#123; increment, decrement &#125;)(Counter)/* connect( mapStateToprops, //即state对象的属性组成的对象 mapDispatchToProps //action的相关函数组成的对象 )(Counter)*/index.js12345678910111213141516171819import React from "react";import ReactDOM from "react-dom";import &#123; createStore &#125; from "redux";import &#123; counter &#125; from "./redux/reducers";import &#123; Provider &#125; from "react-redux";import App from "./containters/App";//根据一个reducer创建store对象const store = createStore(counter);/** * Provider：让所有组件都可以得到state数据 */ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById("root"),);¶十五、redux异步编程¶1. 为什么要使用因为redux默认是不能进行异步处理的，但实际应用中却可能需要在redux中用到异步处理。¶2. 安装依赖1$ npm install --save redux-thunk¶3. 使用案例action-types.js12345/*action对象的type常量名称模块 */export const INCREMENT = 'increment'export const DECREMENT = 'decrement'actions.js12345678910111213141516171819/*action creator模块同步action调用时返回对象异步action调用时返回一个函数 */import &#123; INCREMENT, DECREMENT &#125; from "./action-types";export const increment = (number) =&gt; (&#123; type: INCREMENT, number &#125;);export const decrement = (number) =&gt; (&#123; type: DECREMENT, number &#125;);// 异步action creator(返回一个函数)export const incrementAsync = (number) =&gt; &#123; return (dispatch) =&gt; &#123; //异步处理 setTimeout(() =&gt; &#123; dispatch(increment(number)); &#125;, 2000); &#125;;&#125;;reducers.js12345678910111213141516171819import &#123; INCREMENT, DECREMENT &#125; from "./action-types";/** * 定义一个reducer函数 * 根据老的state和指定action, 处理返回一个新的state * @param &#123;*&#125; state * @param &#123;Object&#125; action */export const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case INCREMENT: // 返回一个新的状态，不能修改原来的状态 return state + action.number; case DECREMENT: return state - action.number; default: return state; &#125;&#125;;components/counter.jsx12345678910111213141516171819202122232425262728293031323334/* UI组件: 不包含任何redux API a.只负责 UI 的呈现，不带有任何业务逻辑 b.通过props接收数据(一般数据和函数) c.不使用任何 Redux 的 API */import React from 'react'import PropTypes from 'prop-types'export default class Counter extends React.Component &#123; //声明store管理的状态和action函数，此处接收的内容要和容器组件App中connect()中定义的状态属性名和action函数名一致。 static propTypes = &#123; count: PropTypes.number.isRequired, increment: PropTypes.func.isRequired, decrement: PropTypes.func.isRequired, incrementAsync: PropTypes.func.isRequired &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt; &#123;this.props.count&#125; &lt;/h1&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; this.props.increment(1)&#125;&gt;increment&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.props.decrement(1)&#125;&gt;decrement&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.props.incrementAsync(1)&#125;&gt;incrementAsync&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ) &#125;&#125;containters/App.jsx12345678910111213141516171819202122232425/* 包含Counter组件的容器组件 a.负责管理数据和业务逻辑，不负责UI的呈现 b.使用 Redux 的 API */// 引入连接函数import &#123; connect &#125; from 'react-redux'import * as actions from "../redux/actions";import Counter from '../components/counter'/** connect()：用于包装UI组件从而生成容器组件 由于store是绑定在&lt;Provider/&gt;中的，而不是&lt;Counter/&gt;中，要在Counter组件中接收store里的内容，则需要让store和Counter组件进行关联， connect()函数就起到了关联的作用。原理就是将Provider中store里的内容解析放到Counter组件中去。 */export default connect( state =&gt; (&#123; count: state &#125;), &#123; ...actions &#125;)(Counter)/* connect( mapStateToprops, //即state对象的属性组成的对象 mapDispatchToProps //action的相关函数组成的对象 )(Counter)*/index.js1234567891011121314151617181920212223import React from "react";import ReactDOM from "react-dom";import &#123; createStore, applyMiddleware &#125; from "redux";import thunk from "redux-thunk";import &#123; counter &#125; from "./redux/reducers";import &#123; Provider &#125; from "react-redux";import App from "./containters/App";//根据一个reducer创建store对象const store = createStore( counter, applyMiddleware(thunk), // 应用上异步中间件);/** * Provider：让所有组件都可以得到state数据 */ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById("root"),);]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装oracle]]></title>
    <url>%2Fdevops%2Foracle_docker.html</url>
    <content type="text"><![CDATA[这里给出两种方式，第一种是直接使用别人已经安装并配置好oracle的镜像，第二种是已经写好安装脚本，只需指定安装包目录就能得到oracle容器。¶一、oracle11gR2¶1、第一种¶1.1 拉取镜像1$ docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g该镜像由阿里云提供，比较大，可能需要下载一会，等待下载即可。¶1.2 运行容器1234#通过镜像运行容器$ docker run -d -p 1521:1521 --name oracle registry.aliyuncs.com/helowin/oracle_11g#检查容器是否运行成功$ docker ps¶1.3 配置oracle¶（1）配置环境变量1234567891011121314151617#进入容器$ docker exec -it oracle bash#切换到root用户，密码是helowin$ su root$ vi /etc/profile#在文件的末尾添加以下内容export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH# 刷新配置文件，使得环境变量生效$ source /etc/profile#创建软连接$ ln -s $ORACLE_HOME/bin/sqlplus /usr/bin¶（2）创建或修改oracle用户密码12345678910111213141516#从root用户切换到oracle用户$ su oracle#使用sysdba 连接oracle$ sqlplus /nologSQL&gt; conn /as sysdba#创建qcmoke用户，密码123456SQL&gt; create user qcmoke identified by 123456;SQL&gt; grant connect,resource to qcmoke;SQL&gt; commit;#修改system的密码为systemSQL&gt; alter user system identified by system;#修改sys的密码为sysSQL&gt; alter user sys identified by sys;#退出orcleSQL&gt; exit¶1.4 客户端登陆oracle客户端配置（假设oracle服务端ip为：example.com）：123456789helowin = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = example.com)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = helowin) ) )连接服务名：helowin账号：system，密码：system或者账号：qcmoke，密码：123456springboot配置12345678spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@example.com:1521:helowin username: system password: system #username: qcmoke #password: 123456¶2、第二种¶2.1 下载安装包安装包下载地址:https://www.oracle.com/database/technologies/112010-linx8664soft.html下载两个oracle安装包：linux.x64_11gR2_database_1of2.zip 和 linux.x64_11gR2_database_2of2.zip💁‍♂温馨提示：如果官方下载地址失效，可到本人网盘下载：链接：https://pan.baidu.com/s/1YwFRecm1_O3pA5efxak7iw提取码：e5rj¶2.2 运行容器1234#解压安装包到/install目录$ mkdir /install/ &amp;&amp; unzip ~/linux.x64_11gR2_database_1of2.zip -d /install/ &amp;&amp; unzip ~/linux.x64_11gR2_database_2of2.zip -d /install/#拉去并运行容器$ docker run --privileged --name oracle11g -p 1522:1521 -v /install:/install jaspeen/oracle-11g¶2.3 创建或修改oracle用户密码123456789101112131415161718192021222324252627#进入oracle11g容器$ docker exec -it oracle11g /bin/bash#切换到image的oracle用户$ su - oracle#进入oracle数据库$ sqlplus / as sysdba#创建qcmoke用户，密码123456SQL&gt; create user qcmoke identified by 123456;SQL&gt; grant connect,resource to qcmoke;SQL&gt; commit;#解锁scott用户SQL&gt; alter user scott account unlock;User altered.SQL&gt; commit;Commit complete.SQL&gt; conn scott/tigerERROR:ORA-28001: the password has expiredChanging password for scott#输入tiger即可New password:#在此输入tiger即可Retype new password:Password changedConnected.SQL&gt;¶2.4 客户端登录oracle客户端配置（假设oracle服务端ip为39.108.102.215）：123456789orcl = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 39.108.102.215)(PORT = 1522)) ) (CONNECT_DATA = (SERVICE_NAME = orcl) ) )连接服务名：orcl账号：scott，密码：tiger或者账号：qcmoke，密码：123456springboot配置12345678spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@39.108.102.215:1522:orcl username: scott password: tiger #username: qcmoke #password: 123456¶二、oracle19c有时候为了试验，需要安装Oracle新版本数据库，由于安装比较繁琐耗时，所以可通过docker快速安装部署。需要提前下载好oracle19c的安装包：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c，下载Linux x86-64的ZIP包即可，下载后得到LINUX.X64_193000_db_home.zip。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263$ git clone https://github.com/oracle/docker-images.git#把下载好的LINUX.X64_193000_db_home.zip压缩包放到docker-images/OracleDatabase/SingleInstance/dockerfiles/19.3.0里$ cd docker-images/OracleDatabase/SingleInstance/dockerfiles/#生成docker镜像（注意构件的过程中依赖oraclelinux:7-slim镜像，如果服务器可连接互联网，那么构建的过程会自动下载该镜像，如果是内网环境构建的话，可以通过离线导入镜像的方式得到）$ sh buildContainerImage.sh -v 19.3.0 -e#查看生成的镜像$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEoracle/database 19.3.0-ee 2f97d020b76a 3 hours ago 6.53GBoraclelinux 7-slim 0a28ba78f4c9 4 weeks ago 132MB#假设将oracle的数据文件挂载到宿主机上，注意：目录权限一定要正确，在容器中oracle用户的uid是54321，所以要保证容器内的oracle用户有权限读写该目录。所以需要创建oracle用户且uid是54321，并给挂载的目录设置权限。$ groupadd -g 54321 oinstall $ groupadd -g 54322 dba$ groupadd -g 54323 oper$ groupadd -g 54324 backupdba$ groupadd -g 54325 dgdba$ groupadd -g 54326 kmdba$ groupadd -g 54330 racdba$ useradd -u 54321 -g oinstall -G dba,oper,backupdba,dgdba,kmdba,racdba -d /home/oracle -s /bin/bash -c "Oracle Software Owner" oracle echo "123456" | passwd --stdin oracle$ mkdir -p /data1/oracle/oradata$ chown oracle:oinstall /data1/oracle/oradata#通过镜像创建并运行oracle docker容器实例，设置数据库的sid为xtcrm；pdb名称为pdb；并且设置sys、system、pdbadmin用户密码为123456$ docker run --name oracle-19c \-d \-p 1521:1521 -p 5500:5500 \-e ORACLE_SID=xtcrm \-e ORACLE_PDB=pdb \-e ORACLE_PWD=123456 \-v /data1/oracle/oradata:/opt/oracle/oradata \oracle/database:19.3.0-ee#查看日志$ docker logs -f oracle-19c#注意要等日志到看到如下提示，才说明启动并且创建数据库实例成功，这个时间有点长，需要耐心等待。#########################DATABASE IS READY TO USE!##########################进入oracle docker容器执行sql$ docker exec -it oracle-19c /bin/bash$ export ORACLE_SID=XTCRM #注意每次进入容器都执行以下这个命令$ sqlplus / as sysdbaSQL&gt; show pdbs;#创建普通用户$ docker exec -it oracle-19c /bin/bash$ export ORACLE_SID=XTCRM #注意每次进入容器都执行以下这个命令$ sqlplus / as sysdbaSQL&gt; alter session set "_ORACLE_SCRIPT"=true; SQL&gt; create user qcmoke identified by 123456;SQL&gt; grant connect,resource to qcmoke;#SQL&gt; grant connect,resource,dba to qcmoke;#查看字符编码SQL&gt; select userenv('language') from dual;可以分享镜像给其他服务器使用123456#镜像导出$ docker save -o oracle_database_19.3.0-ee.tar 2f97d020b76a#镜像导入$ docker load -i oracle_database_19.3.0-ee.tar#如果已经是&lt;none&gt;得名称了，也可以通过以下命令重命名镜像名称$ docker tag 2f97d020b76a oracle/database:19.3.0-eeOracle Enterprise Manage访问地址：https://10.223.117.106:5500/emUsername：sysPassword：123456Container Name：pdb时间同步问题：12#在宿主机上复制时间文件到容器中即可$ docker cp /usr/share/zoneinfo/Asia/Shanghai oracle-19c:/etc/localtime参考：https://www.jianshu.com/p/4ede7dcc1d86https://hub.docker.com/r/jaspeen/oracle-11ghttps://github.com/oracle/docker-images/tree/main/OracleDatabase/SingleInstancehttps://www.jianshu.com/p/b683640677c9]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>linux - docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s学习笔记]]></title>
    <url>%2Fdevops%2Fk8s.html</url>
    <content type="text"><![CDATA[¶一、概念¶1. 定义k8s是Google开源的一个容器集群管理系统。k8s用于容器化应用程序部署、扩展和管理。k8s提供了容器编排，资源调度，自动修复，弹性伸缩（自动根据服务器的并发情况扩增或者缩减容器数量)，自动部署，回滚处理，服务发现，负载均衡等一些列功能。k8s目标是让容器化应用简单高效。官网：https://kubernetes.io官方中文文档：https://kubernetes.io/zh/docs/home简单理解：仅用 Docker，则只能管理单个服务器节点的容器，而无法同时维护多个服务器节点。通过使用k8s则可以使用同一入口即可同时维护多个服务器节点的所有容器，并可以实现多服务器之间的自动修复，弹性伸缩，回滚处理，服务发现，负载均衡等。¶2. 核心对象Kubernetes 对象Pod最小可部署单元（k8s不能直接启动容器，而是需要通过Pod间接启动容器）一组容器（docker）集合一个Pod中的所有容器共享网络命名空间Pod是短暂的，运行完就结束了Service 服务将一组Pod（比如mysql Pod）关联起来，提供统一的入口防止pod失联，Pod地址发生改变，入口不受影响Volume 数据卷类似于Docker的VolumeNamespace 命名空间用于隔离Pod的运行环境（默认情况Pod可以互相访问）使用场景：①为开发环境、测试环境、生产环境准备不同的命名空间②为不同的用户提供不同的隔离的运行环境Controller 控制器Controller控制器基本对象构建并提供额外的功能和方便使用的特性，用于控制pod启动、停止、删除等。DeploymentDaemonSetStatefulSetReplicaSetJob¶3. 节点分类和重要组件master node：主控节点worker node：工作节点（1）master node 相关的组件（程序）apiserver：接收客户端操作k8s的指令（唯一入口），此外也是其他组件互调的桥梁。提供认证、授权、访问控制、API 注册和发现等机制。schduler：负责资源调度，根据规定的调度策略，在多个worker node服务器的pod中选举一个来部署容器。controller manager：管理控制器，负责维护技巧的状态，包括故障检测、自动扩展、滚动更新等，以及用于向work node的kubelet发送指令。etcd：分布式键值对数据库。用于保存整个集群的状态数据，比如pod、service等对象信息。（2）worker node 相关的组件（程序）kubelet：向容器发送指令以管理容器，同时负责 Volume（CVI）和网络（CNI）的管理。并汇报节点状态给apiserver，再保存状态至etcd。kubeproxy：管理docker容器的网络（包括服务发现与负载均衡等，主要提供 iptables、ipvs 规则）。¶二、部署 k8s 集群¶1. 集群规划主机名ip组件k8s-master192.168.60.101kube-apiserver、kube-controller-manager、kube-scheduler、etcdk8s-node1192.168.60.201kubelet、kube-proxyk8s-node2192.168.60.202kubelet、kube-proxy¶2. 系统环境操作系统：centos7k8s版本：1.23.6docker版本：18.09.9-3硬件配置：至少2G内存，2核CPU¶3. 初始化服务器（1）关闭防火墙12systemctl stop firewalldsystemctl disable firewalld如为云服务器，则需要注意开放相关安全组端口：master 节点：TCP至少开放：6443、2379、2380、60080、60081；UDP协议端口全开worker 节点：UDP协议端口全开（2）关闭selinux1234567# 临时生效setenforce 0# 永久生效（推荐）sed -i 's/enforcing/disabled/' /etc/selinux/config# 重启以生效reboot（3）关闭交换分区1234567891011# 临时生效swapoff -a# 永久生效（注释掉swap的配置）sed -ri 's/.*swap.*/#&amp;/' /etc/fstab# 重启以生效reboot#检测是否关闭成功（total为0即可）free -m（4）配置主机名12345678910#在k8s-master上执行hostnamectl set-hostname k8s-master#在k8s-node1上执行hostnamectl set-hostname k8s-node1#在k8s-node2上执行hostnamectl set-hostname k8s-node2#查看主机名（验证是否修改成功）hostname（5）配置名称解析三台主机都做如下配置12345cat &lt;&lt; EOF &gt;&gt; /etc/hosts192.168.60.101 k8s-master192.168.60.201 k8s-node1192.168.60.202 k8s-node2EOF然后互相ping查看是否都能通过主机名连接12$ ping 主机名#如：ping k8s-master（6）修改内核参数（开启数据包转发功能）所有服务器都执行如下命令：1234567891011121314cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1#vm.swappiness = 0#vm.max_map_count = 262144EOF# 加载br_netfilter模块# 查看是否加载：lsmod | grep br_netfiltermodprobe br_netfilter# 使配置生效sysctl -p /etc/sysctl.d/k8s.conf（7）配置时间同步所有服务器都执行如下命令以同步时间：1234yum install ntpdate -y#强制快速同步系统时间ntpdate ntp1.aliyun.comhwclock -w（8）安装 ipset 和 ipvsadm所有服务器都执行如下命令：在kubernetes中service有两种代理模型，一种是基于iptables，另一种是基于ipvs的。ipvs的性能要高于iptables的，但是如果要使用它，需要手动载入ipvs模块123456789101112131415# 安装yum install -y ipset ipvsadm# 配置cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF# 授权、运行、检查是否加载：chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4¶4. 安装 Docker所有服务器都执行如下命令：123456789101112131415161718192021222324252627#安裝Docker源wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo#查看可安装的docker版本yum list docker-ce --showduplicates#选择指定版本Docker安装yum install -y --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7#启动Dockersystemctl start dockersystemctl enable docker#配置Docker加速源，并修改cgroup驱动为k8s官方推荐的systemd，否则k8s初始化可能会报错mkdir -p /etc/dockercat &gt; /etc/docker/daemon.json &lt;&lt; EOF&#123; "exec-opts": ["native.cgroupdriver=systemd"], "registry-mirrors": ["https://b9pmyelo.mirror.aliyuncs.com"]&#125;EOF#重启 docker 服务systemctl restart docker#查看 Docker 配置是否修改生效（关注：Registry Mirrors、Cgroup Driver）docker info注意：K8s 和 Docker 之间有一些版本兼容性要求，以确保它们可以正常协作工作¶5. 安裝 k8s 相关工具所有服务器都执行如下命令：1234567891011121314151617181920212223#添加k8s的yum源cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF#安装kubeadm、kubelet、kubectlyum install -y kubelet-1.23.6 kubeadm-1.23.6 kubectl-1.23.6# 为了实现Docker使用的cgroup drvier和kubelet使用的cgroup drver一致，需要修改"/etc/sysconfig/kubelet"文件的内容：cat &gt; /etc/sysconfig/kubelet &lt;&lt;EOFKUBELET_EXTRA_ARGS="--cgroup-driver=systemd"KUBE_PROXY_MODE="ipvs"EOF#设置kubelet开机自启动systemctl enable kubelet¶6. 初始化 Master 节点在 Master 节点上执行：1234567891011121314151617181920212223242526#初始化k8s集群（自动运行必要组件到Docker容器中） #apiserver-advertise-address填写当前Master节点的实际ip，其他地方不用动 #image-repository：指定拉取镜像的地址（由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里需要指定阿里云镜像仓库地址） #service-cidr：k8s服务发现网段 #pod-network-cidr：Pod运行的网段kubeadm init \ --apiserver-advertise-address=192.168.60.101 \ --image-repository registry.aliyuncs.com/google_containers \ --kubernetes-version v1.23.6 \ --service-cidr=10.1.0.0/16 \ --pod-network-cidr=10.2.0.0/16 \ --service-dns-domain=cluster.local \ --ignore-preflight-errors=Swap \ --ignore-preflight-errors=NumCPU \ --ignore-preflight-errors=Mem # 配置环境变量和配置文件mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config#echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profile#source ~/.bash_profile¶7. 初始化 Node 节点12345678910111213#在Master节点获取token（在Master执行）kubeadm token create --print-join-command --ttl 0##在Node执行如下命令# 在node1和node2添加如下的命令向k8s集群中添加Node节点（根据Master节点获取token将当前Node节点加入到集群中）：kubeadm join 192.168.60.101:6443 --token pikadq.zwpr1wpypqp71ssk --discovery-token-ca-cert-hash sha256:eaa3781137e6180b0a23d670335614f13b5b93f6f1ce5b0696a6fe930aef890c##在Master执行如下命令# 获取所有节点（正常可以获取到master，node1和node2）kubectl get nodes# 获取所有节点（含更多详细信息）kubectl get nodes -owide其他相关 token 令牌的命令：12345678#列出当前有效的token令牌列表kubeadm token list#获取证书公钥hash值openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'#Node加入集群的命令kubeadm join &lt;master节点的IP&gt;:6443 --token &lt;有效的token令牌&gt; --discovery-token-ca-cert-hash sha256:&lt;证书公钥hash值&gt;¶8. 部署 CNI 网络插件在 Master 节点部署CNI网络插件：12wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml#代理下载：wget https://gh.con.sh/https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml1234#修改flannel配置文件vim kube-flannel.yml#（1）修改 "Network": "10.244.0.0/16" 的值为初始化集群时pod-network-cidr的网段，即：10.2.0.0/16#（2）在kube-flannel容器中添加一行参数：- --iface=ens33 （其中ens33为Master节点的网卡名称）具体修改如下：123456789101112131415161718 net-conf.json: | &#123; "Network": "10.2.0.0/16", #（1）修改Pod网段 "Backend": &#123; "Type": "vxlan" &#125; &#125;#其他配置内容 containers: - name: kube-flannel image: docker.io/flannel/flannel:v0.22.3 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=ens33 #（2）添加网卡名称（其中ens33为Master节点的网卡名称）12345678910111213kubectl apply -f kube-flannel.yml#查看pode的状态(查看部署进度，等所有Pod状态都变成Running，需要耐心等待一下)，kubectl get pods -n kube-system#获取所有节点（等待所有节点状态都为Ready）kubectl get nodes -owide#查看集群健康状态kubectl get cs#所有节点状态都为Ready，并且所有Pod状态都变成Running时说明集群部署完成#kube-controller-manager和kube-scheduler-k8s状态如果为CrashLoopBackOff，通常是Master节点分配的资源太少造成的，建议给Master节点分配多一点资源，至少2G内存，2核CUP，然后重启即可#查看指定Pod的详细信息（包括Pod的状态、容器的状态、事件日志等）#kubectl describe pods kube-controller-manager-k8s-master -n kube-system¶9. 通过 k8s 启动 nginx 容器待 k8s 集群部署好后，就可以在集群中运行容器了。在master节点上执行操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445#创建Pod控制器（通过部署间接创建容器） #在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod #Pod控制器的种类有很多，如：Deployment、ReplicaSet、StatefulSet、DaemonSet、Job、CronJob等 #在集群中创建一个名为 "nginx-test" 的Pod控制器（Deployment） #k8s会随机选择node节点进行镜像下载和启动 #nginx-test 为docker服务名称，可以自定义名称 #--replicas 指定创建的Pod副本数 #--image 指定要使用的docker镜像版本kubectl create deployment nginx-test --replicas=3 --image=nginx:1.8#列出所有Deployment类型的Pod控制器kubectl get deployment#查看pode的状态（含部署服务）kubectl get pods -owide#给Pod控制器创建服务（简单理解：即暴露容器的端口给宿主机）kubectl expose deployment nginx-test --type=NodePort --port=80#列出集群中的所有服务 #服务：服务与Pod控制器相关，表示向客户端提供访问Pod的接口，提供有负载均衡和服务发现的能力。 #简写：kubectl get svckubectl get services#NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE#kubernetes ClusterIP 10.1.0.1 &lt;none&gt; 443/TCP 60m#nginx-test NodePort 10.1.6.232 &lt;none&gt; 80:32724/TCP 6s#比如通过上面的命令查nginx容器映射到宿主机端口是32724，那么访问集群任意一个节点（）的32724端口都能访问nginxcurl http://192.168.60.101:32724curl http://192.168.60.201:32724#删除Pod控制器（如需）kubectl delete deployment nginx-test#删除服务（如需）kubectl delete service nginx-test#修改指定Pod控制器的副本数（如需）kubectl scale deployment --replicas=2 nginx-test#执行Pod容器命令kubectl exec nginx-test-7cf98b694b-6p6xg -- ls /#进入Pod容器执行命令kubectl exec -it nginx-test-7cf98b694b-6p6xg -- bash¶10. 部署 Dashboard在 Matser 上执行下面操作安装 Dashboard123456789101112131415161718192021222324252627282930313233343536373839404142#下载yaml配置文件wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml#代理下载：wget https://gh.con.sh/https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml#编辑yaml配置文件vim recommended.yaml#修改如下内容：kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboardspec: type: NodePort # 新增 ports: - port: 443 targetPort: 8443 nodePort: 30009 # 新增 selector: k8s-app: kubernetes-dashboard #部署kubectl create -f recommended.yaml#查看Pod和服务信息kubectl get pod,svc -n kubernetes-dashboard#浏览器访问：https://192.168.60.101:30009#访问dashboard时需要token令牌才能使用，故需要回到Master节点执行如下命令创建账户token令牌：#创建账户kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard#授权账户kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin#获取账户秘钥#kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin#根据账户秘钥获取token令牌#kubectl describe secrets &lt;账户秘钥&gt; -n kubernetes-dashboard#根据账户秘钥获取token令牌kubectl describe secrets $(kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin | awk '&#123;print $1&#125;') -n kubernetes-dashboard默认 Chrome 等浏览器由于 SSL 证书不受信任的原因无法正常访问 Dashboard，需要如下操作：12345678910111213141516171819#生成自签证书openssl genrsa -out dashboard.key 2048 openssl req -new -out dashboard.csr -key dashboard.key -subj '/CN=10.0.0.10'openssl x509 -req -days 3650 -in dashboard.csr -signkey dashboard.key -out dashboard.crt#删除原有证书kubectl get secret kubernetes-dashboard-certs -n kubernetes-dashboardkubectl delete secret kubernetes-dashboard-certs -n kubernetes-dashboard#通过新生成的证书创建secretkubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.key --from-file=dashboard.crt -n kubernetes-dashboard#查看dashboard的podkubectl get pod -n kubernetes-dashboard | grep kubernetes-dashboard#删除原有pod即可（会自动创建新的pod）kubectl delete pod $(kubectl get pod -n kubernetes-dashboard | grep kubernetes-dashboard | awk '&#123;print $1&#125;') -n kubernetes-dashboard#再次查看，等待重建的pod创建完成kubectl get pod -n kubernetes-dashboard | grep kubernetes-dashboard以上操作完成就可以使用 Chrome 访问 Dashboard 了。提示：火狐浏览器不需要如上操作也能默认可以访问参考：https://blog.csdn.net/qq_35078688/article/details/130662916效果如下：¶拓展知识¶重置节点如果集群部署出问题了，需要重新部署，可以先重置所有节点然后再重新部署，其中重置节点操作如下：12345678910111213141516171819202122232425262728293031#重置节点（Master或Node节点通用）kubeadm reset#关闭kubelet和docker服务systemctl stop kubeletsystemctl stop docker#清除遗留文件rm -rf /root/.kuberm -rf /etc/kubernetesrm -rf /var/lib/kubelet/*rm -rf /var/lib/etcdrm -rf /etc/cni/rm -rf /var/lib/cni/#清理ipvsadmipvsadm -C#重置防火墙iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X#重置相关网卡配置ifconfig cni0 downifconfig flannel.1 downifconfig docker0 downip link delete cni0ip link delete flannel.1#重启kubelet和docker服务systemctl start kubeletsystemctl start docker12345#如果仅重置Node节点，需要在Master节点中执行如下命令从集群中删除相关节点#将节点设置为不可调度状态，以防止新的 Pod 被调度到该节点上kubectl cordon &lt;node-name&gt;#从集群中删除该节点kubectl delete node &lt;node-name&gt;¶卸载 k8s1234567891011121314#停止并删除 Kubernetes 服务systemctl stop kubeletsystemctl disable kubeletkubeadm reset#删除 Kubernetes 软件包yum remove -y kubelet kubeadm kubectl#删除相关的 Docker 容器和镜像docker rm -f $(sudo docker ps -aq)docker rmi -f $(sudo docker images -q)#删除 Kubernetes 相关的配置文件和目录rm -rf ~/.kube /etc/kubernetes¶在任意节点使用 kubectl123456# 1. 将 master 节点中 /etc/kubernetes/admin.conf 拷贝到需要运行的服务器的 /etc/kubernetes 目录中scp /etc/kubernetes/admin.conf root@k8s-node1:/etc/kubernetes# 2. 在对应的服务器上配置环境变量echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profilesource ~/.bash_profile¶三、参考https://www.bilibili.com/video/BV19c411R73d （更简单的k8s部署方式）https://znunwm.top/archives/k8s-xiang-xi-jiao-chenghttps://juejin.cn/post/7095568050597920781https://www.jianshu.com/p/f21fc213446c加入k8s集群报错this Docker version is not on the list of validated versions: 20.10.17. Latest validated…]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次deepin使用体验]]></title>
    <url>%2Flinux%2Fdeepin_experience.html</url>
    <content type="text"><![CDATA[​ 由于最近做完了毕业设计，准备考虑进入云服务部署的阶段，但毕设作为微服务项目非常吃服务器的性能，我自己的两台阿里云和腾讯云学生机已经完全不够用了，但又没money再买服务器，而自己又有一台华为matebook E笔记本在吃灰，所以打算让其安装一个UI做的比较美观的deepin linux系统来分担一下云服务器的压力。于是开始了这条不归路…​ 在安装deepin后使用的过程中，整体的用户体验还是不错的，但有几个地方需要吐槽一下（虽然不完是deepin的锅~~~）！（1）安装好deepin后默认系统无线网卡不支持，所以无法搜索到wifi，于是网上找到如下解决方案：①首先卸载bcmwl-kernel-source（或者保证这个没有安装）可以使用：apt-get remove bcmwl-kernel-source 指令进行卸载②然后下载https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/l/linux-firmware/ 驱动固件，我下载的是linux-firmware_1.157_all.deb下载完后进行解压，找到lib/firmware/brcm/brcmfmac4356-pcie.bin这个文件，把这个文件从copy到系统的/lib/firmware/brcm/进行替换替换后重新启动电脑，这时应该可以看到wifi的标志了，但如果还是搜索不到wifi信号无法连接，继续后面的操作。③下面需要下载brcmfmac4356-pcie.txt文件，同样copy到系统的的/lib/firmware/brcm/目录下这个文件下载地址为：https://fedorapeople.org/~jwrdegoede/brcmfmac4356-pcie.txt把里面所有内容copy出来，自己建一个brcmfmac4356-pcie.txt的文件，copy到上面提到的目录下，然后再重新启动电脑④这时应该就可以正常使用wifi了经过实测发现上面的方案对于matebook安装Ubuntu时如果出现同样的问题一样适用。（2）通过vim进入文件编辑界面时，没法使用鼠标复制粘贴内容，于是网上找了一波才找到如下解决方案：1$ vim ~/.vimrc然后加入如下内容：12syntax onset mouse-=a（3）root用户ls等操作无法高亮显示进入系统默认的普通用户主目录(比如是/home/qcmoke/)，然后复制该目录下的.bashrc文件到/root/目录即可。123$ su$ cp /home/qcmoke/.bashrc /root/$ source /root/.bashrc]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo代码块进阶写法]]></title>
    <url>%2Fblog%2Fhexo_code.html</url>
    <content type="text"><![CDATA[如果你是一名程序猴子🐒并且善于在hexo上写博客的话，我相信你肯定不少接触markdown代码块语法，但普通的markdown代码块语法提供的功能是有限的，如果你想在代码块标题栏或者内部加入一点新鲜的点缀，比如在标题栏上显示文件名、文件路径、下载地址等等；在代码内部根据行首的+或者-进行diff高亮，那么你是否无从下手？哈哈😄 …废话不多说！下面就为您提供方案。正常markdown代码块的写法是这样的：&#x60;&#x60;&#x60; [language]code snippet&#x60;&#x60;&#x60;而本文介绍的hexo代码块进阶写法是如下格式的：&#x60;&#x60;&#x60; [language] [title] [url] [link text]code snippet&#x60;&#x60;&#x60;各参数意义如下：langugae：语言名称，引导渲染引擎正确解析并高亮显示关键字title：代码块标题，将会显示在左上角url：链接地址，如果没有指定 link text 则会在右上角显示 linklink text：链接名称，指定 url 后有效，将会显示在右上角url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。¶进阶一、langugae+title案例：&#x60;&#x60;&#x60;java&nbsp;/root/Demo.javapublic class Demo{}&#x60;&#x60;&#x60;效果如下：/root/Demo.java1public class Demo&#123;&#125;¶进阶二、langugae + title + url + text案例：&#x60;&#x60;&#x60;java&nbsp;&nbsp;Demo类&nbsp;https://example.com/&nbsp;我的主页public class Demo{}&#x60;&#x60;&#x60;效果如下：Demo类我的主页1public class Demo&#123;&#125;¶进阶三、langugae + url + text如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。案例：&#x60;&#x60;&#x60;java&nbsp;&nbsp;&nbsp;https://example.com/public class Demo{}&#x60;&#x60;&#x60;效果如下：我的主页1public class Demo&#123;&#125;¶进阶四、langugae + url案例：&#x60;&#x60;&#x60;java&nbsp;&nbsp;&nbsp;https://example.com/public class Demo{}&#x60;&#x60;&#x60;没有text的话，默认显示的名称是link效果如下：link1public class Demo&#123;&#125;¶进阶五、diff高亮只需在 [language] 这写 diff，然后在相应代码前面加上 - 和 + 就行了。案例：&#x60;&#x60;&#x60;diff- public static void main(String[] args){-- }+ public static void main(String[] args){++ }&#x60;&#x60;&#x60;效果如下：12345678public class Demo&#123;- public static void main(String[] args)&#123;- - &#125; + public static void main(String[] args)&#123;+ + &#125;&#125;💁‍♂ 如果diff没有显示，尝试编辑站点配置文件配置文件 /myblog/_config.yml ，设置自动高亮试试（反正我的不设置也能用）：123456highlight: enable: true line_number: true- auto_detect: true+ auto_detect: true tab_replace:]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中引入eslint]]></title>
    <url>%2Ffront%2Feslint.html</url>
    <content type="text"><![CDATA[ESLint 是一个开源的 JavaScript 代码检查工具，自从es6普及后。在优秀的vue开发团队里，开发的过程中免不了制定一些代码规范，而ESLint正好很好的解决这些问题。但对于想我这种初学者来说，在ide工具里，如果不懂点es6语法规范，那么开发的过程中就会经常因为一堆红色的报错信息而苦恼。由此在学会基本的es6语法的同时，学习配置ESLint也是一门必不可少的功课…eslint中文社区：https://cn.eslint.org¶一、安装ESLint插件如果使用vscode，那么安装如下三个插件（1）ESLint（2）Vetur（3）Prettier-Code Formatter然后在vscode的settings.json中添加如下ESLint插件配置：123456789101112131415161718//-------保存文件时eslint自动格式化设置----------"editor.codeActionsOnSave": &#123; "source.fixAll.eslint": true&#125;,/** 代码格式化配置 */"editor.tabSize": 2,// 尽可能控制尾随逗号的打印"prettier.trailingComma": "all",// 在保存时格式化文件"editor.formatOnSave": false,// 保存时自动fix"eslint.autoFixOnSave": true,"[vue]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode"&#125;,"[javascript]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode"&#125;下面是以前版本vscode的ESLint插件配置，上面的尝试不成功，可以试试这个。123456789101112131415161718//-------保存文件时eslint自动格式化设置----------"prettier.eslintIntegration": true, //让prettier使用eslint的代码格式进行校验"vetur.format.defaultFormatter.js": "vscode-typescript", //让vue中的js按编辑器自带的ts格式进行格式化"vetur.format.defaultFormatterOptions": &#123; "js-beautify-html": &#123; "wrap_attributes": "force-aligned" //属性强制折行对齐 &#125;&#125;,"eslint.autoFixOnSave": true,"eslint.validate": [ "javascript", &#123; "language": "vue", "autoFix": true &#125;, "html", "vue"]¶二、全局安装eslint1$ npm install -g eslint¶三、使用方式¶1. 方式一¶1.1 安装依赖将以下依赖配置到package.json的devDependencies中：1234"@vue/cli-plugin-babel": "^3.0.1","@vue/cli-plugin-eslint": "^3.0.1","@vue/eslint-config-standard": "^3.0.0-beta.10","eslint-plugin-cypress": "^2.0.1"然后执行下面命令安装依赖1$ npm install¶1.2 配置eslint规则在项目目录创建eslintrc.js文件，内容如下123456789101112131415161718192021module.exports = &#123; root: true, 'extends': [ 'plugin:vue/essential', '@vue/standard' ], rules: &#123; // allow async-await 'generator-star-spacing': 'off', // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'vue/no-parsing-error': [2, &#123; 'x-invalid-end-tag': false &#125;], 'no-undef': 'off', 'camelcase': 'off' &#125;, parserOptions: &#123; parser: 'babel-eslint' &#125;&#125;备注：在main.js的new Vue所在的行上面加/* eslint-disable no-new */注释，如下：12345/* eslint-disable no-new */new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;)¶2. 方式二¶2.1 安装依赖12345$ npm install eslint --save-dev$ npm install babel-eslint --save-dev$ npm install eslint-friendly-formatter --save-dev #指定错误报告的格式规范插件$ npm install eslint-loader --save-dev #启动vuecli时就可以检测$ npm install eslint-plugin-vue --save-dev #符合vue项目推荐的代码风格¶2.3 配置eslint规则项目目录创建eslintrc.js文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192module.exports = &#123; root: true, // 根文件，不会往上一层查找 parserOptions: &#123; parser: 'babel-eslint', sourceType: 'module' &#125;, env: &#123; browser: true, node: true, es6: true, &#125;, extends: ['plugin:vue/recommended', 'eslint:recommended'], // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: &#123; "vue/max-attributes-per-line": [2, &#123; "singleline": 10, "multiline": &#123; "max": 1, "allowFirstLine": false &#125; &#125;], "vue/name-property-casing": ["error", "PascalCase"], 'accessor-pairs': 2, 'arrow-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'block-spacing': [2, 'always'], 'brace-style': [2, '1tbs', &#123; 'allowSingleLine': true &#125;], 'camelcase': [0, &#123; 'properties': 'always' &#125;], 'comma-dangle': [2, 'never'], 'comma-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'comma-style': [2, 'last'], 'constructor-super': 2, 'curly': [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 2, 'eqeqeq': [2, 'allow-null'], 'generator-star-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'handle-callback-err': [2, '^(err|error)$'], 'indent': [2, 2, &#123; 'SwitchCase': 1 &#125;], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [2, &#123; 'beforeColon': false, 'afterColon': true &#125;], 'keyword-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'new-cap': [2, &#123; 'newIsCap': true, 'capIsNew': false &#125;], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 0, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [2, &#123; 'allowLoop': false, 'allowSwitch': false &#125;], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [2, &#123; 'max': 1 &#125;], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 2, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 0, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [2, &#123; 'defaultAssignment': false &#125;], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': 0, 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [2, &#123; 'initialized': 'never' &#125;], 'operator-linebreak': [2, 'after', &#123; 'overrides': &#123; '?': 'before', ':': 'before' &#125; &#125;], 'padded-blocks': [2, 'never'], 'quotes': [2, 'single', &#123; 'avoidEscape': true, 'allowTemplateLiterals': true &#125;], 'semi': [2, 'never'], 'semi-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [2, &#123; 'words': true, 'nonwords': false &#125;], 'spaced-comment': [2, 'always', &#123; 'markers': ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] &#125;], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], 'yoda': [2, 'never'], 'prefer-const': 2, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [2, 'always', &#123; objectsInObjects: false &#125;], 'array-bracket-spacing': [2, 'never'] &#125;&#125;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok反向代理内网git仓库]]></title>
    <url>%2Ftools%2Fngrok_git.html</url>
    <content type="text"><![CDATA[你是否因为无法访问公司内网的git服务器而感到发恼，只要你在公司内部有一台pc电脑，看看这篇文章，问题就能够很快解决…需要先安装ngrok并编译生成代理服务端和代理客户端程序。具体操作可参考：《ngrok实现内网穿透》¶1. 代理服务端（公网）启动服务端程序1$ ~/ngrok/bin/ngrokd -domain="ngrok.example.com"¶2. 代理客户端ngrok配置（内网）（1）下载编译生成的代理客户端程序后配置ngrok.cfg123456789$ vim ngrok.cfgserver_addr: "ngrok.example.com:4443"trust_host_root_certs: false#隧道列表tunnels: git: remote_port: 2222 proto: tcp: gitlab.company.com:2222（2）启动内网中的代理客户端1$ ./ngrok.exe -config ngrok.cfg start git¶2. 外网用户端操作（外网）（1）生成密钥默认已经有~/.ssh/id_rsa密钥的话,可以生成不同名称的密钥文件。为什么不用默认的~/.ssh/id_rsa？因为如果github的git注册账号和公司的git注册账号不一样的话，对应的ssh_key也不一样。1$ ssh-keygen -t rsa -C "qcmoke@company.com" -f ~/.ssh/id_rsa_company（2）给ssh用户端添加私钥1$ ssh-add ~/.ssh/id_rsa_company（3）在公司内网服务中加入公钥用户端ssh_key,即~/.ssh/id_rsa_company.pub里的内容。（4）配置git服务12345678910#假设公司内网git域名为gitlab.company.com，而端口是2222(默认是22)，git账号为qcmoke#HostName指向代理服务器#IdentityFile为生成的私钥文件路径$ vim ~/.ssh/configHost gitlab.company.com HostName ngrok.example.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_company User qcmoke Port 2222（5）添加私钥到用户端的ssh中123456#启用ssh代理$ ssh-agent bash#列出添加的所有私钥$ ssh-add -l#添加私钥$ ssh-add ~/.ssh/id_rsa_company #ssh清空私钥ssh-add -D（6）测试和克隆仓库12$ ssh -T git@gitlab.company.com$ git clone ssh://git@gitlab.company.com:2222/test.git]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>内网穿透</tag>
        <tag>反向代理</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2Fdevops%2Fdocker.html</url>
    <content type="text"><![CDATA[¶一、简介Docker 是一个开源的应用容器引擎，它是由 Go 语言 开发实现的轻量级容器技术，它是基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。官网：https://www.docker.com中文网：https://dockerdocs.cnDocker Hub（Docker 镜像仓库）：https://hub.docker.com¶二、概念¶1. 概要理解Docker支持安装各种软件并做好配置后编译成镜像，最终可以直接运行镜像产生一个或多个运行于宿主机内核上的容器。为了形象的理解容器，可以简单的理解它为运行在操作系统上的独立沙箱系统，这些沙箱系统内部的文件系统和Linux的非常相似，事实上确是如此，因为Docker就是融合了Linux内核而实现的虚拟化技术，由于具有沙箱的特性，所以各个容器之间是隔离运行的、独立的、互不影响的，程序员甚至不用担心容器内部损坏或者崩溃导致宿主机出错，因为只要删除掉这些有问题的容器，而再运行相关的镜像又会得到全新的容器了，只要不进行数据挂载，整个过程甚至干净不留残余。¶2. 核心内容docker主机(Host)：或者称为docker宿主机，即安装了Docker程序的机器。docker客户端(Client)：连接docker主机进行操作的程序。docker镜像(Images)：是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。docker容器(Container)：运行镜像后产生的实例称为容器，实质是运行于独立的 命名空间的进程。docker仓库(Registry)：集中存储、分发镜像的仓库服务系统，作用是允许用户上传、下载并管理镜像，包括公有仓库和私有仓库。¶3. 对比传统虚拟机特性虚拟机的架构容器的架构启动分钟级秒级性能弱于原生接近原生硬盘使用一般为GB一般为MB系统支持量一般几十个单机上千个容器虚拟机的架构： 每个虚拟机都包括应用程序、必要的二进制文件和库以及一个完整的客户操作系统(Guest OS)，尽管它们被分离，它们共享并利用主机的硬件资源，将近需要十几个 GB 的大小。容器的架构： 容器包括应用程序及其所有的依赖，但与其他容器共享内核。它们以独立的用户空间进程形式运行在宿主机操作系统上。他们也不依赖于任何特定的基础设施，Docker 容器可以运行在任何计算机上，任何基础设施和任何云上。 ¶4. 优势（1）快速的启动时间由于Docker容器直接运行于宿主内核，无需启动完整的操作系统即可运行，因此可以做到秒级、甚至毫秒级的启动时间，这大大的节约了开发、测试、部署的时间。（2）一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于不同物理机的开发环境不一致，经常出现安装了相同的软件但却有不同的运行效果现象，甚至有的环境下还会出现bug。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，以至于不会再出现 “这段代码在我机器上没问题啊” 这类的问题。（3）持续交付和部署Docker可以一次创建或配置镜像，而可以在任意地方正常运行。即&quot;一处构建，到处运行&quot;。（4）更方便的迁移Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。（5）更轻量的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。¶5. 分层存储因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。¶6. 容器存储层镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。¶7. 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录，当容器内部的目录(文件)映射到宿主机的某目录(文件)时，那么就称这个宿主机的目录(文件)为数据卷。它绕过 UFS，可以提供很多有用的特性，如下：数据卷 可以在容器之间共享和重用对 数据卷 的修改会立马生效对 数据卷 的更新，不会影响镜像数据卷 默认会一直存在，即使容器被删除注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。¶三、Docker 安装和维护Docker 分为 CE 和 EE 两大版本。CE 即社区版，EE 即企业版，强调安全，付费使用。¶1. 包管理器安装 Docker说明：下面以使用 CentOS7 的 Yum 包管理器安装 Docker 为例进行讲解，其他 Linux 发行版包管理器的安装说明可参考：https://docs.docker.com/engine/install/¶1）安装旧版本（不推荐）CentOS7 从默认的 Yum 源中安装的 Docker 版本是旧版本，旧版本的 Docker 称为 docker 或 docker-engine ，由于目前官方不在维护，故建议跳过以下去安装新版本。12345678910#检查内核版本，必须是3.10及以上uname -r#安装dockeryum install docker -y#启动dockersystemctl start docker#开机启动dockersystemctl enable docker#查看docker版本，验证安装是否成功(有client和service两部分表示docker安装启动都成功了)docker -v¶2）安装新版本123456789101112131415161718192021222324252627282930#卸载旧版本，如果已安装这些程序，请卸载它们以及相关的依赖项yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine #安裝Docker源wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo#yum install yum-utils -y#yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo#查看可安装的docker版本yum list docker-ce --showduplicates#安装docker-ce。yum install docker-ce -y#选择指定版本Docker安装#yum install -y --setopt=obsoletes=0 docker-ce-&lt;version&gt;#如：yum install -y --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7#查看docker版本，验证安装是否成功(有client和service两部分表示docker安装启动都成功了)docker version#启动并加入开机启动systemctl start dockersystemctl enable docker更多内容：查看所有仓库中所有docker版本：yum list docker-ce --showduplicates | sort -r安装指定版本：比如yum install docker-ce-17.12.0.ce新版docker安装好后命令自动补全会有些缺失，所以可以选择安装命令补全依赖工具。1234567#docker自动补齐需要依赖工具bash-complete，安装好后会得到文件为 /usr/share/bash-completion/bash_completionyum install -y bash-completion#apt install -y bash-completion#装好docker自动补齐依赖之后，要刷新下才能让其生效source /usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/completions/docker¶3）内网环境集群安装¶（1）yum离线安装如果内网中有一台服务器能够访问外网，可使用一下方式安装：1234567891011121314151617181920212223#在内网中可访问外网的服务器中下载清华的镜像源文件（要求这台服务器依软件赖环境纯净，最好没有安装过任何软件。目的是这台服务器的所有软件依赖一定要在其他内网服务器中都存在。）wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.reposed -i 's+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+' /etc/yum.repos.d/docker-ce.repoyum updateyum list docker-ce --showduplicates|sort -r#下载docker安装的所有依赖到/tmp/docker-19.03目录yum install --downloadonly --downloaddir=/tmp/docker-19.03 docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7#复制下载好的/tmp/docker-19.03到目标服务器(比如192.168.0.13)scp -r /tmp/docker-19.03/ root@192.168.0.13:/tmp/#登录进目标服务器之后进入文件夹安装ssh root@192.168.0.13cd /tmp/docker-19.03/yum install *.rpm#启动并加入开机启动systemctl start dockersystemctl enable docker¶（2）完全离线安装如果内网中所有服务器都不能访问外网，可使用一下方式安装：下载安装包在客户机中访问docker官网下载安装包：安装包各版本下载地址：https://download.docker.com/linux/static/stable/x86_64/这里下载的版本是：https://download.docker.com/linux/static/stable/x86_64/docker-19.03.5.tgz安装运行下载好安装包后通过ftp等客户端工具上传安装包到目标服务器，然后通过ssh客户端工具登录到该目标服务器执行如下命令：12345678910#解压安装压缩包tar xzvf docker-19.03.5.tgz#拷贝安装cp docker/* /usr/bin/#运行服务dockerd &amp;#停止服务启动ps -ef|grep dockerdkill -9 1958 #这里的1958改成ps出来的pid配置开机启动123456#关闭selinux策略vi /etc/selinux/configSELINUX=disabled#重启系统reboot配置docker.socket1vi /etc/systemd/system/docker.socket1234567891011121314151617181920212223[Unit]Description=Docker Socket for the APIPartOf=docker.service[Socket]# If /var/run is not implemented as a symlink to /run, you may need to# specify ListenStream=/var/run/docker.sock instead.ListenStream=/run/docker.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.target配置docker.service1vi /etc/systemd/system/docker.service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target启动服务123systemctl daemon-reloadsystemctl start dockersystemctl enable docker¶4）参考https://docs.docker.com/engine/install/centos¶2. 一键脚本安装 Docker12345678910111213#使用官方源安装（国内直接访问较慢）curl -fsSL https://get.docker.com | bash#使用阿里源安装#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun#使用中国区Azure源安装#curl -fsSL https://get.docker.com | bash -s docker --mirror AzureChinaCloud#指定特定版本安装#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun --version 18.06.3#设置开机自启systemctl enable docker#启动Dockersystemctl start docker参考：https://github.com/docker/docker-installhttps://www.vps69.com/posts/install-docker/¶3. 配置 Docker 的镜像源鉴于国内网络问题，Docker 的默认镜像源拉取 Docker 镜像十分缓慢，我们可以配置国内的镜像源来加速镜像下载（可以配置多个镜像源）。Azure 中国镜像 https://dockerhub.azk8s.cn阿里云加速器(需登录账号获取)网易云加速器 https://hub-mirror.c.163.comAliyun 的镜像（需要登录到阿里云后台获取，地址：https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors）测速：https://github.com/docker-practice/docker-registry-cn-mirror-test/actionsDocker 的镜像源配置文件路径（如果文件不存则需要手动创建）：Linux： /etc/docker/daemon.jsonWindows：%programdata%\docker\config\daemon.json12345678910111213cat &gt; /etc/docker/daemon.json &lt;&lt; 'EOF'&#123; "registry-mirrors": [ "https://hub-mirror.c.163.com", "https://docker.mirrors.ustc.edu.cn" ]&#125;EOF#重启 docker 服务systemctl restart docker#查看 Docker 配置是否修改生效（其中 “Registry Mirrors” 即为 Docker 的镜像源）docker info¶4. 配置 Docker 的默认存储路径（可选）Docker 会使用 /var/lib/docker/ 目录作为默认存储目录，用以存放拉取的镜像和创建容器等的相关文件。由于该目录通常都位于系统盘，如果系统盘比较小，而镜像和容器使用得越多就会占用越多的系统盘空间，当系统盘不够时就会比较尴尬了，故而可能需要通过数据盘来转移镜像和容器内容，这就可能需要修改 Docker 的默认存储目录。假设 /data1 目录挂载点的磁盘空间比较大，需要将其设置为 Docker 的默认存储路径，可如下操作：12345678910111213141516mkdir -p /data1/docker/libcat &gt; /etc/docker/daemon.json &lt;&lt; 'EOF'&#123; "registry-mirrors": [ "https://docker.mirrors.ustc.edu.cn", "https://hub-mirror.c.163.com" ], "data-root": "/data1/docker/lib"&#125;EOF#重启 Docker 服务systemctl restart docker#查看 Docker 配置是否修改生效（其中 “Docker Root Dir” 即为 Docker 的存储路径）docker info¶5. Docker 服务管理12345678910111213141516#启动docker服务（提示：docker即docker.service，启动服务后会自动启动docker网络套接字守护进程，即docker.socket）systemctl start docker#重启docker服务systemctl restart docker#关闭docker服务 #如果该命令无法停止服务（报错提示：Warning: Stopping docker.service, but it can still be activated by: docker.socket，这个问题通常是由于容器使用了 --restart always 等重启策略导致服务无法关闭，解决办法就是还需要关闭 docker.socket 网络套接字守护进程）systemctl stop docker#关闭docker网络套接字守护进程systemctl stop docker.socket#开启开机自启动docker服务systemctl enable docker#禁止开机自启动docker服务systemctl disable docker¶6. 卸载 Docker1234567891011121314151617181920212223242526##卸载准备（可选）#停止并删除所有正在运行的 Docker 容器docker stop $(sudo docker ps -a -q)docker rm $(sudo docker ps -a -q)#删除所有 Docker 镜像docker rmi $(sudo docker images -q)#停止 Docker 服务systemctl stop docker.socketsystemctl stop docker.service##（1）yum 卸载 Docker#删除 Docker 安装包yum remove -y docker docker-ce docker-ce-cli containerd.ioyum autoremove -y#删除残余文件rm -rf /var/lib/docker #含镜像、容器、配置文件等内容rm -rf /var/lib/containerdrm -rf /etc/docker#（2）apt 卸载 Docker#删除 Docker 安装包apt purge -y docker docker-ce docker-ce-cli containerd.io#删除残余文件rm -rf /var/lib/docker #含镜像、容器、配置文件等内容rm -rf /var/lib/containerdrm -rf /etc/docker¶四、镜像管理https://hub.docker.com/123456789101112131415161718192021#检索 (去https://hub.docker.com上查看镜像的详细信息。eg：docker search redis)docker search 镜像关键字#拉取 (name是镜像名，:tag是可选的，tag表示标签，多为软件的版本，默认是latest)docker pull name[:tag]#列出 (查看所有本地镜像)docker images#删除 (删除指定的本地镜像,image-id是镜像id)docker rmi image-id#查看容器/镜像详细信息docker inspect image-name-or-id#镜像导出docker save -o 打包文件名.tar 镜像id#或者docker save 镜像id &gt; 文件名.tar#镜像导入docker load -i 打包文件名.tar#或者docker load &lt; 打包文件名.tar镜像导出并导入案例：123456#例如，以下导出方式将会让docker load导入时的镜像没有名字(即&lt;none&gt;)docker save -o redis.tar 7864316753#因此，推荐使用镜像的名字进行导出，此方式导入时就有镜像名称了docker save -o redis:5.0.2#另外，如果已经是&lt;none&gt;的名称了，也可以通过以下命令重命名镜像名称docker tag [镜像id] [新镜像名称]:[新镜像标签]¶五、容器管理¶1. 管理命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#运行并创建一个容器 #-d：表示守护态运行，即后台状态运行 #--name：给容器自定义命名 #-p：表示端口映射 #格式：-p &lt;host&gt;:&lt;host_port&gt;:&lt;container_port&gt;/&lt;protocol&gt; #&lt;host&gt; 是指宿主机的IP地址（可以使用 0.0.0.0 表示监听所有网络接口） #&lt;host_port&gt; 是指宿主机上的端口，可指定为单个端口或者端口范围（如果不指定将自动映射到宿主机的一个随机端口） #&lt;container_port&gt; 是指容器内部的端口，可指定为单个端口或者端口范围 #&lt;protocol&gt; 是要使用的传输协议，可指定为tcp或者udp（不指定默认为tcp） #示例：-p 2222:22 -p 1194:1194/udp -p 127.0.0.1:8080:8080/tcp -p 9000-9100:9000:9100 #--volume（-v）：数据卷或目录挂载，即挂载物理主机数据卷或者目录或文件到容器里 #--restart：设置docker守护进程对容器的重启策略，可选值如下： #no（默认）：容器退出后（无论是否正常退出），docker守护进程在重启时都不会自动启动该容器。 #always：容器退出后（无论是否正常退出），docker守护进程在重启时都会自动启动该容器。（提示：docker stop 关闭容器后并不会执行重启策略，仅是docker守护进程重启时，重启策略才会发挥作用） #on-failure[:max-retries]：容器在非正常退出时（退出状态码不等于0，如：强制关机导致容器异常退出、手动关闭容器但容器且异常退出、容器内部程序执行错误导致异常退出等），docker守护进程在重启时会自动启动该容器。参数使用如：--restart=on-failure，可选地指定 max-retries 参数来限制最大重试次数。例如，--restart=on-failure:3 表示容器最多会重试 3 次，如果在重试次数耗尽之后容器仍然无法正常运行，它将停止。 #unless-stopped：容器在非正常退出时，除非手动关闭，docker守护进程将在重启时会自动启动该容器。 #补充说明：对于开机自启动的情况，可选 always 或 unless-stoppeddocker run -d --name 容器名称 -p 主机端口:容器端口 -v 主机目录路径:容器目录路径 镜像名称#关闭容器docker stop 容器名称/容器id#启动已经关掉的容器docker start 容器名称/容器id#重启容器docker restart 容器名称/容器id#删除指定容器docker rm 容器名称/容器id#强制删除当前所有容器docker rm -f $(docker ps -a -q)#显示容器列表（默认只显示运行中的容器）docker psdocker ps -s #-s：显示容器占用磁盘空间大小#显示容器列表（所有，包括运行中和已停止的容器）docker ps -a#查看 Docker 容器里的环境变量docker exec -it &lt;container_name_or_id&gt; env#查看 Docker 容器里的指定环境变量docker exec -it &lt;container_name_or_id&gt; sh -c 'echo $ENV_VARIABLE_NAME'#执行容器内命令docker exec -it 容器名称或容器id 命令#如：docker exec -it nginx ip iddr#进入容器内部docker exec -it 容器名称或容器id bash#从容器内部退出exit#从主机拷贝文件到容器docker cp 主机文件或目录 容器名称或容器id:容器文件或目录#从容器拷贝文件到主机docker cp 容器名称或容器id:容器文件或目录 主机文件或目录#查看容器/镜像详细信息docker inspect 容器名称/容器id#查看容器运行日志docker logs 容器名称/容器id#查看容器资源的使用情况，包括：CPU、内存、网络I/O、磁盘I/O 等资源占用情况docker stats##通过runlike去查看一个容器的docker run启动参数# 安装runlike安装包pip install runlike# 可能需要退出终端会话重新连接才能生效exit# 查看容器运行命令runlike -p &lt;container_name&gt; # 后面可以是容器名和容器id，-p参数是显示自动换行#容器导出和导入#将容器导出为镜像包docker export -o 镜像包名称.tar 容器名称或容器id#将镜像包导入为镜像docker import 镜像包名称.tar 新镜像名称:新镜像标签#修改容器配置 #注意只能修改一些配置项，并非所有配置都能修改，如数据卷、目录挂载等就修改不了 #常见参数如下： # --cpu-shares=&lt;权重&gt;: 设置容器的 CPU 权重，影响 CPU 时间片的分配。（默认值为 1024，数值越高表示容器获得的 CPU 时间片越多） # --cpu-period=&lt;周期&gt;: 设置 CPU 周期，用于控制 CPU 时间片的周期。 # --cpu-quota=&lt;配额&gt;: 设置 CPU 配额，限制 CPU 的使用。 # --blkio-weight=&lt;权重&gt;: 设置块 I/O 权重，用于限制容器的磁盘 I/O。 # --memory=&lt;内存限制&gt;: --memory可缩写-m，设置容器的内存限制。 # --memory-swap=&lt;内存+交换限制&gt;: 设置内存加交换限制，控制内存和交换空间的使用。 # --kernel-memory=&lt;内核内存限制&gt;: 设置容器可以使用的内核内存限制。 # --restart=&lt;策略&gt;: 配置容器的重启策略。可选策略包括 no、on-failure、always、unless-stopped 等。docker update [OPTIONS] &lt;容器名称或ID&gt; #docker update --restart always &lt;容器名称或ID&gt; #docker update --restart=no &lt;容器名称或ID&gt; #docker update --cpu-shares 512 &lt;容器名称或ID&gt; #docker update -m 512M &lt;容器名称或ID&gt;容器导出和导入案例：12345678910#创建容器docker run -itd --name centos7-test centos:centos7#尝试修改容器docker exec -it centos7-test touch /tmp/test#将容器导出为镜像包docker export -o centos7-test.tar centos7-test#将镜像包导入为镜像docker import centos7-test.tar centos7:centos7-test#通过新镜像创建容器docker run -itd --name centos7-test2 centos7:centos7-test¶2. 设置容器与宿主机时间同步12345##为了保证容器和宿主机之间的时间同步#1、使用docker run运行容器时，添加如下参数-v /etc/localtime:/etc/localtime:ro 如下：docker run -it -v /etc/localtime:/etc/localtime:ro centos#2、如果容器已经运行则可以如下操作：docker cp -L /usr/share/zoneinfo/Asia/Shanghai [容器名]:/etc/localtime¶六、数据管理由于docker容器和宿主机系统是隔离的，这会带来下面几个问题：不能在宿主机上很方便地访问容器中的文件无法在多个容器之间共享数据当容器删除时，容器中产生的数据将丢失为了能够保存（持久化）数据以及共享容器间的数据，docker 引入了数据卷(volume) 机制。数据卷是存在于一个或多个容器中的特定文件或文件夹，它可以绕过默认的联合文件系统，以正常的文件或者目录的形式存在于宿主机上。生存周期独立于容器的生存周期的，所以删除容器后数据卷并不会丢失。容器中主要有两种管理数据方式：数据卷(Data Volumes)，数据卷容器(Data Volume Containers)。¶1. 数据卷数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：（1）数据卷 可以在容器之间共享和重用（2）对 数据卷 的修改会立马生效（3）对 数据卷 的更新，不会影响镜像（4）数据卷 默认会一直存在，即使容器被删除数据卷的使用类似 linux 下对目录或文件进行 mount 操作，目前Docker提供了三种不同的方式将数据卷从宿主机挂载到容器中：数据卷挂载：volume mount绑定挂载：bind mounttmpfs mount其中volume、bind mount比较常用，tmpfs mount基本不会用.¶1.1 数据卷挂载数据卷挂载即将特定数据卷挂载到容器内部，数据卷挂载需要提前创建volume数据卷，然后再提供给容器绑定，新建的数据卷位于宿主机的/var/lib/docker/volumes目录里。这种挂载方式就是不需要手动指定宿主机目录并且能够通过docker volume命令来维护数据卷。12345678910111213141516171819202122232425#创建数据卷docker volume create 数据卷名#显示数据卷的详细信息docker volume inspect 数据卷名#列出所有的数据卷docker volume ls#删除未使用的数据卷（正被容器使用的数据卷无法删除）。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令docker volume rm 数据卷名#删除所有未使用的数据卷docker volume prune#运行容器并挂载数据卷#type：挂载类型，包括volume（默认）和bind。source：数据卷名称（数据卷不存在则自动创建，如果不指定数据卷则自动创建随机数名称的数据卷）#可以将多个数据卷挂载给一个容器；可以将一个数据卷挂载给多个容器，但是都共同使用同一个宿主机的数据卷目录docker run -d --name 容器名称 --mount type=volume,source=数据卷名,target=容器内部目录或文件绝对路径 镜像名称或id#可以使用-v(--volume)来简写，数据卷不存在则自动创建，如果不指定数据卷（如-v 容器内部目录或文件绝对路径）则自动创建随机数名称的数据卷docker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径 镜像名称或id##数据卷权限#Docker挂载数据卷的默认权限是可读写rw，可以通过ro标记指定为只读，这样可以防止容器修改文件#使用--mount时设置数据卷权限。不指定readonly则为读写docker run -d --name 容器名称 --mount type=volume,source=数据卷名,target=容器内部目录或文件绝对路径,readonly 镜像名称或id#使用-v(--volume)时设置数据卷权限docker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径:rw 镜像名称或iddocker run -d --name 容器名称 -v 数据卷名:容器内部目录或文件绝对路径:ro 镜像名称或id示例：1234567891011121314151617docker volume create my-voldocker volume inspect my-vol [ &#123; "CreatedAt": "2022-08-26T11:11:08+08:00", "Driver": "local", #local表示宿主机。配置为vieux/sshfs（需要安装插件）可以把数据卷存储到其他云主机去，这里不做过多介绍。 "Labels": &#123;&#125;, "Mountpoint": "/var/lib/docker/volumes/my-vol/_data", #数据卷所在宿主机位置 "Name": "my-vol", "Options": &#123;&#125;, "Scope": "local" &#125;]docker run -d --name nginx --mount type=volume,source=my-vol,target=/usr/share/nginx/html nginx:1.22.0-alpine#可以使用-v(--volume)来简写，如下：#docker run -d --name nginx -v my-vol:/usr/share/nginx/html nginx:1.22.0-alpine¶1.2 绑定挂载绑定挂载即直接将主机文件系统中的目录或文件挂载到容器内部的方式，没有涉及到数据卷管理。当你使用绑定挂载时，主机上的目录或文件会直接映射到容器内部的路径，它们之间的更改会实时同步。注意这种方式不能使用 docker volume 命令来维护挂载目录或文件。12345678910111213#使用source表示自定义数据卷路径，source必须是绝对路径，且路径必须已经存在，否则报错docker run -d --name 容器名称 --mount type=bind,source=宿主机目录或文件绝对路径,target=容器内部目录或文件绝对路径 镜像名称或id#可以使用-v(--volume)来简写，如下：#--mount和-v(--volume)有个区别，就是使用-v宿主机目录或文件不存在也能自动创建，而使用--mount不存在则会运行失败docker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径 镜像名称或id##挂载目录或文件的权限#Docker挂载目录或文件的默认权限是rw（即可读写），可以通过ro标记指定为只读，这样可以防止容器修改宿主机的目录或文件#可使用--mount时设置挂载目录的权限，如只读（readonly）。docker run -d --name 容器名称 --mount type=bind,source=宿主机目录或文件绝对路径,target=容器内部目录或文件绝对路径,readonly 镜像名称或id#使用-v(--volume)时设置数据卷权限docker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径:rw 镜像名称或iddocker run -d --name 容器名称 -v 宿主机目录或文件绝对路径:容器内部目录或文件绝对路径:ro 镜像名称或id示例：123mkdir -p /opt/nginxdocker run -d --name nginx --mount type=bind,source=/opt/nginx,target=/usr/share/nginx/html nginx:1.22.0-alpine#docker run -d --name nginx -v /opt/nginx:/usr/share/nginx/html nginx:1.22.0-alpine¶2. 数据卷容器数据卷不仅可以设置在宿主机，同样也可以设置在其他容器中。这样即使容器挂掉或者被删除，也不会影响数据卷容器里已经同步的数据，同样的数据卷容器挂掉或者被删除也不会影响容器的数据。1234#创建数据卷容器docker run -d -v 数据卷名称或者宿主机目录或文件:容器目录或文件 --name=数据卷容器名称 镜像名称[:版本号]或ID#挂载数据卷容器给其他容器docker run -d --name=容器名称 --volumes-from 数据卷容器名称或ID 镜像名称[:版本号]或ID示例：12345docker run -d --name nginx-backup -v /opt/data:/opt/data nginx:1.22.0-alpinedocker run -d --name nginx --volumes-from nginx-backup nginx:1.22.0-alpinedocker exec -it nginx touch /opt/data/test.txtdocker rm -f nginxdocker exec -it nginx-backup ls /opt/data¶七、Docker 网络Docker默认提供了3种网络模式，生成容器时不指定网络模式下默认使用bridge桥接模式。¶1. host 模式容器不会创建自己的网卡，配置 IP 等，而是使用宿主机的 IP 和端口1docker run -d --name 容器名称 --net=host 镜像名称¶2. container 模式容器不会创建自己的网卡，配置 IP 等，而是和一个指定的容器共享 IP和端口1docker run -d --name 容器名称 --net=container:容器名称或容器id 镜像名称¶3. none 模式关闭网络功能，不进行任何网络设置1docker run -d --name 容器名称 --net=none 镜像名称¶4. bridge 模式（默认模式）为每一个容器分配、设置 IP 等，并将容器连接到 docker0 虚拟网桥上，这是 docker run 创建容器时使用的默认模式。当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥（网卡/路由器），此主机上启动的Docker容器都会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。宿主机和Docker容器之间是可以进行网络连接的，同样的，Docker容器和容器之间只要是在一个虚拟网桥下，那么也可以直接进行网络连接。12#通过--net=bridge显示指定，默认就是bridge，也可以不设置docker run -d --name 容器名称 --net=bridge 镜像名称¶5. 自定义网络12345678910111213141516171819202122232425##自定义创建名称为mynet的网络#--driver bridge 桥接模式#--subnet 192.168.0.0/16 子网掩码（网段）的主机IP可选范围为：192.168.0.1-192.168.255.254#--gateway 192.168.0.1 网关#其中192.168.0.1被设置为网关（即宿主机的虚拟网卡IP），故容器主机IP的可选范围为：192.168.0.2-192.168.255.254docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet#删除网络docker network rm mynet#删除主机上全部未使用的网络docker network prune#查看当前Docker所有的网络模式docker network ls#查看自定义网络详细信息docker network inspect mynet#通过--net在启动容器时指定自定义网络docker run -d --name 容器名称 --net mynet 镜像名称#不同Docker网络之间的容器想要连接的话，需要把该容器注册到另一个容器所在的网络上#如下假设centos01容器本来在默认的bridge（docker0）上，想要让其和mynet网络下的容器互通，则需要把centos01注册到mynet中。#成功注册到mynet网络后，docker将会在centos01中创建一个网卡并且分配一个mynet网段内的IP，并且将新ip-主机名映射加入自己的hosts中docker network connect mynet centos01默认docker0是无法Ping通容器名，而自定义网络可以Ping通容器名。在多个微服务部署到docker时，通过自定义网络方便统一的网络配置。¶6. 多个容器之间通过容器名称互相访问docker run 创建容器时默认使用的是 docker0 网络，容器可以通过另一个容器的 ip 来访问其他容器主机，但是没法通过容器 id 或者主机名来访问，因为容器的 hosts 文件中默认只有容器自己的 ip-主机名映射，而没有其他容器的。为了能够通过容器名称来访问其他容器，可以在容器的 hosts 文件中配置其他容器的 ip-主机名映射，这个过程可以使用 docker exec 命令进入容器内手动修改 hosts 文件实现，但这种方式会有点麻烦。还有另一解决方式是在 docker run 创建容器的时候通过指定 --link 参数来配置其他容器的ip-主机名映射。如下：12#创建centos02容器，并在其内部hosts中加入centos01容器的ip-主机名映射。docker run -d -it --name centos02 --link centos01容器的 centos:centos7docker run 创建容器时会自动把分配到的的 ip 和 hostname（即主机名，默认为容器id）写入到容器的hosts文件中。其中 主机名可以在 docker run 时指定 --hostname 来修改。如上配置后就能让 centos02 能够访问到 centos01，但是 centos01 却不能访问 centos02，这是因为 centos01 的hosts 文件中没有加入 centos02 的 ip - hostname映射，除非使用 docker exec 命令进入 centos01 容器内修改其 hosts 文件，可见使用--link 参数配置的方式操作也很麻烦。为了更加简便地实现 docker 中多个容器之间的互相访问，有一种更好的解决方案，那就是使用“docker自定义网络”，docker 自定义网络可以理解为“网卡”，docker 允许用户将多个容器配置到同一个自定义网络中，容器之间通过容器名称互相访问的时候，docker 将会根据自定义网络中的容器配置信息解析容器名称得到对应的 ip ，进而实现访问。可以通过 docker inspect 自定义网络名称 命令来查看自定义网络中的容器配置信息，如下：1234567891011121314151617181920212223242526272829303132docker network ls#查看自定义网络配置docker inspect 自定义网络名称#自定义网络中多个容器的配置信息如下：[ &#123; "Name": "mynet", "Containers": &#123; "0a348b84901337546e60bfcc7cd8592a81e244339337f1ceea9b578bba09d9dd": &#123; "Name": "nginx2", "EndpointID": "867176b7354f17095eff8f5a047bbae062d3f80b4ad150f1711a13f0543ed549", "MacAddress": "02:42:c0:a8:00:04", "IPv4Address": "192.168.0.4/16", "IPv6Address": "" &#125;, "6bfc4ad47e7f878f14b5fa1c3a59029fc6b50a1e04cdb946bd45de4e052a7416": &#123; "Name": "nginx1", "EndpointID": "4498313ad280f9e15c86f5c756a66dbdb39982f8469be50c2761e058b333bb31", "MacAddress": "02:42:c0:a8:00:03", "IPv4Address": "192.168.0.3/16", "IPv6Address": "" &#125;, "a29f5b6558b22bf557a2b997c3c03284f013bc75da89065a983a2452f27bee0c": &#123; "Name": "nginx3", "EndpointID": "85e61dc0d27a7d2a7be14c11e6566656817693981ee22b277328ee3116aafef4", "MacAddress": "02:42:c0:a8:00:02", "IPv4Address": "192.168.0.2/16", "IPv6Address": "" &#125; &#125; &#125;]将多个容器配置到同一个自定义网络中的操作如下：12345678910111213141516171819#创建一个名称为mynet的自定义网络docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet#使用默认bridge（docker0）网络创建centos01docker run -d --name centos01 centos:centos7#使用自定义网络mynet创建centos02docker run -d --name centos02 --net mynet centos:centos7docker run -d --name centos01 centos:centos7#使用自定义网络mynet创建centos03docker run -d --name centos03 --net mynet centos:centos7#测试centos01是否连通到centos03情况（发现连通成功）docker exec -it centos01 ping centos03#测试centos03是否连通到centos01情况（发现连通成功）docker exec -it centos03 ping centos01#测试centos01是否连通到centos02情况（发现不通）docker exec -it centos01 ping centos02#把该centos01注册到centos02所在的mynet网络上。docker network connect mynet centos01#测试centos01是否连通到centos02情况（发现连通成功）docker exec -it centos01 ping centos02¶7. 查看容器ip两种方式：1、由于docker run创建容器时就会给容器分配ip等信息了，所以可以直接使用docker inspect命令来过滤数据获取。2、通过docker exec命令进入容器内部在使用如ifconfig等方式查看12345678910##通过docker inspect查看容器ip#查看容器ipdocker inspect --format='&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' 容器名称或容器id#显示所有容器 IP 地址docker inspect --format='&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' $(docker ps -aq)##通过docker exec查看容器ipdocker exec -it 容器名称或容器id ifconfigdocker exec -it 容器名称或容器id ip iddrdocker exec -it 容器名称或容器id cat /etc/hosts参考：https://blog.csdn.net/CSDN1csdn1/article/details/123961079¶8. Docker与防火墙¶1）bridge 网络模式的防火墙配置Docker 默认使用的是 bridge 网络模式，在创建容器时会自动为容器配置 iptables 规则以进行网络安全控制。具体来说，Docker 会在主机上创建一个名为 docker0 的虚拟网桥，并将容器连接到该网桥中。同时，它还会为每个容器分配一个随机的 IP 地址，并通过 NAT 的方式将容器和宿主机的 IP 地址进行映射。说明：bridge 网络模式下，启动或停止 docker 容器时，docker 都会在 iptables 防火墙配置中自动创建或删除和容器相关的规则策略，而不需要人为手动进行配置。由于 docker 使用的是iptables 命令维护防火墙配置，所以用户只能通过iptables 命令来查看 docker 相关的防火墙规则策略，而使用firewall、ufw 等上层防火墙工具则无法查看。¶2）host 网络模式的防火墙配置当 Docker 使用 host 网络模式时，Docker 容器将直接使用宿主机的网络环境，包括 IP 和端口。此时 Docker 不会再为容器自动进行 iptables 配置，而是直接使用宿主机的防火墙规则。¶9. 反向代理到容器¶1）简要概述使用一些反向代理服务（如：Nginx）可以将用户请求代理到容器内部的端口监听服务上，从而可以给 docker 容器做负载均衡、网络安全防护等，这些都是常见的运维需求。其中网络安全防护的一些具体需求如下：（1）通过限制外网访问 docker 容器从而实现多个 docker 微服务容器之间可以在内网中互相访问，但不允许外网直接访问。（2） docker 中的 HTTP 服务容器未进行 SSL 加密而直接提供外网访问是非常不安全的，一般做法是先配置 docker 容器禁止外网访问而只允许内网访问，再使用 nginx 通过反向代理转发外网的 HTTPS 请求给 docker 容器中的 HTTP 服务。下面是以上需求的具体实现方案：¶2）限制外网访问 docker 容器方式1：使用默认的 bridge 网络模式创建 docker 容器并指定端口映射时限制访问 IP。操作如下：1docker run -d --name 容器名称 -p 127.0.0.1:宿主机端口:容器端口 镜像名称注意：docker会自动维护防火墙配置，通常不设置 ip 则容器对应的宿主机端口默认对所有 IP 访问不限制。这种方式运行容器，容器程序的监听端口会占用宿主机的端口。方式2：使用 host 网络模式创建 docker 容器，让容器监听端口直接使用宿主机端口。操作如下：1docker run -d --name 容器名称 --net=host 镜像名称注意：使用 host 网络模式创建 docker 容器时， docker 不会进行 iptables 自动配置，而是直接使用宿主机的防火墙规则。这种方式运行容器，容器程序的监听端口会占用宿主机的端口。方式3：创建 docker 容器时不进行端口映射，而通过容器 IP 进行访问。12345678910111213#方法1：使用默认的bridge网络自动分配IP给容器（默认的bridge网络IP网段为172.17.0.0/16）docker run -d --name 容器名称 镜像名称#方法2：手动指定一个自定义网络的固定IP给容器docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetdocker run -d --name 容器名称 --net=mynet --ip 192.168.0.100 镜像名称#查看容器的ipdocker inspect 容器名称或ID | grep IPAddress#或者：docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' 容器名称或ID#查看默认的bridge网络的ip网段docker network inspect bridge | grep Subnet这种方式运行容器，容器程序的监听端口不会占用宿主机的端口。注意：不能使用默认的 bridge 网络模式指定自定义 IP，否则会报错或设置无效。¶3）通过nginx反向代理到docker的HTTP服务容器（1）配置 nginx SSL证书和反向代理，如下：配置nginx SSL证书并监听一个对外网访问的端口，并反向代理到docker容器的监听端口（设端口为：8080）12345678910111213141516171819server &#123; listen 443 ssl; #此处端口为nginx对外网暴露的端口 server_name example.com; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; charset utf-8; location ^~ / &#123; proxy_pass http://127.0.0.1:8080; #此处端口为docker的HTTP服务容器的监听端口 #proxy_pass http://172.17.0.100:8080; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; &#125;&#125;假设docker run 运行 http 容器时限制 ip 映射端口为 -p 127.0.0.1:宿主机端口:容器端口，那么可以代理到 http://127.0.0.1:8080。而如果不进行端口映射，则可以通过命令 docker inspect 容器名称或ID | grep IPAddress 查看容器的 ip ，然后反向代理到对应的地址，如：http://172.17.0.100:8080（2）配置防火墙放行nginx对外网暴露的端口123456##宿主机配置防火墙#对于 UFW 防火墙：ufw allow 443/tcp#对于 FirewallD 防火墙：firewall-cmd --zone=public --add-port=443/tcp --permanentfirewall-cmd --reload最后外网访问的地址为：https://example.com（即：https://example.com:443）¶八、构建自定义镜像¶方式1：上传程序到vps后构建需求：构建一个能在tomcat容器里运行的war包程序镜像，并通过镜像创建一个实例容器。由于依赖于tomcat容器，故需要先拉去tomcat镜像到本地。tomcat镜像主页：https://c.163yun.com/hub#/library/repository/info?repoId=3105¶（1）拉取tomcat镜像到宿主机1docker pull hub.c.163.com/library/tomcat:latest¶（2）上传war包创建一个webdemo项目，并在这个webdemo项目的资源路径里添加一个index.jsp页面。12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;然后打包得到webdemo.war文件。并上传这个webdemo.war文件到vps的/root/project目录¶（3）编写Dockerfile文件12#在/root/project下编写一个Dockerfile文件vim Dockerfile123456#继承于某个镜像from hub.c.163.com/library/tomcat#镜像所有者信息MAINTAINER qcmoke qcmoke@gmail.com#把程序copy到容器镜像当中，前面的参数是本地路径，后面的参数是容器镜像路径(可以到镜像主页得到tomcat的webapp路径)COPY /root/project /usr/local/tomcat/webapps¶（4）构建生成镜像12#在Dockerfile文件所在的目录，即/root/project里执行如下命令docker build -t webdemo:latest .¶（5）查看本地镜像仓库是否构建成功1docker images123REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest aeea3708743f Less than a second ago 529 MBwebdemo latest 10f75818641a 46 seconds ago 310 MB¶（6）通过构建的镜像实例化一个容器并运行1docker run -d -p 8080:8080 webdemo:latest¶（7）访问测试访问index.jsp：http://192.168.222.131:8080/webdemo/index.jsp¶（8）其他在用-d指定为后台启动的情况下，可以使用以下命令查看容器实时的日志情况：1docker logs -f 容器名称或者容器id¶方式2：通过idea插件连接vps构建¶（1）配置docker允许外网访问在vps中配置docker允许外网访问1vim /usr/lib/systemd/system/docker.service在ExecStart属性原来值的最后追加1-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock新版Docker CE配置如下1234567891011121314........[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sockExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=always........旧版Docker配置如下：1234567891011121314151617181920[Service]........ExecStart=/usr/bin/dockerd-current \ --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \ --default-runtime=docker-runc \ --exec-opt native.cgroupdriver=systemd \ --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \ --init-path=/usr/libexec/docker/docker-init-current \ --seccomp-profile=/etc/docker/seccomp.json \ $OPTIONS \ $DOCKER_STORAGE_OPTIONS \ $DOCKER_NETWORK_OPTIONS \ $ADD_REGISTRY \ $BLOCK_REGISTRY \ $INSECURE_REGISTRY \ $REGISTRIES \ -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock........¶（2）重新加载配置并重启Docker12systemctl daemon-reloadsystemctl restart docker¶（3）启动防火墙并开放2375端口开放了防火墙2375端口用于远程连接123service firewalld startfirewall-cmd --permanent --add-port=2375/tcpfirewall-cmd --reload不需要另外开放容器映射到宿主机的端口。经操作发现，如果使用vmware的linux作为vps，不能直接关闭防火墙，开放相应的端口即可。¶（4）创建一个springboot项目pom.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo-boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!--将其他模块的依赖一起打包生成可执行jar--&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;DemoApplication.java12345678910111213141516171819202122package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author qcmoke */@RestController@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @RequestMapping("/hello") public Object hello() &#123; return "hello docker!"; &#125;&#125;application.yml12server: port: 8080Dockerfile123456789FROM openjdk:8u212-jre#存放持久化数据的目录VOLUME /tmp#要复制到容器中的问件ADD target/demo-boot-0.0.1-SNAPSHOT.jar /demo-boot.jar#docker容器启动时执行的命令ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/demo-boot.jar"]#启动端口号(容器中的)EXPOSE 8080¶（5）编译项目生成jar包¶（6）配置远程docker插件连接默认新版的idea自带有这个插件，如果没有直接到插件中心安装即可。¶（7）然后配置DockerFile¶（8）运行docker插件运行插件部署镜像到vps，并通过镜像创建一个实例容器¶（9）访问测试最后访问: http://192.168.222.132:8080/hello¶九、Docker Compose¶1. 简介Compose项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。地址：https://github.com/docker/compose使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。Compose 允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个项目。¶2. 安装在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。1234curl -L https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose#旧版：curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose --version因为 Docker Compose 存放在 GitHub，可能网络不太稳定。可以想办法下载后再上传到服务器，操作如下：（1）手动下载 docker-compose 文件，下载地址：https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64（2）复制并重命名下载的文件为docker-compose1&gt;mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose¶3. 卸载如果是二进制包方式安装的，删除二进制文件即可。1rm /usr/local/bin/docker-compose¶4. 编排文件下面以编排 mysql、redis、nacos 容器为示例，配置如下：在任意目录创建compose编排配置文件：docker-compose.yml12345678910111213141516171819202122232425262728293031323334353637## 编排文件的版本version: '3'services: # compose管理的服务 redis: image: redis # 指定镜像 container_name: redis-1 # 容器名称 restart: always # 开机自动启动 ports: # 端口映射 - 6379:6379 volumes: # 目录映射 - /opt/redis/conf:/usr/local/etc/redis - /opt/redis/data:/data command: redis-server --requirepass qcmoke123456 --appendonly yes #执行的命令; requirepass来指定远程登录密码; appendonly来指定是否开启持久化策略 #command: redis-server /usr/local/etc/redis/redis.conf --appendonly yes mysql: image: mysql:5.7.24 container_name: mysql-1 ports: - 3306:3306 environment: # 环境变量 MYSQL_ROOT_PASSWORD: qcmoke123456 # 设置数据库root密码 restart: always volumes: - /opt/mysql/data:/var/lib/mysql #当 MySQL 服务启动时会以/etc/mysql/my.cnf为配置文件，而该文件会导入/etc/mysql/conf.d目录中所有以.cnf为后缀的文件。 #这些文件会拓展或覆盖 /etc/mysql/my.cnf 文件中的配置。因此创建以.cnf结尾的配置文件并挂载至MySQL容器中的/etc/mysql/conf.d目录即可。 #在本项目中只要在docker-compose up前上传my.cnf文件到宿主机的/opt/mysql/conf.d/my.cnf目录即可。如果在docker-compose up后的话，需要重启mysql容器才能重新加载到自定义的配置文件。 - /opt/mysql/conf.d:/etc/mysql/conf.d nacos: image: nacos/nacos-server container_name: nacos-standalone environment: - MODE=standalone ports: - 8848:8848注意：如果编排文件没有显式指定网络，则 Docker Compose 在默认情况下会自动创建一个新的 “bridge”（桥接）网络，并将Compose文件中的所有容器服务连接到该网络。这个默认的&quot;bridge&quot;网络在Compose文件中的每个服务之间提供了连接和通信的能力。通过这个网络，服务可以通过它们的服务名称相互访问，并使用容器的IP地址进行通信。如果在Compose文件中显式指定了网络，那么服务将连接到指定的网络。下面是以上编排文件中使用到的 mysql 配置文件：/opt/mysql/conf.d12345678910111213141516171819[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录# basedir=/var/lib/mysql# 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=/var/lib/mysql/data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 最大连接数max_connections=500¶5. 操作命令在docker-compose.yml所在的目录执行如下命令12345678910111213141516171819202122232425262728#查看正在运行的容器docker-compose ps#启动容器 #尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。相关的服务都将会被自动启动，除非已经处于运行状态。 #注意：如果不指定SERVICE，则默认运行配置文件的所有容器服务 #以守护进程模式运行加-d选项 #添加--build表示启动前构建镜像（如果已经存在镜像则强制重新构建）docker-compose up -d [SERVICE...]#暂停容器docker-compose pause [SERVICE...]#恢复暂停的容器docker-compose unpause [SERVICE...]#停止并移除所有相关容器（此命令将会停止并移除up命令所启动的容器，并移除网络，但不会移除卷，如需移除卷，则需要加--volumes参数）docker-compose down#docker-compose down --volumes#重启项目中的服务。docker-compose restart [options] [SERVICE...]#执行容器内部命令docker-compose exec &lt;service_name&gt; &lt;command&gt;#查看容器日志docker-compose logs¶十、Docker SwarmDocker Swarm 是 Docker 的集群管理工具，或者说是资源管理工具。swarm 集群由管理节点（manager）和工作节点（work node）构成。swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。注意：跟集群管理有关的任何操作，都是在管理节点上操作的。准备6台linux服务器manager-1：192.168.99.101manager-2：192.168.99.102manager-3：192.168.99.103worker-1：192.168.99.201worker-2：192.168.99.202worker-3：192.168.99.203¶1. 关闭所有服务器的防火墙1service firewalld stop¶2. 初始化 swarm 集群进行初始化的这台机器，就是集群的管理节点。1docker swarm init --advertise-addr 192.168.68.101eg：12345678910[root@localhost ~]# docker swarm init --advertise-addr 192.168.68.101Swarm initialized: current node (w7xdf6see52t2t24x1ykedg5o) is now a manager.To add a worker to this swarm, run the following command: docker swarm join \ --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \ 192.168.68.101:2377To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.¶3. 添加worker节点在manager节点下生成worker令牌，以让其他worker服务器加入1docker swarm join-token workereg：123456[root@localhost ~]# docker swarm join-token workerTo add a worker to this swarm, run the following command: docker swarm join \ --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \ 192.168.68.101:2377然后在三台worker节点运行：123docker swarm join \ --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-3xqtzzxymio3077xfki41od0e \ 192.168.68.101:2377¶4. 添加manager节点在manager节点下生成manager令牌，以让其他manager服务器加入1docker swarm join-token managereg：123456[root@localhost ~]# docker swarm join-token managerTo add a manager to this swarm, run the following command: docker swarm join \ --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-4nbcolan6w4akrs3zsbvrkqxe \ 192.168.68.101:2377然后在三台manager节点运行如下命令：123docker swarm join \ --token SWMTKN-1-04sl6nb0acbzzgvfrqycph4jtnyh0wcoix70gz44sjuaf66cwd-4nbcolan6w4akrs3zsbvrkqxe \ 192.168.68.101:2377¶5. 查看所有管理的节点manager-1运行命令查看所有管理的节点1docker node lseg：12345678[root@localhost ~]# docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUSdif8w8hp6pevz9k0owqkg6hjl localhost.localdomain Ready Active j9jqdioy91olyxd8dfghgm8qc localhost.localdomain Ready Active mfv24dim85bi7sd9wl589rhdf localhost.localdomain Ready Active Reachableq1qayx19ebfg7oi8dv7e3mzyh localhost.localdomain Ready Active rbeb5mykx83qpr6u8afriqx9z localhost.localdomain Ready Active Reachablew7xdf6see52t2t24x1ykedg5o * localhost.localdomain Ready Active Leader¶6. 创建集群服务1docker service create -p 80:80 --name my-nginx nginx这时候将会在任意节点中选择一台通过docker创建nginx服务。我们可以在集群下任意一台服务器（manager或者worker节点）访问nginx服务都能访问到，因为swarm创建的服务使用的是swarm集群网络。¶7. 查看服务集群情况1docker service lseg：123[root@localhost ~]# docker service lsID NAME MODE REPLICAS IMAGEv1hn945nmyds my-nginx replicated 1/1 nginx:latestREPLICAS：副本数量¶8. 集群服务扩容对my-nginx服务扩容为5个第一种方式：1docker service update --replicas 5 my-nginxeg:12345[root@localhost ~]# docker service update --replicas 5 my-nginxmy-nginx[root@localhost ~]# docker service lsID NAME MODE REPLICAS IMAGEv1hn945nmyds my-nginx replicated 5/5 nginx:latest第二种方式：1docker service scale my-nginx=512345[root@localhost ~]# docker service scale my-nginx=5my-nginx scaled to 5[root@localhost ~]# docker service lsID NAME MODE REPLICAS IMAGEv1hn945nmyds my-nginx replicated 5/5 nginx:latestupdate更多的应用场景在于image的升级导致的运行中的服务需要更新等等¶9. 删除集群服务1docker service rm my-nginx这时候所有副本都会被删除¶10. 修改服务比如修改nginx服务镜像版本为1.9.51$ docker service update --image nginx:1.9.5 my-nginx123456789101112[root@localhost ~]# docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSkzg8qncaal9a my-nginx.1 nginx:1.9.5 localhost.localdomain Running Running about a minute ago er55pvmd8fn6 \_ my-nginx.1 nginx:latest localhost.localdomain Shutdown Shutdown about a minute ago kv3t6poxh3rb my-nginx.2 nginx:1.9.5 localhost.localdomain Running Running about a minute ago tuzkxmb0th6x \_ my-nginx.2 nginx:latest localhost.localdomain Shutdown Shutdown about a minute ago edt0tg6tg120 my-nginx.3 nginx:1.9.5 localhost.localdomain Running Running about a minute ago qfwlzj8hb3gl \_ my-nginx.3 nginx:latest localhost.localdomain Shutdown Shutdown about a minute ago bb9kjj3n81yx my-nginx.4 nginx:1.9.5 localhost.localdomain Running Running about a minute ago spx8ybz9wlph \_ my-nginx.4 nginx:latest localhost.localdomain Shutdown Shutdown about a minute ago vs4akco7zpls my-nginx.5 nginx:1.9.5 localhost.localdomain Running Running about a minute ago qtaqq0jout6k \_ my-nginx.5 nginx:latest localhost.localdomain Shutdown Shutdown about a minute ago¶11. 服务回滚1docker service update --rollback¶十一、运行常用 Docker 容器示例步骤：软件镜像（安装程序）—&gt; 运行镜像 —&gt; 产生一个容器（正在运行的软件）。¶1. 安装 nginx1234567891011121314151617181920212223242526272829303132333435#拉取(下载)镜像docker pull nginx:latest#首先简单运行一个nginx临时容器，用于复制容器内部的一些nginx相关重要文件到宿主机docker run -d --name nginx nginx:latest#创建映射目录mkdir -p /opt/nginx/&#123;conf,html,logs&#125;#复制容器内部的一些nginx相关重要文件到映射目录中(注意命令中的末尾的点，它表示复制目录中的所有内容而不是整个目录本身)docker cp nginx:/etc/nginx/. /opt/nginx/confdocker cp nginx:/usr/share/nginx/html/. /opt/nginx/htmldocker cp nginx:/var/log/nginx/. /opt/nginx/logs#删除nginx临时容器docker rm -f nginx#生产环境下运行nginx容器#（1）使用host网络模式直接使用宿主机网络IP地址和端口（可以避免每次配置新的监听端口都需要重新docker run映射端口）#（2）限制内存上限为200MB#（3）指定时区并同步宿主机和容器的时间#（4）映射几个主要的nginx相关目录docker run -d \--restart always \--name nginx \--net=host \-m 200m \-e TZ=Asia/Shanghai \-v /etc/localtime:/etc/localtime:ro \-v /opt/nginx/conf:/etc/nginx \-v /opt/nginx/html:/usr/share/nginx/html \-v /opt/nginx/logs:/var/log/nginx \-v /opt/cache:/opt/cache:rw \-v /opt/ssl-certs:/opt/ssl-certs:rw \nginx:latest#防火墙设置（开放nginx默认配置的80端口）firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --reload访问地址如：http://192.168.60.201提示：Docker 安装的 nginx 容器里的默认路径下的日志文件都只是符号链接，如下：access.log -&gt; /dev/stdouterror.log -&gt; /dev/stderr这样做是方便通过 docker logs nginx 查看。如需修改为真实文件，只需修改日志路径或者文件名称即可，当然更建议针对不同网站使用不同的日志路径。¶2. 安装 tomcat123456789101112131415161718192021222324252627282930#1、搜索镜像docker search tomcat#2、拉取(下载)镜像#docker pull tomcat#这里使用的是网易镜像站的，网址：https://c.163yun.com/hub#/homedocker pull hub.c.163.com/library/tomcat#3、根据镜像实例化一个容器并运行# 选项：-d：表示后台运行；-p: 表示将主机的端口映射到容器的一个端口，如-p 主机端口:容器内部的端口。# 启动一个做了端口映射的tomcat,假设虚拟机ip为192.168.222.132,那么启动容器后访问http://192.168.222.132:8080docker run -d --name mytomcat -p 8080:8080 hub.c.163.com/library/tomcat#4、查看运行中的容器docker ps#5、查看当前所有容器docker ps -a#6、 停止运行中的容器docker stop mytomcat#7、启动容器docker start mytomcat#8、删除一个容器(需要先停止运行中的容器)docker rm mytomcat#9、查看容器的日志 docker logs container-name或者container-iddocker logs mytomcat更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档¶3. 安装 mysql1234567#获取镜像docker pull mysql#docker pull mysql:5.7 #指定版本用 :标签（版本号）#运行容器docker run -d -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 mysql#docker run -d -p 3306:3306 --name mysql5_7 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7指定 mysql 配置文件运行 mysql 容器案例示例：1234docker pull mysql:5.7mkdir /opt/mysql/conf -pmkdir /opt/mysql/data -pvim /opt/mysql/conf/my.cnf1234567891011121314151617181920## my.cnf[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录# basedir=/var/lib/mysql# 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错datadir=/var/lib/mysql/data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 最大连接数max_connections=500123#运行mysql实例docker run -d --name mysql -p 3306:3306 -v /opt/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7docker run -d --name mysql -p 3306:3306 -v /opt/mysql/conf:/etc/mysql/conf.d -v /opt/mysql/data:/var/lib/mysql/data -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7¶4. 安装 rabbitmq（1）获取镜像12#该版本包含了web控制页面docker pull rabbitmq:management（2）运行镜像12345#方式一：默认用户名和密码都是guestdocker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management#方式二：设置用户名和密码docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management（3）访问rabbitmq管理页面页面 http://ip:15672¶5. 安装 redis创建redis配置文件12345678910111213141516171819mkdir -p /opt/redis/&#123;conf,data&#125;/cat &gt; /opt/redis/conf/redis.conf &lt;&lt; 'EOF'#节点端口port 6379#访问认证密码requirepass 123456#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth 123456#日志文件和序列化文件等默认存当前目录，可修改到指定目录#dir ./#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled noEOF该原始文件可从官网下载bind 127.0.0.1 注释掉这部分，这是限制redis只能本地访问protected-mode no 默认yes，开启保护模式，限制为本地访问daemonize no#默认no 改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败databases 16 数据库个数（可选），我修改了这个只是查看是否生效。。dir ./ 输入本地 redis 数据库存放文件夹（可选）appendonly yes redis持久化（可选）requirepass 123456 配置redis访问密码运行redis镜像12345docker run -d --name redis \-v /opt/redis/conf/redis.conf:/etc/redis/redis.conf \-v /opt/redis/data:/data \-p 6379:6379 \redis:6.2.7 redis-server /etc/redis/redis.conf --appendonly yes配置防火墙123firewall-cmd --permanent --add-port=6379/tcpfirewall-cmd --reloadfirewall-cmd --list-all¶6. 安装 zookeeper1234#-Xmx指定应用程能够使用的最大内存数docker run -d --name zookeeper --restart always -e JVMFLAGS="-Xmx1024m" -p 2181:2181 zookeeperdocker exec -it zookeeper /bin/bash/apache-zookeeper-3.6.2-bin/bin/zkCli.shhttps://hub.docker.com/r/wurstmeister/kafka/¶7. 安装 kafka提前安装并启动zookeeper12345678910111213141516# KAFKA_BROKER_ID：kafka集群节点id（唯一）# KAFKA_ZOOKEEPER_CONNECT：zookeeper连接地址# KAFKA_ADVERTISED_LISTENERS：广播地址端口，即客户端访问的具体地址（会把这个地址端口注册给zookeeper，以备消费者获取）# KAFKA_LISTENERS：外部代理地址和监听端口(限制访问ip以及服务端运行的端口)# KAFKA_LOG_RETENTION_HOURS: 数据文件保留时间(非必选。缺省168小时，即7天)# KAFKA_NUM_PARTITIONS：topic的分区数(非必选)# KAFKA_DEFAULT_REPLICATION_FACTOR：分区的副本数(非必选)docker run --name kafka \-p 9092:9092 \-v /opt/kafka:/kafka \-v /etc/localtime:/etc/localtime:ro \-e KAFKA_BROKER_ID=0 \-e KAFKA_ZOOKEEPER_CONNECT=39.106.195.202:2181 \-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://39.106.195.202:9092 \-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \-d wurstmeister/kafka¶8. 安装 Linux 系统¶安装 centos 容器¶简单用法12345678#运行容器 #-d 这个参数表示的是在后台运行，即 –deamon。 #-i 表示 interactive 可交互的，让容器的标准输入（stdin）保持打开 #-t 表示给容器分配一个伪终端。 #注意：运行容器时注意加-it参数，否则运行失败docker run -itd --name centos7-test centos:centos7#进入容器内部docker exec -it centos7-test bash¶使用 ssh 服务并支持简体中文¶容器内部修改的方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869##创建容器#无服务初始化方式系统（可以不加 --privileged） #保持后台运行通过supervisor、runit、dumb-init和s6-overlay等解决，而不是用Systemddocker run -itd --name centos7-test centos:centos7 #host网络模式运行容器： #docker run -itd --restart always --name centos7-test --net=host centos:centos7 #bridge 网络模式运行容器并映射端口： #docker run -itd --restart always --name centos7-test -p 53371:22 -p 53372-53379:53372-53379 centos:centos7#使用 Systemd 初始化系统方式管理服务（可选） #使用 Systemd 管理服需要同时加 --privileged 和 /usr/sbin/init，否则报错：Failed to get D-Bus connection: Operation not permitteddocker run --privileged -itd --name centos7-test centos:centos7 /usr/sbin/init #docker run --privileged -itd --restart always --name centos7-test -p 53371:22 -p 53372-53379:53372-53379 centos:centos7 /usr/sbin/initdocker exec -it centos7-test bash#安装常用命令yum install telnet net-tools curl wget vim -y#安装opensshyum install openssh openssh-clients openssh-server -y#修改 sshd_config 配置文件 #找到 PermitRootLogin 并将其值修改为 yes，表示允许 root 管理员登录系统。将 PasswordAuthentication 的值改为 yes 表示使用帐号密码方式登录系统。 #注意：如果使用 host 网络模式创建容器，则需要将容器 ssh 程序的端口改为其他宿主机未被占用的端口，否则端口冲突导致 ssh 程序无法运行vim /etc/ssh/sshd_config#给容器的root用户设置密码passwd root##如果是无服务方式初始化系统，则如下操作：ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_keyssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key/usr/sbin/sshd #每次重启容器时需要手动执行这条命令##如果是使用 Systemd 初始化系统方式管理服务（可选），则如下操作：#systemctl 相关命令：systemctl restart|stop|start|status sshd#service 相关命令：service ssh restart|stop|start|status#启动服务（通常安装后默认都已启动）systemctl start sshd#service sshd start #如果命令不存在，可安装相关依赖：yum install -y initscripts#重启服务systemctl restart sshd#或：service sshd restart#开机启动systemctl enable sshd#或：chkconfig sshd on#通过ifconfig查看docker容器的ip，然后在宿主机上进行ssh登录。如果要在宿主机外的其他机器登录，则需要docker run时映射端口到容器的22端口，如-p 2222:22ssh root@172.18.0.3#安装简体中文语言包并修改配置以支持简体中文（CentOS官方的Docker镜像默认不支持简体中文） #查看系统支持的语言：locale -a #查看当前使用的语言包：locale #参考：https://blog.51cto.com/u_8877512/2483145yum install -y kde-l10n-Chinese glibc-common#修改配置支持简体中文 #在 /etc/bashrc 文件末尾配置 export LC_ALL=en_US.UTF-8 #下面写那么复复杂主要是防止执行多次重复添加 #注意 en_US.UTF-8 只是支持解析简体中文，而如果希望将系统信息都使用特定地区的日期、时间格式或货币格式，则可以将 en_US.UTF-8 改为 zh_CN.UTF-8 ，而如果不需要这些与地区相关的设置，那么 en_US.UTF-8 就足够了。 #虽然按道理也可以改 /etc/locale.conf 配置文件实现，但实测仅改这个文件无法解决 ping 命令含中文字符的域名时会报错的问题text_str='export LC_ALL="en_US.UTF-8"' ;\file_str='/etc/bashrc' ;\grep -v '^#' "$file_str" | grep -q "$text_str" || echo "$text_str" &gt;&gt; "$file_str"#重载配置source /etc/bashrc#退出容器并重新进入即可生效exitdocker exec -it centos7-test bash¶编写 Dockerfile 封装镜像的方式参考：https://blog.csdn.net/liuguangrong/article/details/82464139https://blog.csdn.net/kakaops_qing/article/details/109089858¶高特权用法123456#创建具有更高特权容器 #--privileged（或 --privileged=true）：表示开启特权 #使用该选项和参数，带有 --privileged 时，这个容器内的进程实质上就像直接运行在主机上一样，它会拥更高的权限，包括直接访问宿主机的硬件。 #否则执行高权限，如修改内核参数（只是可以修改内核参数而不是修改内核，如果修改宿主机的内核参数也会受到影响）、创建文件系统、创建分区、挂载分区、更改网络配置等时会报错（相关命令包括：如：sysctl、fdisk、mount 等） ##注意在使用官方的 centos 镜像创建容器使用 --privileged 时需要加在命令最后加 /usr/sbin/init，表示使用 systemd 作为第一启动程序，不加会报错。docker run --privileged -itd --name centos7-test centos:centos7 /usr/sbin/init¶安装 ubuntu 容器¶简单用法1234567#运行容器（运行容器时注意加-it参数，否则运行失败） #-d 这个参数表示的是在后台运行，即 –deamon。 #-i 表示 interactive 可交互的，以便可以从标准输入与容器交互。 #-t 表示给容器分配一个虚拟终端。docker run -itd --name ubuntu-test ubuntu:20.04#进入容器内部docker exec -it ubuntu-test bash¶使用 ssh 服务并支持简体中文¶容器内部修改的方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#运行容器（运行容器时注意加-it参数，否则运行失败） #-d 这个参数表示的是在后台运行，即 –deamon。 #-i 表示 interactive 可交互的，以便可以从标准输入与容器交互。 #-t 表示给容器分配一个虚拟终端。docker run -itd --name ubuntu-test ubuntu:20.04 #docker run -itd --restart always --name ubuntu-test -p 53371:22 -p 53372-53379:53372-53379 ubuntu:20.04#进入容器内部docker exec -it ubuntu-test bash#更新软件源，这个步骤优先级最高，因为不更新很多组件安装不了apt update#安装常用工具apt install -y telnet iputils-ping net-tools curl wget vim#安装opensshapt install -y openssh-server#修改 sshd_config 配置文件 #找到 PermitRootLogin 并将其值修改为 yes，表示允许 root 管理员登录系统。将 PasswordAuthentication 的值改为 yes 表示使用帐号密码方式登录系统。 #注意：如果使用 host 网络模式创建容器，则需要将容器 ssh 程序的端口改为其他宿主机未被占用的端口，否则端口冲突导致 ssh 程序无法运行vim /etc/ssh/sshd_config#给容器的root用户设置密码passwd root#启动ssh/usr/sbin/ssh##服务管理方式（按道理以上方式在这里无效，但在Ubuntu中service命令启动和停止可以管理ssh进程运行，具体可看/etc/init.d/ssh脚本逻辑）#service 相关命令：service ssh restart|stop|start|status#启动服务（通常安装后默认都已启动）#service ssh start#重启服务#service ssh restart#启用开机自启动#update-rc.d ssh defaults#禁止开机自启动（如需）#update-rc.d -f ssh remove#通过ifconfig查看docker容器的ip，然后在宿主机上进行ssh登录。如果要在宿主机外的其他机器登录，则需要docker run时映射端口到容器的22端口，如-p 2222:22ssh root@172.18.0.3#安装简体中文语言包并修改配置以支持简体中文（Ubuntu官方的Docker镜像默认不支持简体中文） #查看系统支持的语言：locale -a #查看当前使用的语言包：localeapt install -y language-pack-zh-hans#修改配置支持简体中文 #在 /etc/bash.bashrc 文件末尾配置 export LC_ALL="C.UTF-8" #下面写那么复复杂主要是防止执行多次重复添加 #注意 C.UTF-8 只是支持解析简体中文，而如果希望将系统信息都使用特定地区的日期、时间格式或货币格式，则可以将 C.UTF-8 改为 zh_CN.UTF-8 ，而如果不需要这些与地区相关的设置，那么 C.UTF-8 就足够了。text_str='export LC_ALL="C.UTF-8"' ;\file_str='/etc/bash.bashrc' ;\grep -v '^#' "$file_str" | grep -q "$text_str" || echo "$text_str" &gt;&gt; "$file_str"#重载配置source /etc/bash.bashrc#退出容器并重新进入即可生效exitdocker exec -it ubuntu-test bash¶编写 Dockerfile 封装镜像的方式说明：由于官方的 Ubuntu 镜像没有内置 systemd 相关依赖包，所以默认无法使用 systemd 来管理 ssh 服务，但可以使用默认的 SysVinit 启动，简单来说就是使用 service 命令来管理 ssh 服务器（如：service ssh start）。当然如果非要用 systemd 来管理 ssh 服务，官方的 Ubuntu 官方的镜像来创建容器并使之支持，操作过程会比较麻烦，如下：12345&gt;docker run -itd --name ubuntu-test ubuntu:20.04&gt;docker exec -it ubuntu-test bash&gt;apt update&gt;apt install -y systemd #安装失败，可以修改 apt 的软件源为国内源再重试&gt;ln -sf /lib/systemd/systemd /usr/sbin/init但此时容器已经创建，没法再指定 /usr/sbin/init 为第一启动程序了，当然可以通过提交容器为新镜像的方式来重新运行，并在 docker run 命令最后加上 /usr/sbin/init，表示使用 systemd 作为第一启动程序，然后就能使用 systemd 了，但很明显这一系列操作太麻烦，所以不推荐。更推荐编写 Dockerfile 封装镜像的方式，参考：https://github.com/robertdebock/docker-ubuntu-systemdhttps://github.com/eniocarboni/docker-ubuntu-systemdhttps://luckfu.com/post/ampere_a1_docker/ （手动封装）¶高特权用法12345#创建具有更高特权容器 #--privileged（或 --privileged=true）：表示开启特权 #使用该选项和参数，带有 --privileged 时，这个容器内的进程实质上就像直接运行在主机上一样，它会拥更高的权限，包括直接访问宿主机的硬件。 #否则执行高权限，如修改内核参数（只是可以修改内核参数而不是修改内核，如果修改宿主机的内核参数也会受到影响）、创建文件系统、创建分区、挂载分区、更改网络配置等时会报错（相关命令包括：如：sysctl、fdisk、mount 等）docker run --privileged -itd --name ubuntu-test ubuntu:20.04¶更多 Linux 系统参考https://virt.spiritlhl.net/guide/docker/docker_build.html （一键脚本开设含 Systemd 和 SSH 服务的 Linux 系统，支持 alpine、debian、ubuntu、almalinux）¶十二、问题排错(1)出现 Error response from daemon: oci runtime error: container_linux.go:247: start.... 报错提示。原因是系统和docker版本不兼容。解决办法：执行yum update(2)rying to pull repository docker.io/library/mysql ... Get https://registry-1.。解决办法：执行以下命令：1234$ yum install bind-utils #安装dig工具$ dig @114.114.114.114 registry-1.docker.io$ vi /etc/hosts52.54.155.177 registry-1.docker.io(3)[root@izuf6dskn3b7v2sly08bqtz ~]# docker pull mysql Using default tag: latest Trying to pull repository docker.io/library/mysql ... Get https://registry-1.docker.io/v2/: x509: certificate is valid for *.theranest.com, theranest.com, not registry-1.docker.io解决办法：镜像加速解决(3)执行docker-compose up -d后出现错误：ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule: (iptables failed: iptables --wait -t nat -I DOCKER -i br-950144d461c2 -j RETURN: iptables: No chain/target/match by that name. (exit status 1))解决办法：重启docker试试12systemctl stop dockersystemctl start docker（4）service network restart 重启网络后导致 docker 容器端口无法访问解决办法：重启 Docker 服务并重启容器12systemctl restart dockerdocker restart 容器名称/容器id¶十三、参考📚《Docker — 从入门到实践》]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个python编写的百度网盘命令行客户端]]></title>
    <url>%2Ftools%2Fbypy.html</url>
    <content type="text"><![CDATA[该命令主要是在Linux下使用，这样很大的一个好处是可以利用到百度云盘的大容量存储空间；你可以在任何服务器上，利用自动化脚本实现一些数据文件、日志文件等等备份操作，同时也提供丰富的文件列表、上传、下载、对比、同步以及批量操作等。¶1. 安装1sudo pip install bypy¶2. 百度授权首次安装之后，需要进行授权，只需要运行任何一个命令都可以，例如bypy info，然后根据提示打开网页登录你的百度网盘账号并取得授权码。12345678910111213141516qcmoke@DESKTOP-LUQTQE6:~$ bypy infoPlease visit:#打开这个如下的网址https://openapi.baidu.com/oauth/2.0/authorize?scope=basic+netdisk&amp;redirect_uri=oob&amp;response_type=code&amp;client_id=q8WE4Ep*******NBnAnd authorize this appPaste the Authorization Code here within 10 minutes.Press [Enter] when you are done#输入如下授权码并回车87559e********8d6ed22Authorizing, please be patient, it may take upto 300 seconds...Authorizing/refreshing with the OpenShift server ...OpenShift server failed, authorizing/refreshing with the Heroku server ...Heroku server failed, authorizing/refreshing with the Heroku1 server ...Successfully authorizedQuota: 2.020TBUsed: 1.124TB💁‍♂如果需要注销授权，可以删除掉目录~/ .bypy/即可。¶3. 基本使用12345678910111213141516171819[root@izwz93gbbvcxl07uju1onwz ~]# mkdir baiduyun[root@izwz93gbbvcxl07uju1onwz ~]# cd baiduyun/[root@izwz93gbbvcxl07uju1onwz baiduyun]# touch hello.txt#上传当前目录的hello.txt到百度网盘里"我的应用数据(apps)/bypy/file/"下[root@izwz93gbbvcxl07uju1onwz baiduyun]# bypy upload ./hello.txt /file/#查看百度网盘里"我的应用数据(apps)/bypy/"下的文件或者目录root@DESKTOP-LUQTQE6:~/baiduPan# bypy ls/apps/bypy ($t $f $s $m $d):D file 0 2020-04-20, 16:10:53#查看百度网盘里"我的应用数据(apps)/bypy/file/"下的文件或者目录root@DESKTOP-LUQTQE6:~/baiduPan# bypy ls /file/apps/bypy/file ($t $f $s $m $d):F hello.txt 0 2020-04-20, 16:10:53 8e23f7635tb64136eddb0719602bc477#将百度网盘里"我的应用数据(apps)/bypy/file/hello.txt"下载到用户主目录里root@DESKTOP-LUQTQE6:~/baiduPan# bypy download /file/hello.txt ~[====================] 100% (0.0B/0.0B) root@DESKTOP-LUQTQE6:~/baiduPan#root@DESKTOP-LUQTQE6:~/baiduPan# ls ~baiduPan hello.txt💁‍♂ 提示：在云盘里面出现一个我的应用数据这里面有一个bypy的文件夹.这个就是你的工具的根目录,你要上传下载的文件都在这里面而不是其他的地方。📑 其他命令：更详细的了解某一个命令：bypy help显示在云盘（程序的）根目录下文件列表：bypy list把当前目录同步到云盘：bypy syncup 或者bypy upload把云盘内容同步到本地来：bypy syncdown --downloader aria2或者bypy downdir / --downloader aria2这个命令不好用,要在后面加 –downloader aria2,要不没有速度比较本地当前目录和云盘（程序的）根目录（个人认为非常有用）：bypy compare下载文件 bypy downfile 下载文件名上传文件 bypy upload 文件名在远端创建文件夹tmp bypy mkdir tmp/bypy运行时添加\ -v\ 参数，会显示进度详情。运行时添加\ -d\ ，会显示一些调试信息。运行时添加\ -ddd\ ，还会会显示HTTP通讯信息（\ 警告：非常多\ ）bypy upload localfile cloudfile bypy upload ./123.txt /cloud.将本地123.txt文件上传到云盘我的应用程序(apps) /bypy/cloud 文件夹内.也可上传整个文件夹，命令示例如下：bypy upload /123 /cloud.将本地123文件夹内所有文件上传到云盘 apps/bypy/cloud 文件夹内.¶4. 常见问题123456789101112[root@izwz93gbbvcxl07uju1onwz ~]# bypy info/usr/lib/python2.7/site-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.25.9) or chardet (2.2.1) doesn't match a supported version! RequestsDependencyWarning)Quota: 2.020TBUsed: 1.117TB#解决方案，制裁urllib3 和chardetsudo pip uninstall urllib3sudo pip uninstall chardet#然后，再卸载从新安装requestssudo pip uninstall requestssudo pip install requests]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>bypy</tag>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node版本管理工具nvm]]></title>
    <url>%2Ftools%2Fnvm.html</url>
    <content type="text"><![CDATA[¶1. 背景可能由于多个开发项目需要的nodejs版本不一样，以至于需要频繁的切换版本，为了方便快捷的切换版本，使用nvm进行版本管理尤为重要。下面就来介绍Windows10安装和配置nvm的全过程。¶2. 下载官方下载地址：nvm downloadnvm-noinstall.zip： 绿色免安装版本，但是使用之前需要配置nvm-setup.zip：安装包，下载之后点击安装，无需配置就可以使用，方便。Source code(zip)：zip压缩的源码Sourc code(tar.gz)：tar.gz的源码，一般用于 linux 系统我在这里下载的版本是1.1.7，安装包格式是nvm-noinstall.zip¶3. 安装（1）安装前把原有node卸载干净。（2）还要删除掉默认的依赖包目录和缓存目录。C:\Users\用户名\AppData\Roaming\npmC:\Users\用户名\AppData\Roaming\npm-cache（3）此外原来的node环境变量也要删除掉。解压zip包到D:\Development\node\nvm-noinstall目录里。见到如图提示输入压缩包解压的绝对路径。注意路径不支持空格，不能设为类似C:\Program Files这种，否则node可能无法使用。在D:\Development\node\nvm-noinstall目录里创建文件settings.txt。其内容为如下：123456root: D:\Development\node\nvm-noinstallpath: D:\Development\node\nodejsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/root：表示安装node是存储的路径。默认就是nvm的安装路径。path：表示当前使用的node版本目录，会根据nvm版本选择的变化，path的内容也会变化。事实path就是一个快捷链接，指向了root目录中的指定版本。arch：系统架构版本设置为64位。proxy：不使用代理。node_mirror和npm_mirror所有版本都使用淘宝镜像。¶4. 配置环境变量配置一下环境变量到系统中。NVM_HOME：D:\Development\node\nvm-noinstallNVM_SYMLINK：D:\Development\node\nodejsPATH：%NVM_HOME% 和 %NVM_SYMLINK% (在PATH的最后添加)¶5. 安装使用指定版本 node12nvm install 12.14.1nvm use 12.14.1 #这一步一定要管理员身份执行，要不然报错：exit status 1: “乱码”¶6. npm全局依赖目录配置123#配置用npm下载全局包时全局依赖包安装和缓存的路径npm config set prefix "E:\Cache\node\node_global"npm config set cache "E:\Cache\node\node_cache"提示：添加 E:\Cache\node\node_global 到 PATH 系统环境变量中，否则 npm 全局安装的命令会找不到。设置后所有版本的 nodejs 就都共用相同的全局依赖包安装和缓存的路径了。12#查看是否修改完成npm config get¶7. nvm常用命令123456789101112131415161718192021222324252627282930#显示可下载版本的部分列表nvm list available#列出所有安装的版本nvm ls#安装指定版本nvm install &lt;version&gt;#安装最新版本nvm install latest#卸载删除已安装的指定版本，语法与install类似nvm uninstall &lt;version&gt;#切换使用指定的版本nodenvm use &lt;version&gt;#切换制定的node版本和位数nvm use [version] [arch]#显示当前nvm的版本nvm version#给不同的版本号添加别名nvm alias &lt;name&gt; &lt;version&gt;#删除已定义的别名nvm unalias &lt;name&gt;#在当前版本node环境下，重新全局安装指定版本号的npm包nvm reinstall-packages &lt;version&gt;#显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构nvm arch [32|64]#启用node.js版本管理。nvm on#禁用node.js版本管理(不卸载任何东西)nvm off#设置和查看root路径nvm root [path]¶8. Linux安装nvm1234curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bashsource ~/.bashrcnvm install 12.14.1]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于代理技术的理解]]></title>
    <url>%2Ftools%2Fproxy_study.html</url>
    <content type="text"><![CDATA[正向代理：假设A是客户端（访问资源的请求方，处于内网中），这里以A所在的网络为内网做为参照，B是代理服务器（数据转发的中间者，既处于内网又处于外网），C是web服务器（接收请求的服务方，对于A来说处于外网中）。由于各种网络原因A无法访问C（可以理解A处于内网中，A与C不在一个网络中，故无法访问），但A能够访问B（A和B处于一个内网中），B能够访问C（B和C都处于一个外网中），那么A就可以通过B做一个桥梁去访问C，即A去访问B，B再去访问C。B在这个过程中就负责转发A和C之间的数据包。当C收到B的请求后，将数据发送回给B，B再转发数据给A，A最终就能得到了想要的数据。数据传输的过程图：A—&gt;B—&gt;C----&gt;B-----&gt;A特点：A向C访问数据时，对于用户来说B是不可见的。比如国内的某个用户想要访问google搜索页面，但由于你懂得的原因是访问不了的。所以他大胆地配置了一台代理服务器，在代理服务器上安装了代理服务软件，并且在自己的本机上安装了代理客户软件，那么他就可以直接在浏览器输入https://www.google.com来访问google搜索页面了，注意，虽然他向google web服务器的请求对于机器来说首先是发送到代理服务器的，但是他并不是输入代理服务器的域名或者ip路径。所以说代理服务器对于用户每次访问外网资源来说是透明不可见的。从这个例子可看出用户访问外网的服务器资源是看似直接正向地访问的，即对用户来说访问外网服务器资源是正向代理的访问过程。反向代理：与正向代理的原理也是很类似的。这里仍然以A所在的网络为内网做为参照，即各个主机处于内网和外网的概念没有改变，即：A 仍然处于内网中，A和B处于一个内网，B又和C处于一个外网。但此时主机(计算机)角色变了，即：A是web服务器（接收请求的服务方，处于内网中），B是代理服务器（数据转发的中间者，即处于内网又处于外网，角色没有变），C是客户端（访问资源的请求方，处于外网中）。现在变成了C去访问A，由于A处于自己所在的内网中，故C在外网中无法访问（找到）A（C和A不在一个网络中，故无法访问），但C能访问B（C和B都处于一个外网中），B能访问A（B和C都处于一个外网中），故C可以访问B，B再去访问A，A收到请求后将数据发送给B，B再将数据转发给C，C最终获得了想要的数据。特点：C访问A的过程中，对于用户来说A是不可见的，可见的只有B。比如：用户通过C访问A的时候，用户只知道B的域名和ip，并不知道A的域名和ip。用户直接发送请求给B，然后B再返回信息给用户，至于B怎么得到的数据，对于用户来说是看不见的。数据传输的过程图：C—&gt;B—&gt;A----&gt;B-----&gt;C 。 刚好A和C的位置和正向代理中A和C的位置相反，故反向代理由此得出。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>正向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7安装oracle 11g r2]]></title>
    <url>%2Fdevops%2Foracle.html</url>
    <content type="text"><![CDATA[本文记录从无到有部署一个CentOS 7+Oracle 11gR2单实例，做为主要学习试验环境。由于本人在安装的过程中踩了很多次坑，故下定决心将实战过程记录下来，希望对众网友有所帮助。¶一、前置准备¶1. 检查系统安装条件123456#物理内存不小于1G: 查看方式:$ grep MemTotal /proc/meminfo#可用硬盘不小于8G: 查看方式:$ df -hl#Swap分区空间不小于2G(实测512M也可): 查看方式（如果swap空间为空则可以根据第五大点“问题解决方案”的办法来解决）:$ grep SwapTotal /proc/meminfo¶2. 关闭firewalld防火墙123$ systemctl status firewalld.service #查看firewalld防火墙状态$ systemctl stop firewalld.service #关闭firewalld防火墙$ systemctl disable firewalld.service #禁止开机使用firewalld防火墙¶3. 修改系统标识和内核参数由于Oracle默认不支持CentOS，故需要修改,修改系统标识文件1$ vim /etc/redhat-release12#将文件内容替换为redhat-7redhat-7修改内核参数文件1$ vim /etc/sysctl.conf1234567891011121314#在最后添加以下内容fs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmmni = 4096kernel.sem = 250 32000 100 128kernel.shmall = 2097152kernel.shmmax = 2147483648net.ipv4.ip_local_port_range = 9000 65500net.ipv4.icmp_echo_ignore_broadcasts = 1net.ipv4.conf.all.rp_filter = 1net.core.rmem_default = 262144net.core.rmem_max= 4194304net.core.wmem_default= 262144net.core.wmem_max= 1048576修改完后,启用新的配置1$ sysctl -p¶4. 安装依赖库1$ yum -y install binutils* compat-libcap1* compat-libstdc++* gcc* gcc-c++* glibc* glibc-devel* ksh* libaio* libaio-devel* libgcc* libstdc++* libstdc++-devel* libXi* libXtst* make* sysstat* elfutils* unixODBC* unzip lrzsz¶5. 创建用户以及组123456$ groupadd oinstall #创建安装oracle程序用户组 $ groupadd dba #创建DBA用户组$ useradd -g dba -m oracle #创建用户oracle 并加入到dba组$ usermod -a -G oinstall oracle #将用户oracle加入到oinstall组$ passwd oracle #修改用户oracle的密码$ id oracle #查看用户oracle的信息¶6. 创建安装目录并设置权限123456789#创建相关目录$ mkdir -p /data/oracle #创建oracle主目录$ mkdir -p /data/inventory #创建oralce配置目录$ mkdir -p /data/src #创建oracle压缩包解压目录#修改目录权限$ chown -R oracle:oinstall /data/oracle $ chown -R oracle:oinstall /data/inventory $ chown -R oracle:oinstall /data/src1$ ll /data #查看目录权限¶7. 修改oracle用户的安全性能设置1$ vim /etc/security/limits.conf12345#在文件最后一行前,追加以下内容oracle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536¶8. 修改用户环境变量修改用户环境变量文件1$ vim /home/oracle/.bashrc12345678910#在最后追加以下内容export PATHexport ORACLE_BASE=/data/oracleexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1export ORACLE_SID=orclexport ORACLE_UNQNAME=orclexport PATH=$ORACLE_HOME/bin:/usr/sbin:$PATHexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/libexport LANG=Cexport NLS_LANG=AMERICAN_AMERICA.AL32UTF8修改完后立即启用生效:1$ source /home/oracle/.bashrc¶9. 关闭selinux修改selinux配置文件1$ vim /etc/selinux/config12SELINUX=disabled #修改SELINUX的值为disabledSELINUXTYPE=targeted保存后需要重启机器1$ reboot¶二、安装Oracle¶1. 下载安装包下载地址:https://www.oracle.com/database/technologies/112010-linx8664soft.html下载两个oracle安装包：linux.x64_11gR2_database_1of2.zip 和 linux.x64_11gR2_database_2of2.zip💁‍♂温馨提示：如果官方下载地址失效，可到本人网盘下载：链接：https://pan.baidu.com/s/1YwFRecm1_O3pA5efxak7iw提取码：e5rj¶2. 解压安装包到安装目录12$ unzip linux.x64_11gR2_database_1of2.zip -d /data/src/$ unzip linux.x64_11gR2_database_2of2.zip -d /data/src/¶3. 设置安装目录权限1$ chown -R oracle:oinstall /data/src/12#查看目录权限$ ll /data/src/¶4. 安装Oracle切换为Oracle用户1$ su oracle修改静默安装响应文件1$ vim /data/src/database/response/db_install.rsp123456789101112131415161718#修改以下内容oracle.install.option=INSTALL_DB_SWONLY # 安装类型ORACLE_HOSTNAME=oracle.server # 主机名称UNIX_GROUP_NAME=oinstall # 安装组INVENTORY_LOCATION=/data/inventory # INVENTORY目录SELECTED_LANGUAGES=en,zh_CN # 选择语言ORACLE_HOME=/data/oracle/product/11.2.0/db_1 # oracle_homeORACLE_BASE=/data/oracle # oracle_baseoracle.install.db.InstallEdition=EE # oracle版本oracle.install.db.DBA_GROUP=dba # dba用户组oracle.install.db.OPER_GROUP=oinstall # oper用户组oracle.install.db.config.starterdb.type=GENERAL_PURPOSE # 数据库类型oracle.install.db.config.starterdb.globalDBName=orcl # globalDBNameoracle.install.db.config.starterdb.SID=orcl # SIDoracle.install.db.config.starterdb.characterSet=AL32UTF8 # 默认数据库编码oracle.install.db.config.starterdb.memoryLimit=800 # 自动管理内存的最小内存(M)oracle.install.db.config.starterdb.password.ALL=oracle # 设定所有数据库用户使用同一个密码DECLINE_SECURITY_UPDATES=true # 设置安全更新启动安装程序1$ /data/src/database/runInstaller -silent -responseFile /data/src/database/response/db_install.rsp -ignorePrereq漫长的等待…(时间的话看机器性能咯)当出现如下画面时候,请照做要执行配置脚本,请执行以下操作:(1)打开另外一个终端窗口（注意是另外一个终端窗口）(2)以&quot;root&quot;身份登陆(3)运行脚本12$ /data/inventory/orainstRoot.sh$ /data/oracle/product/11.2.0/db_1/root.sh(5)返回此窗口并按&quot;Enter&quot;键继续到这里Oracle主程序就安装完啦…¶5. 配置Oracle监听程序编辑监听配置文件1$ vim /data/src/database/response/netca.rsp修改以下参数12345INSTALL_TYPE=""custom"" # 安装的类型LISTENER_NUMBER=1 # 监听器数量LISTENER_NAMES=&#123;"LISTENER"&#125; # 监听器的名称列表LISTENER_PROTOCOLS=&#123;"TCP;1521"&#125; # 监听器使用的通讯协议列表LISTENER_START=""LISTENER"" # 监听器启动的名称执行命令安装监听程序:1$ /data/oracle/product/11.2.0/db_1/bin/netca /silent /responseFile /data/src/database/response/netca.rsp默认安装后就会启动，查看监听程序是否运行1$ netstat -tnulp | grep 1521¶6. 配置数据库实例编辑数据库实例文件1$ vim /data/src/database/response/dbca.rsp123456789101112131415161718#修改以下参数RESPONSEFILE_VERSION = "11.2.0" # 不要变哦OPERATION_TYPE = "createDatabase" # 操作为创建实例 GDBNAME ="orcl" # 数据库实例名(有两行都要改)SID ="orcl" # 实例名字TEMPLATENAME = "General_Purpose.dbc" # 建库用的模板文件(有4行，都要改)#配置管理员密码（以下每个变量都可能会有多行，每个变量只需要去掉注释仅保留一行并修改即可）SYSPASSWORD = "oracle"SYSTEMPASSWORD = "oracle"SYSMANPASSWORD= "oracle" DBSNMPPASSWORD= "oracle"DATAFILEDESTINATION =/data/oracle/oradata # 数据文件存放目录RECOVERYAREADESTINATION=/data/oracle/flash_recovery_area # 恢复数据存放目录CHARACTERSET ="AL32UTF8" # 字符集NATIONALCHARACTERSET= "AL16UTF16" # 字符集TOTALMEMORY ="1638" # 1638MB，物理内存2G*80%。¶7. 创建数据库实例执行以下命令创建数据库实例1$ /data/oracle/product/11.2.0/db_1/bin/dbca -silent -responseFile /data/src/database/response/dbca.rsp查看实例是否运行1$ ps -ef | grep ora_ | grep -v grep¶8. 启动和关闭oracle服务¶8.1 启动12345su - oracle#开启监听:$ /data/oracle/product/11.2.0/db_1/bin/lsnrctl start#启动数据库实例（执行脚本+具体的数据库实例）:$ /data/oracle/product/11.2.0/db_1/bin/dbstart /data/oracle/product/11.2.0/db_1或者12345su - oraclelsnrctl start #启动oracle服务监听sqlplus /nologconn /as sysdbastartup #启动数据库实例¶8.2 关闭12345su - oracle#关闭监听:$ /data/oracle/product/11.2.0/db_1/bin/lsnrctl stop#关闭数据库实例（执行脚本+具体的数据库实例）:$ /data/oracle/product/11.2.0/db_1/bin/dbshut /data/oracle/product/11.2.0/db_1或者12345su - oraclelsnrctl stop #关闭oracle服务监听sqlplus /nologconn /as sysdbashut #关闭数据库实例¶10. 开机自启动Oracle服务对于以上，每次重启都需要手动执行相关命令来开启Oracle实例，为了不用每次开机都有手动启动Oracle，可以设置开机自启动Oracle服务。oracle用户模式下修改oracle相关文件:1$ su oracle12345$ vim /etc/oratab#修改以下内容，N改为Y。要自动启动数据库实例，则将N改为Y，在调用dbstart命令时生效。dbstart根据这些配置来启动相应的数据库实例。#orcl:/data/oracle/product/11.2.0/db_1:Norcl:/data/oracle/product/11.2.0/db_1:Yroot用户模式下修改linux自启动配置文件:12$ su$ chmod +x /etc/rc.d/rc.local12345$ vim /etc/rc.d/rc.local#在文件最后追加以下内容：su oracle -lc "/data/oracle/product/11.2.0/db_1/bin/lsnrctl start"su oracle -lc "/data/oracle/product/11.2.0/db_1/bin/dbstart /data/oracle/product/11.2.0/db_1"¶三、客户端连接oracle实例¶1. sqlplus连接当前服务器的sqlplus客户端直接连接12$ su oracle$ sqlplus sys/oracle as sysdba创建用户12SQL&gt; create user qcmoke identified by 123456;SQL&gt; grant connect,resource to qcmoke;¶2. PLSQL Developer客户端连接①安装PLSQL Developer官方下载地址：https://www.allroundautomations.com/傻瓜式安装完即可。②安装oracle客户端插件instantclient客户端插件官方下载地址：https://www.oracle.com/database/technologies/instant-client/downloads.html注意：如果PLSQL Developer是64位那么instantclient也要是64位，如果PLSQL Developer是32位，那么instantclient也要是32位。下载包如下：32位：instantclient-basic-nt-11.2.0.4.0.zip64位：instantclient-basic-windows.x64-11.2.0.4.0.zip下载后解压到任意目录下即完成安装。此外还需要配置监听文件，在instantclient目录下新建network/admin目录，在该目录下建立tnsnames.ora文件，在tnsnames.ora中写入数据库连接字符串，示例如下：123456789ORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 39.106.195.202)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = orcl) ) )③PLSQL Developer配置instantclient插件④PLSQL Developer登录密码是oracle⑤创建并授权用户¶3. Navicat客户端连接配置instantclient插件，但不需要像PLSQL Developer那样还需要配置监听文件tnsnames.ora登录密码是oracle¶五、问题解决方案¶1. 设置启动脚本（可选）123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost ~]# vim /etc/init.d/oracle#!/bin/sh # chkconfig: 345 61 61 # description: Oracle 11g R2 AutoRun Servimces # /etc/init.d/oracle # # Run-level Startup script for the Oracle Instance, Listener, and # Web Interface export ORACLE_BASE=/data export ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/db_1 export ORACLE_SID=ORCL export PATH=$PATH:$ORACLE_HOME/bin ORA_OWNR="oracle" # if the executables do not exist -- display error if [ ! -f $ORACLE_HOME/bin/dbstart -o ! -d $ORACLE_HOME ] then echo "Oracle startup: cannot start" exit 1 fi # depending on parameter -- startup, shutdown, restart # of the instance and listener or usage display case "$1" in start) # Oracle listener and instance startup su $ORA_OWNR -lc $ORACLE_HOME/bin/dbstart echo "Oracle Start Succesful!OK." ;; stop) # Oracle listener and instance shutdown su $ORA_OWNR -lc $ORACLE_HOME/bin/dbshut echo "Oracle Stop Succesful!OK." ;; reload|restart) $0 stop $0 start ;; *) echo $"Usage: `basename $0` &#123;start|stop|reload|reload&#125;" exit 1 esac exit 012service oracle start #开启服务，包括开启监听+开启实例service oracle stop #关闭服务，包括关闭监听+关闭实例¶2. swap不足报错报错：Checking swap space: 0 MB available, 150 MB required. Failed &lt;&lt;&lt;&lt;当运行如下安装命令报错：12345678910111213[oracle@localhost database]$ ./runInstaller -silent -responseFile /home/oracle/db_install.rspStarting Oracle Universal Installer...Checking Temp space: must be greater than 120 MB. Actual 150565 MB PassedChecking swap space: 0 MB available, 150 MB required. Failed &lt;&lt;&lt;&lt;Some requirement checks failed. You must fulfill these requirements beforecontinuing with the installation,Exiting Oracle Universal Installer, log for this session can be found at /tmp/OraInstall2017-06-07_02-08-39PM/installActions2017-06-07_02-08-39PM.log解决方法：1、检查 Swap 空间在设置 Swap 文件之前，有必要先检查一下系统里有没有既存的 Swap 文件。运行以下命令：1$ swapon -s如果返回的信息概要是空的，则表示 Swap 文件不存在。2、检查文件系统在设置 Swap 文件之前，同样有必要检查一下文件系统，看看是否有足够的硬盘空间来设置 Swap 。运行以下命令：1$ df -hal3、创建并允许 Swap 文件下面使用 dd 命令来创建 Swap 文件。检查返回的信息，还剩余足够的硬盘空间即可。1$ dd if=/dev/zero of=/swapfile bs=1024 count=512k参数解读：if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;bs=bytes：同时设置读入/输出的块大小为bytes个字节count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。4、格式化并激活 Swap 文件上面已经创建好 Swap 文件，还需要格式化后才能使用。1$ mkswap /swapfile激活 Swap1$ swapon /swapfile以上步骤做完，再次运行命令1234$ swapon -s#你会发现返回的信息概要：Filename Type Size Used Priority/swapfile file 524284 0 -1机器重启的时候自动挂载 Swap1$ vim /etc/fstab12#在/etc/fstab最后添加如下一行/swapfile swap swap defaults 0 0最后，赋予 Swap 文件适当的权限：12$ chown root:root /swapfile $ chmod 0600 /swapfile¶3. 禁止oracle用户ssh登录可以将oracle用户添加到禁止SSH登录的名单中，防止破解登录。但可以通过其他用户登录到服务器后切换到oracle用户。123$ vim /etc/ssh/sshd_config#在最后添如下配置DenyUsers oracle1234567#重新启动sshd服务$ service sshd restart或者#重新加载sshd配置文件$ service sshd reload¶六、19C安装需要提前下载好oracle19c的安装包：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c，下载Linux x86-64的ZIP包即可，下载后得到LINUX.X64_193000_db_home.zip。¶1、禁用防火墙和 selinux12345$ systemctl stop firewalld.service$ systemctl disable firewalld.service$ systemctl status firewalld.service$ sed -i 's@SELINUX=enforcing@SELINUX=disabled@g' /etc/selinux/config¶2、创建用户和组、安装目录以及设置权限123456789$ /usr/sbin/groupadd -g 65431 oinstall$ /usr/sbin/groupadd -g 65432 dba$ /usr/sbin/groupadd -g 65433 oper$ useradd -u 61001 -g oinstall -G dba,oper -m oracle$ echo "123456" | passwd --stdin oracle$ mkdir -p /data1/app/oracle/product/19.3.0/dbhome_1$ mkdir -p /data1/app/oraInventory$ chown -R oracle:oinstall /data1$ chmod -R 775 /data1¶3、修改用户安全限制12345678$ cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOForacle soft nproc 16384oracle hard nproc 16384oracle soft nofile 16384oracle hard nofile 65536oracle soft stack 10240oracle hard stack 32768EOF¶4、shell限制1$ echo "session required pam_limits.so" &gt;&gt; /etc/pam.d/login¶5、修改内核参数1234567891011121314151617$ cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOFfs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmall = 424673kernel.shmmax = 1739461754kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576kernel.panic_on_oops = 1EOF#修改后执行$ sysctl -p提示：kernel.shmmax和kernel.shmall的配置需要特别注意参数设置计算：kernel.shmmax = 当前内存GB * 1024 * 1024 * 1024 * 0.9注：当前内存推荐至少4GBkernel.shmall = kernel.shmmax / kernel.shmmni详细解释：shmall 是全部允许使用的共享内存大小shmmax 是单个段允许使用的大小这两个可以设置为内存的 90%例如 16G 内存，1610241024102490% = 15461882265shmall 的大小为 15461882265/4k(getconf PAGESIZE可得到) = 3774873¶6、设置用户环境变量123456789101112131415161718192021222324252627282930313233#切换到oracle用户$ su - oracle$ vi .bash_profile#再尾部加配置如下：# User specific environment and startup programs#PS1="[`whoami`@`hostname`:"'$PWD]$'#export PS1export TMP=/tmpexport LANG=en_US.UTF-8export TMPDIR=$TMPexport ORACLE_UNQNAME=xtcrmexport ORACLE_SID=xtcrmexport ORACLE_BASE=/data1/app/oracleexport ORACLE_HOME=$ORACLE_BASE/product/19.3.0/dbhome_1export ORACLE_TERM=xtermexport NLS_DATE_FORMAT="yyyy-mm-dd HH24:MI:SS"export NLS_LANG=AMERICAN_AMERICA.ZHS16GBKexport PATH=.:$PATH:$HOME/.local/bin:$HOME/bin:$ORACLE_HOME/binexport THREADS_FLAG=nativeumask=022if [ $USER = "oracle" ]; thenif [ $SHELL = "/bin/ksh" ]; thenulimit -p 16384ulimit -n 65536elseulimit -u 16384 -n 65536fiumask 022fi#设置环境变量生效$ source .bash_profile¶7、依赖和安装包准备123456789101112#注：从oracle 18c开始，必须把压缩文件解压到 $ORACLE_HOME 里面$ su$ mkdir /oracle_install#安装依赖（可以先到一台同样配置通外网的机器下载依赖，然后再在内网机器安装）$ yum install --downloadonly --downloaddir=/oracle_install/base bc gcc gcc-c++ binutils compat-libcap1 compat-libstdc++ dtrace-modules dtrace-modules-headers dtrace-modules-provider-headers dtrace-utils elfutils-libelf elfutils-libelf-devel fontconfig-devel glibc glibc-devel ksh libaio libaio-devel libdtrace-ctf-devel libX11 libXau libXi libXtst libXrender libXrender-devel libgcc librdmacm-devel libstdc++ libstdc++-devel libxcb make smartmontools sysstat unzip vim wget telnet#把下载好的LINUX.X64_193000_db_home.zip压缩包放到/oracle_install里$ mv LINUX.X64_193000_db_home.zip /oracle_install$ chown -R oracle:oinstall /oracle_install &amp;&amp; chmod -R 775 /oracle_install$ rpm -ivh /oracle_install/base/*.rpm --force --nodeps¶8、静默安装oracle123456789101112131415161718192021222324252627282930#解压缩到$ORACLE_HOME里$ su - oracle$ cd $ORACLE_HOME$ unzip -q /oracle_install/LINUX.X64_193000_db_home.zip$ /data1/app/oracle/product/19.3.0/dbhome_1/runInstaller -ignorePrereq -waitforcompletion -silent \-responseFile /data1/app/oracle/product/19.3.0/dbhome_1/install/response/db_install.rsp \oracle.install.option=INSTALL_DB_SWONLY \UNIX_GROUP_NAME=oinstall \INVENTORY_LOCATION=/data1/app/oraInventory \SELECTED_LANGUAGES=en,en_GB \ORACLE_HOME=/data1/app/oracle/product/19.3.0/dbhome_1 \ORACLE_BASE=/data1/app/oracle \oracle.install.db.InstallEdition=EE \oracle.install.db.OSDBA_GROUP=dba \oracle.install.db.OSOPER_GROUP=oper \oracle.install.db.OSBACKUPDBA_GROUP=dba \oracle.install.db.OSDGDBA_GROUP=dba \oracle.install.db.OSKMDBA_GROUP=dba \oracle.install.db.OSRACDBA_GROUP=dba \SECURITY_UPDATES_VIA_MYORACLESUPPORT=false \DECLINE_SECURITY_UPDATES=true#输出如下信息表示此步骤正确#Successfully Setup Software with warning(s).#切换到root用户，依次执行以下2个脚本$ su$ /data1/app/oraInventory/orainstRoot.sh$ /data1/app/oracle/product/19.3.0/dbhome_1/root.sh¶9、启动监听服务器123$ su - oracle $ cd $ORACLE_HOME$ lsnrctl start¶10、创建数据库123456789101112131415161718$ su - oracle &amp;&amp; cd $ORACLE_HOME#响应文件: $ORACLE_HOME/assistants/dbca/dbca.rsp$ dbca -silent -createDatabase \-templateName General_Purpose.dbc \-gdbname xtcrm \-sid xtcrm \-databaseConfigType SI \-createAsContainerDatabase TRUE \-numberOfPDBs 1 \-pdbName pdb \-useLocalUndoForPDBs TRUE \-pdbAdminPassword 123456 \-sysPassword 123456 \-systemPassword 123456 \-characterSet AL32UTF8 \-memoryPercentage 30 \-datafileDestination /data1/app/oracle/oradata-recoveryAreaDestination /data1/app/oracle/flash_recovery_area1234$ sqlplus / as sysdbaSQL&gt; alter session set "_ORACLE_SCRIPT"=true; SQL&gt; create user qcmoke identified by 123456;SQL&gt; grant connect,resource,dba to qcmoke;其他操作：12345#查看oracle版本SQL&gt; select * from v$version;#查看字符编码SQL&gt; select userenv('language') from dual;]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins学习笔记]]></title>
    <url>%2Fjavaee%2Fjenkins.html</url>
    <content type="text"><![CDATA[自动化部署（持续集成/CI+持续交付/CD）不仅可以提升开发效率，让程序员更专注产品与业务的开发，还可以节省很多运维成本以及提升运维效率。其中，Jenkins就是自动化部署中最流行的工具，会使用这个技术将会让软件部署变得更加便捷和高效。¶一、docker安裝¶1. 安装Jenkins123$ docker pull jenkins/jenkins:lts$ mkdir /data/jenkins_home &amp;&amp; chown -R 1000:1000 /data/jenkins_home$ docker run -d --name jenkins -p 8081:8080 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:lts备注：-d ： 启动在后台–name： 容器名字-p： 端口映射（8081：宿主主机端口，8080：容器内部端口）-v： 数据卷挂载映射（/data/jenkins_home：宿主主机目录，另外一个即是容器目录）enkins/jenkins:lts：Jenkins镜像（最新版）参考：https://developer.aliyun.com/article/742451¶2. 安装中文社区插件123$ cd /data/jenkins_home/plugins$ wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/localization-zh-cn/latest/localization-zh-cn.hpi$ wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/localization-support/latest/localization-support.hpi浏览器访问Jenkins后台web页面：http://39.106.195.202:8081在安装完成后，默认生成了一个登录密码，首次登录需要这个密码。可通过如下命令查看密码：1$ cat /data/jenkins_home/secrets/initialAdminPassword访问：http://39.106.195.202:8081/chinese将https://updates.jenkins-zh.cn/update-center.json填入下图中然后点击提交然后再访问http://39.106.195.202:8081参考：Jenkins 插件中心 国内镜像源配置解决方案：https://jenkins-zh.cn/wechat/articles/2019/11/2019-11-11-update-center-mirror-announcement/¶3. 安装主要插件¶3.1 Maven Integration plugin¶4. 插件离线安装官方插件下载：https://plugins.jenkins.io/国内插件镜像下载：https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/¶二、Linux安装¶1、安装需要配置好jdk环境，然后再下载安装。12345#下载和安装部署wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war#运行java -jar jenkins.war --httpPort=8080访问管理页面： http://ip:8080（注意开放服务器端口，对于阿里云等默认屏蔽端口的服务商还需要到阿里云管理后台开放防火墙端口）需要填写密码才能进入管理主页，初始密码可通过以下查看：1cat /root/.jenkins/secrets/initialAdminPassword¶2、tomcat集成Jenkins编辑conf/tomcat-users.xml12345&lt;role rolename="manager-gui"/&gt;&lt;role rolename="manager-script"/&gt;&lt;role rolename="manager-jmx"/&gt;&lt;role rolename="manager-status"/&gt;&lt;user username="tomcat_user" password="123456" roles="manager-gui,manager-script,manager-jmx,manager-status" /&gt;此外还要编辑 webapps/manager/META-INF/context.xml 文件注释掉以下部分1234&lt;!--&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt;--&gt;将之前下载的jenkins.war包复制到 tomcat 的webapps目录中。然后启动tomcat，让tomcat来启动jenkins。1apache-tomcat-8.5.31/bin/startup.sh访问管理页面： http://ip:8080/jenkins¶3、安装插件选择安装推荐插件即可。安装Maven Integration pluginDeploy to container]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo学习笔记]]></title>
    <url>%2Fjavaee%2Fdubbo.html</url>
    <content type="text"><![CDATA[¶一、发展演变单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。缺点： 1、性能扩展比较难​ 2、协同开发问题​ 3、不利于升级维护垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。缺点： 公用模块无法重复利用，开发性的浪费分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的****分布式服务框架(RPC)****是关键。流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。¶二、RPC的概念¶1、RPC概念RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。¶2、RPC基本原理RPC两个核心模块：通讯，序列化。¶三、Dubbo核心概念¶1、简介Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。官网：http://dubbo.apache.org/¶2、基本概念组件角色服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心调用关系说明l 服务容器负责启动，加载，运行服务提供者。l 服务提供者在启动时，向注册中心注册自己提供的服务。l 服务消费者在启动时，向注册中心订阅自己所需的服务。l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。¶四、Dubbo环境搭建¶1、安装注册中心Zookeeper（windows）¶1.1 下载zookeeper官网下载网址 https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/¶1.2 解压zookeeper解压后运行zkServer.cmd，初次运行会报错，原因是没有zoo.cfg配置文件。¶1.3 修改zoo.cfg配置文件将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：12dataDir=../data #临时数据存储的目录（可写相对路径）clientPort=2181 #zookeeper的端口号修改完成后再次启动zkServer.cmd¶1.4 测试是否搭建完成点击运行zkCli.cmd123ls / #列出zookeeper根下保存的所有节点create -e /qcmoke 123456 #创建一个qcmoke节点，值为123456get /qcmoke #获取/qcmoke节点的值，如果出来数据就表示搭建完成Zookeeper是一个树型的目录服务，支持变更推送，可作为 Dubbo 服务的注册中心。¶2、安装管理控制台dubbo-admin¶2.1下载dubbo-admin下载地址：https://github.com/apache/incubator-dubbo-ops2.2 进入dubbo-admin目录，修改dubbo-admin配置修改src\main\resources\application.properties 指定zookeeper地址。123spring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181¶2.3 运行打包在dubbo-admin/目录里执行命令运行打包dubbo-admin1mvn clean package -Dmaven.test.skip=true¶2.4 运行dubbo-admin在dubbo-admin/target目录里执行命令运行dubbo-admin1java -jar dubbo-admin-0.0.1-SNAPSHOT.jar #注意要先启动zookeeper¶2.5 访问监控管理控制台http://localhost:7001默认使用root/root登陆¶五、Spring中使用Dubbo某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；我们现在 需要创建两个服务模块进行测试模块功能订单服务web模块创建订单等用户服务service模块查询用户地址等测试预期结果：​ 订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。¶1. 创建如下三个maven工程1234.├── gmall-interface #公共模块，多服务之间的公共接口和实体类├── order-service-consumer #服务提供者，订单服务web模块└── user-service-provider #服务消费者，用户服务service模块¶1.1 gmall-interface模块1234567891011121314.├── pom.xml└── src └── main ├── java │ └── com │ └── qcmoke │ └── gmall │ ├── bean │ │ └── UserAddress.java │ └── service │ ├── OrderService.java │ └── UserService.java └── resourcespom.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;com.qcmoke.gmall.bean.UserAddress.java1234567891011121314151617181920212223package com.qcmoke.gmall.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;/** * 用户地址 */@Data@NoArgsConstructor@AllArgsConstructorpublic class UserAddress implements Serializable &#123; private Integer id; private String userAddress; //用户地址 private String userId; //用户id private String consignee; //收货人 private String phoneNum; //电话号码 private String isDefault; //是否为默认地址 Y-是 N-否&#125;com.qcmoke.gmall.service.OrderService.java1234567891011121314package com.qcmoke.gmall.service;import com.qcmoke.gmall.bean.UserAddress;import java.util.List;public interface OrderService &#123; /** * 初始化订单 * * @param userId */ public List&lt;UserAddress&gt; initOrder(String userId);&#125;com.qcmoke.gmall.service.UserService.java1234567891011121314151617181920package com.qcmoke.gmall.service;import com.qcmoke.gmall.bean.UserAddress;import java.util.List;/** * 用户服务 */public interface UserService &#123; /** * 按照用户id返回所有的收货地址 * * @param userId * @return */ public List&lt;UserAddress&gt; getUserAddressList(String userId);&#125;¶1.2 order-service-consumer模块1234567891011121314.├── pom.xml└── src └── main ├── java │ └── com │ └── qcmoke │ └── gmall │ ├── MainApplication.java │ └── service │ └── impl │ ├── UserServiceImpl.java └── resources └── provider.xmlpom.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;order-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入dubbo --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;com.qcmoke.gmall.service.impl.UserServiceImpl.java123456789101112131415161718192021222324252627package com.qcmoke.gmall.service.impl;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.UserService;import org.springframework.stereotype.Service;import java.util.Arrays;import java.util.List;@Service("userServiceImpl01")public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println("UserServiceImpl.....old..."); // TODO Auto-generated method stub UserAddress address1 = new UserAddress(1, "北京市昌平区宏福科技园综合楼3层", "1", "李老师", "010-56253825", "Y"); UserAddress address2 = new UserAddress(2, "深圳市宝安区西部硅谷大厦B座3层（深圳分校）", "1", "王老师", "010-56253825", "N"); /*try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;*/ return Arrays.asList(address1, address2); &#125;&#125;provider.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） ==》只要服务已启动就会注册到zookeeper注册中心了--&gt; &lt;dubbo:application name="user-service-provider"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181"/&gt; &lt;!-- 3、指定通信规则 ===》用于服务提供者和消费者之间的通信 name：通信协议（有规定要求） port：通信端口（可自定义） --&gt; &lt;dubbo:protocol name="dubbo" port="20882"/&gt; &lt;!-- 4、暴露服务 ===》用于给服务消费者提供服务 &lt;dubbo:service&gt; interface：暴露的接口 ref：指向服务的真正的实现对象 --&gt; &lt;dubbo:service interface="com.qcmoke.gmall.service.UserService" ref="userServiceImpl01"/&gt;&lt;/beans&gt;com.qcmoke.gmall.MainApplication.java1234567891011121314package com.qcmoke.gmall;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;public class MainApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("provider.xml");//加载配合文件 ioc.start();//启动ioc容器 System.in.read();//读取一个字符用于阻塞，防止ioc容器运行终止 &#125;&#125;¶1.3 user-service-provider模块1234567891011121314.├── pom.xml├── src│ └── main│ ├── java│ │ └── com│ │ └── qcmoke│ │ └── gmall│ │ ├── MainApplication.java│ │ └── service│ │ └── impl│ │ └── OrderServiceImpl.java│ └── resources│ └── consumer.xmlpom.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;user-service-provider&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入dubbo --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;com.qcmoke.gmall.service.impl.OrderServiceImpl.java12345678910111213141516171819202122232425262728package com.qcmoke.gmall.service.impl;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.OrderService;import com.qcmoke.gmall.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class OrderServiceImpl implements OrderService &#123; @Autowired UserService userService; @Override public List&lt;UserAddress&gt; initOrder(String userId) &#123; System.out.println("用户id：" + userId); //远程调用user-service-provider服务的UserServiceImpl.getUserAddressList(String userId) List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId); for (UserAddress userAddress : addressList) &#123; System.out.println(userAddress.getUserAddress()); &#125; return addressList; &#125;&#125;consumer.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字--&gt; &lt;dubbo:application name="order-service-consumer"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"/&gt; &lt;!--3、指定要调用的远程服务；声明需要调用的远程服务的接口；生成远程服务代理 interface: 调用的远程服务接口 id: 远程服务接口的名称 --&gt; &lt;dubbo:reference interface="com.qcmoke.gmall.service.UserService" id="userService"/&gt;&lt;/beans&gt;com.qcmoke.gmall.MainApplication.java1234567891011121314151617181920package com.qcmoke.gmall;import com.qcmoke.gmall.service.OrderService;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;public class MainApplication &#123; @SuppressWarnings("resource") public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("consumer.xml"); OrderService orderService = ioc.getBean(OrderService.class); orderService.initOrder("1"); System.out.println("调用完成...."); System.in.read(); &#125;&#125;¶1.4 测试启动zookeeper，然后启动dubbo-admin，再启动user-service-provider，最后启动order-service-consumer。查看order-service-consumer的输出结果。¶2. 安装监控中心¶1、下载 dubbo-opshttps://github.com/apache/incubator-dubbo-ops¶2、打包dubbo-monitor-simple进入incubator-dubbo-ops-master/dubbo-monitor-simple下运行以下命令12$ mvn package#mvn clean package -Dmaven.test.skip=true¶3. 进入target/目录解压dubbo-monitor-simple-2.0.0-assembly.tar.gz得到dubbo-monitor-simple-2.0.0,并将之移动到非target的目录去。修改dubbo-monitor-simple-2.0.0/conf/dubbo.properties的以下三处必要配置：123456# 注册中心的地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 其他服务与监控中心的通信端口dubbo.protocol.port=7070# 监控中心的web访问端口dubbo.jetty.port=8080¶4、运行启动监控中心monitor运行dubbo-monitor-simple-2.0.0/assembly.bin/start.bat注意：前提要先启动zookeeper和dubbo-admin¶5、启动访问monitor管理页面访问 http://localhost:8080¶6、服务中配置monitor在服务的ioc容器中配置如下已能够和监控中心建立连接关系。12345&lt;!-- 连接监控中心 protocol="registry":表示当前服务从注册中心发现监控中心的地址。 address="127.0.0.1:7070":表示当前服务是直连监控中心，而不是从注册中心发现的。--&gt;&lt;dubbo:monitor protocol="registry"/&gt; &lt;!--&lt;dubbo:monitor address="127.0.0.1:7070"/&gt;--&gt;修改order-service-consumer模块的consumer.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字--&gt; &lt;dubbo:application name="order-service-consumer"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"/&gt; &lt;!--3、指定要调用的远程服务；声明需要调用的远程服务的接口；生成远程服务代理 interface: 调用的远程服务接口 id: 远程服务接口的名称 --&gt; &lt;dubbo:reference interface="com.qcmoke.gmall.service.UserService" id="userService"/&gt; &lt;!-- 连接监控中心 protocol="registry":表示当前服务从注册中心发现监控中心的地址。 address="127.0.0.1:7070":表示当前服务是直连监控中心，而不是从注册中心发现的。 --&gt; &lt;dubbo:monitor protocol="registry"/&gt; &lt;!--&lt;dubbo:monitor address="127.0.0.1:7070"/&gt;--&gt;&lt;/beans&gt;修改user-service-provider的provider.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） ==》只要服务已启动就会注册到zookeeper注册中心了--&gt; &lt;dubbo:application name="user-service-provider"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181"/&gt; &lt;!-- 3、指定通信规则 ===》用于服务提供者和消费者之间的通信 name：通信协议（有规定要求） port：通信端口（可自定义） --&gt; &lt;dubbo:protocol name="dubbo" port="20882"/&gt; &lt;!-- 4、暴露服务 ===》用于给服务消费者提供服务 &lt;dubbo:service&gt; interface：暴露的接口 ref：指向服务的真正的实现对象 --&gt; &lt;dubbo:service interface="com.qcmoke.gmall.service.UserService" ref="userServiceImpl01"/&gt; &lt;!-- 连接监控中心 protocol="registry":表示当前服务从注册中心发现监控中心的地址。 address="127.0.0.1:7070":表示当前服务是直连监控中心，而不是从注册中心发现的。 --&gt; &lt;dubbo:monitor protocol="registry"/&gt; &lt;!--&lt;dubbo:monitor address="127.0.0.1:7070"/&gt;--&gt;&lt;/beans&gt;¶7、测试monitor启动顺序：zookeepe—&gt;dubbo-admin—&gt;monitor—&gt;user-service-provider—&gt;order-service-consumer¶六、SpringBoot中使用Dubbo¶1、概述对于服务提供者：123456789101112131415161718192021221.引入依赖&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;2.配置文件 # 服务唯一名称 dubbo.application.name=user-service-provider # 注册中心协议和地址 dubbo.registry.protocol=zookeeper dubbo.registry.address=127.0.0.1:2181 # 通信协议和端口 dubbo.protocol.name=dubbo #dubbo.protocol.port=20881 # 监控中心 dubbo.monitor.protocol=registry3.注解 在启动类上加@EnableDubbo 在需要暴露的服务上使用@com.alibaba.dubbo.config.annotation.Service对于服务消费者：12345678910111213141516171.引入依赖&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;2.配置文件 server.port=8081 dubbo.application.name=boot-order-service-consumer dubbo.registry.protocol=zookeeper dubbo.registry.address=127.0.0.1:2181 dubbo.monitor.protocol=registry3.注解 在启动类上加@EnableDubbo 在注入远程服务对象时使用的是@Reference¶3、三个maven模块123456789101112131415161718192021222324252627282930313233343536373839404142434445.├── boot-order-service-consumer│ ├── pom.xml│ └── src│ └── main│ ├── java│ │ └── com│ │ └── qcmoke│ │ └── gmall│ │ ├── ConsumerBootApplication.java│ │ ├── controller│ │ │ └── OrderController.java│ │ └── service│ │ └── impl│ │ └── OrderServiceImpl.java│ └── resources│ └── application.properties├── boot-user-service-provider│ ├── pom.xml│ └── src│ └── main│ ├── java│ │ └── com│ │ └── qcmoke│ │ └── gmall│ │ ├── ProviderBootApplication.java│ │ └── service│ │ └── impl│ │ └── UserServiceImpl.java│ └── resources│ └── application.properties├── gmall-interface│ ├── pom.xml│ └── src│ └── main│ ├── java│ │ └── com│ │ └── qcmoke│ │ └── gmall│ │ ├── bean│ │ │ └── UserAddress.java│ │ └── service│ │ ├── OrderService.java│ │ └── UserService.java│ └── resources¶1.1 gmall-interface和“SpringBoot中使用Dubbo”中的内容一样，这里不再阐述。¶1.2 boot-user-service-provider模块pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;boot-user-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;boot-user-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;com.qcmoke.gmall.ProviderBootApplication.java12345678910111213package com.qcmoke.gmall;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableDubbo@SpringBootApplicationpublic class ProviderBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderBootApplication.class, args); &#125;&#125;com.qcmoke.gmall.service.impl.UserServiceImpl.java1234567891011121314151617181920212223242526272829package com.qcmoke.gmall.service.impl;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.UserService;import org.springframework.stereotype.Service;import java.util.Arrays;import java.util.List;@com.alibaba.dubbo.config.annotation.Service//暴露服务,并注册到注册中心@Servicepublic class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println("UserServiceImpl..服务1....."); UserAddress address1 = new UserAddress(1, "北京东路", "1", "李老师", "010-123456", "Y"); UserAddress address2 = new UserAddress(2, "深圳宝安", "1", "王老师", "010-123457", "N"); /* //模拟异常报错 if (Math.random() &gt; 0.5) &#123; throw new RuntimeException(); &#125; */ return Arrays.asList(address1, address2); &#125;&#125;application.properties123456789101112# 服务唯一名称dubbo.application.name=boot-user-service-provider# 注册中心协议和地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 通信协议和端口dubbo.protocol.name=dubbodubbo.protocol.port=20881# 监控中心dubbo.monitor.protocol=registry#配置Dubbo缓存文件。如果在本地同时启动同一个项目的多个实例，那么server.port、dubbo.protocol.port、dubbo.registry.file都不能相同。否则报错。#dubbo.registry.file=F:/Code/dubbo/cache/boot-user-service-provider8081.cache¶1.3 boot-order-service-consumer模块pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;boot-order-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;boot-order-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;com.qcmoke.gmall.ConsumerBootApplication.java12345678910111213package com.qcmoke.gmall;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableDubbo@SpringBootApplicationpublic class ConsumerBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerBootApplication.class, args); &#125;&#125;com.qcmoke.gmall.service.impl.OrderServiceImpl.java12345678910111213141516171819202122package com.qcmoke.gmall.service.impl;import com.alibaba.dubbo.config.annotation.Reference;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.OrderService;import com.qcmoke.gmall.service.UserService;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class OrderServiceImpl implements OrderService &#123; //@Autowired @Reference UserService userService; @Override public List&lt;UserAddress&gt; initOrder(String userId) &#123; List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId); return addressList; &#125;&#125;com.qcmoke.gmall.controller.OrderController.java12345678910111213141516171819202122package com.qcmoke.gmall.controller;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.OrderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class OrderController &#123; @Autowired OrderService orderService; @RequestMapping("/initOrder")//http://127.0.0.1:8081/initOrder?uid=1 public List&lt;UserAddress&gt; initOrder(@RequestParam("uid") String userId) &#123; System.out.println("/initOrder"); return orderService.initOrder(userId); &#125;&#125;application.properties12345server.port=8081dubbo.application.name=boot-order-service-consumerdubbo.registry.protocol=zookeeperdubbo.registry.address=127.0.0.1:2181dubbo.monitor.protocol=registry¶1.4 测试启动顺序：zookeepe—&gt;dubbo-admin—&gt;monitor—&gt;boot-user-service-providerr—&gt;boot-order-service-consumer访问http://127.0.0.1:8081/initOrder?uid=1¶七、dubbo配置¶1、配置优先原则★ JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。★ XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。★ Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。对boot-user-service-provider模块做一下修改：application.properties(想当于xml)：123456789# 服务唯一名称dubbo.application.name=boot-user-service-provider# 注册中心协议和地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 通信协议和端口dubbo.protocol.name=dubbodubbo.protocol.port=20881# 监控中心dubbo.monitor.protocol=registrydubbo.properties：1dubbo.protocol.port=20882由于application.properties优先级更高，启动后会发现dubbo.properties的20882端口会被application.properties的20881端口覆盖。¶2、重试次数失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。重试次数配置如下：12服务提供者：&lt;dubbo:service retries="2" /&gt;1234567服务消费者：(1)全局重试次数配置&lt;dubbo:reference retries="2" /&gt;(2)指定接口以及特定方法重试次数配置&lt;dubbo:reference&gt; &lt;dubbo:method name="findFoo" retries="2" /&gt;&lt;/dubbo:reference&gt;¶3、超时时间配置由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。12345678910消费端:(1)全局超时配置&lt;dubbo:consumer timeout="5000" /&gt;(2)指定接口以及特定方法超时配置//设置消费者请求服务者某个服务所有方法的超时时间为2000ms&lt;dubbo:reference interface="com.foo.BarService" timeout="2000"&gt; //明确指定某个方法的超时时间为3000ms &lt;dubbo:method name="sayHello" timeout="3000" /&gt; &lt;/dubbo:reference&gt;12345678服务端:(1)全局超时配置&lt;dubbo:provider timeout="5000" /&gt;(2)指定接口以及特定方法超时配置&lt;dubbo:provider interface="com.foo.BarService" timeout="2000"&gt; &lt;dubbo:method name="sayHello" timeout="3000" /&gt;&lt;/dubbo:provider&gt;如果消费端和服务端都配置同样的超时配置，那么消费端的配置优于服务端配置¶4、配置原则配置的覆盖规则：方法级配置别优于接口级别，即小Scope优先Consumer端配置 优于 Provider配置 优于 全局配置，最后是Dubbo Hard Code的配置值（见配置文档）dubbo推荐在Provider上尽量多配置Consumer端属性：（1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等（2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的¶5、版本号当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。可以按照以下的步骤进行版本迁移：在低压力时间段，先升级一半提供者为新版本再将所有消费者升级为新版本然后将剩下的一半提供者升级为新版本1234567891011121314老版本服务提供者配置：&lt;dubbo:service interface="com.foo.BarService" version="1.0.0" /&gt;新版本服务提供者配置：&lt;dubbo:service interface="com.foo.BarService" version="2.0.0" /&gt;老版本服务消费者配置：&lt;dubbo:reference id="barService" interface="com.foo.BarService" version="1.0.0" /&gt;新版本服务消费者配置：&lt;dubbo:reference id="barService" interface="com.foo.BarService" version="2.0.0" /&gt;如果不需要区分版本，可以按照以下的方式配置：&lt;dubbo:reference id="barService" interface="com.foo.BarService" version="*" /&gt;对user-service-provider模块做修改：provider.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） ==》只要服务已启动就会注册到zookeeper注册中心了--&gt; &lt;dubbo:application name="user-service-provider"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181"/&gt; &lt;!-- 3、指定通信规则 ===》用于服务提供者和消费者之间的通信 name：通信协议（有规定要求） port：通信端口（可自定义） --&gt; &lt;dubbo:protocol name="dubbo" port="20882"/&gt; &lt;!-- 4、暴露服务 ===》用于给服务消费者提供服务 &lt;dubbo:service&gt; interface：暴露的接口 ref：指向服务的真正的实现对象 version: 当有同接口的多个不同实现类时，可以使用ref和version共同确定版本以提供给消费者选择。 --&gt; &lt;dubbo:service interface="com.qcmoke.gmall.service.UserService" ref="userServiceImpl01" version="0.0.1"/&gt; &lt;dubbo:service interface="com.qcmoke.gmall.service.UserService" ref="userServiceImpl02" version="0.0.2"/&gt; &lt;!-- 连接监控中心 protocol="registry":表示当前服务从注册中心发现监控中心的地址。 address="127.0.0.1:7070":表示当前服务是直连监控中心，而不是从注册中心发现的。 --&gt; &lt;dubbo:monitor protocol="registry"/&gt; &lt;!--&lt;dubbo:monitor address="127.0.0.1:7070"/&gt;--&gt;&lt;/beans&gt;添加实现类com.qcmoke.gmall.service.impl.UserServiceImpl2.java123456789101112131415161718192021package com.qcmoke.gmall.service.impl;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.UserService;import org.springframework.stereotype.Service;import java.util.Arrays;import java.util.List;@Service("userServiceImpl02")public class UserServiceImpl2 implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println("UserServiceImpl.....new..."); UserAddress address1 = new UserAddress(1, "南京", "1", "李老师", "010-56253825", "Y"); UserAddress address2 = new UserAddress(2, "杭州", "1", "王老师", "010-56253825", "N"); return Arrays.asList(address1, address2); &#125;&#125;对order-service-consumer模块做修改:consumer.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.qcmoke.gmall.service.impl"/&gt; &lt;!-- 1、指定当前服务/应用的名字--&gt; &lt;dubbo:application name="order-service-consumer"/&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"/&gt; &lt;!--3、指定要调用的远程服务；声明需要调用的远程服务的接口；生成远程服务代理 interface: 调用的远程服务接口 id: 远程服务接口的名称 check:设置启动时是否检查注册中心中有服务提供者(默认true，检查)，如果想要配置当前所有的服务都启动不检查注册中心中有服务提供者那么可以统一配置:&lt;dubbo:consumer check="false" timeout="5000"/&gt; retries:设置失败重试次数，0表示不重试（默认）。 是否使用重试？ 幂等,就是多次执行方法得到的结果一样，比如查询、删除、修改，这种情况可以设置重试次数。 非幂等，就是多次执行方法得到的结果不一样，比如数据库新增操作，即使参数相同新增后数据库记录会变多，这种情况不能设置重试次数。 version:在服务提供者使用version指定版本的时候，可以在消费者上指定对应的版本来确定同一接口的具体实现类对象。 --&gt; &lt;dubbo:reference interface="com.qcmoke.gmall.service.UserService" id="userService" retries="3" version="0.0.1"/&gt; &lt;!-- 连接监控中心 protocol="registry":表示当前服务从注册中心发现监控中心的地址。 address="127.0.0.1:7070":表示当前服务是直连监控中心，而不是从注册中心发现的。 --&gt; &lt;dubbo:monitor protocol="registry"/&gt; &lt;!--&lt;dubbo:monitor address="127.0.0.1:7070"/&gt;--&gt; &lt;!-- (1)全局超时配置 &lt;dubbo:consumer timeout="5000" /&gt; (2)指定接口以及特定方法超时配置 &lt;dubbo:reference interface="com.qcmoke.gmall.service.UserService" id="userService" timeout="5000"&gt; 设置消费者请求服务者某个服务所有方法的超时时间为5000ms &lt;dubbo:method name="getUserAddressList" timeout="1000"/&gt; 明确指定某个方法的超时时间为1000ms &lt;/dubbo:reference&gt; --&gt;&lt;/beans&gt;运行两个服务后观察消费者的输出：1234用户id：1南京杭州调用完成....¶八、熔断与降级整合hystrix，可实现服务的熔断与降级。Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。¶1. 使用hystrix¶1.1 创建提供者模块boot-user-service-provider-hystrix除了添加dubbo依赖和gmall-interface外，还有添加如下netflix依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;完整pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;boot-user-service-provider-hystrix&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;!--&lt;version&gt;2.1.7.RELEASE&lt;/version&gt;--&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;创建启动类并在类上增加@EnableHystrix注解。HystrixProviderBootApplication.java123456789101112131415package com.qcmoke.gmall;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@EnableDubbo@EnableHystrix@SpringBootApplicationpublic class HystrixProviderBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixProviderBootApplication.class, args); &#125;&#125;配置application.properties12345server.port=8081dubbo.application.name=boot-user-service-provider-hystrixdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.protocol.name=dubbodubbo.protocol.port=20881UserServiceImpl.java12345678910111213141516171819package com.qcmoke.gmall.service.impl;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.UserService;import org.springframework.stereotype.Service;import java.util.List;@com.alibaba.dubbo.config.annotation.Service@Servicepublic class UserServiceImpl implements UserService &#123; @HystrixCommand @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; throw new RuntimeException("Exception to show hystrix enabled."); &#125;&#125;¶1.2 创建消费者模块boot-order-service-consumer-hystrixpom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;boot-order-service-consumer-hystrix&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;!--&lt;version&gt;2.1.7.RELEASE&lt;/version&gt;--&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;application.properties1234server.port=80dubbo.application.name=boot-order-service-consumer-hystrixdubbo.registry.protocol=zookeeperdubbo.registry.address=127.0.0.1:2181HystrixConsumerBootApplication.java123456789101112131415package com.qcmoke.gmall;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@EnableDubbo@EnableHystrix@SpringBootApplicationpublic class HystrixConsumerBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixConsumerBootApplication.class, args); &#125;&#125;UserController.java1234567891011121314151617181920212223242526272829303132package com.qcmoke.gmall.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.qcmoke.gmall.bean.UserAddress;import com.qcmoke.gmall.service.UserService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.Collections;import java.util.List;@RestControllerpublic class UserController &#123; @Reference private UserService userService; @HystrixCommand(fallbackMethod = "getUserAddressListHystrix") @RequestMapping("/getUserAddressList") public List&lt;UserAddress&gt; getUserAddressList(@RequestParam("uid") String userId) &#123; System.out.println("/getUserAddressList"); return userService.getUserAddressList(userId); &#125; public List&lt;UserAddress&gt; getUserAddressListHystrix(@RequestParam("uid") String userId) &#123; System.out.println("/getUserAddressListHystrix"); UserAddress address = new UserAddress(null, null, null, null, null, null); return Collections.singletonList(address); &#125;&#125;测试：先启动提供者，然后启动消费者访问http://127.0.0.1/getUserAddressList?uid=1返回结果：1[&#123;"id":null,"userAddress":null,"userId":null,"consignee":null,"phoneNum":null,"isDefault":null&#125;]¶九、负载均衡]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper 学习笔记]]></title>
    <url>%2Fjavaee%2Fzookeeper.html</url>
    <content type="text"><![CDATA[¶一、简介zooKeeper是一个经典的分布式数据一致性解决方案服务，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调存储服务。zooKeeper由雅虎研究院开发，是Google Chubby的开源实现，后来托管到Apache，于2010年11月正式成为Apache的顶级项目。zookeeper官网：https://zookeeper.apache.org/¶二、应用场景（1）维护配置信息（2）分布式锁服务（3）集群管理（4）生成分布式唯一ID¶三、数据模型zookeeper的数据节点可以视为树状结构（或者文件系统），树中的各节点被称为znode（即zookeeper node），一个znode可以有多个子节点。zookeeper节点在结构上表现为树状；使用路径path来定位某个znode。znode兼具文件和目录（文件路径而非文件夹）两种特点，既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。一个znode大体上分为3各部分：data：与该Znode关联的数据，即znode data(节点path, 节点data)的关系就像是java map中(key,value)的关系children：该Znode下的子节点stat：该Znode节点的状态信息，用来描述当前节点的创建、修改记录、版本、权限等、包括cZxid、ctime等cZxid 数据节点创建时的事务 IDctime 数据节点创建时的时间mZxid 数据节点最后一次更新时的事务 IDmtime 数据节点最后一次更新时的时间pZxid 数据节点的子节点最后一次被修改时的事务 IDcversion 子节点的更改次数dataVersion 节点数据的更改次数aclVersion 结点的ACL更改次数——类似linux的权限列表，维护的是当前结点的权限列表被修改的次数ephemeralOwner 如果节点是临时节点，则表示创建该节点的会话的SessionID；如果节点是持久节点，则该属性值为 0dataLength 数据内容的长度numChildren 数据节点当前的子节点个数Znode的类型Znode被分为持久（persistent）节点，顺序（sequential）节点和临时（ephemeral）节点。持久节点 - 该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除临时节点 - 该节点的生命周期依赖于创建它们的会话。一旦会话( Session）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，Zookeeper的临时节点不允许拥有子节点顺序节点 - 顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 /myapp 的znode创建为顺序节点，则ZooKeeper会将路径更改为 /myapp0000000001 ，而下一个序列号将递增为0000000002。顺序节点在锁定和同步中起重要作用。¶四、安装部署¶1. 单机版12345678910111213141516171819202122232425262728$ mkdir /opt/zookeeper$ cd /opt/zookeeper$ wget http://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz$ tar -zxvf zookeeper-3.4.14.tar.gz$ mkdir /opt/zookeeper/zookeeper-3.4.14/data$ cd zookeeper-3.4.14/conf$ cp zoo_sample.cfg zoo.cfg$ vim zoo.cfg#此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全dataDir=/opt/zookeeper/zookeeper-3.4.14/data$ cd /opt/zookeeper/zookeeper-3.4.14/bin/#启动zookeeper$ zkServer.sh start# 启动$ zkServer.sh start# 重启$ zkServer.sh restart# 停止$ zkServer.sh stop# 查看状态$ zkServer.sh status# zookeeper客户端命令工具连接到zookeeper服务$ zkCli.sh¶2. docker版123$ docker run -d --restart always --name zookeeper -e JVMFLAGS="-Xmx1024m" -p 2181:2181 zookeeper$ docker exec -it zookeeper /bin/bash$ /apache-zookeeper-3.6.2-bin/bin/zkCli.sh¶3. 集群¶3.1 架构看看下面的图表。它描述了ZooKeeper的“客户端-服务器架构”。图中部分组件在下表中进行了说明。部分描述Client客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。Server服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。Leader服务领导者。1、处理事务请求和非事务请求（如增删改查）；2、调度集群内部的各个服务Follower服务跟随者。1、处理非事务请求（如查，如果接收到事务请求的话则转发给Leader）；2、参与Leader选举投票Observer服务观察者。1、处理非事务请求（如查，如果接收到事务请求的话则转发给Leader）。（不参与Leader选举投票）¶3.2 部署准备三台服务器（多台同理，需要基数倍，集群中从3台变成2台仍可用，而变成1台时将不不可用）172.16.10.111172.16.10.112172.16.10.113分别在三台zk服务器中执行如下操作：1234567891011121314151617181920$ mkdir -p /home/zookeeper/conf$ mkdir -p /home/zookeeper/data$ vim /home/zookeeper/conf/zoo.cfgclientPort=2181 dataDir=/data dataLogDir=/data/logtickTime=2000 initLimit=5 syncLimit=2 autopurge.snapRetainCount=3 autopurge.purgeInterval=0 maxClientCnxns=60server.111=172.16.10.111:2888:3888 server.112=172.16.10.112:2888:3888 server.113=172.16.10.113:2888:3888#想让服务节点为observer观察者，需要如下两行配置#peerType=observer#server.113=172.16.10.113:2888:3888:observerserver.服务id=服务器ip:服务器之间通信端口:服务之间投票选举端口服务id编号越大，在Leader选举中权重越大，选举票数超过半数则为Leader。分别在三台zk服务器中的/home/zookeeper/data目录下创建myid，并配置id，里面的id一定要和上面配置的server.id一致123456#zk1$ echo 111 &gt; /home/zookeeper/data/myid#zk2$ echo 112 &gt; /home/zookeeper/data/myid#zk3$ echo 113 &gt; /home/zookeeper/data/myid分别运行zk docker镜像1234567891011#获取zk docker镜像$ docker pull zookeeper:3.4.13#运行镜像生产docker容器$ docker run -d --restart always --network host -v /home/zookeeper/data:/data -v /home/zookeeper/conf:/conf --name zookeeper-2181 zookeeper:3.4.13#或者以下（目前发现以下命令不可用）#docker run -d --restart always -p 2181:2181 -p 2888:2888 -p 3888:3888 -v /home/zookeeper/data:/data -v /home/zookeeper/conf:/conf --name=zookeeper-2181 zookeeper:3.4.13#进入容器中查看leader选举情况$ docker exec -it zookeeper-2181 /bin/sh$ zkServer.sh status每台主机的2181/2888/3888端口都会开放出来123456$ service firewalld start$ firewall-cmd --permanent --add-port=2181/tcp$ firewall-cmd --permanent --add-port=2888/tcp$ firewall-cmd --permanent --add-port=3888/tcp$ firewall-cmd --reload$ firewall-cmd --list-all¶五、常用命令12345678910111213141516171819202122232425262728293031323334353637##1、查看目录列表（子节点列表）#查看某个路径下目录列表#path：指定要创建节点的路径，比如 /test。ls path#查看某个路径下目录列表，它比 ls 命令列出更多的详细信息ls -s pathls2 path #旧版##2、获取节点数据和状态信息#（1）获取节点数据和状态信息，[watch]：对节点进行事件监听。get path [watch]#例：get /test watch #终端1查询并监听节点set /test 1 #终端2对节点进行修改#（2）查看节点状态信息stat path [watch]##3、创建节点并赋值#[-s] [-e]：-s 和 -e 都是可选的，-s 代表顺序节点(递增)， -e 代表临时节点（不加表示持久节点），注意其中 -s 和 -e 可以同时使用的，并且临时节点不能再创建子节点。#path：指定要创建节点的路径，比如 /test。#data：要在此节点存储的数据。不设置则为null#acl：访问权限相关，默认是 world，相当于全世界都能访问。create [-s] [-e] path [data] [acl]#例：添加临时顺序节点并赋值create -s -e /test "hello"##4、修改节点存储的数据#[version]：可选项，版本号(可用作乐观锁)。即状态信息中的dataVersionset path data [version]##5、删除节点#[version]：可选项，版本号（同 set 命令）。#delete 命令只能一层一层删除。新版本可以通过 deleteall 命令递归删除delete path [version]¶六 、权限控制zookeeper 的 ACL（Access Control List，访问控制表）权限可以针对节点设置相关读写等权限，保障数据安全性。zookeeper 的 acl 通过 [scheme:id:permissions] 来构成权限列表。（1）scheme：代表采用的某种权限机制（权限模式），包括 world、auth、digest、ip、super 几种。world：只有一个用户：anyone，代表登录zookeeper所有人(默认)auth：使用已添加认证的用户认证digest：使用&quot;用户名：密码&quot;方式认证ip：限制ip进行访问（2）id：代表允许访问的用户。（3）permissions：权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限，create©：创建子节点权限delete(d)：删除子节点的权限read®：获取当前节点/子节点的权限write(w)：设置节点数据的权限admin(a)：设置节点权限的权限。¶1. world模式1234567891011$ create /test$ create /test/child$ getAcl /test#更新节点 permissions 权限部分为 crwa$ setAcl /test world:anyone:crwa#结果删除子节点失败$ delete /test/child#更新节点 permissions 权限部分为 cdrwa$ setAcl /test world:anyone:cdrwa#结果删除子节点成功$ delete /test/child¶2. auth模式auth 用于授予权限（以用户名和明文密码的形式授权）。1234567$ create /test/child demo#给当前会话创建用户名为user1密码为123456的用户$ addauth digest user1:123456$ setAcl /test/child auth:user1:123456:cdrwa$ getAcl /test/child'digest,'user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=: cdrwa另外起一个终端测试12345678$ get /test/child#提示如下无权限操作org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth for /test/child#给当前会话创建该节点需要的用户后就可以操作节点了$ addauth digest user1:123456#在=再次操作即可成功$ get /test/child¶3. digest模式digest同样用于授予权限（以用户名和密文密码的形式授权，密文可在创建时的会话中通过getAcl查看）。1234567# 计算密码echo -n user1:123456 | openssl dgst -binary -sha1 | openssl base64# 获取密码，设置权限列表setAcl /test2 digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:cdrwa# 现在想要get /hadoop 需要登录了addauth digest user1:123456get /test2¶4. ip模式限制 IP 地址的访问权限，把权限设置给 IP 地址为 192.168.3.7 后，IP 为 192.168.3.38 已经没有访问权限。123456$ create /test/ip 0$ getAcl /test/ip$ setAcl /test/ip ip:192.168.3.7:cdrwa$ get /test/ip#假设当前所在终端并非192.168.3.7，则提示无权限操作Authentication is not valid : /test/ip¶5. 组合模式仅需逗号隔开setAcl /test ip:192.168.3.7:cdrwa,auth:user1:cdrwa,digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:cdrwa 12345678910111213### 6. 超级管理员&#96;zookeeper&#96;的权限管理模式有一种叫做&#96;super&#96;，该模式提供一个超管，可以方便的访问任何权限的节点。默认是没有配置super的，需要到&#96;zookeeper&#96;目录下&#96;&#x2F;bin&#x2F;zkServer.sh&#96;文件中加相关配置。&#96;&#96;&#96;bash &#x2F;nohup # 快速查找，可以看到如下 nohup &quot;$JAVA&quot; &quot;-Dzookeeper.log.dir&#x3D;$&#123;ZOO_LOG_DIR&#125;&quot; &quot;-Dzookeeper.root.logger&#x3D;$&#123;ZOO_LOG4J_PROP&#125;&quot; \ 加入运行参数-Dzookeeper.DigestAuthenticationProvider.superDigest。如下：1nohup "$JAVA" "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;" "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=" \注意：-Dzookeeper.DigestAuthenticationProvider.superDigest参数的值为super:密码摘要。假设密码为admin，可通过如下获得密码摘要。1echo -n super:admin | openssl dgst -binary -sha1 | openssl base64如果使用的是docker安装的，可以在运行容器的时候指定jvm参数如下设置超级管理员即可（不需要修改zkServer.sh）。1docker run -d --restart always --name zookeeper -e JVMFLAGS="-Xmx1024m -Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=" -p 2181:2181 zookeeper使用1234# 登录超管addauth digest super:admin# 强行操作节点(设/test/ip节点在登录前无权操作)get /test/ip¶七、图形化客户端¶1. PrettyZoo下载地址：https://github.com/vran-dev/PrettyZoo/releases¶2. ZooInspector下载地址：https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip解压后进入目录ZooInspector\build，运行java -jar zookeeper-dev-ZooInspector.jar]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 学习笔记]]></title>
    <url>%2Fjavaee%2Fspringcloud.html</url>
    <content type="text"><![CDATA[¶一、微服务概念¶1. 微服务定义广义上讲，微服务是一种架构风格,或者说是一种开发软件的架构和组织方法。狭义上讲，微服务是组成一个大型复杂软件系统的一个或多个小型独立的服务软件应用。一个大型复杂软件应用由通过明确定义的 API 进行通信的一个或多个小型独立服务(微服务)组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。¶2. 微服务架构微服务架构是⼀种架构模式，它提倡将单⼀应⽤程序划分成⼀组⼩的服务，服务之间互相协调、互相配合，为⽤户提供最终价值。每个服务运⾏在其独⽴的进程中，服务与服务间采⽤轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进⾏构建，并且能够被独⽴的部署到⽣产环境、类⽣产环境等。另外，应当尽量避免统⼀的、集中式的服务管理机制，对具体的⼀个服务⽽⾔，应根据业务上下⽂，选择合适的语⾔、⼯具对其进⾏构建。¶3. 微服务化微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。¶4. 微服务的优缺点优点（1）每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求（2）开发简单、开发效率提高，一个服务可能就是专一的只干一件事。微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。（3）微服务能使用不同的语言开发。（4）易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。（5）微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。（6）微服务允许你利用融合最新技术。（7）微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。（8）每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。（9）由于多个微服务应用各自能独立运行，所以其中一些服务出现问题一般不会影响其他服务的正常运行和使用。缺点（1）开发人员要处理分布式系统的复杂性（2）多服务运维难度，随着服务的增加，运维的压力也在增大（3）系统部署依赖（4）服务间通信成本（5）数据一致性（6）系统集成测试（7）性能监控……¶5. 微服务技术栈服务开发 Springboot、Spring、SpringMVC服务配置与管理 Netflix公司的Archaius、阿里的Diamond等服务注册与发现 Eureka、Consul、Zookeeper等服务调用 Rest、RPC、gRPC服务熔断器 Hystrix、Envoy等负载均衡 Ribbon、Nginx等服务接口调用(客户端调用服务的简化工具) Feign等消息队列 Kafka、RabbitMQ、ActiveMQ等服务配置中心管理 SpringCloudConfig、Chef等服务路由(API网关) Zuul等服务监控 Zabbix、Nagios、Metrics、Spectator等全链路追踪 Zipkin，Brave、Dapper等服务部署 Docker、OpenStack、Kubernetes等数据流操作开发包 SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）事件消息总线 Spring Cloud Bus¶6. 各微服务框架对比¶7. 微服务中SpringCloud与Dubbo的区别DubboSpringCloud服务注册中心ZookeeperSpring Cloud Netfilx Eureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring Boot Admin断路器不完善pring Cloud Netflix Hystrix服务网关无Spring Cloud Netflix Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总线无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无Spring Cloud Task………………当然这里需要申明一点，Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能，比如：分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。但是Spring Cloud中的Config组件除了提供配置管理之外，由于其存储可以使用git，因此它天然的实现了配置内容的版本管理，可以完美的与应用版本管理整合起来。服务跟踪：可以使用京东开源的Hydra批量任务：可以使用当当开源的Elastic-Job……最大区别：Spring Cloud抛弃了RPC通讯，采用基于HTTP的REST方式。Spring Cloud牺牲了服务调用的性能，但是同时也避免了原生RPC带来的问题。REST比RPC更为灵活，不存在代码级别的强依赖，在强调快速演化的微服务环境下，显然更合适。Dubbo只是实现了服务治理，而Spring Cloud下面有17个子项目（可能还会新增）分别覆盖了微服务架构下的方方面面，服务治理只是其中的一个方面，一定程度来说，Dubbo只是Spring Cloud Netflix中的一个子集。一句话：Dubbo像组装机，Spring Cloud像一体机社区的支持与力度：Dubbo曾经停运了5年，虽然重启了，但是对于技术发展的新需求，还是需要开发者自行去拓展，对于中小型公司，显然显得比较费时费力，也不一定有强大的实力去修改源码总结解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案 ；¶二、SpringCloud¶1. 概念官网：http://projects.spring.io/spring-cloud/参考文档：本次开发API说明：https://springcloud.cc/spring-cloud-netflix.html http://cloud.spring.io/spring-cloud-static/Dalston.SR1/ https://springcloud.cc/spring-cloud-dalston.htmlspringcloud中国社区：http://springcloud.cn/springcloud中文网：https://springcloud.cc/SpringCloud是基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。SpringCloud=分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到一键启动和部署。SpringBoot并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包¶2. SpringBoot和SpringCloudSpringBoot专注于快速方便的开发单个个体微服务。SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系.SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。¶3.项目搭建示例项目¶3.1 需求项目搭建为springmvc+mybatis+mysql，以Dept部门模块做一个微服务通用案例。Consumer消费者（Client）通过REST调用Provider提供者（Server）提供的服务。创建maven聚合工程：12345678910111213#父项目(microservicecloud)聚合很多子项目(microservicecloud-api,microservicecloud-provider-dept-8001,microservicecloud-consumer-dept-80)---- microservicecloud #父项目(类似一个抽象父类) |---- pom.xml (pom) | |-------- microservicecloud-api #封装的整体entity/接口/公共配置等 | |-------- pom.xml (jar) | |-------- microservicecloud-provider-dept-8001 #微服务落地的服务提供者 | |-------- pom.xml (jar) | |-------- microservicecloud-consumer-dept-80 #微服务调用的消费者 | |-------- pom.xml (jar)¶3.2 第一步（1）创建一个大包方式为pom的父项目microservicecloudgroupId: com.qcmokeartifactId: microservicecloudversion: 0.0.1-SNAPSHOTpackaging: pom（2）修改pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;!-- 1.dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。一般在我们项目顶层的pom文件中，我们会看到dependencyManagement元素 2.dependencies即使在子模块中不写该依赖项，那么子模块仍然会从父项目中继承该依赖项（全部继承）。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt;¶3.3 第二步（1）创建子模块microservicecloud-api（2）修改该模块的pom.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 子类里面显示声明才能有明确的继承表现 --&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 当前Module我自己叫什么名字 --&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（3）创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）123&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt;&lt;/modules&gt;（4）在src/main/java下新建com.qcmoke.entities.Dept12345678910111213141516171819202122232425262728package com.qcmoke.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors;/** * 部门实体类 * * @author qcmoke * @date 2019/09/02 03:14 */@Data@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true)public class Dept &#123; private Long deptno;//主键 private String dname; //部门名称 private String db_source; // 来自那个数据库，因为微服务架构可以一个服务对应一个数据库，同一个信息被存储到不同数据库 public Dept(String dname) &#123; super(); this.dname = dname; &#125;&#125;¶3.4 第三步（1）创建子模块microservicecloud-provider-dept-8001（2）编辑该模块的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的其他模块（microservicecloud-api） --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（3）创建完成后在父工程的pom文件的&lt;project&gt;标签下修改&lt;modules&gt;为如下代码。（一般IDE工具会自动添加）1234&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt;&lt;/modules&gt;（4）在该模块下新建启动类com.qcmoke.DeptProvider8001App.java123456789101112131415161718package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * microservicecloud-provider-dept-8001模块的启动类 * * @author qcmoke * @date 2019/09/02 03:34 */@SpringBootApplicationpublic class DeptProvider8001App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001App.class, args); &#125;&#125;（5）在该模块下创建src/main/resources/application.yml1234567891011121314151617181920212223server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间（6）在该模块下创建src/main/resources/mybatis/mybatis.cfg.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;!-- 二级缓存开启 --&gt; &lt;/settings&gt;&lt;/configuration&gt;（7）mysql执行以下sql创建数据库和添加相关表数据123456789101112131415161718DROP DATABASE IF EXISTS cloudDB01;CREATE DATABASE cloudDB01 CHARACTER SET UTF8;USE cloudDB01;CREATE TABLE dept( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(60), db_source VARCHAR(60));INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE()); -- DATABASE()函数可获取当前数据库的名称，在分库的情况下需要INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE());SELECT * FROM dept;（9）在该模块下添加com.qcmoke.dao.DeptDao.java1234567891011121314151617181920212223package com.qcmoke.dao;import com.qcmoke.entities.Dept;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * DeptDao * * @author qcmoke * @date 2019/09/02 03:26 */@Repository@Mapperpublic interface DeptDao &#123; public boolean addDept(Dept dept); public Dept findById(Long id); public List&lt;Dept&gt; findAll();&#125;（10）在该模块下创建src/main/resources/mybatis/mapper/DeptMapper.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qcmoke.dao.DeptDao"&gt; &lt;select id="findById" resultType="Dept" parameterType="Long"&gt; select deptno,dname,db_source from dept where deptno=#&#123;deptno&#125;; &lt;/select&gt; &lt;select id="findAll" resultType="Dept"&gt; select deptno,dname,db_source from dept; &lt;/select&gt; &lt;insert id="addDept" parameterType="Dept"&gt; INSERT INTO dept(dname,db_source) VALUES(#&#123;dname&#125;,DATABASE()); &lt;/insert&gt; &lt;/mapper&gt;（11）在该模块下添加com.qcmoke.service.DeptService.java12345678910111213141516171819package com.qcmoke.service;import com.qcmoke.entities.Dept;import java.util.List;/** * DeptService * * @author qcmoke * @date 2019/09/02 03:30 */public interface DeptService &#123; public boolean add(Dept dept); public Dept get(Long id); public List&lt;Dept&gt; list();&#125;（12）在该模块下添加com.qcmoke.service.DeptServiceImpl.java1234567891011121314151617181920212223242526272829303132333435package com.qcmoke.service;import com.qcmoke.dao.DeptDao;import com.qcmoke.entities.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * DeptServiceImpl * * @author qcmoke * @date 2019/09/02 03:30 */@Servicepublic class DeptServiceImpl implements DeptService &#123; @Autowired DeptDao deptDao; @Override public boolean add(Dept dept) &#123; return deptDao.addDept(dept); &#125; @Override public Dept get(Long id) &#123; return deptDao.findById(id); &#125; @Override public List&lt;Dept&gt; list() &#123; return deptDao.findAll(); &#125;&#125;（13）在该模块下添加com.qcmoke.controller.DeptController.java123456789101112131415161718192021222324252627282930313233343536package com.qcmoke.controller;import com.qcmoke.entities.Dept;import com.qcmoke.service.DeptService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * DeptController * * @author qcmoke * @date 2019/09/02 03:32 */@RestControllerpublic class DeptController &#123; @Autowired private DeptService service; @RequestMapping(value = "/dept/add", method = RequestMethod.POST) public boolean add(@RequestBody Dept dept) &#123; return service.add(dept); &#125; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") Long id) &#123; return service.get(id); &#125; @RequestMapping(value = "/dept/list", method = RequestMethod.GET) public List&lt;Dept&gt; list() &#123; return service.list(); &#125;&#125;（14）启动com.qcmoke.DeptProvider8001App.java测试http://localhost:8001/dept/get/2http://localhost:8001/dept/list¶3.5 第四步（1）创建子模块microservicecloud-consumer-dept-80（2）修改该模块的pom.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-80&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（3）创建完成后在父工程的pom文件的&lt;project&gt;标签下修改&lt;modules&gt;为如下代码。（一般IDE工具会自动添加）12345&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt;&lt;/modules&gt;（4）在该模块下创建src/main/resources/application.yml12server: port: 80（5）在该模块下创建com.qcmoke.config.ConfigBean.java12345678910111213141516171819202122232425package com.qcmoke.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * ConfigBean * * @author qcmoke * @date 2019/09/02 04:32 */@Configurationpublic class ConfigBean &#123; /** * RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集 * * @author qcmoke * @date 2019/9/2 4:41 */ @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125;RestTemplate官网地址https://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html使用使用restTemplate访问restful接口非常的简单粗暴无脑。(url, requestMap, ResponseBean.class)这三个参数分别代表REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。（6）在该模块下创建com.qcmoke.controller.DeptConsumerController.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.qcmoke.controller;import com.qcmoke.entities.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;/** * DeptConsumerController * * @author qcmoke * @date 2019/09/02 04:34 */@RestControllerpublic class DeptConsumerController &#123; private static final String REST_URL_PREFIX = "http://localhost:8001"; @Autowired private RestTemplate restTemplate; @RequestMapping(value = "/consumer/dept/add") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + "/dept/add", dept, Boolean.class); &#125; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/get/" + id, Dept.class); &#125; @SuppressWarnings("unchecked") @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/list", List.class); &#125;&#125;（7）在该模块下创建启动类com.qcmoke.MicroServiceCloudConsumerDept80.java123456789101112131415161718package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * MicroservicecloudConsumerDept80 * * @author qcmoke * @date 2019/09/02 04:37 */@SpringBootApplicationpublic class MicroServiceCloudConsumerDept80 &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroServiceCloudConsumerDept80.class, args); &#125;&#125;（8）测试首先启动microservicecloud-provider-dept-8001模块的com.qcmoke.DeptProvider8001App.java然后启动microservicecloud-consumer-dept-80模块的com.qcmoke.MicroServiceCloudConsumerDept80.javahttp://localhost/consumer/dept/get/2http://localhost/consumer/dept/listhttp://localhost/consumer/dept/add?dname=AI¶4. Eureka服务注册与发现¶4.1 概念Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了。功能类似于dubbo的注册中心，比如Zookeeper。Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。Eureka包含两个组件：Eureka Server和Eureka ClientEureka Server提供服务注册服务各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）Eureka构架设计：对比Dubbo架构的设计：¶4.2 需求三大角色Eureka Server 提供服务注册和发现Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务¶4.3 第一步（1）创建 eureka服务注册中心子模块microservicecloud-eureka-7001（2）修改该模块pom.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-eureka-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）123456&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt;&lt;/modules&gt;（3）在该模块下创建src/main/resources/application.yml1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己就是注册中心，职责就是维护服务实例，并不需要自我注册，自我检查。 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。（4）创建启动类com.qcmoke.EurekaServer7001App.java1234567891011121314151617181920package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * EurekaServer7001App * * @author qcmoke * @date 2019/09/02 18:39 */@SpringBootApplication@EnableEurekaServer//EurekaServer服务器端启动类,接受其它微服务注册进来public class EurekaServer7001App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7001App.class, args); &#125;&#125;（5）运行com.qcmoke.EurekaServer7001App.java 测试访问http://localhost:7001/¶4.4 第二步将已有的部门微服务microservicecloud-provider-dept-8001注册进eureka服务中心microservicecloud-eureka-7001（1）修改microservicecloud-provider-dept-8001的pom.xml添加如下依赖123456789&lt;!-- 将微服务provider侧注册进eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;修改好的pom.xml如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的其他模块（microservicecloud-api） --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（2）修改该项目的application.yml添加如下配置1234eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka修改好的application.yml12345678910111213141516171819202122232425262728server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka（3）修改该项目的启动类com.qcmoke.DeptProvider8001App.java给启动类添加@EnableEurekaClient注解1234567891011121314151617181920package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * microservicecloud-provider-dept-8001模块的启动类 * * @author qcmoke * @date 2019/09/02 03:34 */@SpringBootApplication@EnableEurekaClient //本服务启动后会自动注册进eureka服务中public class DeptProvider8001App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001App.class, args); &#125;&#125;（4）测试先启动microservicecloud-eureka-7001的com.qcmoke.EurekaServer7001App.java然后再启动microservicecloud-provider-dept-8001的com.qcmoke.DeptProvider8001App.java访问http://localhost:7001/如图标注的名称就是microservicecloud-provider-dept-8001 yml配置文件中指定的name:123spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点）在microservicecloud-eureka-7001中能检测microservicecloud-provider-dept-8001，说明服务注册成功。（5）个性化配置（可选）（5.1）指定如下图标注的服务名称修改microservicecloud-provider-dept-8001的application.yml,在eureka下添加如下配置：12instance: instance-id: microservicecloud-dept8001修改好后的全配置：123456789101112131415161718192021222324252627282930server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka instance: instance-id: microservicecloud-dept8001修改好后，先启动microservicecloud-eureka-7001的com.qcmoke.EurekaServer7001App.java，然后再启动microservicecloud-provider-dept-8001的com.qcmoke.DeptProvider8001App.java，最后访问http://localhost:7001/（5.2）修改服务访问信息ip的提示，如下图：修改microservicecloud-provider-dept-8001的application.yml,在eureka下添加如下配置：1234567eureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #添加的配置修改好后的全配置：12345678910111213141516171819202122232425262728293031server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址修改好后，先启动microservicecloud-eureka-7001的com.qcmoke.EurekaServer7001App.java，然后再启动microservicecloud-provider-dept-8001的com.qcmoke.DeptProvider8001App.java，最后访问http://localhost:7001/（5.3）配置微服务http://ip/info的详细信息页面内容（点击服务超链接报告ErrorPage）修改microservicecloud-provider-dept-8001的pom.xml添加如下依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;修改好后的全部配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的其他模块（microservicecloud-api） --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;总的父工程microservicecloud修改pom.xml添加构建build配置添加如下配置：1234567891011121314151617181920&lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;修改好后的全部配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--模块（子项目）,会被构建成项目的一部分 --&gt; &lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;!-- 1.dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。一般在我们项目顶层的pom文件中，我们会看到dependencyManagement元素 2.dependencies即使在子模块中不写该依赖项，那么子模块仍然会从父项目中继承该依赖项（全部继承）。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;修改microservicecloud-provider-dept-8001的application.yml添加如下配置：12345info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;修改好后的全部配置：1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;修改好后，先启动microservicecloud-eureka-7001的com.qcmoke.EurekaServer7001App.java，然后再启动microservicecloud-provider-dept-8001的com.qcmoke.DeptProvider8001App.java，最后访问http://localhost:7001/ 并点击microservicecloud-dept8001（5.3）eureka自我保护的状况故障现象导致原因：什么是自我保护模式？默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时，该Eureka Server节点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。在Spring Cloud中，可以在microservicecloud-eureka-7001的application.yml中使用eureka.server.enable-self-preservation = false禁用自我保护模式，但不建议。¶4.5 第三步服务发现Discovery，对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息（1）修改microservicecloud-provider-dept-8001工程的DeptController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.qcmoke.controller;import com.qcmoke.entities.Dept;import com.qcmoke.service.DeptService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.*;import java.util.List;/** * DeptController * * @author qcmoke * @date 2019/09/02 03:32 */@RestControllerpublic class DeptController &#123; @Autowired private DeptService service; @Autowired private DiscoveryClient client; @RequestMapping(value = "/dept/discovery", method = RequestMethod.GET) public Object discovery() &#123; List&lt;String&gt; list = client.getServices(); System.out.println("**********" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances("MICROSERVICECLOUD-DEPT"); for (ServiceInstance element : srvList) &#123; System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t" + element.getUri()); &#125; return this.client; &#125; @RequestMapping(value = "/dept/add", method = RequestMethod.POST) public boolean add(@RequestBody Dept dept) &#123; return service.add(dept); &#125; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") Long id) &#123; return service.get(id); &#125; @RequestMapping(value = "/dept/list", method = RequestMethod.GET) public List&lt;Dept&gt; list() &#123; return service.list(); &#125;&#125;（2）修改microservicecloud-provider-dept-8001的DeptProvider8001App.java，添加@EnableDiscoveryClient注解12345678910111213141516171819202122package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * microservicecloud-provider-dept-8001模块的启动类 * * @author qcmoke * @date 2019/09/02 03:34 */@SpringBootApplication@EnableEurekaClient //本服务启动后会自动注册进eureka服务中@EnableDiscoveryClient //服务发现public class DeptProvider8001App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001App.class, args); &#125;&#125;（3）修改microservicecloud-consumer-dept-80工程的DeptConsumerController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.qcmoke.controller;import com.qcmoke.entities.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;/** * DeptConsumerController * * @author qcmoke * @date 2019/09/02 04:34 */@RestControllerpublic class DeptConsumerController &#123; private static final String REST_URL_PREFIX = "http://localhost:8001"; //测试@EnableDiscoveryClient,消费端可以调用服务发现 @RequestMapping(value = "/consumer/dept/discovery") public Object discovery() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/discovery", Object.class); &#125; @Autowired private RestTemplate restTemplate; @RequestMapping(value = "/consumer/dept/add") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + "/dept/add", dept, Boolean.class); &#125; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/get/" + id, Dept.class); &#125; @SuppressWarnings("unchecked") @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/list", List.class); &#125;&#125;（4）测试先启动microservicecloud-eureka-7001的com.qcmoke.EurekaServer7001App.java然后启动microservicecloud-provider-dept-8001的com.qcmoke.DeptProvider8001App.java最后再启动microservicecloud-consumer-dept-80的com.qcmoke.MicroServiceCloudConsumerDept80.java访问http://localhost/consumer/dept/discovery¶4.6 Eureka集群配置需求：集群三个Eureka服务器、并且注册一台微服务。（1）新建microservicecloud-eureka-7002和microservicecloud-eureka-7003（2）按照microservicecloud-eureka-7001为模板粘贴pom.xml到microservicecloud-eureka-7002/microservicecloud-eureka-7003创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）12345678&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt;&lt;/modules&gt;（3）修改主启动类microservicecloud-eureka-7002：com.qcmoke.EurekaServer7002App.java1234567891011121314151617181920package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * EurekaServer7002App * * @author qcmoke * @date 2019/09/02 18:39 */@SpringBootApplication@EnableEurekaServer//EurekaServer服务器端启动类,接受其它微服务注册进来public class EurekaServer7002App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7002App.class, args); &#125;&#125;microservicecloud-eureka-7003：com.qcmoke.EurekaServer7003App.java1234567891011121314151617181920package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * EurekaServer7002App * * @author qcmoke * @date 2019/09/02 18:39 */@SpringBootApplication@EnableEurekaServer//EurekaServer服务器端启动类,接受其它微服务注册进来public class EurekaServer7003App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7003App.class, args); &#125;&#125;（4）配置ip域名映射由于是在本地测试，可以通过配置windows的C:\Windows\System32\drivers\etc\hosts文件来实现ip域名映射。添加如下配置到hosts文件中即可。123127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com127.0.0.1 eureka7003.com（5）3台eureka服务器的yml配置microservicecloud-eureka-70011234567891011server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。microservicecloud-eureka-70021234567891011server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。microservicecloud-eureka-70031234567891011server: port: 7003eureka: instance: hostname: eureka7003.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。（6）配置microservicecloud-provider-dept-8001的yml1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（7）依次启动microservicecloud-eureka-7001、microservicecloud-eureka-7002、microservicecloud-eureka-7003、microservicecloud-provider-dept-8001。然后访问http://eureka7001.com:7001/、http://eureka7002.com:7002/、http://eureka7003.com:7003/ 都能看到如下页面，说明集群成功。¶4.7 Eureka对比Zookeepe作为服务注册中心，Eureka比Zookeeper好在哪里？著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在权衡选择中：Zookeeper保证的是CP,Eureka则是AP。4.1 Zookeeper保证CP当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。4.2 Eureka保证APEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)当网络稳定时，当前实例新的注册信息会被同步到其它节点中因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。¶5. Ribbon负载均衡¶5.1 概念Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。¶5.2 负载均衡LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。常见的负载均衡有软件Nginx，LVS，硬件 F5等。相应的在中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。负载均衡有应用情景：（1）集中式LB即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；（2）进程内LB将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。¶5.3 工作原理Ribbon在工作时分成两步第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。¶5.4 Ribbon配置在做负载均衡的案例时，首先先来看看怎么配置Ribbon。需求：Ribbon和Eureka整合后Consumer可以通过使用Ribbon调用微服务的名称的方式直接调用微服务而不用再关心地址和端口号。（1）修改microservicecloud-consumer-dept-80工程的pom.xml添加如下依赖：12345678910111213&lt;!-- Ribbon相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;全：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-80&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（2）修改application.yml 追加eureka的服务注册地址12345678server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/（3）对com.qcmoke.config.ConfigBean.java添加注解@LoadBalanced 获得Rest时加入Ribbon的配置123456789101112131415161718192021222324252627package com.qcmoke.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * ConfigBean * * @author qcmoke * @date 2019/09/02 04:32 */@Configurationpublic class ConfigBean &#123; /** * RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集 * * @author qcmoke * @date 2019/9/2 4:41 */ @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125;（4）主启动类com.qcmoke.MicroServiceCloudConsumerDept80.java添加@EnableEurekaClient1234567891011121314151617181920package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * MicroservicecloudConsumerDept80 * * @author qcmoke * @date 2019/09/02 04:37 */@SpringBootApplication@EnableEurekaClientpublic class MicroServiceCloudConsumerDept80 &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroServiceCloudConsumerDept80.class, args); &#125;&#125;（5）修改com.qcmoke.controller.DeptConsumerController.java客户端访问类访问微服务的地址为微服务的名称。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qcmoke.controller;import com.qcmoke.entities.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;/** * DeptConsumerController * * @author qcmoke * @date 2019/09/02 04:34 */@RestControllerpublic class DeptConsumerController &#123; //private static final String REST_URL_PREFIX = "http://localhost:8001"; private static final String REST_URL_PREFIX = "http://MICROSERVICECLOUD-DEPT"; //测试@EnableDiscoveryClient,消费端可以调用服务发现 @RequestMapping(value = "/consumer/dept/discovery") public Object discovery() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/discovery", Object.class); &#125; @Autowired private RestTemplate restTemplate; @RequestMapping(value = "/consumer/dept/add") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + "/dept/add", dept, Boolean.class); &#125; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/get/" + id, Dept.class); &#125; @SuppressWarnings("unchecked") @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/list", List.class); &#125;&#125;（6）先启动3个eureka集群后，再启动microservicecloud-provider-dept-8001，最后启动启动microservicecloud-consumer-dept-80。（7）测试访问：http://localhost/consumer/dept/get/1http://localhost/consumer/dept/listhttp://localhost/consumer/dept/add?dname=大数据部¶5.5 Ribbon负载均衡需求：通过使用Ribbon负载均衡实现：浏览consumer时，consumer在自身应用里使用Ribbon实现轮询访问的负载均衡方式访问3个不同的provider。（1）参考microservicecloud-provider-dept-8001，新建两份，分别命名为microservicecloud-provider-dept-8002，microservicecloud-provider-dept-8003,并且pom.xml都加入以下依赖:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的其他模块（microservicecloud-api） --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;（2）将8001的src/main的所有内容覆盖掉8002/8003的src/main，然后修改8002的启动类为DeptProvider8002App.java；将8003的启动类修改为DeptProvider8003App.java（3）创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）12345678910&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt;&lt;/modules&gt;（4）新建8002/8003数据库，各自微服务分别连各自的数据库8002的sql:123456789101112131415161718192021 DROP DATABASE IF EXISTS cloudDB02; CREATE DATABASE cloudDB02 CHARACTER SET UTF8; USE cloudDB02; CREATE TABLE dept( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(60), db_source VARCHAR(60)); INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); SELECT * FROM dept;8003的sql：123456789101112131415161718192021DROP DATABASE IF EXISTS cloudDB03; CREATE DATABASE cloudDB03 CHARACTER SET UTF8; USE cloudDB03; CREATE TABLE dept( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(60), db_source VARCHAR(60)); INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); SELECT * FROM dept;（5）修改8002/8003各自application.yml修改服务端口和instance-id已经数据库名称即可8002：1234567891011121314151617181920212223242526272829303132333435363738server: port: 8002mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB02 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8002 prefer-ip-address: true #访问路径可以显示IP地址info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;8003：1234567891011121314151617181920212223242526272829303132333435363738server: port: 8003mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB03 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8003 prefer-ip-address: true #访问路径可以显示IP地址info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（6）测试先启动3个eureka集群配置区，然后启动3个provider，最后启动consumer。访问http://localhost/consumer/dept/list浏览consumer页面时，consumer是通过轮询的方式访问3个provider的（可通过db_source字段来判断轮询情况），说明负载均衡实现。¶5.6 Ribbon负载均衡调度策略Ribbon负载均衡调度策略关系到Ribbon的一个核心组件IRule。该组件规定的调度策略规则有以下（1）RoundRobinRule 轮询（默认）（2）RandomRule 随机（3）AvailabilityFilteringRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问（4）WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule。（5）RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务（6）BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务（7）ZoneAvoidanceRule 复合判断server所在区域的性能和server的可用性选择服务器在知道了以上调度策略规则后，那怎么来自定义地使用这些规则呢？需求：基于前面轮询访问的规则改为RandomRule随机访问的规则。只需要修改和配置microservicecloud-consumer-dept-80模块即可。（1）在该模块下新建自定义org.qcmoke.rules.MyRuleConfig.java规则配置类官方文档明确给出了警告：这个自定义规则配置类不能放在@ComponentScan(也就是启动类)所扫描的当前包下以及子包下，否则我们自定义的这个规则配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊化定制的目的了。为了避免自定义的规则配置类会被所有的Ribbon客户端所共享，只要不在com.qcmoke这个包以及子包下即可。故我们可以定义在org.qcmoke.rules下即可。1234567891011121314151617181920package org.qcmoke.rules;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * MyRuleConfig * * @author qcmoke * @date 2019/09/04 01:48 */@Configurationpublic class MyRuleConfig &#123; @Bean public IRule myRule() &#123; return new RandomRule();//Ribbon默认是轮询，我自定义为随机 &#125;&#125;（4）修改该模块下的主启动类在启动该微服务的时候就能去加载我们的自定义Ribbon配置类，从而使配置生效12345678910111213141516171819202122package com.qcmoke;import org.qcmoke.rules.MyRuleConfig;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;/** * MicroservicecloudConsumerDept80 * * @author qcmoke * @date 2019/09/02 04:37 */@SpringBootApplication@EnableEurekaClient@RibbonClient(name = "MICROSERVICECLOUD-DEPT", configuration = MyRuleConfig.class)public class MicroServiceCloudConsumerDept80 &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroServiceCloudConsumerDept80.class, args); &#125;&#125;（5）测试先启动3个eureka集群配置区，然后启动3个provider，最后启动consumer。访问 http://localhost/consumer/dept/list发现访问的规则已经变成随机的了。¶5.7 自定义调度策略规则只需要继承AbstractLoadBalancerRule抽象类并实现choose(ILoadBalancer lb, Object key)方法就能实现自定义的调度策略。需求：依旧轮询策略，但是加上新需求，每个服务器要求被调用5次。也即以前是每个服务调用一次后调用下一个，现在是每个服务调用5次后调用下一个。（1）创建规则类org.qcmoke.rules.MyRule.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.qcmoke.rules;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;import java.util.List;/** * 自定义调度策略 * 需求： * 依旧轮询策略，但是加上新需求，每个服务器要求被调用5次。也即以前是每个服务调用一次后调用下一个，现在是每个服务调用5次后调用下一个 * * @author qcmoke * @date 2019/09/04 10:43 */public class MyRule extends AbstractLoadBalancerRule &#123; /** * 总共被调用的次数，目前要求每个服务被调用5次 */ private int total = 0; /** * /当前提供服务的序号 */ private int currentIndex = 0; /** * 自定义调度策略 * * @param lb 当前Ribbon到Eureka获取到的服务负载列表 * @param key * @return 调度到的服务 */ public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; &#125;// int index = rand.nextInt(serverCount);// server = upList.get(index); if (total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125; else &#123; total = 0; currentIndex++; if (currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; &#125;&#125;（2）修改org.qcmoke.rules.MyRuleConfig.java的调度配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.qcmoke.rules;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;import java.util.List;/** * 自定义调度策略 * 需求： * 依旧轮询策略，但是加上新需求，每个服务器要求被调用5次。也即以前是每个服务调用一次后调用下一个，现在是每个服务调用5次后调用下一个 * * @author qcmoke * @date 2019/09/04 10:43 */public class MyRule extends AbstractLoadBalancerRule &#123; /** * 总共被调用的次数，目前要求每个服务被调用5次 */ private int total = 0; /** * /当前提供服务的序号 */ private int currentIndex = 0; /** * 自定义调度策略 * * @param lb 当前Ribbon到Eureka获取到的服务负载列表 * @param key * @return 调度到的服务 */ public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; &#125;// int index = rand.nextInt(serverCount);// server = upList.get(index); if (total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125; else &#123; total = 0; currentIndex++; if (currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; &#125;&#125;（3）测试先启动3个eureka集群配置区，然后启动3个provider，最后启动consumer。访问 http://localhost/consumer/dept/list¶6. Feign负载均衡¶6.1 概念官网解释：http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feignFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单, 它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。Feign是一个声明式的Web服务客户端，使得编写Web服务客户端变得非常容易，只需要创建一个接口，然后在上面添加注解即可。参考官网：https://github.com/OpenFeign/feignFeign能干什么Feign旨在使编写Java Http客户端变得更容易。前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。Feign集成了Ribbon利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用简单的说：Feign是Ribbon的再封装。¶6.2 使用步骤（1）新建microservicecloud-consumer-dept-feign模块（2）复制microservicecloud-consumer-dept-80模块的src内容到microservicecloud-consumer-dept-feign的src中（3）该模块的pom.xml配置复制microservicecloud-consumer-dept-80模块的依赖并额外添加Feign依赖12345&lt;!--Feign--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;注释掉Ribbon（因为Feign依赖中已经包含了Ribbon）1234567&lt;!-- Ribbon相关 --&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;全：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-feign&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka Client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--Feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（4）父项目添加该子模块1234567891011&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt;&lt;/modules&gt;（5）为了Feign能在多个客户端中都能通用，所以把Feign服务定义到microservicecloud-api模块中。给microservicecloud-api工程的pom.xml添加如下依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;全：1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 子类里面显示声明才能有明确的继承表现 --&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 当前Module我自己叫什么名字 --&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt;（6）在microservicecloud-api模块中新建com.qcmoke.service.DeptClientService.java接口并新增注解@FeignClient12345678910111213141516171819202122232425262728package com.qcmoke.service;import com.qcmoke.entities.Dept;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.List;/** * DeptClientService * 针对于MICROSERVICECLOUD-DEPT服务的Feign * * @author qcmoke * @date 2019/09/04 13:49 */@FeignClient(value = "MICROSERVICECLOUD-DEPT")public interface DeptClientService &#123; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") long id); @RequestMapping(value = "/dept/list", method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = "/dept/add", method = RequestMethod.POST) public boolean add(Dept dept);&#125;（7）修改microservicecloud-consumer-dept-feign模块的com.qcmoke.controller.DeptConsumerController.java，调用上一步新建的DeptClientService接口1234567891011121314151617181920212223242526272829303132333435363738package com.qcmoke.controller;import com.qcmoke.entities.Dept;import com.qcmoke.service.DeptClientService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * DeptConsumerController * * @author qcmoke * @date 2019/09/02 04:34 */@RestControllerpublic class DeptConsumerController &#123; @Autowired private DeptClientService service; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return this.service.get(id); &#125; @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return this.service.list(); &#125; @RequestMapping(value = "/consumer/dept/add") public Object add(Dept dept) &#123; return this.service.add(dept); &#125;&#125;（8）给microservicecloud-consumer-dept-feign模块的主启动类添加@EnableFeignClients12345678910111213141516171819202122package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.feign.EnableFeignClients;/** * MicroservicecloudConsumerDept80 * * @author qcmoke * @date 2019/09/02 04:37 */@SpringBootApplication@EnableEurekaClient//@RibbonClient(name = "MICROSERVICECLOUD-DEPT", configuration = MyRuleConfig.class)@EnableFeignClients(basePackages = &#123;"com.qcmoke"&#125;)public class MicroServiceCloudConsumerDept80 &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroServiceCloudConsumerDept80.class, args); &#125;&#125;删除com.qcmoke.config.ConfigBean.java和org.qcmoke.rules包（9）测试先启动3个eureka集群，然后启动3个部门微服务8001/8002/8003，最后启动Feign。访问http://localhost/consumer/dept/list发现实现了Ribbon+RestTemplate的效果。只是Feign省去了RestTemplate调用的复杂过程，让com.qcmoke.controller.DeptConsumerController（Ribbon）也实现了面向接口编程。¶7.Hystrix断路器¶7.1 分布式系统面临的问题复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。服务雪崩在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者，就是所谓的“扇出”。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用，进而引起系统崩溃，所谓的“雪崩效应”。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址https://github.com/Netflix/Hystrix）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离，限流模式等功能，通过这些功能可以提供服务的容错率。备注：一般情况对于服务依赖的保护主要有4种解决方案:（1）熔断模式： 这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。（2）隔离模式： 这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。（3）限流模式： 上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。（4）服务降级： 其实就是线程池中单个线程障处理，防止单个线程请求时间太长，导致资源长期被占有而得不到释放，从而导致线程池被快速占用完，导致服务崩溃。Hystrix能解决如下问题：1.请求超时降级，线程资源不足降级，降级之后可以返回自定义数据2.线程池隔离降级，分布式服务可以针对不同的服务使用不同的线程池，从而互不影响3.自动触发降级与恢复4.实现请求缓存和请求合并¶7.2 服务熔断熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回&quot;错误&quot;的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。（1）参考microservicecloud-provider-dept-8001，新建microservicecloud-provider-dept-hystrix-8001模块创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）123456789101112&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt;&lt;/modules&gt;（2）复制microservicecloud-provider-dept-8001 src里的内容到microservicecloud-provider-dept-hystrix-8001的src里。（3）microservicecloud-provider-dept-hystrix-8001的pom.xml新增依赖12345 &lt;!-- hystrix --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;全：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-provider-dept-hystrix-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的其他模块（microservicecloud-api） --&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（4）修改application.yml1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.qcmoke.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件spring: application: name: microservicecloud-dept #对外暴露的微服务的名称（重点） datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 123456 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（5）修改主启动类为DeptProviderHystrix8001App.java，并添加@EnableCircuitBreaker注解123456789101112131415161718192021222324package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * microservicecloud-provider-dept-8001模块的启动类 * * @author qcmoke * @date 2019/09/02 03:34 */@SpringBootApplication@EnableEurekaClient //本服务启动后会自动注册进eureka服务中@EnableDiscoveryClient //服务发现@EnableCircuitBreaker//对hystrixR熔断机制的支持public class DeptProviderHystrix8001App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProviderHystrix8001App.class, args); &#125;&#125;（6）修改DeptController.java一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qcmoke.controller;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.qcmoke.entities.Dept;import com.qcmoke.service.DeptService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * DeptController * * @author qcmoke * @date 2019/09/02 03:32 */@RestController@Slf4jpublic class DeptController &#123; @Autowired private DeptService service; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) @HystrixCommand(fallbackMethod = "fallbackForGetDept") public Dept get(@PathVariable("id") Long id) &#123; Dept dept = service.get(id); if (null == dept) &#123; throw new RuntimeException("该ID：" + id + "没有没有对应的信息"); &#125; return dept; &#125; /** * 服务熔断处理 * @param id id * @return Dept */ public Dept fallbackForGetDept(@PathVariable("id") Long id) &#123; Dept dept = new Dept().setDeptno(-1L).setDname("null").setDb_source("null"); log.error("fallbackForGetDept = &#123;&#125;", dept); return dept; &#125;&#125;（7）测试先启动3个eureka先启动，然后启动microservicecloud-provider-dept-hystrix-8001，最后启动microservicecloud-consumer-dept-80。访问http://localhost/consumer/dept/get/112 ,由于数据库不存在112这个部门，所以会触发服务熔断处理。¶7.3 服务降级整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。服务降级处理是在客户端实现完成的，与服务端没有关系。（1）修改microservicecloud-api工程，根据已经有的DeptClientService接口新建一个实现了FallbackFactory接口的类com.qcmoke.service.DeptClientServiceFallbackFactory。123456789101112131415161718192021222324252627282930313233343536373839package com.qcmoke.service;import com.qcmoke.entities.Dept;import feign.hystrix.FallbackFactory;import org.springframework.stereotype.Component;import java.util.List;/** * DeptClientServiceFallbackFactory *千万不要忘记在类上面新增@Component注解 * @author qcmoke * @date 2019/09/08 01:19 */@Componentpublic class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt; &#123; @Override public DeptClientService create(Throwable throwable) &#123; return new DeptClientService() &#123; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id) .setDname("该ID：" + id + "没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭") .setDb_source("no this database in MySQL"); &#125; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125;（2）修改microservicecloud-api工程，DeptClientService接口在注解@FeignClient()中添加fallbackFactory属性值12345678910111213141516171819202122232425262728package com.qcmoke.service;import com.qcmoke.entities.Dept;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.List;/** * DeptClientService * 针对于MICROSERVICECLOUD-DEPT服务的Feign * * @author qcmoke * @date 2019/09/04 13:49 */@FeignClient(value = "MICROSERVICECLOUD-DEPT", fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") long id); @RequestMapping(value = "/dept/list", method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = "/dept/add", method = RequestMethod.POST) public boolean add(Dept dept);&#125;（3）修改microservicecloud-consumer-dept-feign工程的yml,添加如下配置123feign: hystrix: enabled: true全：123456789101112server: port: 80feign: hystrix: enabled: trueeureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/（4）测试先启动3个eureka先启动，然后启动microservicecloud-provider-dept-8001，再启动microservicecloud-consumer-dept-feign。先尝试访问http://localhost/consumer/dept/get/1然后故意关闭微服务microservicecloud-provider-dept-8001，然后再次访问http://localhost/consumer/dept/get/1此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。¶7.4 服务监控hystrixDashboard除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。（1）新建工程microservicecloud-consumer-hystrix-dashboard创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）12345678910111213&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-hystrix-dashboard&lt;/module&gt;&lt;/modules&gt;（2）POM1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-consumer-hystrix-dashboard&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- hystrix和 hystrix-dashboard相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（3）YML12server: port: 9001（4）主启动类改名为com.qcmoke.MicroServiceCloudDashboard.java+新注解@EnableHystrixDashboard（5）所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置，添加这个依赖后所有的HystrixCommand 就都会被监控了。12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;（6）启动microservicecloud-consumer-hystrix-dashboard该微服务监控消费端（7）监控测试（7.1）先启动3个eureka集群，然后启动microservicecloud-provider-dept-hystrix-8001，最后启动microservicecloud-consumer-hystrix-dashboard。（7.2）先访问监控窗口http://localhost:9001/hystrix，然后填写监控地址1：Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置该属性来降低客户端的网络和CPU消耗。2：Title：该参数对应了头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题。（7.3）再打开另一个浏览器便签访问并多次刷新http://localhost:8001/dept/get/1（7.4）然后观察监控窗口如何看？7色1圆1曲7色从左到右：请求的成功，熔断数，错误的请求，超时的请求，线程池拒绝数，失败的请求和最近10秒内错误的比率通过上面颜色的含义来表示下图的数字图标：1圆实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例。1曲曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。¶8.zuul路由网关¶8.1 概念其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础.Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。Zuul提供： 代理+路由+过滤三大功能注意：Zuul服务最终还是会注册进Eureka¶8.2 路由基本配置（1）新建Module模块microservicecloud-zuul-gateway-9527创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）1234567891011121314&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;microservicecloud-zuul-gateway-9527&lt;/module&gt;&lt;/modules&gt;（2）pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-zuul-gateway-9527&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- zuul路由网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix容错--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日常标配 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（3）主启动类com.qcmoke.ZuulApplicationApp.java12345678910111213141516171819package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;/** * ZuulApplicationApp * * @author qcmoke * @date 2019/09/08 21:27 */@SpringBootApplication@EnableZuulProxypublic class ZuulApplicationApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplicationApp.class, args); &#125;&#125;（4）修改C:\Windows\System32\drivers\etc\hosts，添加以下映射1127.0.0.1 myzuul.com（5）application.yml123456789101112131415161718192021server: port: 9527spring: application: name: microservicecloud-zuul-gatewayeureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: gateway-9527.com prefer-ip-address: trueinfo: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（6）先启动三个eureka集群，然后启动microservicecloud-provider-dept-8001，最后启动microservicecloud-zuul-gateway-9527。通过路由网关访问的服务接口地址为：http://路由网关ip:路由网关port/访问的服务名/具体的controller接口访问http://myzuul.com:9527/microservicecloud-dept/dept/get/2¶8.3 路由访问映射规则需求：忽略原真实服务名，修改为其他名称以不向外透露服务详细情况。（1）修改yml，添加如下路由网关配置1234567zuul: #prefix: /qcmoke #设置统一公共前缀，那么访问地址为：http://myzuul.com:9527/qcmoke/mydept/dept/get/1 #ignored-services: microservicecloud-dept #原真实服务名忽略 ignored-services: "*" #忽略所有的服务名（如果有多个） routes: mydept.serviceId: microservicecloud-dept mydept.path: /mydept/**全：1234567891011121314151617181920212223242526272829server: port: 9527spring: application: name: microservicecloud-zuul-gatewayeureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: gateway-9527.com prefer-ip-address: truezuul: #prefix: /qcmoke #设置统一公共前缀，那么访问地址为：http://myzuul.com:9527/qcmoke/mydept/dept/get/1 #ignored-services: microservicecloud-dept #原真实服务名忽略 ignored-services: "*" #忽略所有的服务名（如果有多个） routes: mydept.serviceId: microservicecloud-dept mydept.path: /mydept/**info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（2）先启动三个eureka集群，然后启动microservicecloud-provider-dept-8001，最后启动microservicecloud-zuul-gateway-9527。访问http://myzuul.com:9527/microservicecloud-dept/dept/get/2（并网关屏蔽拦截）访问http://myzuul.com:9527/mydept/dept/get/1（访问成功）¶9.SpringCloud Config分布式配置中心¶9.1 SpringCloud Config服务端配置（1）在git远程仓库上新建一个名为microservicecloud-config的新Repository。（2）再本地创建一个仓库，名称为microservicecloud-config,然后进入到仓库里进行初始化。1$ git init（3）再仓库里创建一个文件application.yml123456789101112131415spring: profiles: active: - dev---spring: profiles: dev #开发环境 application: name: microservicecloud-config-qcmoke-dev---spring: profiles: test #测试环境 application: name: microservicecloud-config-qcmoke-test# 请保存为UTF-8格式保存格式必须为UTF-8（4）提交application.yml到git远程仓库1234$ git add .$ git commit -m "init"$ git remote add origin https://github.com/qcmoke/springcloud-config.git$ git push -u origin master（5）新建microservicecloud-config-3344模块它即为Cloud的配置中心模块创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）123456789101112131415&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;microservicecloud-zuul-gateway-9527&lt;/module&gt; &lt;module&gt;microservicecloud-config-3344&lt;/module&gt;&lt;/modules&gt;（6）pom.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-config-3344&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- springCloud Config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt; &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（7）bootstrap.yml1234567891011121314server: port: 3344spring: application: name: microservicecloud-config cloud: config: server: git: uri: https://github.com/qcmoke/springcloud-config.git #git远程仓库上面的git仓库名字# search-paths: pathName# username: qcmoke #账号密码写真实的快一些我觉得，不使用也能访问有点慢# password: ******（8）主启动类com.qcmoke.ConfigApplication3344.java12345678910111213141516171819package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;/** * ConfigApplication3344 * * @author qcmoke * @date 2019/09/08 22:25 */@SpringBootApplication@EnableConfigServerpublic class ConfigApplication3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication3344.class, args); &#125;&#125;（9）修改C:\Windows\System32\drivers\etc\hosts，添加以下映射1127.0.0.1 config-3344.com（10）测试通过Config微服务是否可以从git远程仓库上获取配置内容启动微服务microservicecloud-config-3344访问 http://config-3344.com:3344/application-dev.yml访问 http://config-3344.com:3344/application-test.yml访问 http://config-3344.com:3344/application-xxx.yml (不存在的配置)¶9.2 配置读取规则/{application}-{profile}.ymlhttp://config-3344.com:3344/application-dev.ymlhttp://config-3344.com:3344/application-test.ymlhttp://config-3344.com:3344/application-xxx.yml(不存在的配置)/{application}/{profile}[/{label}]http://config-3344.com:3344/application/dev/masterhttp://config-3344.com:3344/application/test/masterhttp://config-3344.com:3344/application/xxx/master/{label}/{application}-{profile}.ymlhttp://config-3344.com:3344/master/application-dev.ymlhttp://config-3344.com:3344/master/application-test.yml¶9.3 SpringCloud Config客户端配置与测试（1）再本地仓库新建microservicecloud-config-client.yml1234567891011121314151617181920212223242526spring: profiles: active: - dev---server: port: 8201 spring: profiles: dev application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-dev.com:7001/eureka/ ---server: port: 8202 spring: profiles: test application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-test.com:7001/eureka/（2）提交到远程库123$ git add .$ git commit -m "modify"$ git push origin master（3）新建microservicecloud-config-client-3355创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）12345678910111213141516&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;microservicecloud-zuul-gateway-9527&lt;/module&gt; &lt;module&gt;microservicecloud-config-3344&lt;/module&gt; &lt;module&gt;microservicecloud-config-client-3355&lt;/module&gt;&lt;/modules&gt;（4）POM在需要请求config服务的模块里加如下依赖即可12345&lt;!-- SpringCloud Config客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;全：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloud Config客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;（5）再模块里创建bootstrap.yml1234567spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: dev #本次访问的配置项 label: master uri: http://config-3344.com:3344 #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址applicaiton.yml是用户级的资源配置项bootstrap.yml是系统级的，优先级更加高Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。（6）windows下修改hosts文件，增加映射1127.0.0.1 client-config.com（9）创建启动类com.qcmoke.ConfigClientApplication.java12345678910111213141516171819package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * ConfigClientApplication * * @author qcmoke * @date 2019/09/09 02:26 */@SpringBootApplicationpublic class ConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication.class, args); &#125;&#125;（8）新建测试com.qcmoke.controller.ConfigClientRestController.java12345678910111213141516171819202122232425262728293031package com.qcmoke;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * ConfigClientRestController * * @author qcmoke * @date 2019/09/09 02:22 */@RestControllerpublic class ConfigClientRestController &#123; @Value("$&#123;spring.application.name&#125;") private String applicationName; @Value("$&#123;eureka.client.service-url.defaultZone&#125;") private String eurekaServers; @Value("$&#123;server.port&#125;") private String port; @RequestMapping("/config") public String getConfig() &#123; String str = "applicationName: " + applicationName + "\t eurekaServers:" + eurekaServers + "\t port: " + port; System.out.println("******str: " + str); return "applicationName: " + applicationName + "\t eurekaServers:" + eurekaServers + "\t port: " + port; &#125;&#125;（9）测试先启动Config配置中心3344 config服务，然后再启动3355作为Client准备访问决定从github上读取什，决定于bootstrap.yml里面的profile值是什么。假如目前是 profile: dev，dev默认在github上对应的端口就是8201，那就访问http://client-config.com:8201/config假如目前是 profile: test，test默认在github上对应的端口就是8202，那就访问http://client-config.com:8202/config¶9.4 SpringCloud Config配置实战（1）本地仓库新建文件microservicecloud-config-eureka-client.yml1234567891011121314151617181920212223242526272829303132333435363738spring: profiles: active: - dev---server: port: 7001 #注册中心占用7001端口,冒号后面必须要有空格 spring: profiles: dev application: name: microservicecloud-config-eureka-client eureka: instance: hostname: eureka7001.com #冒号后面必须要有空格 client: register-with-eureka: false #当前的eureka-server自己不注册进服务列表中 fetch-registry: false #不通过eureka获取注册信息 service-url: defaultZone: http://eureka7001.com:7001/eureka/---server: port: 7001 #注册中心占用7001端口,冒号后面必须要有空格 spring: profiles: test application: name: microservicecloud-config-eureka-client eureka: instance: hostname: eureka7001.com #冒号后面必须要有空格 client: register-with-eureka: false #当前的eureka-server自己不注册进服务列表中 fetch-registry: false #不通过eureka获取注册信息 service-url: defaultZone: http://eureka7001.com:7001/eureka/（2）再本地仓库新建文件microservicecloud-config-dept-client.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980spring: profiles: active: - dev--- server: port: 8001spring: profiles: dev application: name: microservicecloud-config-dept-client datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/cloudDB01 username: root password: 123456 dbcp2: min-idle: 5 initial-size: 5 max-total: 5 max-wait-millis: 200 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml type-aliases-package: com.qcmoke.entities mapper-locations: - classpath:mybatis/mapper/**/*.xml eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka instance: instance-id: dept-8001.com prefer-ip-address: true info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;---server: port: 8001spring: profiles: test application: name: microservicecloud-config-dept-client datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/cloudDB02 username: root password: 123456 dbcp2: min-idle: 5 initial-size: 5 max-total: 5 max-wait-millis: 200 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml type-aliases-package: com.qcmoke.entities mapper-locations: - classpath:mybatis/mapper/**/*.xml eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://eureka7001.com:7001/eureka instance: instance-id: dept-8001.com prefer-ip-address: true info: app.name: microservicecloud company.name: example.com build.artifactId: $&#123;project.artifactId&#125; build.version: $&#123;project.version&#125;（3）提交到远程库123$ git add .$ git commit -m "modify"$ git push origin master（4）新建工程microservicecloud-config-eureka-client-7001，配置Config版的eureka服务端创建完成后在父工程的pom文件的&lt;project&gt;标签下添加如下代码。（一般IDE工具会自动添加）1234567891011121314151617&lt;modules&gt; &lt;module&gt;microservicecloud-api&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7001&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7002&lt;/module&gt; &lt;module&gt;microservicecloud-eureka-7003&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;microservicecloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;microservicecloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;microservicecloud-zuul-gateway-9527&lt;/module&gt; &lt;module&gt;microservicecloud-config-3344&lt;/module&gt; &lt;module&gt;microservicecloud-config-client-3355&lt;/module&gt; &lt;module&gt;microservicecloud-config-eureka-client-7001&lt;/module&gt;&lt;/modules&gt;microservicecloud-config-eureka-client-7001的pom.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-config-eureka-client-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloudConfig配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;bootstrap.yml1234567spring: cloud: config: name: microservicecloud-config-eureka-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: dev label: master uri: http://config-3344.com:3344 #SpringCloudConfig获取的服务地址application.yml123spring: application: name: microservicecloud-config-eureka-client启动类com.qcmoke.ConfigGitEurekaServerApplication.java12345678910111213141516171819package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * ConfigGitEurekaServerApplication * * @author qcmoke * @date 2019/09/10 02:50 */@SpringBootApplication@EnableEurekaServerpublic class ConfigGitEurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigGitEurekaServerApplication.class, args); &#125;&#125;（5）参考之前的8001拷贝后新建工程microservicecloud-config-dept-client-8001把microservicecloud-provider-dept-8001的src下的文件和目录copy到microservicecloud-config-dept-client-8001的src下pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservicecloud-config-dept-client-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloudConfig配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;bootstrap.yml123456789spring: cloud: config: name: microservicecloud-config-dept-client #需要从github上读取的资源名称，注意没有yml后缀名 #profile配置是什么就取什么配置dev or test #profile: dev profile: test label: master uri: http://config-3344.com:3344 #SpringCloudConfig获取的服务地址application.yml123#spring:# application:# name: microservicecloud-config-dept-client主启动类com.qcmoke.ConfigDeptProvider8001App.java123456789101112131415161718192021package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * ConfigDeptProvider8001App * * @author qcmoke * @date 2019/09/10 02:59 */@SpringBootApplication@EnableEurekaClient //本服务启动后会自动注册进eureka服务中@EnableDiscoveryClient //服务发现public class ConfigDeptProvider8001App &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigDeptProvider8001App.class, args); &#125;&#125;测试：先启动microservicecloud-config-3344微服务，保证Config总配置是OK的，再启动microservicecloud-config-eureka-client-7001微服务，最后启动microservicecloud-config-dept-client-8001先访问http://eureka7001.com:7001/test配置默认访问，http://localhost:8001/dept/list本地换配置成dev，http://localhost:8001/dept/list]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastdfs结合nginx搭建高性能文件服务器]]></title>
    <url>%2Fdevops%2Ffastdfs.html</url>
    <content type="text"><![CDATA[¶FastDFS介绍FastDFS开源地址：https://github.com/happyfish100参考：FastDFS分布式文件系统¶1、简介FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。Tracker Server：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。Storage Server：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份和同步。Client：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。¶2、FastDFS性能方案¶3、FastDFS的存储策略为了支持大容量，存储集群系统采用了分卷（或分组）的组织方式。存储集群系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。在卷中增加服务器时，同步已有的文件由FastDFS系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。当需要做更多备份的时候，可以在卷中添加存储服务器来实现。¶4、FastDFS的上传过程FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。文件名的格式如下：¶5、FastDFS的文件同步写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。¶6、FastDFS的文件下载客户端uploadfile成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。跟upload file一样，在downloadfile时客户端可以选择任意tracker server。tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求。¶环境准备和安装¶使用的系统软件名称说明centos7.xlibfatscommonFastDFS分离出的一些公用函数包FastDFSFastDFS本体fastdfs-nginx-moduleFastDFS和nginx的关联模块nginxnginx1.15.4¶编译环境1yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y¶磁盘目录说明位置所有安装包/usr/local/src数据存储位置/home/dfs/#这里我为了方便把日志什么的都放到了dfs12mkdir /home/dfs #创建数据存储目录cd /usr/local/src #切换到安装目录准备下载安装包¶安装libfatscommonlibfastcommon是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库，基础环境，安装即可 。123git clone https://github.com/happyfish100/libfastcommon.git --depth 1cd libfastcommon/./make.sh &amp;&amp; ./make.sh install #编译安装¶安装FastDFS1234567cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs.git --depth 1cd fastdfs/./make.sh &amp;&amp; ./make.sh install #编译安装#配置文件准备cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/ #供nginx访问使用cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/ #供nginx访问使用¶安装fastdfs-nginx-module123cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfsfastdfs-nginx-module 模块说明FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制， 有同步延迟的问题。假设 Tracker 服务器将文件上传到了 192.168.51.128，上传成功后文件 ID已经返回给客户端。此时 FastDFS 存储集群机制会将这个文件同步到同组存储 192.168.51.129，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.51.129 上取文件,就会出现文件无法访问的错误。而 fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误。¶安装nginx123456wget http://nginx.org/download/nginx-1.15.4.tar.gz #下载nginx压缩包tar -zxvf nginx-1.15.4.tar.gz #解压cd nginx-1.15.4/#添加fastdfs-nginx-module模块./configure --add-module=/usr/local/src/fastdfs-nginx-module/src/ make &amp;&amp; make install #编译安装¶单机部署首先复制示例配置文件为需要使用的配置文件123cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confcp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confcp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用¶tracker配置设服务器ip为 192.168.52.112345mkdir /home/dfsvim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122 # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs # 存储日志和数据的根目录12#启动tracker服务/etc/init.d/fdfs_trackerd start12#关闭防火墙systemctl stop firewalld.service¶storage配置1234567vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000 # storage服务端口（默认23000,一般不修改）base_path=/home/dfs # 数据和日志文件存储根目录store_path0=/home/dfs # 第一个存储目录tracker_server=192.168.52.1:22122 # tracker服务器IP和端口http.server_port=8888 # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)12#启动storage服务/etc/init.d/fdfs_storaged start12#关闭防火墙systemctl stop firewalld.service¶client测试1234vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/dfstracker_server=192.168.52.1:22122 #tracker服务器IP和端口12#关闭防火墙systemctl stop firewalld.service12#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz¶配置nginx访问可以用任意一台安装了nginx的服务器作为nginx服务器12345678910111213141516171819202122vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.1:22122 #tracker服务器IP和端口url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server &#123; listen 8888; ## 该端口为storage.conf中的http.server_port相同 server_name localhost; location ~/group[0-9]/ &#123; ngx_fastdfs_module; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;#测试下载，用外部浏览器访问刚才已传过的nginx安装包,引用返回的IDhttp://192.168.52.1:8888/group1/M00/00/00/wKgAQ1pysxmAaqhAAA76tz-dVgg.tar.gz#弹出下载单机部署全部跑通¶分布式部署设服务器有6台。3台tracker服务器，ip分别为tracker1: 192.168.52.2tracker2: 192.168.52.3tracker3: 192.168.52.43台storage服务器，ip分别为storage1: 192.168.52.5storage2: 192.168.52.6storage3: 192.168.52.7需求：fastdfs分布式集群系统的结构为：有3台tracker服务器同时监控group1(包含storage1和storage2)和group2(只包含storage3)¶tracker配置3台tracker服务器都要做以下配置1234567mkdir /home/dfscp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confvim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122 # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs # 存储日志和数据的根目录store_lookup=0 #选择对storage服务器采取轮询方式存取12#启动tracker服务/etc/init.d/fdfs_trackerd start12#关闭防火墙systemctl stop firewalld.service¶storage配置3台storage服务器都要做以下配置1234567891011121314mkdir /home/dfscp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confvim /etc/fdfs/storage.conf#需要修改的内容如下#设置当前storage server所属的storage组，其中storage1和storage2为group1; storage3为group2group_name=group1#group_name=group2port=23000 # storage服务端口（默认23000,一般不修改）base_path=/home/dfs # 数据和日志文件存储根目录store_path0=/home/dfs # 第一个存储目录tracker_server=192.168.52.2:22122 # tracker1tracker_server=192.168.52.3:22122 # tracker2tracker_server=192.168.52.4:22122 # tracker3http.server_port=8888 # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)12#启动storage服务/etc/init.d/fdfs_storaged start12#关闭防火墙systemctl stop firewalld.service¶client测试12345678mkdir -p /home/moe/dfscp /etc/fdfs/client.conf.sample /etc/fdfs/client.confvim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/moe/dfstracker_server=192.168.52.2:22122 # tracker1tracker_server=192.168.52.3:22122 # tracker2tracker_server=192.168.52.4:22122 # tracker312#关闭防火墙systemctl stop firewalld.service12#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz¶配置nginx访问可以用任意一台安装了nginx的服务器作为nginx服务器123456789101112131415161718192021vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.2:22122 # 服务器1tracker_server=192.168.52.3:22122 # 服务器2tracker_server=192.168.52.4:22122 # 服务器3url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server &#123; listen 8888; ## 该端口为storage.conf中的http.server_port相同 server_name localhost; location ~/group[0-9]/ &#123; ngx_fastdfs_module; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;¶命令使用¶防火墙123#不关闭防火墙的话无法使用systemctl stop firewalld.service #关闭systemctl restart firewalld.service #重启¶tracker1234/etc/init.d/fdfs_trackerd start #启动tracker服务/etc/init.d/fdfs_trackerd restart #重启动tracker服务/etc/init.d/fdfs_trackerd stop #停止tracker服务chkconfig fdfs_trackerd on #自启动tracker服务¶storage1234/etc/init.d/fdfs_storaged start #启动storage服务/etc/init.d/fdfs_storaged restart #重动storage服务/etc/init.d/fdfs_storaged stop #停止动storage服务chkconfig fdfs_storaged on #自启动storage服务¶nginx123/usr/local/nginx/sbin/nginx #启动nginx/usr/local/nginx/sbin/nginx -s reload #重启nginx/usr/local/nginx/sbin/nginx -s stop #停止nginx¶检测集群12/usr/bin/fdfs_monitor /etc/fdfs/storage.conf# 会显示会有几台服务器 有3台就会 显示 Storage 1-Storage 3的详细信息¶说明¶配置文件12345tracker_server #有几台服务器写几个group_name #地址的名称的命名bind_addr #服务器ip绑定store_path_count #store_path(数字)有几个写几个store_path(数字) #设置几个储存地址写几个 从0开始¶可能遇到的问题12345如果不是root 用户 你必须在除了cd的命令之外 全部加sudo如果不是root 用户 编译和安装分开进行 先编译再安装如果上传成功 但是nginx报错404 先检查mod_fastdfs.conf文件中的store_path0是否一致如果nginx无法访问 先检查防火墙 和 mod_fastdfs.conf文件tracker_server是否一致如果不是在/usr/local/src文件夹下安装 可能会编译出错]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok实现内网穿透]]></title>
    <url>%2Ftools%2Fngrok.html</url>
    <content type="text"><![CDATA[ngrok的作用就是实现内网穿透，内网穿透就是允许内网的主机能够被外网的其他主机访问。内网穿透是反向代理技术中的一个中间环节技术。对于反向代理的更多理解可见另外一文《关于代理技术的理解》。ngrok支持的协议：httphttpstcp¶一、域名解析解析ngrok和 *.ngrok两条A记录到dns服务器上：比如域名为example.com而ip为198.23.188.200，那么做以下域名解析：A记录 ngrok --&gt; 198.23.188.200A记录 *.ngrok --&gt; 198.23.188.200¶二、服务端这个代理服务端一般是提供外网（公网）ip的服务器。用其作为反向代理服务器。¶1. 安装（1）安装依赖12$ yum install epel-release -y$ yum install git gcc make golang -y（2）下载ngrok1$ git clone https://github.com/inconshreveable/ngrok.git ~/ngrok（3）配置证书这里为了方便直接在服务器生成自签名证书了，为了安全传输的话可以通过购买或者用Let’s Encrypt免费生成的CA证书。1234567891011121314151617$ cd ~/ngrok $ mkdir cert $ cd cert$ export NGROK_DOMAIN="ngrok.example.com"$ openssl genrsa -out rootCA.key 2048$ openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pem$ openssl genrsa -out device.key 2048$ openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csr$ openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000#配置证书。其实就是替换掉原来的证书(提示overwrite输入y)$ cp rootCA.pem ../assets/client/tls/ngrokroot.crt$ cp device.crt ../assets/server/tls/snakeoil.crt$ cp device.key ../assets/server/tls/snakeoil.key（4）编译服务端和客户端123456#切换回ngrok目录$ cd ~/ngrok#编译服务端程序,生成路径在~/ngrok/bin/ngrokd$ make release-server#编译客户端程序,会生成~/ngrok/bin/windows_amd64/ngrok.exe，编译好后记得将windows_amd64目录copy到本地客户端$ GOOS=windows GOARCH=amd64 make release-client如果编译其他平台客户端可参照以下：Linux 平台 32 位系统：GOOS=linux GOARCH=386Linux 平台 64 位系统：GOOS=linux GOARCH=amd64Windows 平台 32 位系统：GOOS=windows GOARCH=386Windows 平台 64 位系统：GOOS=windows GOARCH=amd64MAC 平台 32 位系统：GOOS=darwin GOARCH=386MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64ARM 平台：GOOS=linux GOARCH=arm¶2. 运行服务端程序1234#为了方便直接关闭防火墙$ service firewalld stop#运行服务端程序$ ~/ngrok/bin/ngrokd -domain="ngrok.example.com"¶三、客户端¶1. 代理web服务在本地客户端的windows_amd64目录里新建文件ngrok.cfg并编辑，在文件里加入以下内容：12server_addr: "ngrok.example.com:4443" trust_host_root_certs: false启动客户端程序12#http://demo.ngrok.example.com:80$ ngrok -config=ngrok.cfg -subdomain demo 80准确的说这个客户端是资源服务器，而真正的客户端因该属于其他终端，故可以在其他终端上访问http://demo.ngrok.example.com:80请求过程：其他终端—&gt;代理服务器—&gt;资源服务器在代理服务端中通过以下命令查看客户端映射到服务端的端口（可以通过打开另一个终端页操作）1$ netstat -tunlp|grep ngrokd¶2. 代理tcp服务ngrok是可以代理tcp协议请求的，比如代理mysql，让内网中的mysql暴露到外网，提供给外网的用户使用。此外不仅可以代理到内网中运行ngrok客户端的主机，还可以代理到同一个内网的其他主机，简直暴力得不像话。编辑客户端配置文件windows_amd64/ngrok.cfg123456789101112131415server_addr: "ngrok.example.com:4443" trust_host_root_certs: false#隧道列表tunnels: mysql-localhost: remote_port: 3306 proto: #代理到本地的mysql,相当于localhost:3306 tcp: 3306 mysql-other: remote_port: 3306 proto: #代理到内网中的其他主机的mysql tcp: 192.168.222.131:3306注意remote_port是远程的代理端口（可以修改为其他值来防止服务器端口冲突），tcp是本地端口。ngrok会将端口为remote_port请求代理到本地端口。启动客户端程序1234567#ngrok -config ngrok.cfg start 隧道名称#代理到本地的mysql$ ./ngrok.exe -config ngrok.cfg start mysql-localhost#代理到内网中的其他主机的mysql$ ./ngrok.exe -config ngrok.cfg start mysql-other¶3. 更多详细代理配置🎁🎁🎁最后献上我个的常用客户端代理配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server_addr: "ngrok.example.com:4443"trust_host_root_certs: false#隧道列表tunnels: ##http代理服务配置 #通过subdomain配置子域名，测试：http://www.ngrok.example.com http: subdomain: www proto: http: 80 ##https代理服务配置 #通过subdomain配置子域名，测试：https://www.ngrok.example.com https: subdomain: www proto: https: 443 ##ssh远程登录代理配置 #防止和代理服务器的ssh端口冲突，所以改用2222 #测试：ssh -p 2222 root@ngrok.example.com ssh: remote_port: 2222 proto: tcp: 192.168.222.131:22 ##mysql代理服务配置 #测试：mysql -h ngrok.example.com -u root -p #(1)代理到本地的mysql mysql-localhost: remote_port: 3306 proto: #相当于localhost:3306 tcp: 3306 #(2)代理到内网中的其他主机的mysql mysql-other: remote_port: 3306 proto: tcp: 192.168.222.131:3306 ##oracle代理服务配置 oracle: remote_port: 1522 proto: tcp: 127.0.0.1:1521 ##gitlib代理服务配置 gitlib: remote_port: 2222 proto: tcp: gitlab.example.com:2222]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>反向代理</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 搭建个人的 gitpages 服务]]></title>
    <url>%2Fblog%2Fgitpages.html</url>
    <content type="text"><![CDATA[gitpages 是结合 git 服务操作的 web 网页托管平台。通过 git 提交再结合 git hook 脚本就能很好的将提交的文件上传到web服务虚拟目录里。但是 Github、Netlify、Coding 等已经提供了免费 gitpages 服务，为什么还要自己在 vps 上折腾搭建 gitpages 呢？因为这些服务商提供的 gitpages 是有限制的，比如空间容量相对较小、对动态网页支持不完善或者没有、访问速度较慢等。那么自建的 gitpages 的优势就显现出来了。下面就介绍怎么一步步搭建该服务。¶1. 搭建 git 服务器仓库¶1）安装 git12apt install -y gityum install -y git接下来我们创建一个git用户组和用户，用来运行git服务：1234#创建git用户组groupadd git#创建git用户并设置登录的shell为git-shell（通过设置git-shell，用户可以通过SSH连接到系统，但只能与远程仓库进行Git交互，而不能执行其他命令，从而确保git用户操作的安全性）useradd git -g git -s /usr/bin/git-shell¶2）配置 ssh 秘钥登录收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。如果没有该文件创建它：12345mkdir -p /home/git/.sshchmod 755 /home/git/.sshtouch /home/git/.ssh/authorized_keyschmod 644 /home/git/.ssh/authorized_keyschown -R git:git /home/git配置客户端的 ssh key 到服务端中，操作如下：1234#copy客户端的秘钥到vps的/home/git/.ssh/authorized_keyscat ~/.ssh/id_rsa.pub#查看ssh秘钥是否配置成功ssh -T git@服务器ip¶3）创建 git 仓库123mkdir -p /opt/blog/gitgit init --bare /opt/blog/git/blog.gitvim /opt/blog/git/blog.git/hooks/post-receive12#!/bin/bashgit --work-tree=/opt/blog/web --git-dir=/opt/blog/git/blog.git checkout -f12345chown -R git:git /opt/blog/git &amp;&amp; chgrp -R git /opt/blog/git &amp;&amp; chmod -R 755 /opt/blog/gitchmod +x /opt/blog/git/blog.git/hooks/post-receivemkdir -p /opt/blog/webchmod -R 777 /opt/blog/web¶4）其他方式搭建 git 服务器仓库以上方式是通过 git 原始支持的方式搭建 git 服务器仓库，此外还可以通过搭建开源的 git 仓库托管平台（如：Gitlab、Gogs 等）来创建服务器仓库，其使用体验会更好。对于在 Gogs 中使用 Git 钩子来部署网站，则操作如下（设 Gogs 是通过 Docker 安装的）：12345docker exec -it gogs bashrm -rf /opt/cache/myblogmkdir -p /opt/cache/myblogchmod -R 777 /opt/cache/myblogexit可在 Gogs 后台面板中的对应仓库，并找到“管理 Git 钩子”，修改 post-receive，内容如下：12345678910111213141516171819#!/bin/sh## An example hook script for the "post-receive" event.## The "post-receive" script is run after receive-pack has accepted a pack# and the repository has been updated. It is passed arguments in through# stdin in the form# &lt;oldrev&gt; &lt;newrev&gt; &lt;refname&gt;# For example:# aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/masterwhile read oldrev newrev refnamedo branch=$(git rev-parse --symbolic --abbrev-ref $refname) if [ "master" = "$branch" ]; then # Do something git --work-tree=/opt/cache/myblog --git-dir=/data/git/gogs-repositories/qcmoke/myblog.git checkout -f fidone提示：以上的 /data/git/gogs-repositories/qcmoke/myblog.git 是对应仓库在 Gogs 容器中的路径，其中 /data/git/gogs-repositories 是固定的，而 /qcmoke/myblog.git 则需根据自己的情况进行修改。¶2. 搭建 web 服务需要安装好nginx，可以参考我的另一篇文章《nginx学习笔记》。这里已经提前通过编译安装的方式把nginx安装到了/opt/nginx目录，然后只需配置nginx即可。1vim /opt/nginx/conf/conf.d/blog.conf12345678server &#123; listen 80; server_name example.com; #填写个人域名 location / &#123; root /data/blog; #配置web根目录 index index.html; &#125;&#125;1234#启动nginx（如果没有启动的话）nginx#重新加载nginx配置文件nginx -s reload¶3. 配置 https 服务使用 https 就需要配置 SSL 证书 ，SSL证书有免费的和付费的，这里使用的是免费的 Let’ s Encrypt SSL证书。具体操作参考《通过certbot工具生成ssl证书》。参考该教程使用 certbot 工具通过HTTP 验证模式申请签发多域名证书。配置nginx web服务1vim /opt/nginx/conf/conf.d/blog.conf需求：http://example.com、http://www.example.com、https://example.com都重定向到https://www.example.com，并且图片都能压缩传输。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152server &#123; listen 80; listen 443 ssl; server_name example.com; # 配置域名所属的SSL证书和私钥文件 ssl_certificate /path/fullchain.pem; ssl_certificate_key /path/privkey.pem; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; charset utf-8; # 请求全部跳转到 https://www.example.com location / &#123; #rewrite ^ https://www.$host$request_uri? permanent; #rewrite ^(.*)$ https://www.$host$1 permanent; return 301 https://www.$host$request_uri; &#125;&#125;server &#123; listen 80; listen 443 ssl; server_name www.example.com; # 配置域名所属的SSL证书和私钥文件 ssl_certificate /path/fullchain.pem; ssl_certificate_key /path/privkey.pem; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; charset utf-8; root /opt/blog/web; #root /opt/cache/myblog; index index.html index.htm; error_page 404 /404.html; # 请求全部跳转到 https if ($scheme = http) &#123; return 301 https://$host$request_uri; &#125; location ~ .*\.(jpg|png|gif)$ &#123; # root /opt/blog/web/images; #传输压缩，压缩本身比较耗费服务端性能，但给带宽带来更好的传输。恰当的使用会增强资源的访问效率。 gzip on; gzip_http_version 1.1; gzip_comp_level 2; #压缩的文件类型，一般按需选择，但这里为了未来方便添加文件类型多选一些。具体配置参考文件/etc/nginx/mime.types gzip_types gzip_types text/plain application/json application/x-javascript application/css application/xml application/xml+rss text/javascript application/x-httpd-php image/jpeg image/gif image/png; #设置静态资源文件在客户端的缓存时间，除非客户清楚缓存或者关闭缓存或者强制访问才会再访问。 expires 5h; &#125;&#125;重载配置1nginx -s reload¶4. 测试客户机123456git clone git@example.com:/opt/blog/git/blog.gitcd blog/echo "&lt;h1&gt;My Bolg&lt;/h1&gt;" &gt;&gt; index.htmlgit add . git commit -m "init my blog"git push -u origin master之后浏览器访问http://example.com就能访问到push到服务器的index.html页面了。📚 参考https://www.jianshu.com/p/23aa1eef5b23https://juejin.im/post/5c935d7c6fb9a070b24b11a6]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+vsftp搭建图片服务器]]></title>
    <url>%2Fdevops%2Fftp_nginx.html</url>
    <content type="text"><![CDATA[¶一、nginxNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。以上是百度百科的介绍，我们目前只需要知道nginx是一个服务器就行了，类似于tomcat的服务器，只不过我们把它用来保存图片。¶二、vsftpVSFTP是一个基于GPL发布的类Unix系统上使用的FTP服务器软件，它有安全、高速、稳定等特点。我们暂且这样理解:vsftp就是用来传输文件的一个服务，在linux系统中开启vsftp服务，并在windows中就可以通过服务器的ip、端口、用户名及密码来连接vsftp服务，之后就可以方便的把windows中东西上传到linux中，也可以把linux中的东西下载到windows中。¶三、nginx+vsftp上面分别介绍了nginx和vsftp，那么这两个东西怎么组合起来用呢？怎么实现图片服务器呢？我们知道，tomcat安装好启动后，在浏览器输入localhost:8080，就会出现tomcat的欢迎页，nginx也一样。比如linux的ip是192.168.50.122，那么启动nginx后，在浏览器访问这个地址也会出现nginx的欢迎页，其实是因为它有个默认的访问页面，完整的地址应该是192.168.50.122/index.html，那么我们就可以根据这个，把它默认的访问路径面改成我们上传的图片的保存路径，比如上传了一张pic.jpg图片到linux的/home/ftpuser/images中，如果我们把web根路径设置为：/home/ftpuser，那么在浏览器中输入192.168.50.122/images/pic.jpg，就可以访问到这张图片了。下面就来介绍nginx、vsftp的安装以及配置。¶四、安装nginx¶1.准备活动123456##下载wget http://nginx.org/download/nginx-1.14.0.tar.gz##解压tar zxvf nginx-1.14.0.tar.gz##设置vim编辑nginx配置文件语法高亮（可选，如果不想用了直接删除~/.vim/目录即可）mkdir ~/.vim &amp;&amp; cp -r nginx-1.14.0/contrib/vim/* ~/.vim/¶2. 安装编译工具及依赖库文件1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre pcre-devel¶3.编译安装12345678910111213141516#进入解压好的源码目录cd nginx-1.14.0#生成MakeFile./configure \--prefix=/usr/local/nginx \--with-http_stub_status_module \--with-http_ssl_module \--with-http_sub_module \--with-http_gzip_static_module#根据MakeFile编译make#安装make install¶4.启动1&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx查看是否启动命令： ps aux | grep nginx¶5.停止123/usr/local/nginx/sbin/nginx -s stop#或者/usr/local/nginx/sbin/nginx -s quit¶6 动态加载1/usr/local/nginx/sbin/nginx -s reload区别：nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。nginx -s reload:动态加载，当配置文件nginx.conf有变化时执行该命令动态加载。¶7 测试配置文件nginx.conf正确性1/usr/local/nginx/sbin/nginx -t¶8.其他常用命令12#查看编译加载的模块/usr/local/nginx/sbin/nginx -V¶五、安装vsftp¶1. 安装1yum -y install vsftpd¶2. 关闭SELinux命令行设置selinux12setenforce 0 # 设置SELinux 成为permissive模式 （临时关闭SELinux）setenforce 1 # 设置SELinux 成为enforcing模式 （临时开启SELinux）或者修改selinux配置文件（永久）1234567vi /etc/selinux/config# SELINUX=enforcing # 注释掉# SELINUXTYPE=targeted # 注释掉SELINUX=disabled # 增加:wq! #保存退出setenforce 0或者设置SELinux123456getsebool -a | grep ftpsetsebool -P ftpd_full_access onsystemctl stop firewalld.service#停止firewallsystemctl disable firewalld.service#禁止firewall开机启动¶3. 防火墙设置关闭防火墙，如果你不愿意关闭防火墙，需要防火墙添加FTP服务。12firewall-cmd --permanent --zone=public --add-service=ftpfirewall-cmd --reload¶4. 设置开机启动1[root@localhost ~]# chkconfig vsftpd on¶5. 配合vsftp1vim /etc/vsftpd/vsftpd.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Example config file /etc/vsftpd/vsftpd.conf## The default compiled in settings are fairly paranoid. This sample file# loosens things up a bit, to make the ftp daemon more usable.# Please see vsftpd.conf.5 for all compiled in defaults.## READ THIS: This example file is NOT an exhaustive list of vsftpd options.# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's# capabilities.## Allow anonymous FTP? (Beware - allowed by default if you comment this out).anonymous_enable=YES## Uncomment this to allow local users to log in.# When SELinux is enforcing check for SE bool ftp_home_dirlocal_enable=YES## Uncomment this to enable any form of FTP write command.write_enable=YES## Default umask for local users is 077. You may wish to change this to 022,# if your users expect that (022 is used by most other ftpd's)local_umask=022## Uncomment this to allow the anonymous FTP user to upload files. This only# has an effect if the above global write enable is activated. Also, you will# obviously need to create a directory writable by the FTP user.# When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access#anon_upload_enable=YES## Uncomment this if you want the anonymous FTP user to be able to create# new directories.#anon_mkdir_write_enable=YES## Activate directory messages - messages given to remote users when they# go into a certain directory.dirmessage_enable=YES## Activate logging of uploads/downloads.xferlog_enable=YES## Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES## If you want, you can arrange for uploaded anonymous files to be owned by# a different user. Note! Using "root" for uploaded files is not# recommended!#chown_uploads=YES#chown_username=whoever## You may override where the log file goes if you like. The default is shown# below.#xferlog_file=/var/log/xferlog## If you want, you can have your log file in standard ftpd xferlog format.# Note that the default log file location is /var/log/xferlog in this case.xferlog_std_format=YES## You may change the default value for timing out an idle session.#idle_session_timeout=600## You may change the default value for timing out a data connection.#data_connection_timeout=120## It is recommended that you define on your system a unique user which the# ftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure## Enable this and the server will recognise asynchronous ABOR requests. Not# recommended for security (the code is non-trivial). Not enabling it,# however, may confuse older FTP clients.#async_abor_enable=YES## By default the server will pretend to allow ASCII mode but in fact ignore# the request. Turn on the below options to have the server actually do ASCII# mangling on files when in ASCII mode. The vsftpd.conf(5) man page explains# the behaviour when these options are disabled.# Beware that on some FTP servers, ASCII support allows a denial of service# attack (DoS) via the command "SIZE /big/file" in ASCII mode. vsftpd# predicted this attack and has always been safe, reporting the size of the# raw file.# ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES## You may fully customise the login banner string:#ftpd_banner=Welcome to blah FTP service.## You may specify a file of disallowed anonymous e-mail addresses. Apparently# useful for combatting certain DoS attacks.#deny_email_enable=YES# (default follows)#banned_email_file=/etc/vsftpd/banned_emails## You may specify an explicit list of local users to chroot() to their home# directory. If chroot_local_user is YES, then this list becomes a list of# users to NOT chroot().# (Warning! chroot'ing can be very dangerous. If using chroot, make sure that# the user does not have write access to the top level directory within the# chroot)chroot_local_user=YESallow_writeable_chroot=YES#chroot_list_enable=YES# (default follows)#chroot_list_file=/etc/vsftpd/chroot_list## You may activate the "-R" option to the builtin ls. This is disabled by# default to avoid remote users being able to cause excessive I/O on large# sites. However, some broken FTP clients such as "ncftp" and "mirror" assume# the presence of the "-R" option, so there is a strong case for enabling it.#ls_recurse_enable=YES## When "listen" directive is enabled, vsftpd runs in standalone mode and# listens on IPv4 sockets. This directive cannot be used in conjunction# with the listen_ipv6 directive.listen=NO## This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 "any" address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.# Make sure, that one of the listen options is commented !!listen_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES¶6. 重启vsftpd1systemctl restart vsftpd.service¶7. 添加ftp用户1useradd -m -d /home/ftpuser/ ftpuser如果不让ftpuser登陆ssh，但是可以登录ftp可以选择下面的两条命令操作1234567#禁止用户ssh登录useradd -m -d /home/ftpuser -s /sbin/nologin ftpuser#允许禁止ssh登陆的用户ftp登录，释掉PAM模块对vsftp登录的过度验证配置vim /etc/pam.d/vsftpd##注释掉下面这行#auth required pam_shells.so¶8. 给ftp用户添加密码1passwd ftpuser输入两次密码后修改密码。¶9. 设置访问权限1chmod -R 755 /home/ftpuser¶10. 登录vsftp测试下载客户端工具，比如FTPRush安装好ftp客户端后，连接服务器过程如图：此时ftpuser用户访问到的根目录其实是服务器的/home/ftpuser目录。可在这个目录里实现简单的文件操作。¶六、整合nginx和vsftp其实就是将ftpuser用户的主目录定义为nginx的web根目录，如此就能实现基于http资源的图片系统。12345678910111213141516171819server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; root /home/ftpuser; #配置web根目录 index index.html index.htm; &#125; #其他内容省略 ....... ....... .......&#125;nginx加载配置文件1/usr/local/nginx/sbin/nginx -s reload访问测试通过ftp客户端工具上传好图片后，比如先通过ftp客户端创建一个images目录，然后在目录里上传图片90c8013a-2bc4-491c-b74e-d0505b215dd6_logo.jpg。可通过访问地址访问到图片。http://101.132.45.132/images/90c8013a-2bc4-491c-b74e-d0505b215dd6_logo.jpg]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmder工具使用教程]]></title>
    <url>%2Ftools%2Fcmder.html</url>
    <content type="text"><![CDATA[记录一次Cmder安装和使用的历程…1. 安裝 Cmder打开Cmder官网，下载的时候，有两个版本，分别是mini与full版；两个的差别在于有没有内建git-for-windows工具；我这里选择full版本点击下载。下载的是Cmder的压缩包, 可解压即用。2. 启动 Cmder​ Cmder是即压即用的存在，所以解压后双击击Cmder.exe即可运行（启动）。3. 配置 Cmder​ 每次进入到Cmder解压目录双击Cmder.exe打开的方式很麻烦，可以使用下面几种方式很好的解决问题；​ a、把 Cmder 加到环境变量​ 把Cmder.exe存放的目录添加到系统环境变量；加完之后,Win+r一下输入cmder,即可。如下图：b、添加鼠标右键以管理员权限打开cmd，输入下面命令（先把 cmder 添加到系统变量中）1Cmder.exe &#x2F;REGISTER ALL配置完成后，鼠标右键可看到 cmder 选项，打开 cmder，终端显示目录为当前目录若想删除鼠标右键打开 cmder，根目录新建文件*.bat，写入下面内容，以管理员身份运行即可123@echo offReg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder&quot; &#x2F;fpause参考：https://xiaogliu.github.io/2017/04/07/install-and-configure-cmder/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习笔记]]></title>
    <url>%2Ffront%2Fvue.html</url>
    <content type="text"><![CDATA[虽然本人更多从事的是java后端开发，但作为一名精神小伙，本就有着架构的梦想，所以一直希望自己前后端都要有所涉猎，于是开始学习Vue框架作为拓展前端道路的试水区。¶一、简介官网：https://cn.vuejs.org¶1. 概念Vue.js是一套构建用户界面的渐进式框架。Vue只关注视图层， 采用自底向上增量开发的设计。Vue 的目标是通过尽可能简单的 API实现响应的数据绑定和组合的视图组件。简单的理解：Vue就是和jQuery类似但更强的一个前端框架，它的中心思想就是数据驱动。而jQuery是结构驱动的，具体来说jQuery不算框架，而是js库。Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）¶2. 框架和库的区别框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目,虽然有这个缺点，但是功能完善。库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。比如从Jquery 切换到Zepto，又比如从 EJS 切换到 art-template。¶3. 为什么要学习前端框架提高开发效率。提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js/ Vue.js/React.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）减少少DOM操作。在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑。¶4. 前端的MVVM为了维护和管理前端开发，前端开发一般还要MVVM的分层开发模式。不要理解成MVC，MVC 是后端的分层开发概念。而MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM (即ViewModel)。¶二、安装¶1. &lt;script&gt; 标签引入vue.js文件1&lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;例如：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;VueJS Tutorials&lt;/title&gt; &lt;link href="styles.css" rel="stylesheet" /&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;¶2. 使用NPM工具构建12# 最新稳定版$ npm install vue¶三、 hello worldapp.js1234567new Vue(&#123; //引入vue包后，浏览器的内存中就多了一个Vue的构造函数，只需要new Vue，就能实例化出Vue对象，该对象就是ViewModel，每当我们创建了一个Vue实例，就创建了一个新的ViewModel。 el: '#vue-app', //el（即elemet）: 挂载点，需要绑定的vue根容器（根元素），一切的vue相关操作都在这个元素内进行。元素外不起作用。 data: &#123; //data：数据选项，用于数据的存储,存放key/value。data就是mvvm中的model username: 'qcmoke', //只需要在元素标签中使用表达式&#123;&#123;key&#125;&#125;或者v-text等插值表达式就能显示key对应的值，省略了麻烦的dom操作 msg: 'hello world !' &#125;&#125;);index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello world&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;!--引入vue.js--&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- vue根容器（根元素） --&gt; &lt;h1&gt;Hey, &#123;&#123; username &#125;&#125;&lt;/h1&gt;&lt;!--根据data中的key使用模版语法&#123;&#123;&#125;&#125;取出值，vue将&#123;&#123;&#125;&#125;里的内容放到虚拟dom里，再通过虚拟dom将该内容放回真实dom的相关元素里--&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="app.js"&gt;&lt;/script&gt;&lt;!--引入app.js,app.js存储vue对象等相关业务代码--&gt;&lt;/html&gt;¶四、数据显示¶1. 显示文本内容¶1.1 插值表达式123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello world&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- 使用v-cloak结合css样式能够解决插值表达式闪烁的问题 --&gt; &lt;h1 v-cloak&gt;Hey, &#123;&#123; username &#125;&#125;&lt;/h1&gt; &lt;h1 v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; username: 'qcmoke', msg: 'hello world !' &#125; &#125;);&lt;/script&gt;&lt;/html&gt;解决使用插值表达式显示data数据出现闪烁的问题。步骤是，在有插值表达式内容的标签里添加v-cloak属性，然后添加如下css样式表即可解决。12345&lt;style&gt; [v-cloak]&#123; display: none; &#125;&lt;/style&gt;¶1.2 v-text与插值表达式功能是一样的。12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-text&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;h1 v-text="username"&gt;&lt;/h1&gt; &lt;h1 v-text="msg"&gt;&lt;/h1&gt; &lt;!-- &lt;h1&gt;Hey, &#123;&#123; username &#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; username: 'qcmoke', msg: 'hello world !' &#125; &#125;);&lt;/script&gt;&lt;/html&gt;与插值表达式不同的是不会出现插值表达式的闪烁的问题。原因是v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空。如何选择插值表达式和v-text？如果内容含有data没有的一些字符，那么建议使用插值表达式结合v-cloak属性使用。如果内容只有data里的数据，那么建议使用v-cloak。¶2. 显示html元素¶2.1 v-html作用：用于输出data中的html数据。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-html&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;h1 v-html="msg_el"&gt;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; msg_el: '&lt;h1 style="color: red"&gt;hello world !&lt;/h1&gt;' &#125; &#125;);&lt;/script&gt;&lt;/html&gt;使用v-text或者插值表达式只能显示纯文本内容¶五、属性数据绑定¶1. 单向数据绑定 v-bind作用：用于给html元素的属性绑定数据缩写: :实现步骤：在原来属性的值里写vue中data的key，并在原属性前添加&quot;v-bind:&quot;，以此来给属性绑定vue的数据。数据绑定方式：单向数据绑定，即从model自动绑定到view，view上绑定的属性数据(值)会随着model值的改变而改变，但是view中绑定的属性数据(值)的改变不会改变model中属性的数据(值)。绑定方向：model----&gt;view。作用范围：所有标签元素。vue会将元素中属性绑定的key当作是js表达式返回，所以可以进行合法的运算操作。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-bind&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- 在原来属性的值里写vue中data的key，并在原属性前添加"v-bind:"，以此来给属性绑定vue的数据 --&gt; &lt;a v-bind:href="vue_url"&gt;vue的官网链接&lt;/a&gt; &lt;br /&gt; &lt;!-- vue会将元素中属性绑定的key当作是js表达式返回，所以可以进行合法的运算操作 --&gt; &lt;a v-bind:href="vue_url+'/v2/guide/'"&gt;vue官方文档链接&lt;/a&gt; &lt;!-- v-bind 作用：用于给html元素的属性绑定数据 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; vue_url: 'https://cn.vuejs.org' &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2. 双向数据绑定 v-model作用：用于给html元素的属性绑定数据缩写: :model实现步骤：在需要表单元素里添加v-model=&quot;data找那个的key&quot;即可实现双向数据绑定。数据绑定方式：双向数据绑定，即从model和view数据互相绑定，view上绑定的属性数据(值)会随着model值的改变而改变，并且view中绑定的属性数据(值)的改变也会改变model中属性的数据(值)。绑定方向：model&lt;----&gt;view。双向数据绑定不可以进行表达式运算操作。作用范围：v-model只能使用在表单元素中，如input(radio, text, address, email....) 、 select checkbox 、textarea等。测试单向数据绑定和双向数据绑定的区别123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-bind&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; 单向数据绑定：&lt;input type="text" v-bind:value="key1"&gt; &lt;br&gt;&lt;br&gt; 双向数据绑定：&lt;input type="text" v-model="key2"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue-app', data: &#123; key1: 'value of key1', key2: 'value of key2' &#125; &#125;);&lt;/script&gt;&lt;/html&gt;model—&gt;view方向数据变化情况(通过浏览器的控制台操作内存中的vue对象即可改变model中的数据)model数据未改变时：model数据改变时：view—&gt;model方向数据变化情况input（view）不改变值时的情况：input（view）改变值时的情况：从以上两个方向数据的改变即可看出单向数据绑定和双向数据绑定的差异。¶六、事件绑定¶1. v-on作用：事件绑定。缩写: @步骤：在原来的事件属性前添加“v-on:”，并给事件属性赋vue的data key。，最后在vue对象的methods属性里添加key对应的方法。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-on&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;button v-on:click="show"&gt;点击按钮&lt;/button&gt; &lt;!-- v-on 作用：事件绑定。 步骤：在原来的事件属性前添加“v-on:”，并给事件属性赋vue的data key。，最后在vue对象的methods属性里添加key对应的方法。 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 show: function () &#123; alert("hello Vue !"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2. 事件修饰符.stop 阻止冒泡​ 冒泡：在多个绑定有事件的元素嵌套中。当触发一个元素时，伴随着嵌套的元素也会触发事件。.prevent 阻止默认事件.capture 添加事件侦听器时使用事件捕获模式.self 只当事件在该元素本身触发时触发回.once 事件只触发一次¶2.1 阻止冒泡.stop（冒泡的情况）1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;div @click="divHandle"&gt; &lt;!-- 使用v-on缩写的方式指定vue事件绑定 --&gt; &lt;button @click="buttonHandle"&gt;点击按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 divHandle: function () &#123; console.info("hello div !"); &#125;, buttonHandle() &#123; console.info("hello button !"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;（阻止冒泡的情况）在需要阻止冒泡的的元素vue事件属性后添加.stop。12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;div @click="divHandler"&gt; &lt;!-- 使用v-on缩写的方式指定vue事件绑定 使用.stop阻止父元素事件（在当前元素发生事件后就停止了，没有继续冒泡下去） --&gt; &lt;button @click.stop="buttonHandler"&gt;点击按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 divHandler: function () &#123; console.info("hello div !"); &#125;, buttonHandler() &#123; console.info("hello button !"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2.2 阻止默认事件.prevent12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- 使用.prevent事件修饰符阻止a标签的默认跳转事件 --&gt; &lt;a :href="vue_url" @click.prevent="linkHandler"&gt;点击链接&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 linkHandler() &#123; console.info("触发链接点击事件！"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2.3 添加事件捕获 .capture12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- 事件捕获 即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。 就是谁有该事件修饰符，就先触发谁。 在嵌套的事件元素组中，默认事件是从里往外触发的，如果希望从外往里触发，可以在外元素的vue事件后添加.capture修饰符即可完成。 --&gt; &lt;div @click.capture="divHandler" style="width: 100px; height: 100px; background: gray;"&gt; &lt;button @click="buttonHandler"&gt;点击按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 divHandler: function () &#123; console.info("hello div !"); &#125;, buttonHandler() &#123; console.info("hello button !"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2.4 只触发当前元素事件 .self不触发其他嵌套的元素1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- .self 只触发当前元素事件。不触发其他嵌套的元素 --&gt; &lt;div @click.self="divHandler" style="width: 100px; height: 100px; background: gray;"&gt; &lt;button @click="buttonHandler"&gt;点击按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 divHandler: function () &#123; console.info("hello div !"); &#125;, buttonHandler() &#123; console.info("hello button !"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶2.5 事件只触发一次.once作用：事件只触发一次1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- .once 作用：事件只触发一次 只在第一次点击的时候触发.prevent事件修饰符阻止a标签的默认跳转事件，第二次之后原本的默认跳转事件会被触发 --&gt; &lt;a :href="vue_url" @click.prevent.once="linkHandler"&gt;点击链接&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: '#vue-app', //el属性定义vue的控制区域 data: &#123; //data属性定义所有vue数据 vue_url: 'https://cn.vuejs.org' &#125;, methods: &#123; //methods定义所有vue可用的方法 linkHandler() &#123; console.info("触发链接点击事件！"); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt;¶3. 按键修饰符Vue 默认提供了几个常用的按键码的别名（键盘修饰符）：123456789.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right使用方式：1v-on:keyup.键盘修饰符="事件方法()"如下：12&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter="submit"&gt;如果以上提供的键盘修饰符任然不够用，可以通过以下js代码进行扩展。12// 自定义全局按键修饰符Vue.config.keyCodes.自定义修饰符名称 = 键码值;字母和数字键的键码值(keyCode)按键键码按键键码按键键码按键键码A65J74S83149B66K75T84250C67L76U85351D68M77V86452E69N78W87553F70O79X88654G71P80Y89755H72Q81Z90856I73R82048957数字键盘上的键的键码值(keyCode)功能键键码值(keyCode)按键键码按键键码按键键码按键键码0968104F1112F71181979105F2113F8119298*106F3114F9120399+107F4115F101214100Enter108F5116F111225101-109F6117F121236102.1107103/111控制键键码值(keyCode)按键键码按键键码按键键码按键键码BackSpace8Esc27Right Arrow39-_189Tab9Spacebar32Dw Arrow40.&gt;190Clear12Page Up33Insert45/?191Enter13Page Down34Delete46`~192Shift16End35Num Lock144[{219Control17Home36;:186|220Alt18Left Arrow37=+187]}221Cape Lock20Up Arrow38,&lt;188'&quot;222多媒体键码值(keyCode)按键键码按键键码按键键码按键键码音量加175音量减174停止179静音173浏览器172邮件180搜索170收藏171123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; #app input &#123; width: 300px; border-style: solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model:value="enter_value" @keyup.enter='enterHandler' placeholder="请输入值之后，按Enter键完成操作！"&gt; &lt;input type="text" v-model:value="f2_value" @keyup.f2='f2Handler' placeholder="请输入值之后，按F2键完成操作！"&gt; &lt;/div&gt; &lt;script&gt; // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113; new Vue(&#123; el: "#app", data: &#123; enter_value: '', f2_value: '' &#125;, methods: &#123; enterHandler: function () &#123; alert("hello " + this.enter_value); &#125;, f2Handler: function () &#123; alert("hello " + this.f2_value); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶七、样式绑定¶1. class 属性绑定¶1.1 数组形式样式名称数组（此时的样式名称是boolean类型）1&lt;div v-bind:class="['active', 'danger']"&gt;&lt;/div&gt;或者数组中使用三元表达式对样式名称计算1&lt;div v-bind:class="[isActive?'active':'',!'danger']"&gt;&lt;/div&gt;或者数组中使用对象1&lt;div v-bind:class="[!'danger',&#123;active:isActive&#125;]"&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .active &#123; width: 100px; height: 100px; background: green; &#125; .danger &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- 样式名称数组（此时的样式名称是boolean类型） --&gt; &lt;div v-bind:class="['active', 'danger']"&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 数组中使用三元表达式对样式名称计算 --&gt; &lt;div v-bind:class="[isActive?'active':'',!'danger']"&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 数组中使用对象 --&gt; &lt;div v-bind:class="[!'danger',&#123;active:isActive&#125;]"&gt;&lt;/div&gt;&lt;!-- &#123;active:isActive&#125;是一个对象 --&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; isActive: true &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶1.2 对象形式1&lt;div v-bind:class="&#123; key: isActive,danger: false &#125;"&gt;&lt;/div&gt;或者1&lt;div v-bind:class="classObj"&gt;&lt;/div&gt;案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .active &#123; width: 100px; height: 100px; background: green; &#125; .danger &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- v-bind:class的值是一个对象，可以是对象实例，也可以是对象的名称（model的key） --&gt; &lt;!-- &#123; active: isActive,danger: false &#125;是一个对象,对象的key对应的值可以是model的key，也可以是boolean值 --&gt; &lt;div v-bind:class="&#123; active: isActive,danger: false &#125;"&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- classObj是对象的名称（model的key） --&gt; &lt;div v-bind:class="classObj"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#vue-app', data: &#123; isActive: true, classObj: &#123; active: true, danger: true &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶2. style(内联样式)属性绑定在:style中通过key引用data中的样式对象1&lt;h1 :style="styleObj1"&gt;这是一个h1&lt;/h1&gt;在:style中通过数组，引用多个data上的样式对象1&lt;h1 :style="[ styleObj1, styleObj2 ]"&gt;这是一个h1&lt;/h1&gt;案例：1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 在:style中通过key引用data中的样式对象 --&gt; &lt;h1 :style="styleObj1"&gt;这是一个h1&lt;/h1&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 在:style中通过数组，引用多个data上的样式对象 --&gt; &lt;h1 :style="[ styleObj1, styleObj2 ]"&gt;这是一个h1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; styleObj1: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'oblique' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶八、遍历v-for12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 一、遍历数字 --&gt; &lt;!-- in 后面我们放过 普通数组，对象数组，对象， 还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;!-- 每遍历一次生成一个v-for绑定的元素 --&gt; &lt;p v-for="count in 10"&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;/p&gt; &lt;!-- 二、遍历普通数组 (1)通过下标取值 (2)v-for属性遍历 --&gt; &lt;p&gt;&#123;&#123;list[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[1]&#125;&#125;&lt;/p&gt; &lt;p v-for="(item, i) in list"&gt;索引值：&#123;&#123;i&#125;&#125; --- 每一项：&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;!-- 三、遍历对象 --&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for="(val, key, i) in user"&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!-- 四、遍历对象数组 --&gt; &lt;p v-for="(user, i) in users"&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6], user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125;, users: [ &#123; id: 1, name: 'zs1' &#125;, &#123; id: 2, name: 'zs2' &#125;, &#123; id: 3, name: 'zs3' &#125;, &#123; id: 4, name: 'zs4' &#125; ] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶九、条件判断¶1. v-ifv-if 指令将根据表达式的值(true 或 false )来决定是否插入绑定的元素。12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;v-if&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; p &#123; width: 100px; height: 100px; text-align: center; line-height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!-- v-if 指令将根据表达式的值(true 或 false )来决定是否插入绑定的元素。 --&gt; &lt;p v-if="flag1"&gt;p1&lt;/p&gt; &lt;p v-if="flag2"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#vue-app', data: &#123; flag1: false, flag2: true &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶2. v-if、v-else和v-else-if123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;v-if、v-else、v-else-if&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-if="type === 'A'"&gt; A &lt;/div&gt; &lt;div v-else-if="type === 'B'"&gt; B &lt;/div&gt; &lt;div v-else-if="type === 'C'"&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; type: 'C' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶3. v-show根据条件展示或者隐藏元素(而不是像v-if那样插入或者删除元素)12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;v-show&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; p &#123; width: 100px; height: 100px; text-align: center; line-height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue-app"&gt; &lt;!--根据条件展示或者隐藏元素(而不是像v-if那样插入或者删除元素) --&gt; &lt;p v-show="flag1"&gt;p1&lt;/p&gt; &lt;p v-show="flag2"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#vue-app', data: &#123; flag1: false, flag2: true &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶4. v-if和v-show的区别12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;v-if和v-show&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 需求:通过点击修改flag的值。 --&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素。有较高的切换性能消耗。 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式。有较高的初始渲染消耗 选择： 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show。 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if。 --&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;h3 v-if="flag"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show="flag"&gt;这是用v-show控制的元素&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶十、基础语法要点总结12345678910111213141516171. MVC 和 MVVM 的区别2. 学习了Vue中最基本代码的结构3. 插值表达式 v-cloak v-text v-html v-bind（缩写是:） v-on（缩写是@） v-model v-for v-if v-show4. 事件修饰符 ： .stop .prevent .capture .self .once 5. el 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个s后缀，但是是个对象，这里可以自定义了方法6. 在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this7. 在 v-for 要会使用 key 属性 （只接受 string / number）8. v-model 只能应用于表单元素 --&gt;9. 在vue中绑定样式两种方式 v-bind:class v-bind:style¶十一、过滤器概念：Vue.js 允许自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：插值表达式和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由**“管道”**符指示。过滤器调用的格式：1&#123;&#123; name | 过滤器的名称(实参列表) &#125;&#125;过滤器的定义语法:全局过滤器123Vue.filter('过滤器的名称', function(过滤器的参数列表)&#123; //过滤器做的处理&#125;)私有（局部）过滤器12345filters: &#123; 过滤器的名称: function (过滤器的参数列表) &#123; //过滤器做的处理 &#125;&#125;第一个参数是管道前的内容，第二个之后的参数是过滤器调用方法的实参列表。¶1. 全局过滤器对所有VM 对象所控制的 View 区域都起作用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app1"&gt; &lt;h1&gt;app1&lt;/h1&gt; &lt;p&gt;过滤前的内容：&#123;&#123; msg&#125;&#125;&lt;/p&gt; &lt;p&gt;经全局过滤器处理后: &#123;&#123; msg | globalFormat('global', 'filter')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;h1&gt;app2&lt;/h1&gt; &lt;p&gt;过滤前的内容：&#123;&#123; msg&#125;&#125;&lt;/p&gt; &lt;p&gt;经全局过滤器处理后: &#123;&#123; msg | globalFormat('global', 'filter')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; //定义全局过滤器(对所有VM对象所控制的View区域都起作用。) Vue.filter('globalFormat', function (msg, arg, arg2) &#123;//定义一个 Vue 全局的过滤器，名字叫做 localFormat，第一个参数是管道前的内容，其余参数是localFormat()过滤器方法的实参 //过滤器做的处理 return msg.replace(/vue/g, arg + " " + arg2);//字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 &#125;); var vm1 = new Vue(&#123; el: '#app1', data: &#123; msg: 'hello vue1' &#125; &#125;); var vm2 = new Vue(&#123; el: '#app2', data: &#123; msg: 'hello vue2' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶2. 私有过滤器私有（局部）过滤器。只能在当前 VM 对象所控制的 View 区域起作用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app1"&gt; &lt;h1&gt;app1&lt;/h1&gt; &lt;p&gt;过滤前的内容：&#123;&#123; msg&#125;&#125;&lt;/p&gt; &lt;p&gt;经全局过滤器处理后: &#123;&#123; msg | localFormat('local', 'filter')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;h1&gt;app2&lt;/h1&gt; &lt;p&gt;过滤前的内容：&#123;&#123; msg&#125;&#125;&lt;/p&gt; &lt;p&gt;经全局过滤器处理后: &#123;&#123; msg | localFormat('local', 'filter')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm1 = new Vue(&#123; el: '#app1', data: &#123; msg: 'hello vue1' &#125;, filters: &#123; //定义私有（局部）过滤器。只能在 当前 VM 对象所控制的 View 区域起作用 localFormat: function (msg,arg,arg2) &#123;//默认将管道前的内容当作localFormat()过滤器方法的第一个实参,其余参数是localFormat()过滤器方法的实参 //过滤器做的处理 return msg.replace(/vue/g, arg + " " + arg2);//字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 &#125; &#125; &#125;); var vm2 = new Vue(&#123; el: '#app2', data: &#123; msg: 'hello vue2' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶十二、自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。实现自定义指令可以是全局的，也可以是局部的。全局指的是所有vue对象的控制区域，局部指的是当前定义指令所在vue对象的控制区域。案例：用指令来实现开页面后还没点击过任何内容，输入框就处于聚焦状态，并且要求用指令实现输入的内容颜色为可变实参。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.7.0/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 如果需要给自定义指令传参，那么需要在双引号里使用单引号把实参包含住，否则会报错 --&gt; &lt;input type="text" v-focus v-color="'green'"&gt; &lt;/div&gt; &lt;script&gt; /*注册全局自定义指令 v-focus*/ /* 使用 Vue.directive() 定义全局的指令 v-focus 其中： 参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。常用的有三个方法：1.bind() 2.inserted() 3.updated()。一般动作指令在inserted()中调用，而样式等在bind()中调用。 */ Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus(); &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;); /*注册全局指令v-color*/ Vue.directive('color', &#123; bind: function (el, binding) &#123; el.style.color = binding.value; &#125; &#125;); new Vue(&#123; el: "#app", /*注册局部自定义指令 v-focus，如果全局和局部自定义指令的名称相同，那么vue会采取就近原则。*/ directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus(); &#125; &#125;, color: function (el, binding) &#123; el.style.color = binding.value; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;¶十三、vue实例的生命周期¶1. 概念什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！生命周期钩子：就是生命周期事件的别名；生命周期钩子 = 生命周期函数 = 生命周期事件¶2. 生命周期函数分类创建期间的生命周期函数1234(1)beforeCreate //实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性(2)created //实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板(3)beforeMount //此时已经完成了模板的编译，但是还没有挂载到页面中(4)mounted //此时，已经将编译好的模板，挂载到了页面指定的容器中显示运行期间的生命周期函数12(1)beforeUpdate //状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点(2)updated //实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！销毁期间的生命周期函数12(1)beforeDestroy //实例销毁之前调用。在这一步，实例仍然完全可用。(2)destroyed //Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。¶十四、http数据请求vue实现http数据请求有很多种第三方包可以实现。主要有两种插件包可以使用。¶1. vue-resource下载地址：https://github.com/pagekit/vue-resource以get请求举例：12345678&#123; // GET /someUrl this.$http.get('/someUrl').then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;);&#125;按照作用域可分为：1234567// global Vue objectVue.http.get('/someUrl', [config]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);// in a Vue instancethis.$http.get('/someUrl', [config]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);其他请求方式：1234567get(url, [config])head(url, [config])delete(url, [config])jsonp(url, [config])post(url, [body], [config])put(url, [body], [config])patch(url, [body], [config])更多教程参考官方文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md¶2. axios这是重点，在后面的脚手架工程中另作介绍…¶十五、基于脚手架的vue工程工程搭建步骤¶1. 安装node.js官网下载最新版本后默认next傻瓜式安装完成。¶2. 安装cnpm为了npm下载包更快更流畅，可以改用国内淘宝镜像工具cnpm1$ npm install -g cnpm --registry=https://registry.npmmirror.com¶3. 安装webpack1$ cnpm install webpack -g¶4. 安装vue脚手架（命令行工具）使用node自带的npm包管理器安装vue-cli1$ npm install vue-cli -g更多npm命令详解：123456789101112131415161718192021222324252627282930313233343536373839404142##安装包$ npm install #默认根据项目下的 package.json的包配置安装对应的包$ npm install &lt;包名&gt; -S #即 npm install module_name –save 写入package.json dependencies，用于生产环境$ npm install &lt;包名&gt; -D #即npm install module_name –save-dev 写入package.json的devDependencies，用于开发环境$ npm install &lt;包名&gt; #本地安装(将安装包放在 ./node_modules 下)不写入package.json； $ npm install &lt;包名&gt; -g #全局安装(命令行使用)##树型结构列出当前项目安装的所有模块，以及它们依赖的模块。$ npm list #列出已安装的模块。$ npm list -global #加上global参数，会列出全局安装的模块。$ npm list underscore #列出单个模块。##卸载删除包$ npm uninstall &lt;包名&gt; #删除xxx包；$ npm uninstall -g &lt;包名&gt; #删除全局包xxx##更新包npm update &lt;包名&gt; #更新当前项目中安装的某个包npm update #更新当前项目中安装的所有包npm update &lt;包名&gt; -g #更新全局安装的包##搜索包$ npm search &lt;关键字&gt;##初始化package.json#根据交互问答产生一个符合标准的 package.json，如果使用了-f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的package.json文件。npm init##设置环境变量#上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。$ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT'##列出npm的配置$ npm config list -l¶5. 建立工程¶5.1 方式1 使用webpack创建工程1$ vue init webpack demo1 #demo1是工程名字,工程名字不能用中文等待工程初始化并下载依赖包，构建完成后，执行以下命令123$ cd demo1 #进入工程项目$ cnpm install #再次安装依赖，防止init的时候安装错误，如果vue ini不报错可以省略此步$ npm run dev #启动项目¶5.2 方式2 使用vue脚手架创建工程5.2.1 根据模板创建项目1$ vue init webpack-simple demo2 #demo2是工程目录的名字,工程名字不能用中文，如果不加工程名，则默认以当前目录作为工程目录相比于方式1步骤更简单，省略了很多提示步骤等待工程初始化并下载依赖包，构建完成后,执行以下命令1234$ cd demo2$ cnpm install #安装项目依赖$ cnpm install vue-router --save #为了与方式1同步，这里也安装路由模块。当然可以等到需要的时候再单独安装$ npm run dev #启动项目¶6. 工程目录和文件介绍以上面第二种方式创建的工程做介绍¶6.1 工程目录1234567891011.├── README.md #项目介绍文件，可删除├── index.html #首页入口文件。(重点)├── node_modules #加载的项目依赖模块├── package.json #项目配置文件，包含依赖等配置(重点)├── src #资源文件目录(重点)│ ├── App.vue #根组件│ ├── assets #图片资源目录│ │ └── logo.png│ └── main.js #入口js文件，项目的核心文件└── webpack.config.js #webpack配置文件¶6.2 重要工程文件详解inde.html123456789101112&lt;!-- 首页入口文件 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;demo2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/dist/build.js"&gt;&lt;/script&gt; &lt;!-- 指定webpack编译生成的js路径，这个js文件是入口js文件main.js的编译结果 --&gt; &lt;/body&gt;&lt;/html&gt;main.js12345678910111213141516171819202122232425/** * 入口js文件，项目的核心文件 */import Vue from 'vue' //导入vue包import App from './App.vue' //导入组件/* new Vue(&#123; el: '#app', render: function (createElements) &#123; // createElements 是一个 方法，调用它，能够把 指定的 组件模板，渲染为 html 结构 return createElements(App) // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器 &#125;&#125;) */// 创建 Vue 实例，得到 ViewModelnew Vue(&#123; el: '#app', render: h =&gt; h(App) /*箭头函数，用于简写函数(箭头前是函数参数，箭头后是函数的返回值,h相当于createElements)， 而h(App)相当于return createElements(App)，和上面的render: function (createElements) &#123; &#125; 渲染函数意义一样,渲染App组件到el对应的根节点中去，会将组件替代掉el对应的标签元素,这样做的好处 是不需要在html中写组件标签*/&#125;)App.vue123456789101112131415161718192021222324252627282930&lt;!-- 根组件 .vue组件文件由三部分组成: 1. 模版&lt;template&gt; 2. js脚本&lt;script&gt; 3. 样式&lt;style&gt;--&gt;&lt;template&gt; &lt;!-- template里有且仅有一个并行根节点，但是根节点里可以有多个并行节点 --&gt; &lt;div id="app"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "app", data() &#123; return &#123; msg: "Hello Vue !" &#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;#app &#123; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt;¶7. 单文件组件.vue文件，称为单文件组件，是Vue.js自定义的一种文件格式，一个.vue文件就是一个单独的组件，在文件内封装了组件相关的代码：html、css、js。.vue组件文件由三部分组成:模版&lt;template&gt;js脚本&lt;script&gt;样式&lt;style&gt;123456789101112131415161718192021/** * 一、在ES6中，通过规范的形式规定了如何导入和导出模块 * 导入模块： * 1.导入外部的变量或函数等； * import "模块名称" from "模块标识符(路径)"; //对于export default导出时使用 * import &#123;key1, key2, key3&#125; from "模块标识符(路径)"; //对于export导出时使用 * 2.导入外部的模块，并立即执行 * import "路径"; * * 导出模块（暴露成员）： * 1.export default * 2.export * *二、export default和export * 1. export default 向外暴露的成员，可以使用任意名称的变量来接收 * 2. 在一个模块(文件)中，export default只允许向外暴露1次 * 3. 在一个模块(文件)中，可以同时使用一个export default和多个export向外暴露成员 * 4. 使用export向外暴露成员时，只能使用&#123;暴露的成员名称&#125;的形式接收，多个则用逗号隔开，而不需要的成员则可以不再&#123;&#125;中定义，这种行为叫做“按需导出” * 5. 使用export导出的成员，如果需要引入则必须严格按照导出时定义的变量名称在&#123;&#125;中定义接收 * 6. 使用export导出的成员，如果需要引入，如果不希望使用导出时定义的变量名称，可以使用&#123;导出时定义的变量名称 as 别名&#125;的形式修改 */App.css123*&#123; color: #8a2be2;&#125;App.js1alert("执行app.js");App.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;!-- template里有且仅有一个并行根节点，但是根节点里可以有多个并行节点 --&gt; &lt;div id="app"&gt; &lt;!-- 3.在模版中使用引入的组件 --&gt; &lt;v-home&gt;&lt;/v-home&gt; &lt;button @click="getHomeInfo"&gt;点击按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//导入外部的变量或函数等import Home from "./components/Home";import &#123; num, title as myTitle, user &#125; from "./components/Home";//导入外部的模块，并立即执行import "./css/app.css";import "./js/app.js";export default &#123; name: "app", data() &#123; return &#123; appMsg: "This is App.vue !" &#125;; &#125;, methods: &#123; getHomeInfo: function() &#123; console.log("num:" + num); console.log("myTitle:" + myTitle); console.log("user:"); console.log(user); &#125; &#125;, components: &#123; /*挂载组件 1.key/value形式，key是元素标签的名称 2.value形式，value的名称就是元素标签的名称 */ "v-home": Home //key/value形式 // Home //value形式 &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;Home.vue123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id="home"&gt; &lt;h3&gt;&#123;&#123;homeMsg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//暴露组件对象export default &#123; data() &#123; return &#123; homeMsg: "this is Home.vue !" &#125;; &#125;&#125;;//暴露title变量export var title = "Home Title";export var num = 100;//暴露user对象export var user = &#123; username: "wangwu", age: 20&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;¶8. 组件的数据交互¶8.1.组件间传值¶8.1.1 父组件传子组件(1).在父组件设置prop绑定动态属性或者静态属性。设父组件的数据为:1&lt;v-content home2content="静态传的prop数据" v-bind:user="user" v-bind:homefuc="homefuc" v-bind:home="homeobj"/&gt;其中home2content是静态字符串属性，user是动态对象属性，homefuc是动态方法属性，home是动态对象属性(2) 在子组件通过props数组或者对象属性接收父组件传过来的数据。props数组：1props: ["user", "home2content","homefuc","home"]props对象：123456789101112131415props: &#123; //在子组件通过props对象属性接收父组件可以验证传来的数据 "user":Object, "home2content":&#123; type:String, //验证数据类型 required: true, //必填的字符串 default: 'xxxxx' 带有默认值 &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125;&#125;(3) 在子组件的&lt;template&gt;或者&lt;script&gt;直接引用1234567891011 &lt;template&gt; &lt;div id="content"&gt; &#123;&#123;contentMsg&#125;&#125; &lt;div&gt; &lt;div&gt;动态prop： &lt;/div&gt; user.username:&#123;&#123;user.username&#125;&#125;、 home.user.sex:&#123;&#123;home.user.sex&#125;&#125;&lt;/div&gt; &lt;div&gt;静态prop： &#123;&#123;home2content&#125;&#125;&lt;/div&gt; &lt;button v-on:click="homefuc()"&gt;点击按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;¶8.1.2 子组件传父组件(1).在父组件中：(1.1)在父组件中定义有参函数123函数名: function(value) &#123; //value就是子组件传送的值&#125;(1.2)设置prop绑定动态方法属性。1&lt;v-content v-bind:函数名="函数名"/&gt;(2).在子组件中：(2.1)通过props数组或者对象属性接收父组件传过来的数据1props: ["函数名"](2.2)子组件调用父组件方法的同时传入子组件的数据到方法的实参1函数名(子组件的数据)¶8.1.3 非父子组件传值(通过事件广播的方式实现)(1)首先新建一个js文件，在文件中实例一个Vue对象，并暴露出来，内容为：123import Vue from 'vue'var vueEvent = new Vue();export default vueEvent;(2) 在发送数据的组件中引用以上js文件，并发起事件广播(2.1)引用js文件：1import vueEvent from 'js文件路径'(2.2)发起事件广播1vueEvent.$emit('广播名称',数据); //发送广播(3) 在接收方组件的生命周期函数(如mounted)中监听广播事件123vueEvent.$on('广播名称',function(data)&#123; //监听广播事件，function(data)中的data就是监听到的数据 //获取data并可用于操作&#125;);¶8.2 主动获取数据就是不需要在传入方通过绑定属性的方式传值¶8.2.1父组件主动获取子组件数据方式：（1）在调用子组件的时候定义ref属性12&lt;v-content ref="任意变量名"/&gt;如：&lt;v-content ref="content"/&gt;（2）在父组件通过以下方式获取子组件的值12this.$refs.content.子组件属性this.$refs.content.子组件方法¶8.2.2子组件主动获取父组件数据方式：在子组件中通过以下方式获取父组件的数据（不需要定义ref属性）12this.$parent.父组件属性this.$parent.父组件方法¶8.3 vuex如果多个组件依赖于同一状态。传参的方法对于多层嵌套的组件和兄弟组件会非常繁琐。这时有必要学习vuex，来解决这个问题。官网：https://vuex.vuejs.org/zh/Vuex是一个专为Vue.js 应用程序开发的状态管理模式。主要作用是：解决不同组件间同一状态（数据）共享问题。组件的数据持久化¶8.3.1 安装vuex1$ npm install vuex --save¶8.3.2 引入和注册vuex在main.js中引入 vuex12345import Vue from 'vue'//引入Vuex并注册到Vue中import Vuex from 'vuex'Vue.use(Vuex)¶8.3.3 创建和使用数据仓库该文件的主要功能就是提供给各个组件一个数据交互中心(数据仓库)，数据仓库里主要包含数据项和操作数据的方法。原理是注册store到Vue中，各个组件通过引入数据仓库文件后，就可通过 this.$store 访问到store中的数据和方法了。例如：（1）state和mutations的使用数据仓库文件store.js1234567891011121314151617181920212223/*1.导入并注册Vuex到Vue中*/import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex);/*2.使用 vuex 实例化 Vuex.store*/const store = new Vuex.Store(&#123; /*3.state在vuex中用于存储数据*/ state: &#123; count: 1 &#125;, /*4.mutations里面放的是方法，方法主要用于操作state里面的数据*/ mutations: &#123; incCount() &#123; ++this.state.count; &#125; &#125;&#125;)/**5.导出（暴露）出数据仓库 */export default store;组件1：About.vue123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id="about"&gt; about组件： &lt;button @click="toIncCount()"&gt;增加数量&lt;/button&gt; &lt;!--2.通过 this.$store 访问到store中的数据 --&gt; 当前store的数据:&#123;&#123;this.$store.state.count&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1.引入storeimport store from "../vuex/store.js";export default &#123; store: store, methods: &#123; toIncCount() &#123; /*3.通过 this.$store 访问到store中的方法,更改 Vuex 的 store 中的状态的唯一方法是提交 mutation */ this.$store.commit("incCount"); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;div &#123; border: solid 2px red; margin: 20px;&#125;&lt;/style&gt;组件2: Home.vue1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id="home"&gt; home组件： &lt;button @click="toIncCount()"&gt;增加数量&lt;/button&gt; &lt;!--2.通过 this.$store 访问到store中的数据 --&gt; 当前store的数据:&#123;&#123;this.$store.state.count&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1. 引入storeimport store from "../vuex/store.js";export default &#123; data() &#123; return &#123;&#125;; &#125;, store: store, methods: &#123; toIncCount() &#123; /*3.通过 this.$store 访问到store中的方法,更改 Vuex 的 store 中的状态的唯一方法是提交 mutation */ this.$store.commit("incCount"); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;div &#123; border: solid 2px #42109e; margin: 20px;&#125;&lt;/style&gt;效果：（2）getters和actions的使用数据仓库文件store.js1234567891011121314151617181920212223242526272829303132333435363738/*1.导入并注册Vuex到Vue中*/import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex);/*2.使用 vuex 实例化 Vuex.store*/const store = new Vuex.Store(&#123; /*3.state在vuex中用于存储数据*/ state: &#123; count: 1 &#125;, /*4.mutations里面放的是方法，（1）方法主要用于操作state里面的数据；（2）mutation 必须是同步函数。(重点)*/ mutations: &#123; //自定义mutations方法 incCount() &#123; ++this.state.count; &#125; &#125;, /*5.类似计算属性,改变state里面的count数据的时候会触发 getters里面的方法 获取新的值 (基本用不到) */ getters: &#123; //自定义getters方法 computedCount: (state) =&gt; &#123; return state.count * 2 &#125; &#125;, /*6.类似于 mutation,不同在于：(1)Action 提交的是 mutation，而不直接变更数据的状态。(2)Action 可以包含任意异步操作。(基本用不到) */ actions: &#123; //自定义actions方法 incMutationsCount(context) &#123; context.commit('incCount'); /*执行 mutations 里面的incCount方法 改变state里面的数据*/ &#125; &#125;&#125;)/*7.导出（暴露）出数据仓库 */export default store;组件1 Home.vue：123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id="home"&gt; home组件： &lt;button @click="toIncCount()"&gt;增加数量&lt;/button&gt; &lt;button @click="toAction()"&gt;触发actions的方法&lt;/button&gt; 当前store的数据:&#123;&#123;this.$store.state.count&#125;&#125; 当前store getters的计算属性:&#123;&#123;this.$store.getters.computedCount&#125;&#125; &lt;!-- 2.触发了getters的computedCount()方法 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1. 引入storeimport store from "../vuex/store.js";export default &#123; data() &#123; return &#123;&#125;; &#125;, store: store, methods: &#123; toIncCount() &#123; this.$store.commit("incCount"); &#125;, toAction()&#123; this.$store.dispatch('incMutationsCount'); /*3.触发 actions里面的方法 */ &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;div &#123; border: solid 2px #42109e; margin: 20px;&#125;&lt;/style&gt;组件2 About.vue：123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="about"&gt; about组件： &lt;button @click="toIncCount()"&gt;增加数量&lt;/button&gt; 当前store的数据:&#123;&#123;this.$store.state.count&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import store from "../vuex/store.js";export default &#123; store: store, methods: &#123; toIncCount() &#123; this.$store.commit("incCount"); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;div &#123; border: solid 2px red; margin: 20px;&#125;&lt;/style&gt;效果：¶9. 路由官网教程https://router.vuejs.org/zh/控制组件之间的跳转，不会请求页面、不用页面刷新，直接跳转-切换组件安装：1$ cnpm install vue-router --save¶9.1 普通路由Home.vue1234567891011121314151617181920&lt;template&gt; &lt;div id="home"&gt; &lt;h3&gt;&#123;&#123;homeMsg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//暴露组件对象export default &#123; data() &#123; return &#123; homeMsg: "Welcome to Home !" &#125;; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;About.vue1234567891011121314151617181920&lt;template&gt; &lt;div id="about"&gt; &lt;h2&gt;&#123;&#123;aboutMe&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//暴露组件对象export default &#123; data() &#123; return &#123; aboutMe:'I am Qcmoke !' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;main.js123456789101112131415161718192021222324252627282930import Vue from 'vue'import VueRouter from 'vue-router' // 1. 导入 vue-router 包,安装方法：cnpm install vue-router --save// 2. 手动安装 VueRouter Vue.use(VueRouter)// 3.导入组件import App from './App.vue'import Home from './components/Home'import About from './components/About'// 4. 创建路由对象(全局)var router = new VueRouter(&#123; routes: [ //将组件映射到路由 //path 指请求路径，component指的是组件 &#123; path: '/home', component: Home &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/*', component: Home &#125; //默认进入展示Home ]&#125;)new Vue(&#123; el: '#app', render: h =&gt; h(App), router // 5. 将路由对象挂载到 vm 上，(缩写) 相当于 routes: routes&#125;)App.vue1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 6.渲染路由 --&gt; &lt;!-- 路由入口 --&gt; &lt;!-- 使用 router-link 组件来导航，&lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;router-link to="/home"&gt;Home&lt;/router-link&gt; &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "app", data() &#123; return &#123; msg: "Welcome to Your Vue.js App" &#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;¶9.2 带有嵌套关系的路由Home.vue1234567891011121314151617181920&lt;template&gt; &lt;div id="home"&gt; &lt;h3&gt;&#123;&#123;homeMsg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//暴露组件对象export default &#123; data() &#123; return &#123; homeMsg: "Welcome to Home !" &#125;; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;About.vue1234567891011121314151617181920&lt;template&gt; &lt;div id="about"&gt; &lt;h2&gt;&#123;&#123;aboutMe&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//暴露组件对象export default &#123; data() &#123; return &#123; aboutMe:'I am Qcmoke !' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;Login.vue123456789101112&lt;template&gt; &lt;div id="login"&gt; &lt;div&gt;to login&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;Register.vue1234567891011&lt;template&gt; &lt;div id="register"&gt; &lt;div&gt;to register&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;routes.js123456789101112131415161718192021222324252627282930import VueRouter from 'vue-router' // 1. 导入 vue-router 包,安装方法：cnpm install vue-router --save// 2.导入组件import Home from './components/Home'import About from './components/About'import Account from './components/Account'import Login from './components/Login'import Register from './components/Register'// 3. 创建含有嵌套关系的路由对象(全局)var router = new VueRouter(&#123; routes: [ //将组件映射到路由 //path 指请求路径，component指的是组件 &#123; path: '/account', component: Account, children: [ &#123; path: 'login', component: Login &#125;, &#123; path: 'register', component: Register &#125; ] &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/*', component: Home &#125; //默认进入展示Home ]&#125;)export default router;main.js12345678910111213141516171819import Vue from 'vue'import VueRouter from 'vue-router'// 4. 手动安装 VueRouter Vue.use(VueRouter)import App from './App.vue'import router from './routes.js'new Vue(&#123; el: '#app', render: h =&gt; h(App), router // 5. 将路由对象挂载到 vm 上，(缩写) 相当于 routes: routes&#125;)App.vue123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 6.渲染路由 --&gt; &lt;!-- 路由入口 --&gt; &lt;!-- 使用 router-link 组件来导航，&lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;router-link to="/home"&gt;Home&lt;/router-link&gt; &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "app", data() &#123; return &#123; msg: "Welcome to Your Vue.js App" &#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;Account.vue123456789101112131415&lt;template&gt; &lt;div id="account"&gt; &lt;router-link to="/account/login"&gt;Login&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;Register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;¶10. axios¶10.1 简介Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。从浏览器中创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求数据和响应数据取消请求自动转换 JSON 数据客户端支持防御 XSRF¶10.2 安装1$ npm install --save axios¶10.3 使用导入包1import Axios from "axios";请求：1234567Axios.get("api_url") .then(response =&gt; &#123; //请求成功时回调 //请求成功时做的处理 &#125;) .catch(function(error) &#123;//请求失败时回调 //请求失败时做的处理 &#125;);简单案例AxiosDemo.vue12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id="axiosdemo"&gt; &lt;button @click="show"&gt;点我AxiosDemo&lt;/button&gt; &lt;div class="show" v-show="showText"&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Axios from "axios"; //npm install --save axiosexport default &#123; name: "axiosDemo", data() &#123; return &#123; content: "", showText: false &#125;; &#125;, mounted() &#123; Axios.get("https://api.coindesk.com/v1/bpi/currentprice.json") .then(response =&gt; &#123; this.content = response.data.bpi; console.log("ok"); &#125;) .catch(function(error) &#123; console.log(error); &#125;); &#125;, methods: &#123; show() &#123; this.showText = !this.showText; &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;¶10.4 vue-axiosvue-axios是用于将axios集成到Vuejs的小包装器,作用是扩展Vue对象的功能，即让Vue对象具有axios功能，相对原生使用vue-axios会带来更多的便利。安装：1$ npm install --save vue-axios使用：导入vue、axios、vue-axios三个包123import Axios from "axios";import VueAxios from "vue-axios";import Vue from "vue";安装VueAxios和Axios到Vue中1Vue.use(VueAxios, Axios);请求使用1234567891011Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)案例：VueAxiosDemo.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;div id="vueaxios"&gt; &lt;button @click="getDateForVueaxios1()"&gt;点击我vueaxios1&lt;/button&gt; &lt;button @click="getDateForVueaxios2()"&gt;点击我vueaxios2&lt;/button&gt; &lt;button @click="getDateForVueaxios3()"&gt;点击我vueaxios3&lt;/button&gt; &lt;button @click="getDateForVueaxios4()"&gt;点击我vueaxios4&lt;/button&gt; &lt;div id="view"&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/* https://www.npmjs.com/package/vue-axios npm install --save axios vue-axios*/import Axios from "axios";import VueAxios from "vue-axios";//vue-axios是用于将axios集成到Vuejs的小包装器,作用是扩展Vue对象的功能，即让Vue对象具有axios功能import Vue from "vue";//安装VueAxios和Axios到Vue中Vue.use(VueAxios, Axios);export default &#123; data() &#123; return &#123; content: "" &#125;; &#125;, methods: &#123; getDateForVueaxios1() &#123; var api = "https://api.coindesk.com/v1/bpi/currentprice.json"; Axios.get(api) //使用原生Axios .then(response =&gt; &#123; this.content = response.data; console.log("response.data"); &#125;) .catch(function(error) &#123; console.log(error); &#125;); &#125;, getDateForVueaxios2() &#123; var api = "https://api.coindesk.com/v1/bpi/currentprice.json"; Vue.axios.get(api).then(response =&gt; &#123; this.content = response.data; console.log("response.data"); &#125;); &#125;, getDateForVueaxios3() &#123; var api = "https://api.coindesk.com/v1/bpi/currentprice.json"; this.axios.get(api).then(response =&gt; &#123; this.content = response.data; console.log("response.data"); &#125;); &#125;, getDateForVueaxios4() &#123; var api = "https://api.coindesk.com/v1/bpi/currentprice.json"; this.$http.get(api).then(response =&gt; &#123; this.content = response.data; console.log("response.data"); &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;¶11. element-ui官网：https://element.eleme.io/#/zh-CN¶11.1 安装element-ui1$ npm i element-ui -S¶11.2 引入element-ui和element的css12import ElementUI from 'element-ui' //完整引入所有的element-uiimport 'element-ui/lib/theme-chalk/index.css'¶11.3 Vue安装element-ui1Vue.use(ElementUI)¶11.4 配置webpack的loader规则element-ui的css文件中会使用到ttf文件，所以需要到webpack.config.js中配置以下loader规则1234&#123; test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/, loader: 'file-loader'&#125;¶11.5 使用例如使用element-ui的标签，可以在App.vue的template中加入1&lt;el-tag&gt;element-ui标签&lt;/el-tag&gt;以上关系到的文件大概如下：main.js123456789101112131415import Vue from 'vue'//引入element-ui和element的cssimport ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'//Vue安装element-uiVue.use(ElementUI)import App from './App.vue'new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;)webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'vue-style-loader', 'css-loader' ], &#125;, &#123; test: /\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125;, &#123; test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/, // element-ui的css文件中会使用到ttf文件，所以需要到webpack.config.js中配置以下loader规则 loader: 'file-loader' &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125;, extensions: ['*', '.js', '.vue', '.json'] &#125;, devServer: &#123; historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125;App.vue123456789101112131415161718&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 引用element-ui标签 --&gt; &lt;el-tag&gt;element-ui标签&lt;/el-tag&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "app", data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;效果如下图：¶11.6 按需引入（1）安装element-ui1$ npm i element-ui -S（2）除了安装element-ui还需要安装 babel-plugin-component1$ npm install babel-plugin-component -D（3） 配置webpack的loader规则element-ui的css文件中会使用到ttf文件，所以需要到webpack.config.js中配置以下loader规则1234&#123; test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/, loader: 'file-loader'&#125;（4）修改.babelrc配置文件将原来的123456&#123; "presets": [ ["env", &#123; "modules": false &#125;], "stage-3" ]&#125;改为以下：123456789101112&#123; "presets": [["env", &#123; "modules": false &#125;]], "plugins": [ [ "component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125; ] ]&#125;（5）简单使用如果只需要用到按钮和标签，那么可以通过以下实现按需引入1234import Vue from 'vue'import &#123; Button, Tag &#125; from 'element-ui';Vue.use(Button) // 或写为Vue.component(Button.name, Button);Vue.use(Tag) //或写为Vue.component(Tag.name, Tag);注：按需引入element-ui时,element-ui的样式文件可以不用引入完整文件如下：App.vue123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 引用element-ui标签 --&gt; &lt;el-tag&gt;element-ui标签&lt;/el-tag&gt; &lt;el-button type="primary"&gt;按钮&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'//import 'element-ui/lib/theme-chalk/index.css' //按需引入element-ui时,element-ui的样式文件可以不用引入import &#123; Button, Tag &#125; from 'element-ui'; Vue.use(Button) Vue.use(Tag)/* 或写为 * Vue.component(Button.name, Button); * Vue.component(Tag.name, Tag); */export default &#123; name: "app", data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;效果如下：¶13. 插槽slot作用:父组件将不同的内容分发给多个同名的子组件,即填充内容到子组件的插槽中。Vue的插槽slot，分为3种1.匿名插槽2.具名插槽3.作用域插槽一般都会开发好插槽子组件后提供给其他人使用，其他人只要在自己的父组件中引入这个带有插槽的子组件标签后，在子组件标签里自定义自己的内容，如此就能实现相应的功能。1.默认插槽Child1.vue1234567&lt;template&gt; &lt;div id="child1"&gt; &lt;span style="color: blueviolet"&gt; 默认插槽&lt;/span&gt; &lt;!-- 默认插槽;这部分会被父组件中的&lt;child1&gt;里的内容覆盖掉 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;2.具名插槽Child2.vue12345678&lt;template&gt; &lt;div id="child2"&gt; &lt;span style="color: #2557c5"&gt;具名插槽&lt;/span&gt; &lt;slot name="header"&gt;&lt;/slot&gt;&lt;!-- 具名插槽;这部分会被父组件中的&lt;child1&gt;里的内容覆盖掉 --&gt; &lt;slot name="content"&gt;&lt;/slot&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;3.作用域插槽Child3.vue123456789101112131415161718&lt;template&gt; &lt;div id="child3"&gt; &lt;span style="color: #22da62"&gt; 作用域插槽&lt;/span&gt; &lt;!-- 作用域插槽 作用域插槽要求，在slot上面绑定数据 --&gt; &lt;slot :data="user"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data: function() &#123; return &#123; user: ["zhangsan", "lisi", "wanwu", "zhaoliu", "tianqi", "xiaoba"] &#125;; &#125; &#125;;&lt;/script&gt;Father.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt; &lt;!-- 插槽 作用:父组件将不同的内容分发给多个同名的子组件,即填充内容到子组件的插槽中。 Vue的插槽slot，分为3种 1.匿名插槽 2.具名插槽 3.作用域插槽 --&gt; &lt;div class="father" id="father"&gt; &lt;div id="slot1"&gt; &lt;!-- 1.默认插槽 定义：不需要给插槽命名的插槽就是默认插槽（匿名插槽） 首先在子组件中定义插槽&lt;slot&gt;&lt;/slot&gt;，然后在父组件中通过引用子组件元素标签，并给子组件元素标签的内容体编写内容，已实现内容分发给需要的子组件 --&gt; &lt;child1&gt; &lt;div&gt; &lt;li&gt;口水鸡&lt;/li&gt; &lt;li&gt;口水鸭&lt;/li&gt; &lt;/div&gt; &lt;/child1&gt; &lt;child1&gt; &lt;div&gt;大神&lt;/div&gt; &lt;div&gt;码农&lt;/div&gt; &lt;/child1&gt; &lt;/div&gt; &lt;hr /&gt; &lt;!-- 2.具名插槽 定义：需要给插槽命名的插槽就是具名插槽 (1)内容要写在父组件中，然后分给需要的子组件。当slot多个时，可以通过name来加以区分，这就是所谓的具名插槽。 (2)在子组件中定义插槽&lt;slot name="插槽名称"&gt;&lt;/slot&gt;，然后在父组件引用子组件时在内容体里通过（给元素标签定义属性slot="插槽名称"）或者（template元素配合v-slot:插槽名称）来使用插槽，可以在父组件的插槽引用体里编写插槽内容，以此来实现不同显示样式的插槽 --&gt; &lt;div id="slot2"&gt; &lt;child2&gt; &lt;!-- 2.6.0版本之前具名插槽的使用方式: slot="插槽名称" --&gt; &lt;div slot="header"&gt; &lt;div&gt;father header&lt;/div&gt; &lt;/div&gt; &lt;!-- 2.6.0版本之后具名插槽的使用方式: template配合v-slot:插槽名称 --&gt; &lt;template v-slot:content&gt; &lt;div&gt;father content&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;father footer&lt;/div&gt; &lt;/template&gt; &lt;/child2&gt; &lt;/div&gt; &lt;hr /&gt; &lt;!-- 3.作用域插槽 定义：绑定data数据的插槽就是作用域插槽 通过在子组件中定义作用域插槽 &lt;slot :data="数据变量名称"&gt;&lt;/slot&gt;，然后在父组件中使用子组件的时候在内容体里通过 &lt;template slot-scope="子组件绑定的数据变量名称"&gt;&lt;/template&gt;使用插槽，同时可以在父组件中使用子组件插槽绑定过来的数据 --&gt; &lt;div id="slot3"&gt; &lt;child3&gt; &lt;template slot-scope="user"&gt; &lt;li v-for="item in user.data"&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/child3&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child1 from "./Child1"; import child2 from "./Child2"; import child3 from "./Child3"; export default &#123; components: &#123; child1, child2, child3 &#125; &#125;;&lt;/script&gt;效果如下：¶十六、其它vue问题参考Vue 脱坑记 - 查漏补缺(汇总下群里高频询问的 xxx 及给出不靠谱的解决方案)]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习笔记]]></title>
    <url>%2Fdevops%2Fredis.html</url>
    <content type="text"><![CDATA[¶一、简介Redis是key-value（键值对）的存储系统。支持存储的value类型相对更多，包括string、list、set(集合)、zset(有序集合)和hash（哈希类型），算一种nosql内存型缓存数据库。NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL一般应用于超大规模数据的存储。关系型数据库已经不适合处理当今成倍数据量增加的大型互联网商务应用了。这时nosql数据库由于其更高的性能、更快的速度、更好的可扩展性等优势对解决大规模数据起到了良好的应用作用。NoSQL四大分类分类Examples举例典型应用场景数据模型优点缺点键值（key-value）Redis，Tokyo Cabinet/Tyrant, Voldemort, Oracle BDB内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。Key 指向 Value 的键值对，通常用hash table来实现查找速度快数据无结构化，通常只被当作字符串或者二进制数据列存储数据库Cassandra, HBase, Riak分布式的文件系统以列簇式存储，将同一列数据存在一起查找速度快，可扩展性强，更容易进行分布式扩展功能相对局限文档型数据库CouchDB, MongoDbWeb应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）Key-Value对应的键值对，Value为结构化数据数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构查询性能不高，而且缺乏统一的查询语法。图形(Graph)数据库Neo4J, InfoGrid, Infinite Graph社交网络，推荐系统等。专注于构建关系图谱图结构利用图结构相关算法。比如最短路径寻址，N度关系查找等很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。NoSQL适用场景：1、数据模型比较简单；2、需要灵活性更强的IT系统；3、对数据库性能要求较高；4、不需要高度的数据一致性；5、对于给定key，比较容易映射复杂值的环境。通俗来说，Oracle、mysql、sqlserver等这样的关系型数据库主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。而redis主要将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但相应的保存时间有限。使用Redis的情景一般是会话缓存（session cache），用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化，即可以将内存中的数据序列化到硬盘中，如此以确保用户数据的安全性。此外Redis哎集群方面具有很好的优势。NoSQL优缺点优点数据高并发读写海量数据存储和访问效率高对数据可扩展且高可用缺点ACID相比于关系型数据库过于简单无法做太复杂的关系数据库模型¶二、常用命令大全¶1. key相关1234567891011121314$ keys * #查询当前库的所有键 $ EXISTS key #检查给定 key 是否存在 $ DUMP key #序列化给定key，并返回被序列化的值 $ EXPIRE key seconds #为给定 key 设置过期时间，以秒计。 $ EXPIREAT key timestamp # EXPIREAT 的作用和EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX时间戳(unix timestamp) $ KEYS pattern #查找所有符合给定模式( pattern)的 key。 $ MOVE key db #将当前数据库的 key移动到给定的数据库 db 当中。 $ PERSIST key #移除key的过期时间，key将持久保持。 $ PTTL key #以毫秒为单位返回key的剩余的过期时间。 $ TTL key #以秒为单位，返回给定key的剩余生存时间(TTL, time to live)。 $ RANDOMKEY #从当前数据库中随机返回一个 key。 $ RENAME key newkey #修改 key的名称 $ RENAMENX key newkey # 仅当newkey不存在时，将 key改名为 newkey。 $ TYPE key #返回key所储存的值的类型。案例（1）查询当前库的所有键12127.0.0.1:6379&gt; keys *(empty list or set)（2）修改 key的名称1234127.0.0.1:6379&gt; set name qcmokeOK127.0.0.1:6379&gt; rename name usernameOK¶2. String相关1234567$ set key value #添加键值对$ setnx key value #如果不存在key则设置，存在则不设置 $ get key #查询对应键值 $ del key #删除对应键值 $ setex key seconds value #设置key/value的有效期，到时后变为nil(空) $ SETRANGE KEY_NAME OFFSET VALUE #指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始$ GETSET key value #将给定 key 的值设为 value ，并返回 key 的旧值(old value)。案例（1）添加键值对set key value12127.0.0.1:6379&gt; set name zhangsanOK如果已经存在相应的key/value,那么会将原本的值覆盖掉。添加完成后，会根据配置文件中的dir的路径每隔一段时间序列化生成dump.rdb文件。这个文件可以备份和删除，但删除了相应的数据库中就没有相应的数据了，故不要轻易的删除，这很危险。setnx key value如果不存在key则设置，如果存在key则不设置12127.0.0.1:6379&gt; setnx name qcmoke(integer) 1（2）查询对应键值get key12127.0.0.1:6379&gt; get name"zhangsan"（3）删除已存在的键del key12127.0.0.1:6379&gt; del name(integer) 1¶3. 哈希(Hash)1234567891011121314$ HDEL key field1 [field2] #删除一个或多个哈希表字段$ HEXISTS key field #查看哈希表 key 中，指定的字段是否存在。$ HGET key field #获取存储在哈希表中指定字段的值。$ HGETALL key #获取在哈希表中指定 key 的所有字段和值$ HINCRBY key field increment #为哈希表 key 中的指定字段的整数值加上增量 increment $ HINCRBYFLOAT key field increment #为哈希表 key 中的指定字段的浮点数值加上增量 increment 。$ HKEYS key #获取所有哈希表中的字段$ HLEN key #获取哈希表中字段的数量$ HMGET key field1 [field2] #获取所有给定字段的值$ HMSET key field1 value1 [field2 value2 ] #同时将多个 field-value (域-值)对设置到哈希表 key 中。$ HSET key field value #将哈希表 key 中的字段 field 的值设为 value 。$ HSETNX key field value #只有在字段 field 不存在时，设置哈希表字段的值。$ HVALS key #获取哈希表中所有值$ HSCAN key cursor [MATCH pattern] [COUNT count] #迭代哈希表中的键值对。案例（1）将哈希表 key 中的字段 field 的值设为 value1127.0.0.1:6379&gt; hmset user age 21（2）将多个 field-value (域-值)对设置到哈希表 key 中1127.0.0.1:6379&gt; hmset user name zhangsan description "a good boy"（3）从hash里获取指定字段的值123127.0.0.1:6379&gt; hget user name"zhangsan"127.0.0.1:6379&gt;（4）从hash获取指定 key 的所有字段和值1234567127.0.0.1:6379&gt; hgetall user1) "name"2) "zhangsan"3) "description"4) "a good boy"5) "age"6) "21"（5）从hash获取指定 key 的所有值1234127.0.0.1:6379&gt; hvals user1) "zhangsan"2) "a good boy"3) "21¶4. 列表(List)根据收尾添加的不同，既可以实现栈，也可以实现队列。1234567891011121314151617$ BLPOP key1 [key2 ] timeout # 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。$ BRPOP key1 [key2 ] timeout # 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。$ BRPOPLPUSH source destination timeout # 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。$ LINDEX key index # 通过索引获取列表中的元素$ LINSERT key BEFORE|AFTER pivot value # 在列表的元素前或者后插入元素$ LLEN key # 获取列表长度$ LPOP key # 移出并获取列表的第一个元素$ LPUSH key value1 [value2] # 将一个或多个值插入到列表头部，实现先进后出的效果(栈)$ LPUSHX key value # 将一个值插入到已存在的列表头部$ LRANGE key start stop # 获取列表指定范围内的元素$ LREM key count value # 移除列表元素$ LSET key index value # 通过索引设置列表元素的值$ LTRIM key start stop # 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。$ RPOP key # 移除列表的最后一个元素，返回值为移除的元素。$ RPOPLPUSH source destination # 移除列表的最后一个元素，并将该元素添加到另一个列表并返回$ RPUSH key value1 [value2] # 在列表中末尾添加一个或多个值，实现先进先出的效果(队列)$ RPUSHX key value # 为已存在的列表添加值案例（1）将一个或多个值插入到列表头部1234127.0.0.1:6379&gt; lpush lkey zhangsan(integer) 1127.0.0.1:6379&gt; lpush lkey lisi wangwu(integer) 3（2）获取列表指定范围内的元素1234127.0.0.1:6379&gt; LRANGE lkey 0 101) "wangwu"2) "lisi"3) "zhangsan"¶5. 集合Set123456789101112131415$ SADD key member1 [member2] #向集合添加一个或多个成员$ SCARD key #获取集合的成员数$ SDIFF key1 [key2] #返回给定所有集合的差集$ SDIFFSTORE destination key1 [key2] #返回给定所有集合的差集并存储在 destination 中$ SINTER key1 [key2] #返回给定所有集合的交集$ SINTERSTORE destination key1 [key2] #返回给定所有集合的交集并存储在 destination 中$ SISMEMBER key member #判断 member 元素是否是集合 key 的成员$ SMEMBERS key #返回集合中的所有成员$ SMOVE source destination member #将 member 元素从 source 集合移动到 destination 集合$ SPOP key #移除并返回集合中的一个随机元素$ SRANDMEMBER key [count] #返回集合中一个或多个随机数$ SREM key member1 [member2] #移除集合中一个或多个成员$ SUNION key1 [key2] #返回所有给定集合的并集$ SUNIONSTORE destination key1 [key2] #所有给定集合的并集存储在 destination 集合中$ SSCAN key cursor [MATCH pattern] [COUNT count] #迭代集合中的元素案例（1）向集合添加一个或多个成员123456127.0.0.1:6379&gt; sadd skey zhangsan(integer) 1127.0.0.1:6379&gt; sadd skey lisi(integer) 1127.0.0.1:6379&gt; sadd skey wangwu zhaoliu(integer) 1（2）返回集合中的所有成员12345127.0.0.1:6379&gt; smembers skey1) "zhaoliu"2) "zhangsan"3) "wangwu"4) "lisi"¶6. 有序集合(sorted set)1234567891011121314151617181920$ ZADD key score1 member1 [score2 member2] #向有序集合添加一个或多个成员，或者更新已存在成员的分数$ ZCARD key #获取有序集合的成员数$ ZCOUNT key min max #计算在有序集合中指定区间分数的成员数$ ZINCRBY key increment member #有序集合中对指定成员的分数加上增量 increment$ ZINTERSTORE destination numkeys key [key ...] # 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中$ ZLEXCOUNT key min max # 在有序集合中计算指定字典区间内成员数量$ ZRANGE key start stop [WITHSCORES] # 通过索引区间返回有序集合成指定区间内的成员$ ZRANGEBYLEX key min max [LIMIT offset count] # 通过字典区间返回有序集合的成员$ ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] # 通过分数返回有序集合指定区间内的成员$ ZRANK key member # 返回有序集合中指定成员的索引$ ZREM key member [member ...] # 移除有序集合中的一个或多个成员$ ZREMRANGEBYLEX key min max # 移除有序集合中给定的字典区间的所有成员$ ZREMRANGEBYRANK key start stop # 移除有序集合中给定的排名区间的所有成员$ ZREMRANGEBYSCORE key min max # 移除有序集合中给定的分数区间的所有成员$ ZREVRANGE key start stop [WITHSCORES] # 返回有序集中指定区间内的成员，通过索引，分数从高到底$ ZREVRANGEBYSCORE key max min [WITHSCORES] # 返回有序集中指定分数区间内的成员，分数从高到低排序$ ZREVRANK key member # 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序$ ZSCORE key member # 返回有序集中，成员的分数值$ ZUNIONSTORE destination numkeys key [key ...] # 计算给定的一个或多个有序集的并集，并存储在新的 key 中$ ZSCAN key cursor [MATCH pattern] [COUNT count] # 迭代有序集合中的元素（包括元素成员和元素分值）案例（1）向有序集合添加一个或多个成员，或者更新已存在成员的分数1234567127.0.0.1:6379&gt; zadd sskey 1 zhangsan(integer) 1127.0.0.1:6379&gt; zadd sskey 2 lisi(integer) 1127.0.0.1:6379&gt; zadd sskey 2 wangwu(integer) 1127.0.0.1:6379&gt; zadd sskey 3 zhaoliu（2）过索引区间返回有序集合成指定区间内的成员12345127.0.0.1:6379&gt; zrange sskey 0 101) "zhangsan"2) "lisi"3) "wangwu"4) "zhaoliu"（3）取分数和值123456789127.0.0.1:6379&gt; zrange sskey 0 10 WITHSCORES1) "zhangsan"2) "1"3) "lisi"4) "2"5) "wangwu"6) "2"7) "zhaoliu"8) "3"¶7. 高级命令123456$ select [数据库下标] #选择数据库，数据库为0--15（16个），默认进入第0个$ move [key] [数据库下标] #将当前数据库的key移动到其他数据库$ info #查看redis信息$ flushdb #清空当前数据库的key$ flushall #清空所有数据库的key$ dbsize #查看当前数据库key的数量案例（1）切换到下标为某个数字的数据库12127.0.0.1:6379&gt; select 1OK（2）清空当前数据库的key12345127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt;关键字可大小写更多命令请参考：https://redis.io/commands​¶三、部署方案为了实现Redis的高并发高可用应用，Redis支持单机、主从、哨兵、集群多种架构模式部署方案。¶单机模式¶概念单机模式顾名思义就是安装一个 Redis，启动起来，业务调用即可。例如一些简单的应用，并非必须保证高可用的情况下可以使用该模式。¶优缺点优点部署简单；成本低，无备用节点；高性能，单机不需要同步数据，数据天然一致性。缺点可靠性保证不是很好，单节点有宕机的风险。单机高性能受限于 CPU 的处理能力，Redis 是单线程的。单机 Redis 能够承载的 QPS（每秒查询速率）大概在几万左右。取决于业务操作的复杂性，Lua 脚本复杂性就极高。假如是简单的 key value 查询那性能就会很高。假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，单机 Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过主从复制解决该问题，实现系统的高并发。¶安装部署¶1. window版安装步骤大致如下：（1）下载下载地址：https://github.com/microsoftarchive/redis/releases比如下载 Redis-x64-3.0.504.zip（2）启动和关闭解压到任意目录后，点击安装目录里的redis-server.exe即可启动，关闭redis-server.exe启动的窗口即可关闭。（3）开启后台守护进程cmd进入安装目录并执行以下命令即可安装成系统守护进程服务。（当然你可以将安装目录放到环境变量中，就可以在任意目录执行redis命令了，这里为了简便就不做此操作了）1redis-server --service-install redis.windows-service.conf --loglevel verbose（4）启动和关闭守护进程服务1234#启动(如果启动失败，在安装目录里创建一个名称为Logs的文件夹即可)redis-server --service-start#关闭redis-server --service-stop（4）卸载如果没有开启守护进程服务，那么直接删除安装目录即可卸载。如果开启守护进程服务，那么可在安装目录里通过执行以下命令来卸载守护进程服务，执行该命令后删除安装目录即可完全卸载。1redis-server --service-uninstall更多内容可参考菜鸟教程。¶2. Linux版安装这里主要讲linux下编译安装。（1）下载下载地址： https://redis.io/download ，这里使用的是3.0版本。12#下载redis-3.0.0$ wget http://download.redis.io/releases/redis-3.0.0.tar.gz（2）安装12345#解压到/usr/local/$ tar -zxvf redis-3.0.0.tar.gz -C /usr/local/# 进入到解压的文件中并执行make进行编译$ cd /usr/local/redis-3.0.0$ make看到类似“Hint: It's a good idea to run 'make test' ;)”这样的提示表示编译完成。make 后编译好的文件会保存到src目录下。这些文件中有两个重要的文件：redis-server 服务端程序redis-cli 客户端程序其实这个时候我们已经可以执行redis-server和redis-cli 直接使用了，但为了更好的管理程序，我们可以将这些编译好的文件和配置文件移动到其他目录去。如/usr/local/redis/bin/和/usr/local/redis/etc/。12345678910111213141516171819#创建两个目录用来存放redis配置文件和编译好的文件$ mkdir -p /usr/local/redis/bin/$ mkdir -p /usr/local/redis/etc/#进入编译目录$ cd /usr/local/redis-3.0.0/src#copy编译好的可执行文件到/usr/local/redis/bin/,注意下面从“cp /usr/..”直到“/usr/local/redis/bin/”是一条完整的命令。$ cp /usr/local/redis-3.0.0/src/mkreleasehdr.sh \redis-benchmark \redis-check-aof \redis-check-dump \redis-cli \redis-server \redis-sentinel \redis-trib.rb \/usr/local/redis/bin/#copy redis配置文件到/usr/local/redis/etc/$ cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/etc/（3）卸载直接删除/usr/local/redis-3.0.0、/usr/local/redis/bin/和/usr/local/redis/etc/目录即可完成卸载。（4）启动服务端12#redis-server + redis配置文件 一起启动服务$ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf可以通过打开另一个终端执行ps -ef | grep redis 或者 ps -ef | grep 6379查看redis线程。可以按Ctrl+C中断停止服务端启动。（5）配置服务端默认开启redis-server需要保持当前终端开启才能使用，如果关闭当前终端或者中断进程了那么服务就关闭了，如果希望后台启守护进程，我们可以修改redis的配置文件，修改daemonize的值为yes来实现。123$ vim /usr/local/redis/etc/redis.conf#默认daemonize为no，修改为yes表示开启守护进程daemonize yes注意重启redis-server后才能生效以下是其他配置,但学习的话并不建议12345port 6379 #默认端口，可以修改timeout 0 #客户端空闲N秒后关闭连接#dir ./ #指定工作目录，日志文件和数据文件等存放路径dir /usr/local/redis/etc/（6）启动服务端守护进程1$ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf（7）关闭服务端守护进程1$ /usr/local/redis/bin/redis-cli shutdown（8）客户端使用1）启动客户端1$ /usr/local/redis/bin/redis-cli2）关闭客户端按Ctrl+C就能停止客户端启动¶3. docker版安装可参考：《Docker学习笔记》¶主从复制¶概念Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。 只要主从服务器之间的网络连接正常，主服务器就会将写入自己的数据同步更新给从服务器，从而保证主从服务器的数据相同。数据的复制是单向的，只能由主节点到从节点，简单理解就是从节点只支持读操作，不允许写操作。主要是读高并发的场景下用主从架构。主从模式需要考虑的问题是：当 Master 节点宕机，需要选举产生一个新的 Master 节点，从而保证服务的高可用性。¶优缺点优点Master/Slave 角色方便水平扩展，QPS 增加，增加 Slave 即可；降低 Master 读压力，转交给 Slave 节点；主节点宕机，从节点作为主节点的备份可以随时顶上继续提供服务；缺点可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点写的压力；数据冗余（为了高并发、高可用和高性能，一般是允许有冗余存在的）；一旦主节点宕机，从节点晋升成主节点，需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；主节点的写能力受到单机的限制；主节点的存储能力受到单机的限制。¶安装部署这里部署节点架构为：1主2从。因为这里只是学习使用所以就都搭建在同一台服务器上了（即所谓为集群），如果要在生产上使用则应该每个redis节点都应该是一台服务器。为了简化部署过程，这里通过使用redis配置模板文件和docker compose来简化搭建过程。¶redis配置创建配置模板文件12345678910111213141516171819202122232425262728293031323334353637383940mkdir -p /opt/redis/conf##创建主节点配置文件模板cat &gt; /opt/redis/conf/redis-master.tmpl &lt;&lt; 'EOF'#节点端口6379、6380、6381port $&#123;PORT&#125;#访问认证密码requirepass $&#123;requirepass&#125;#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth $&#123;masterauth&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled noEOF##创建从节点配置文件模板cat &gt; /opt/redis/conf/redis-slave.tmpl &lt;&lt; 'EOF'#节点端口6379、6380、6381port $&#123;PORT&#125;#访问认证密码requirepass $&#123;requirepass&#125;#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth $&#123;masterauth&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled no#给当前从节点指定主节点的ip和端口slaveof $&#123;masterIp&#125; $&#123;masterPort&#125;EOF通过模板文件动态生成所有节点的配置文件12345678910111213141516171819202122232425262728#主从节点的密码requirepass=123456#从节点访问主节点需要认证的密码masterauth=123456#主节点ipmasterIp=192.168.60.200#主节点端口masterPort=6379#从节点的所有端口masterPorts="6380 6381"##生成主节点的配置文件PORT=$&#123;masterPort&#125; \requirepass=$requirepass \masterauth=$masterauth \envsubst &lt; /opt/redis/conf/redis-master.tmpl &gt; /opt/redis/conf/redis-master.conf#生成从节点的配置文件count=1for port in $masterPorts; do masterIp=$masterIp \ masterPort=$masterPort \ PORT=$&#123;port&#125; \ requirepass=$requirepass \ masterauth=$masterauth \ envsubst &lt; /opt/redis/conf/redis-slave.tmpl &gt; /opt/redis/conf/redis-slave-$&#123;count&#125;.conf let count++done¶docker配置12mkdir -p /opt/redisvi /opt/redis/docker-compose.yml12345678910111213141516171819202122232425262728293031323334version: '3'services: master: image: redis container_name: redis-master restart: always command: redis-server /etc/redis/redis.conf #容器启动时执行的命令，以下是redis-server启动时指定配置文件，后面可加参数如"--port 6379 --appendonly yes"等参数覆盖配置文件里的一些配置 #command: redis-server /etc/redis/redis.conf --port 6379 --appendonly yes ports: - 6379:6379 volumes: - /opt/redis/conf/redis-master.conf:/etc/redis/redis.conf - /opt/redis/data/redis-master:/data slave1: image: redis container_name: redis-slave-1 restart: always command: redis-server /etc/redis/redis.conf ports: - 6380:6380 volumes: - /opt/redis/conf/redis-slave-1.conf:/etc/redis/redis.conf - /opt/redis/data/redis-slave-1:/data slave2: image: redis container_name: redis-slave-2 restart: always command: redis-server /etc/redis/redis.conf ports: - 6381:6381 volumes: - /opt/redis/conf/redis-slave-2.conf:/etc/redis/redis.conf - /opt/redis/data/redis-slave-2:/data12#创建并启动所有服务容器docker-compose up -d¶哨兵模式¶概念主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。于是，在 Redis 2.8 版本开始，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。如上图所示，哨兵模式由两部分组成，哨兵节点和数据节点：哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据；数据节点：主节点和从节点都是数据节点。Redis Sentinel 是分布式系统中监控 Redis 主从服务器，并提供主服务器下线时自动故障转移功能的模式。其中三个特性为：监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常；提醒(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知；自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。¶优缺点优点哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都有；主从可以自动切换，系统更健壮，可用性更高；Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。缺点主从切换需要时间，会丢失数据；还是没有解决主节点写的压力；主节点的写能力，存储能力受到单机的限制；动态扩容困难复杂，对于集群，容量达到上限时在线扩容会变得很复杂。¶安装部署这里部署节点架构为：1主2从3哨兵。因为这里只是学习使用所以就都搭建在同一台服务器上了（即所谓为集群），如果要在生产上使用则应该每个redis节点都应该是一台服务器。为了简化部署过程，这里通过使用redis配置模板文件和docker compose来简化搭建过程。¶redis配置创建配置模板文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667mkdir -p /opt/redis/conf##创建主节点配置文件模板cat &gt; /opt/redis/conf/redis-master.tmpl &lt;&lt; 'EOF'#节点端口6379、6380、6381port $&#123;PORT&#125;#访问认证密码requirepass $&#123;requirepass&#125;#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth $&#123;masterauth&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled noEOF##创建从节点配置文件模板cat &gt; /opt/redis/conf/redis-slave.tmpl &lt;&lt; 'EOF'#节点端口6379、6380、6381port $&#123;PORT&#125;#访问认证密码requirepass $&#123;requirepass&#125;#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth $&#123;masterauth&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled no#给当前从节点指定主节点的ip和端口slaveof $&#123;masterIp&#125; $&#123;masterPort&#125;EOF##创建哨兵节点配置文件模板cat &gt; /opt/redis/conf/redis-sentinel.tmpl &lt;&lt; 'EOF'#节点端口 26379、26380、26381port $&#123;PORT&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问protected-mode no#是否以守护线程的方式启动（后台启动），默认 nodaemonize no#是否开启 AOF 持久化模式，默认 noappendonly yes# 第三个参数：哨兵名字，可自行修改。（若修改了，那后面涉及到的都得同步）# 第四个参数：master主机ip地址# 第五个参数：redis端口号# 第六个参数：哨兵的数量。比如2表示，当至少有2个哨兵发现master的redis挂了，那么就将此master标记为宕机节点。这个时候就会进行故障的转移，将其中的一个从节点变为mastersentinel monitor mymaster $&#123;masterIp&#125; $&#123;masterPort&#125; 2# 哨兵从master节点宕机后，等待多少时间（毫秒），认定master不可用。默认30ssentinel down-after-milliseconds mymaster 30000# 当替换主节点后，剩余从节点并行同步的数量，默认为 1sentinel parallel-syncs mymaster 1# master中redis的密码sentinel auth-pass mymaster $&#123;masterauth&#125;# 主备切换的时间，若在3分钟内没有切换成功，换另一个从节点切换sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yesEOF通过模板文件动态生成所有节点的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243#主从节点的密码requirepass=123456#从节点或者哨兵节点访问主节点需要认证的密码masterauth=123456#主节点ipmasterIp=192.168.60.200#主节点端口masterPort=6379#从节点的所有端口masterPorts="6380 6381"#哨兵的所有节点端口sentinelPorts="26379 26380 26381"##生成主节点的配置文件PORT=$&#123;masterPort&#125; \requirepass=$requirepass \masterauth=$masterauth \envsubst &lt; /opt/redis/conf/redis-master.tmpl &gt; /opt/redis/conf/redis-master.conf#生成从节点的配置文件count=1for port in $masterPorts; do masterIp=$masterIp \ masterPort=$masterPort \ PORT=$&#123;port&#125; \ requirepass=$requirepass \ masterauth=$masterauth \ envsubst &lt; /opt/redis/conf/redis-slave.tmpl &gt; /opt/redis/conf/redis-slave-$&#123;count&#125;.conf let count++done#生成所有哨兵节点的配置文件count=1for port in $sentinelPorts; do masterIp=$masterIp \ masterPort=$masterPort \ PORT=$&#123;port&#125; \ requirepass=$requirepass \ masterauth=$masterauth \ envsubst &lt; /opt/redis/conf/redis-sentinel.tmpl &gt; /opt/redis/conf/redis-sentinel-$&#123;count&#125;.conf let count++done¶docker配置12mkdir -p /opt/redisvim /opt/redis/docker-compose.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162version: '3'services: master: image: redis container_name: redis-master restart: always command: redis-server /etc/redis/redis.conf #容器启动时执行的命令，以下是redis-server启动时指定配置文件，后面可加参数如"--port 6379 --appendonly yes"等参数覆盖配置文件里的一些配置 #command: redis-server /etc/redis/redis.conf --port 6379 --appendonly yes ports: - 6379:6379 volumes: - /opt/redis/conf/redis-master.conf:/etc/redis/redis.conf - /opt/redis/data/redis-master:/data slave1: image: redis container_name: redis-slave-1 restart: always command: redis-server /etc/redis/redis.conf ports: - 6380:6380 volumes: - /opt/redis/conf/redis-slave-1.conf:/etc/redis/redis.conf - /opt/redis/data/redis-slave-1:/data slave2: image: redis container_name: redis-slave-2 restart: always command: redis-server /etc/redis/redis.conf ports: - 6381:6381 volumes: - /opt/redis/conf/redis-slave-2.conf:/etc/redis/redis.conf - /opt/redis/data/redis-slave-2:/data sentinel1: image: redis container_name: redis-sentinel-1 command: redis-sentinel /etc/redis/sentinel.conf restart: always ports: - 26379:26379 volumes: - /opt/redis/conf/redis-sentinel-1.conf:/etc/redis/sentinel.conf sentinel2: image: redis container_name: redis-sentinel-2 command: redis-sentinel /etc/redis/sentinel.conf restart: always ports: - 26380:26380 volumes: - /opt/redis/conf/redis-sentinel-2.conf:/etc/redis/sentinel.conf sentinel3: image: redis container_name: redis-sentinel-3 command: redis-sentinel /etc/redis/sentinel.conf restart: always ports: - 26381:26381 volumes: - /opt/redis/conf/redis-sentinel-3.conf:/etc/redis/sentinel.conf12#创建并启动所有服务容器docker-compose up -d¶参考https://www.cnblogs.com/hckblogs/p/11186311.htmlhttps://juejin.cn/post/6868426752789020685#heading-10¶集群模式¶概念1、主从复制模式只要解决了单机节点查询并发量瓶颈。但主节点出故障需要人为替换从节点顶替主节点。即主从复制模式解决了读并发，但为解决写并发，同时没有高可用性。2、哨兵模式在主从复制模式的基础上实现了自动化故障恢复。即在主从复制模式的基础上解决了高可用性，但仍然未解决写并发。3、为了解决哨兵模式的写并发问题，诞生了集群模式。集群模式保留了主从复制的读并发能力，同时支持多主节点来解决写并发问题，另外集群中所有节点通过互相定时检测来实现高可用性（主节点故障则对应从节点重新选举替换主节点）。¶高并发实现¶哈希槽分片由上文已经知道主从复制模式解决了读并发，为了解决写并发问题，cluster集群将写操作的数据根据key分配到不同的主节点中，而这个分配规则即“哈希槽分片”。cluster集群的是采用“虚拟哈希槽分区”的方式进行分片存储的，它将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=crc16(key)%16384，其中crc16为16位的循环冗余校验和函数。每一个主节点集群（主节点和其从节点组成的小集群）都负责维护一部分槽以及槽所映射的键值数据（也就是说集群中不是每个节点都保存有所有的数据，每个主节点只负责一部分槽对应的数据存储，所有的主节点存储的数据合起来才是整个集群的数据）。扩容或缩容以后，槽需要重新分配，数据也需要重新迁移，但是服务不需要下线。由于Redis集群无中心节点，客户端请求会随机发给任意主节点；主节点只会处理自己负责槽位的命令请求，对于其它槽位的命令请求该主节点会返回客户端一个转向错误，客户端再根据错误中包含的地址和端口重新向正确负责对应槽位的主节点发起命令请求。¶高可用实现¶Gossip协议Redis Cluster实例间以Gossip协议进行通信的机制。Redis Cluster运行时，各实例间需要通过PING、PONG消息进行信息交换，这些心跳消息包含了当前实例和部分其它实例的状态信息，以及Slot分配信息。这种通信机制有助于Redis Cluster中的所有实例都拥有完整的集群状态信息，从而能够实现高可用。扩容注意事项：随着集群规模的增加，实例间的通信量也会增加。如果我们盲目地对Redis Cluster进行扩容，就可能会遇到集群性能变慢的情况。这是因为，集群中大规模的实例间心跳消息会挤占集群处理正常请求的带宽。而且，有些实例可能因为网络拥塞导致无法及时收到PONG消息，每个实例在运行时会周期性地（每秒10次）检测是否有这种情况发生，一旦发生，就会立即给这些PONG消息超时的实例发送心跳消息。集群规模越大，网络拥塞的概率就越高，相应的，PONG消息超时的发生概率就越高，这就会导致集群中有大量的心跳消息，影响集群服务正常请求。最后，我也给你一个小建议，虽然我们可以通过调整cluster-node-timeout配置项减少心跳消息的占用带宽情况，但是，在实际应用中，如果不是特别需要大容量集群，我建议你把Redis Cluster 的规模控制在400~500个实例。假设单个实例每秒能支撑8万请求操作（8万QPS），每个主实例配置1个从实例，那么，400~ 500个实例可支持 1600万~2000万QPS（200/250个主实例*8万QPS=1600/2000万QPS），这个吞吐量性能可以满足不少业务应用的需求。¶节点故障判断集群中的每个节点都会定期向其他节点发送ping命令，如果接受ping消息的节点在指定时间内没有回复pong，则发送ping的节点就把接受ping的节点标记为主观下线。如果集群半数以上的主节点都将主节点A标记为主观下线，则节点A将被标记为客观下线（通过节点的广播）即下线。¶故障转移当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移执行的步骤：故障的主节点对应的所有从节点进行选举，选举出一个成为新的主节点；新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。¶Cluster限制cluster集群模式和单机模式下从使用上来看是由一些区别的：1、需要客户端的支持（目前jedis、Lettuce、redisson等都有支持）2、只支持一个数据库。单机模式Redis 默认自带有16个数据库，即db0~db15. 但是 Redis Cluster 集群架构下只有一个数据库空间，即db0，select 命令就不能用了，但实际也很少有人使用多数据库，所以这个限制并没什么影响。3、多key操作受限（日常使用中最大的限制）。Redis Cluster要求，同一个redis操作多个key时需要这些key都在同一个slot时才能执行，否则报错。DEL删除多个key、SUNION、事务、LUA脚本等操作都可能有多key操作受限问题。多key操作受限解决方案：Redis Cluster提供了一个hash tag的机制，可以让我们把一组key映射到同一个 slot。例如：user1000.following 这个 key 保存用户 user1000 关注的用户；user1000.followers 保存用户 user1000 的粉丝。这两个 key 有一个共同的部分 user1000，可以指定对这个共同的部分做 slot 映射计算，这样他们就可以在同一个槽中了。使用方式：{user1000}.following 和 {user1000}.followers就是把共同的部分使用 { } 包起来，计算 slot 值时，如果发现了花括号，就会只对其中的部分进行计算。参考：https://www.cnblogs.com/lovezbs/p/13885569.html¶优缺点优点无中心架构；可扩展性，数据按照 Slot 存储分布在多个节点，节点间数据共享，节点可动态添加或删除，可动态调整数据分布；高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本。实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。缺点数据通过异步复制，无法保证数据强一致性；集群环境搭建复杂，不过基于 Docker 的搭建方案会相对简单。存在一些使用限制。比如支持一个数据库、多key操作受限等。¶部署安装¶环境准备redis要求至少三主三从共6个节点才能组成redis集群，可以分布在一台或者多台主机上。假设有两台服务器用于搭建Redis Cluster集群。两台服务器的IP分别是：192.168.102.111192.168.102.112每个服务器跑三个不同端口（6371、6372、6373）的redis服务进程，那么就能在这两台服务器中搭建出6个redis节点出来。为了简化部署过程，这里通过使用redis配置模板文件和docker compose来简化搭建过程。¶创建redis配置模板文件每台服务器都执行如下操作：12345678910111213141516171819202122232425262728mkdir -p /opt/redis/confcat &gt; /opt/redis/conf/redis-cluster.tmpl &lt;&lt; 'EOF'#节点端口port $&#123;PORT&#125;#访问认证密码requirepass $&#123;requirepass&#125;#如果主节点开启了访问认证，从节点访问主节点需要认证的密码masterauth $&#123;masterauth&#125;#保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；protected-mode no#是否以守护线程的方式启动（后台启动），默认 no；daemonize no#是否开启 AOF 持久化模式，默认 no；appendonly yes#是否开启集群模式，默认 no；cluster-enabled yes#集群节点信息文件；cluster-config-file nodes.conf#集群节点连接超时时间；cluster-node-timeout 15000#集群中当前节点IP，填写宿主机的 IP；cluster-announce-ip $&#123;clusterIp&#125;#集群中当前节点端口；cluster-announce-port $&#123;PORT&#125;#集群节点总线端口cluster-announce-bus-port 1$&#123;PORT&#125;EOF每台服务器都执行如下操作，另外注意下面clusterIp的修改（每台服务器ip不一样）：123456789101112131415161718#节点的密码requirepass=123456#从节点访问主节点需要认证的密码masterauth=123456#当前节点的ip（服务器1的ip）clusterIp=192.168.60.201#当前节点的ip（服务器2的ip）#clusterIp=192.168.60.202#集群的所有节点端口clusterPorts=`seq 6371 6373`for port in $clusterPorts; do PORT=$&#123;port&#125; \ requirepass=$requirepass \ masterauth=$masterauth \ clusterIp=$clusterIp \ envsubst &lt; /opt/redis/conf/redis-cluster.tmpl &gt; /opt/redis/conf/redis-$&#123;port&#125;.confdone¶创建docker compose配置文件每台服务器都执行如下操作1vim /opt/redis/docker-compose.yml内容如下：1234567891011121314151617181920212223242526272829303132333435363738# 描述 Compose 文件的版本信息version: "3.1"# 定义服务，可以多个services: redis-6371: # 服务名称 image: redis:6.2.7 # 创建容器时所需的镜像 container_name: redis-6371 # 容器名称 restart: always # 容器总是重新启动 volumes: # 数据卷，目录挂载 - /opt/redis/conf/redis-6371.conf:/etc/redis/redis.conf - /opt/redis/data/6371/data:/data ports: - 6371:6371 - 16371:16371 command: redis-server /etc/redis/redis.conf # 覆盖容器启动后默认执行的命令 redis-6372: image: redis:6.2.7 container_name: redis-6372 volumes: - /opt/redis/conf/redis-6372.conf:/etc/redis/redis.conf - /opt/redis/data/6372/data:/data ports: - 6372:6372 - 16372:16372 command: redis-server /etc/redis/redis.conf redis-6373: image: redis:6.2.7 container_name: redis-6373 volumes: - /opt/redis/conf/redis-6373.conf:/etc/redis/redis.conf - /opt/redis/data/6373/data:/data ports: - 6373:6373 - 16373:16373 command: redis-server /etc/redis/redis.conf💁‍♂ 按照 Redis 官网：https://redis.io/topics/cluster-tutorial 的提示，为了使 Docker 与 Redis Cluster 兼容，推荐使用 Docker 的 host 网络模式。但这里发现不用也能支持，如果发现有网络上的问题可以改试host模式。另外使用host模式注意关闭宿主机防火墙。每台服务器都执行如下操作创建并启动所有服务容器1docker-compose up -d¶初始化并创建集群首先确保两台服务器之间可以互相通信，然后选择任意一台并登录进一个redis服务，并通过redis客户端命令来初始化创建出一个Cluster集群。12345678910# 进入容器docker exec -it redis-6371 bash# 切换至指定目录cd /usr/local/bin/#通过以下命令实现多服务器Redis Cluster集群的创建,出现选择提示信息，输入 yes#-a是redis的登录密码，--replicas 1 代表的是主节点数/从节点数的比例，1表示1个master对应1个从，如果是2，则表示1个master对应2个slaveredis-cli -a 123456 --cluster create \192.168.60.201:6371 192.168.60.201:6372 192.168.60.201:6373 \192.168.60.202:6371 192.168.60.202:6372 192.168.60.202:6373 \--cluster-replicas 1查看集群状态、信息和节点信息1234567891011121314# 进入容器docker exec -it redis-6371 bash# 切换至指定目录cd /usr/local/bin/# 查看集群状态redis-cli -a 123456 --cluster check 192.168.60.201:6371# 连接至集群某个节点，-c表示以集群的方式操作redis-cli -c -a 123456 -p 6371# 查看集群信息cluster info# 查看集群结点信息cluster nodes# 查看槽位信息cluster slots¶集群扩容假又增加一台服务器192.168.60.203，并且启动了一个端口为6371的redis节点，现在希望把它加入到集群中，可如下操作：1234#新增一个节点（默认是主节点的方式加入），将新节点介绍给集群中的任意一个，那么整个集群的所有节点就能与新节点互相认识redis-cli -a 123456 --cluster add-node 192.168.60.203:6371 192.168.60.201:6371#给新节点分配槽，默认情况下新增的节点是没有分配到槽的redis-cli -a 123456 --cluster reshard 192.168.60.203:6371123456789101112131415161718192021222324252627282930313233343536373839404142root@bogon:/data# redis-cli -a 123456 --cluster reshard 192.168.60.203:6371Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Performing Cluster Check (using node 192.168.60.203:6371)M: cd33bd0ef64538dcc803dc60feb9779660bda76f 192.168.60.203:6371 slots: (0 slots) masterM: 6baffb00ad60dae2a1f55fc3307570ce9d95a10b 192.168.60.202:6372 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: e1e64960fabdafa2f7b803d83d72079e60c376ee 192.168.60.202:6371 slots:[5461-10922] (5462 slots) master 1 additional replica(s)M: ae8ec74c69e808a3f2a64604a4847297f1206397 192.168.60.202:6373 slots:[0-5460] (5461 slots) master 1 additional replica(s)S: d07f345fc7140b471ec0fef272e73b0d7cb4edbd 192.168.60.201:6373 slots: (0 slots) slave replicates e1e64960fabdafa2f7b803d83d72079e60c376eeS: 5bd4fb5aeb3e051ebdfafd96e0b16ed633085b86 192.168.60.201:6372 slots: (0 slots) slave replicates 6baffb00ad60dae2a1f55fc3307570ce9d95a10bS: 2a4157b11b4b88e6b6413a75a8ef1f3c3e2db61e 192.168.60.201:6371 slots: (0 slots) slave replicates ae8ec74c69e808a3f2a64604a4847297f1206397[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.How many slots do you want to move (from 1 to 16384)? 4096 #要迁移多少个槽（总共16384个槽位，4个master节点的话可以输入4096个）What is the receiving node ID? cd33bd0ef64538dcc803dc60feb9779660bda76f #接受节点的ndoe ID(这里填新节点的node ID)Please enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs.Source node #1: all #从所有节点中迁移槽到新节点中Ready to move 4096 slots. Source nodes: M: 6baffb00ad60dae2a1f55fc3307570ce9d95a10b 192.168.60.202:6372 slots:[10923-16383] (5461 slots) master 1 additional replica(s)............Do you want to proceed with the proposed reshard plan (yes/no)? yes #输入yes确认即可¶集群模式常用命令12345#在集群中使用keys *，只会返回当前会话所在的单个节点的key，并非整个集群的keydocker exec -it redis-6371 redis-cli -c -a 123456 -p 6371 keys \*#获取整个集群的key（所有节点）docker exec -it redis-6372 redis-cli -c -a 123456 --cluster call 192.168.60.201:6372 keys \*¶参考https://juejin.cn/post/6868426752789020685https://juejin.cn/post/6870674824247640072https://www.cnblogs.com/cqming/p/11191079.htmlhttps://blog.csdn.net/weixin_36691991/article/details/125868968https://zhuanlan.zhihu.com/p/347125538]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx学习笔记]]></title>
    <url>%2Fdevops%2Fnginx.html</url>
    <content type="text"><![CDATA[¶一、简介Nginx 是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。官方开源版官网：https://nginx.org文档：https://nginx.org/en/docs官方商业版官网：https://www.nginx.com中文官网：https://www.nginx-cn.netNGINX Plus 文档：https://docs.nginx.com/nginx在高连接并发的情况下，Nginx 是 Apache 服务器不错的替代品。¶二、在线包管理器安装nginx¶1. apt安装nginx¶（1）安装nginx1234apt updateapt install -y nginx#查看Nginx的显式编译参数nginx -V¶（3）卸载nginx12345678systemctl stop nginxapt purge -y nginx nginx-common#卸载系统中所有不再需要的依赖包apt autoremove -y#删除已下载的软件包文件的缓存apt clean#删除nginx配置文件（如需要）rm -rf /etc/nginx/如果由于 Nginx 卸载不干净导致出现重装失败的问题，解决可参考：https://www.cnblogs.com/alter888/p/9478022.html¶2. yum安装nginx¶（1）设置nginx官方yum源（可选）12345678910111213141516yum install yum-utilscat &gt; /etc/yum.repos.d/nginx.repo &lt;&lt; 'EOF'[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keyEOF设置 nginx 官方 yum 源以能够使用最新版本¶（2）安装nginx1yum install -y nginx¶（3）查看nginx安装信息12345678#查看已经安装nginx包（如：nginx-1.16.0-1.el7.ngx.x86_64）rpm -q nginx#查看nginx版本（如：nginx version: nginx/1.16.0）nginx -v#查看yum安装nginx的目录rpm -ql nginx#查看Nginx的显式编译参数nginx -V¶（4）卸载nginx123456systemctl stop nginxyum remove -y nginx#卸载系统中所有不再需要的依赖包yum autoremove -y#删除nginx配置文件（如需要）rm -rf /etc/nginx/¶3. 在线包管理器安装nginx路径安装nginx的目录如下：12345678910111213141516171819202122232425262728293031323334353637383940414243Nginx主配置文件&#x2F;etc&#x2F;nginx &#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf Cgi、Fastcgi、Uwcgi配置文件&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params&#x2F;etc&#x2F;nginx&#x2F;scgi_params&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params Nginx编码转换映射配置文件&#x2F;etc&#x2F;nginx&#x2F;win-utf&#x2F;etc&#x2F;nginx&#x2F;koi-utf&#x2F;etc&#x2F;nginx&#x2F;koi-win http协议的Content-Type与扩展名配置文件&#x2F;etc&#x2F;nginx&#x2F;mime.types系统守护进程管理器配置文件&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.serviceNginx⽇志轮询,⽇志切割配置文件&#x2F;etc&#x2F;logrotate.d&#x2F;nginxNginx终端管理命令&#x2F;usr&#x2F;sbin&#x2F;nginx&#x2F;usr&#x2F;sbin&#x2F;nginx-debug Nginx模块⽬录&#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules Nginx默认站点⽬录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html#Nginx的缓存⽬录&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.12.2&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gzNginx的⽇志⽬录&#x2F;var&#x2F;log&#x2F;nginxyum安装nginx的编译参数如下：1234567891011121314151617181920212223242526程序安装⽬录和路径--prefix&#x3D;&#x2F;etc&#x2F;nginx--sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx--modules-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules--conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid--lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock 临时缓存⽂件--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp设定Nginx进程启动⽤户和组(安全)--user&#x3D;nginx--group&#x3D;nginx设置额外的参数将被添加到CFLAGS变量--with-cc-opt设置附加的参数, 链接系统库--with-ld-opt¶二、源码编译安装nginx官方下载地址：http://nginx.org/en/download.html版本号是双数的是稳定版，而单数则是开发版。以下以编译安装来讲述。为什么选择编译安装而不选择yum或者apt包管理器安装呢？因为yum或者apt安装的是已经编译好的二进制文件，而已经编译好就说明扩展模块已经固定，很难去添加或者修改自定义的扩展模块，这里选择编译安装就是为了解决这个问题。12345678910111213141516171819202122232425262728293031323334353637383940414243#yum安装nginx编译依赖yum install -y gcc gcc-c++ zlib gd-devel zlib-devel openssl openssl-devel pcre-devel make #apt安装nginx编译依赖# apt install -y gcc make build-essential zlib1g-dev libpcre3-dev libssl-dev#下载nginx源码包wget http://nginx.org/download/nginx-1.18.0.tar.gz#解压nginx源码包tar zxvf nginx-1.18.0.tar.gz#设置vim编辑nginx配置文件语法高亮（可选，如果不想用了直接删除~/.vim/目录即可）mkdir ~/.vim &amp;&amp; cp -r nginx-1.18.0/contrib/vim/* ~/.vim/#进入解压好的nginx源码目录cd nginx-1.18.0#生成nginx的编译配置文件MakeFile./configure \--prefix=/opt/nginx \--with-http_ssl_module \--with-http_v2_module \--with-http_sub_module \--with-http_gzip_static_module \--with-http_stub_status_module#根据MakeFile编译nginxmake#安装nginxmake install#卸载nginx（如需要）rm -rf /opt/nginx#如果MakeFile里有uninstall目标，也可以通过make uninstall进行卸载#make uninstall#清除编译生成文件（如需要，包括生成的MakeFile、二进制文件等）make clean#删除解压nginx源码目录和nginx安装包（如需要）cd .. &amp;&amp; rm -rf nginx-1.18.0 &amp;&amp; rm -f nginx-1.18.0.tar.gz💁‍♂ nginx 安装目录结构说明123456789101112131415161718192021222324&gt;/opt/nginx&gt;├── conf #存放配置文件&gt;│ ├── fastcgi.conf&gt;│ ├── fastcgi.conf.default&gt;│ ├── fastcgi_params&gt;│ ├── fastcgi_params.default&gt;│ ├── koi-utf&gt;│ ├── koi-win&gt;│ ├── mime.types&gt;│ ├── mime.types.default&gt;│ ├── nginx.conf&gt;│ ├── nginx.conf.default&gt;│ ├── scgi_params&gt;│ ├── scgi_params.default&gt;│ ├── uwsgi_params&gt;│ ├── uwsgi_params.default&gt;│ └── win-utf&gt;├── html #web基础根目录&gt;│ ├── 50xhtml&gt;│ └── index.html&gt;├── logs #日志文件目录&gt;└── sbin #执行脚本目录 └── nginx💁‍♂ 常用编译参数说明123456789101112131415161718192021222324252627&gt;--prefix=绝对路径 #定义nginx安装目录。默认为/usr/local/nginx目录。注意：这个目标的设置会影响其他参数中的相对路径目录。（例如：--sbin-path==sbin/nginx,那么实际上可执行文件nginx的安装存放路径为/opt/nginx/sbin/nginx。）&gt;--sbin-path=path #设置nginx可执行文件的安装存放路径。默认为&lt;prefix&gt;/sbin/nginx。&gt;--conf-path=path #设置nginx.conf配置文件的安装存放路径。默认为&lt;prefix&gt;/conf目录。&gt;--pid-path=path #设置将存储主进程的进程ID的nginx.pid文件的路径。默认&lt;prefix&gt;/logs/nginx.pid&gt;--error-log-path=path #设置error警告和诊断日志路径。默认&lt;prefix&gt;/logs/error.log&gt;--http-log-path=path #设置每个HTTP请求完成的记录日志路径。默认&lt;prefix&gt;/logs/access.log&gt;--user=用户名 #指定Nginx worker进程运行时所属的用户。默认为：nobody。&gt;--group=用户组 #指定Nginx worker进程运行时所属的用户组。默认为：nobody。&gt;--with-pcre #允许用户使用正则表达式进行模式匹配和文本处理。（默认启用）&gt;--with-threads #启用 Nginx 的线程池功能。（默认启用）&gt;--with-poll_module #启用poll多路复用器模块，用于处理网络事件的多路复用。（默认启用，如果不显式指定这--with-select_module或--with-poll_module中的任何一个，Nginx 默认会使用 --with-poll_module）&gt;--with-select_module #启用select多路复用器模块。（默认未启用）&gt;--with-file-aio #启用文件异步io支持。（默认未启用）&gt;--with-ipv6 #启用对IPv6的支持。（默认启用）&gt;--with-http_upstream_module #启用反向代理和负载均衡的功能，由ngx_http_upstream_module模块支持（默认启用）&gt;--with-http_ssl_module #启用构建将HTTPS协议支持添加到HTTP服务器的模块的功能。需要OpenSSL库来构建和运行此模块。（默认未启用）&gt;--with-http_gzip_static_module #用于预压缩静态文件，从而提高网站的性能。（默认未启用）&gt;--with-http_gunzip_module #用于在 Nginx 中解压缩经过压缩的 HTTP 响应，以便客户端可以正常接收响应。（默认未启用）&gt;--with-http_sub_module #用于在响应内容中执行字符串替换操作，常用于修改 HTML、CSS、JavaScript 等响应内容。（默认未启用）&gt;--with-http_realip_module #用于替换客户端 IP 地址，以解决反向代理中的 IP 地址伪装问题。（默认未启用）&gt;--with-http_image_filter_module #提供了在 HTTP 请求中处理图像的功能，例如缩放、裁剪、旋转、反转等功能。（默认未启用）&gt;--with-http_mp4_module #提供了处理 MP4 文件的功能，包括切割、拼接、编码等。（默认未启用）&gt;--with-mail #安装邮件服务器反向代理模块，使nginx可以反向代理IMAP、POP3、SMTP等协议。（默认未启用）&gt;--with-mail_ssl_module #使IMAP、POP3、SMTP等协议支持SSL/TLS协议加密传输支持。（默认未启用）&gt;--with-http_v2_module #是用于启用 HTTP/2 模块的选项。（默认未启用）&gt;--with-http_stub_status_module #提供了一个简单的状态页面，用于监控 Nginx 服务器的运行状态。（默认未启用）如果想强制禁用某个模块，只需要将--with改成--without。比如禁用select多路复用器模块，则参数为：--without-select_module¶三、nginx常用命令12345678910111213141516171819#启动nginx#停止nginx -s stop #立即停止服务（查出nginx进程id后直接强制kill杀掉进程）nginx -s quit #安全地停止服务（等待所有请求处理完成再停止服务）#重新加载配置（重新加载配置而无需停止或重启服务）nginx -s reload#检测配置文件正确性nginx -t#查看nginx的【显式】编译参数nginx -V#查看nginx是否在运行ps aux | grep nginx关于nginx -V查看编译参数的说明：注意执行nginx -V只是列出在编译时执行./configure的显式设置参数，而不代表真实编译进nginx的配置，比如有很多的编译参数是默认启用的，编译时也被编译进nginx了，但是通过nginx -V命令却不能看到对应的参数。如在执行./configure时即使没有显式地设置--with-pcre这个编译参数，但是编译好的nginx还是能够使用正则匹配功能。¶五、nginx内置变量http核⼼模块的内置变量http请求变量Nginx内置变量⾃定义变量1234567891011121314151617$uri: 当前请求的uri，不带参数$request_uri: 客户端请求的uri，带完整参数$host: 客户端请求头中Host字段除去端口号的部分。可用于获取请求的域名信息，如果host⾸部为空则$host等价$http_host: 客户端请求头中Host的完整字段（如有客户端请求头Host中有端口则$http_host包含端口）$proxy_host：指proxy_pass中设置的host值（对于端口，默认80不包含，其他端口包含）$remote_addr: 客户端IP（如果只经过一个代理服务器，则可以表示客户端的真实IP，但如果经过多个代理服务器，则只能表示最后代理服务器的IP）$remote_port: 客户端请求的端口（客户端通常会使用随机的动态端口来发起请求）$remote_user: 客户端发起请求时的 HTTP 认证用户名$request_filename: 客户端请求的文件路径$request_method: 求⽅法, GET POST PUT$server_addr: 前服务器的 IP 地址$server_name: 服务器配置的域名。可用于获取当前服务器块（server block）的配置的域名信息（如果在配置中使用了多个 server_name 声明，$server_name 将会返回第一个匹配成功的域名。）$server_port: 服务器监听的端口$server_protocol: nginx服务器使用的协议版本, 如http/1.1 http/1.0$scheme：客户端请求的协议方案，如：http 或 https 等$document_root: 当前请求映射到的root配置$hostname: nginx所在的服务器的主机名¶六、自定义nginx配置文件只需在 nginx 主配置文件 nginx.conf 的 http 节点中导入 conf/conf.d 目录（如果没有自行创建该目录）的所有配置文件，即可在 conf/conf.d 目录下自定义配置文件。如下：12345678910111213http &#123; include mime.types; keepalive_timeout 65; #以上为其他无关配置... ### 添加这行代码 ### include conf.d/*.conf; #nginx加载主配置文件的时候自动导入conf.d目录下的所有自定义配置文件 #以下为其他无关配置... server &#123; &#125;&#125;¶七、配置http服务（1）创建nginx配置文件1vim /opt/nginx/conf/conf.d/http.conf内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243## 第一个虚拟主机配置(静态资源服务器)server &#123; listen 8080; server_name localhost; #server_name example.com; #access_log logs/host.access.log main; location / &#123; root /opt/nginx/html; #配置web根目录 index index.html index.htm; &#125; #图片资源 location ~ .*\.(jpg|png|gif)$ &#123; root /opt/nginx/html; gzip on; #传输压缩，压缩本身比较耗费服务端性能，但给带宽带来更好的传输。恰当的使用会增强资源的访问效率。 gzip_http_version 1.1; gzip_comp_level 2; gzip_types gzip_types text/plain application/json application/x-javascript application/css application/xml application/xml+rss text/javascript application/x-httpd-php image/jpeg image/gif image/png; #压缩的文件类型，一般按需选择，但这里为了未来方便添加文件类型多选一些。具体配置参考文件/etc/nginx/mime.types expires 1h; #设置静态资源文件在客户端的缓存时间，除非客户清楚缓存或者关闭缓存或者强制访问才会再访问。 &#125; #文件下载 location /download &#123; root /opt/nginx/html; #访问 http://localhost:8080/download/test.txt 时会下载 /opt/nginx/html/test.txt 路径的文件 charset utf-8,gbk; #解决目录或者文件显示中文乱码的问题 autoindex on; #自动显示资源路径的文件名称，以此来开启站点下载。默认为关闭。 autoindex_localtime on; #显示的⽂文件时间为文件的服务器时间。默认为off，显示的文件时间为GMT时间 autoindex_exact_size off; #默认为on， 显示出文件的确切⼤大小，单位是bytes;修改为off，显示出文件的⼤大概大小，单位是kB或者MB或者GB。 &#125;&#125;## 第二个虚拟主机配置# server &#123;# listen 8081;# server_name localhost; #主机名，一般为一个或多个域名或者ip# location / &#123;# root /opt/nginx/html;# index index.html index.htm;# &#125;# &#125;（2）配置防火墙和重载 nginx 配置123456#防火墙开放相关监听端口firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --reload#重载配置/opt/nginx/sbin/nginx -s reload（3）测试设服务器 IP 地址为：198.23.188.200，则访问地址：http://198.23.188.200:8080¶八、配置反向代理反向代理：即将客户端对本机的访问请求代理转发到其他服务器。在反向代理中可以按需求配置将请求转发到一个或多个服务器，如果是多个服务器则可实现负载均衡的功能效果。¶1. 反向代理常用指令代理请求常用指令：proxy_pass: 指定反向代理的目标服务器地址。例如：proxy_pass http://backend_server;proxy_set_header: 设置传递给后端服务器的请求头信息（只有目标服务器需要解析这些请求头时才有必要配置，否则可以不配置）。常见的请求头设置配置如下：12345678proxy_set_header "Connection" ""; #删除Connection请求头proxy_set_header Host $host; #设置请求头指定代理请求时的Host头，$host表示使用客户端的Host（不包含端口）作为代理请求的Hostproxy_set_header X-Real-IP $remote_addr; #设置请求头指定客户端真实IP，$remote_addr表示客户端的IP（如果只经过一个代理服务器，则可以表示客户端的真实IP，但如果经过多个代理服务器，则只能表示最后代理服务器的IP）proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #设置请求头指定客户端的真实IP以及每次途经的代理IP（由逗号隔开,如："192.168.60.1, 192.168.60.101"，第一个IP即为客户端的真实IP。目标服务器使用X-Forwarded-For获取客户端真实IP比较可靠）proxy_set_header X-Forwarded-Proto $scheme; #设置请求头指定使用的协议（如：http或者https，$scheme表示客户端请求nginx时使用的协议）##其他请求头设置proxy_set_header Range $http_range;proxy_http_version: 指定 Nginx 使用的 HTTP 协议版本（如：1.0（默认）、1.1）。例如：proxy_http_version 1.1;proxy_cache: 设置反向代理缓存。可以通过 proxy_cache 指令来启用缓存并指定缓存名称。例如：proxy_cache my_cache;proxy_redirect: 设置反向代理的重定向规则。可选值：default（默认值，会自动替换响应头中的域名部分，实现反向代理的重定向）、off（禁用重定向，不进行任何修改）、redirect &lt;replacement&gt;（指定自定义的重定向规则，可以使用正则表达式等方式来进行替换）。例如：proxy_redirect default;proxy_connect_timeout: 设置与后端服务器建立连接的超时时间。例如：proxy_connect_timeout 5s;proxy_read_timeout: 设置从后端服务器读取响应的超时时间。例如：proxy_read_timeout 10s;proxy_send_timeout: 设置向后端服务器发送请求的超时时间。例如：proxy_send_timeout 10s;proxy_buffering： 启用或禁用反向代理缓冲。可选：on（默认）、off，例如：proxy_buffering on;proxy_buffer_size &lt;size&gt;：设置反向代理使用的缓冲区大小。默认 4KB。使用示例：proxy_buffer_size 8k;proxy_buffers &lt;number&gt; &lt;size&gt;：设置反向代理缓冲区的数量和大小。默认每个连接分配两个缓冲区，每个缓冲区大小为 4KB。如：proxy_buffers 4 16k;proxy_busy_buffers_size &lt;size&gt;：设置 Nginx 可以积累的响应数据大小。默认为 proxy_buffers 中每个缓冲区的大小。使用示例：proxy_busy_buffers_size 32k;proxy_ignore_headers: 设置要忽略的响应头字段。例如：proxy_ignore_headers X-Accel-Expires Expires Cache-Control;proxy_intercept_errors: 启用或禁用拦截来自后端服务器的错误响应。使用示例：proxy_intercept_errors on;proxy_max_temp_file_size &lt;size&gt;：设置代理模块在处理响应时，允许创建的临时文件的最大大小。默认：1024MB。使用示例：proxy_max_temp_file_size 512m;代理相应常用指令：1）add_header： 添加自定义响应头到服务器的响应中。例如跨域配置，如下：12345678910111213add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE";add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With";add_header Access-Control-Max-Age 86400;if ($request_method = 'OPTIONS') &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE"; add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With"; add_header Access-Control-Max-Age 86400; add_header Content-Length 0; add_header Content-Type "text/plain charset=UTF-8"; return 200;&#125;¶2. 简单的反向代理配置¶1）反向代理相关配置nginx 配置相关内容如下：12345678910111213141516171819#上游服务器配置（后端服务器）upstream ops_load &#123; #负载均衡配置 #配置多个http服务器即可实现负载均衡，其中http服务器可为本机，也可以为其他服务器 #默认负载均衡的调度模式为轮询方式 server 192.168.60.101::8080; server 192.168.60.102:8080;&#125;server &#123; listen 8080; server_name localhost; location / &#123; #反向代理 #proxy_pass http://localhost:8081; #如果只需要代理到一个服务器，则可以如此配置 proxy_pass http://ops_load; #如果只需要代理到多个服务器，则可以配置upstream来设置多个服务器 &#125;&#125;¶2）反向代理测试示例测试示例需求：在本地的 nginx 中模拟反向代理到本地不同端口的上游服务器。（1）创建nginx配置文件1vim /opt/nginx/conf/conf.d/load_balance.conf内容如下：123456789101112131415161718192021222324252627282930313233#上游服务器配置（后端服务器）upstream ops_load &#123; server localhost:8081; server 127.0.0.1:8082; server 127.0.0.1:8083;&#125;server &#123; listen 8080; server_name localhost; location / &#123; proxy_pass http://ops_load; &#125;&#125;#模拟3个上游服务器server &#123; listen 8081; root /opt/nginx/html/node1; index index.html;&#125;server &#123; listen 8082; root /opt/nginx/html/node2; index index.html;&#125;server &#123; listen 8083; root /opt/nginx/html/node3; index index.html;&#125;（2）服务节点差异设置为了更直观的测试负载均衡效果，可给不同的服务节点的访问页面做一些差异内容1234mkdir -p /opt/nginx/html/&#123;node1,node2,node3&#125;echo "node1" &gt; /opt/nginx/html/node1/index.htmlecho "node2" &gt; /opt/nginx/html/node2/index.htmlecho "node3" &gt; /opt/nginx/html/node3/index.html（3）配置防火墙和重载 nginx 配置123456#防火墙开放相关监听端口firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --reload#重载配置/opt/nginx/sbin/nginx -s reload（4）测试设服务器 IP 地址为：198.23.188.200，则访问地址：http://198.23.188.200:8080提示：浏览器要设置“停用缓存”，否则可能一直观察到的都是一个内容。¶3. 高级的反向代理配置¶1）负载均衡调度模式配置在Nginx中，可以使用以下几种负载均衡调度模式：轮询（Round Robin）：默认情况下，Nginx使用轮询模式进行负载均衡。它按照每个后端服务器的顺序依次分配请求，确保每个后端服务器平均分担负载。加权轮询（Weighted Round Robin）：可以为每个后端服务器分配不同的权重，以调整它们接收请求的比例。较高权重的服务器将获得更多的请求。IP哈希（IP Hash）：基于客户端IP地址对请求进行哈希运算，将相同IP的请求始终转发到同一个后端服务器。这对于需要保持会话或状态的应用程序非常有用。最少连接（Least Connections）：将请求分配给当前连接数最少的后端服务器。这有助于平衡服务器的负载，将请求发送到连接较少的服务器，以确保更均匀的负载分布。URL哈希（URL Hash）：基于请求的URL对后端服务器进行哈希运算，使相同URL的请求总是转发到同一个后端服务器。这对于需要缓存或特定处理逻辑的应用程序非常有用。nginx 配置相关内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#（1）轮询（Round Robin）模式upstream backend-rr &#123; #默认的负载均衡调度模式即为轮询模式，不需要显式地配置 server 192.168.60.101::8080; server 192.168.60.102:8080;&#125;#（2）加权轮询（Weighted Round Robin）模式upstream backend-wrr &#123; server 192.168.60.101::8080 weight=5; server 192.168.60.102:8080 weight=2;&#125;#（3）IP哈希（IP Hash）模式upstream backend-ih &#123; ip_hash; server 192.168.60.101::8080; server 192.168.60.102:8080;&#125;#（4）最少连接（Least Connections）模式upstream backend-lc &#123; least_conn; server 192.168.60.101::8080; server 192.168.60.102:8080;&#125;#（5）URL哈希（URL Hash）模式upstream backend-uh &#123; hash $request_uri; server 192.168.60.101::8080; server 192.168.60.102:8080;&#125;server &#123; listen 8080; server_name localhost; location / &#123; proxy_pass http://backend-rr; # proxy_pass http://backend-wrr; # proxy_pass http://backend-ih; # proxy_pass http://backend-lc; # proxy_pass http://backend-uh; &#125;&#125;¶2）负载均衡健康检查配置¶（1）简要说明Nginx健康检查的作用：Nginx 的健康检查功能主要用于监控后端服务器的可用性和状态，以确保请求被正确地转发给可用的服务器。具体作用如下：确保服务可用性：通过定期向后端服务器发送健康检查请求，Nginx可以检测到服务器是否在线、响应正常以及服务是否可用。如果某个服务器宕机或无法正常响应请求，Nginx将自动将请求转发给其他可用的服务器，确保服务的持续可用性。动态负载均衡：健康检查功能可以让Nginx根据后端服务器的状态自动调整请求的转发策略。当某个服务器出现故障或性能下降时，Nginx可以暂时将请求从故障的服务器转发到其他健康的服务器，实现负载均衡并避免向不可用的服务器发送请求。故障自动恢复：健康检查还能够帮助Nginx检测到后端服务器的恢复情况。一旦某个服务器恢复正常，健康检查会将其标记为健康，并重新将请求转发到该服务器上，实现故障自动恢复。避免服务雪崩效应：通过定期检查后端服务器的状态，Nginx可以及时发现故障服务器，并将请求转发到其他可用的服务器上。这有助于避免由于故障服务器无法处理请求而导致的服务雪崩效应，提高整体系统的稳定性和可靠性。总的来说，Nginx的健康检查功能可以提升后端服务器的可用性、优化负载均衡策略、自动恢复故障服务器，并提高整个系统的可靠性和性能。Nginx健康检查的类型：💁‍♂ Nginx 支持两种类型的健康检查：被动健康检查和主动健康检查。被动健康检查（Passive Health Checks）： 被动健康检查是指Nginx通过监控后端服务器的请求响应来确定服务器的健康状态。当Nginx向后端服务器转发请求时，它会等待一段时间来接收服务器的响应。如果服务器在规定时间内成功响应请求，Nginx将认为服务器是健康的，并继续将请求转发到该服务器。如果服务器在规定时间内无法响应请求（例如返回错误状态码或连接超时），Nginx将认为服务器是不健康的，并停止将请求转发到该服务器，直到下次健康检查重新确定其健康状态。主动健康检查（Active Health Checks）： 主动健康检查是指Nginx定期主动向后端服务器发送健康检查请求来确定服务器的健康状态。Nginx会按照预设的时间间隔发送健康检查请求到后端服务器，并等待服务器的响应。如果服务器成功响应了健康检查请求，Nginx将认为服务器是健康的，并继续将请求转发到该服务器。如果服务器无法响应健康检查请求（例如返回错误状态码或连接超时），Nginx将认为服务器是不健康的，并停止将请求转发到该服务器，直到下次健康检查重新确定其健康状态。主动健康检查相对于被动健康检查可以更快地恢复故障服务器的流量分发，这是因为它可以主动监控和检测后端服务器的健康状态。💁‍♂ 被动健康检查的主动健康检查的选择：使用被动健康检查时，Nginx 只能在收到客户端请求时才能检测后端服务器的状态。如果后端服务器出现故障或变得不可用，Nginx 需要等待客户端请求到达并在一定时间内没有收到正确的响应，才会暂时将流量停止发送到该服务器。这意味着在发生故障时，存在一定的延迟时间（通常是几秒钟）才能切换流量到其他可用的服务器上。其适用于对故障恢复速度要求不高的情况。使用主动健康检查时，其允许 Nginx 定期发送健康检查请求到后端服务器。如果服务器无法正常响应或返回错误的响应，Nginx 将立即意识到该服务器的故障，并停止将流量发送到该服务器，而不需要等待客户端请求。这使得故障服务器的恢复速度更快，因为 Nginx 可以更快地检测到故障并将流量转移到其他健康的服务器上。通过主动健康检查，Nginx 可以更及时地发现故障，并且可以更快地将流量从故障服务器切换到其他可用服务器上，从而提高系统的可用性和故障恢复速度。其适用于对故障恢复速度要求比较高的情况。¶（2）被动健康检查配置Nginx 默认是支持基础的被动健康检查的（由ngx_http_upstream_module模块支持），使用配置如下：123456789101112upstream ops_load &#123; server 192.168.60.101:8080 max_fails=1 fail_timeout=10s; server 192.168.60.102:8080 max_fails=1 fail_timeout=10s;&#125;server &#123; listen 8080; server_name localhost; location / &#123; proxy_pass http://ops_load; &#125;&#125;max_fails=1 fail_timeout=10s 说明：如果后端服务器在一次健康检查周期内（由Nginx配置中的check interval指定）失败一次或更多，则将其标记为不健康状态。一旦标记为不健康状态，Nginx将暂时将其排除在负载均衡范围之外的时间（由fail_timeout指定），在此期间不会将请求转发给该服务器。过了指定的时间后，Nginx将重新尝试将请求转发给该服务器。max_fails=1：表示在一次健康检查周期内，允许的最大失败次数。如果在一次健康检查周期内，该服务器的失败次数达到或超过设定的最大失败次数，则该服务器将被标记为不健康状态。fail_timeout=10s：表示在服务器被标记为不健康状态后，暂时将其排除在负载均衡范围之外的时间。在指定的时间段内，Nginx不会将请求转发给该服务器。在此示例中，如果服务器被标记为不健康状态，将在10秒后重新尝试将请求转发给该服务器。¶（3）主动健康检查Nginx 默认不支持主动健康检查，需使用第三方模块来支持，可使用开源的 nginx_upstream_check_module 模块来实现主动健康检查，重新编译安装 nginx 导入导入该模块，如下：123456789101112131415161718192021222324252627282930#（1）下载nginx_upstream_check_module模块源码git clone https://github.com/yaoweibin/nginx_upstream_check_module.git /tmp/nginx_upstream_check_module#git clone https://ghproxy.com/https://github.com/yaoweibin/nginx_upstream_check_module.git /tmp/nginx_upstream_check_module#（2）下载nginx源码包wget http://nginx.org/download/nginx-1.20.1.tar.gz#（3）解压nginx源码包tar zxvf nginx-1.20.1.tar.gz#（4）进入解压好的nginx源码目录cd nginx-1.20.1#（5）（可选）如果需要使用健康监控页面，则需要使用nginx_upstream_check_module模块的补丁文件给nginx源码打补丁（修改nginx源码）yum install -y patchpatch -p1 &lt; /tmp/nginx_upstream_check_module/check_1.20.1+.patch #指定特定nginx版本的补丁文件给nginx源码打补丁#（6）指定nginx_upstream_check_module模块路径生成nginx的编译配置文件MakeFile./configure \--prefix=/opt/nginx \--with-http_ssl_module \--with-http_v2_module \--with-http_sub_module \--with-http_gzip_static_module \--with-http_stub_status_module \--add-module=/tmp/nginx_upstream_check_module#（7）编译并安装make &amp;&amp; make install说明：nginx 各版本编译nginx_upstream_check_module模块后即可正常使用主动健康检查配置，但是要使用该模块的健康监控页面功能（由模块的check_status指令支持），则需要安装模块中补丁支持的特定版本 nginx（支持版本可在模块源码中查看，例如源码中有check_1.20.1+.patch这个补丁文件，则说明其支持 nginx 的1.20.1版本），并使用模块中特定版本的补丁修改 nginx 源码，否则可能会出现访问健康监控页面失败的问题。提示：健康监控页面是否能用不影响主动健康检查功能的使用，故打不打补丁根据需求来决定。nginx 使用配置如下：123456789101112131415161718192021222324252627upstream ops_load &#123; server 192.168.60.101:8080; server 192.168.60.102:8080; #以10s为一个周期，每隔10s，nginx会自动向上游服务器发送一次请求，如果超过5s超时且达到3次，则该服务器标记为不可用； #如果请求次数有1次以上没有超时，这标记为可用 check interval=10000 rise=1 fall=3 timeout=5000 type=tcp default_down=true; check_http_send "HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"; check_http_expect_alive http_2xx http_3xx;&#125;server &#123; listen 8080; server_name localhost; location / &#123; proxy_pass http://ops_load; &#125; # 健康监控页面 location /status &#123; check_status; access_log off; #allow 127.0.0.1; #deny all; &#125;&#125;nginx_upstream_check_module 模块中相关指令说明:check：健康检查规则语法：check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [default_down=true|false] [type=tcp|http|ssl_hello|mysql|ajp|fastcgi]如果省略参数，则默认参数为 interval=30000 fall=5 rise=2 timeout=1000 default_down=true type=tcp相关参数说明：interval：检查请求的间隔时间rise：如果请求次数有指定次数以上没有超时，这标记为可用状态fall：达到的指定失败次数则标记为不可用状态timeout：请求达到指定的超时时间则标记为不可用状态type：检查协议类型（tcp、ssl_hello、http、mysql、ajp、fastcgi）default_down：设置后端服务器的初始状态（false：可用，默认；true：不可用）port：指定后端服务器的检查端口。有可能与原始服务器端口不同。默认端口为 0，表示与原来的后端服务器相同check_http_send：发送给后端服务器的请求数据报文check_http_expect_alive：判断后端服务器为健康的相应状态码check_status：通过 HTTP 方式显示健康检查服务器的状态。设 Nginx 服务器 IP 地址为：192.168.60.156，则健康监控页面的访问地址：http://192.168.60.156:8080/status可以指定如下 URL 参数指定健康监控页面响应的数据格式/status?format=html/status?format=csv/status?format=json健康监控页面效果如下：¶3）通过反向代理实现动静分离这里的静态资源用图片来表示，而动态资源用 jsp 来表示。¶1. 使用tomcat配置动态资源说明：安装 jdk 并配置环境变量安装 tomcat，官方下载解压即用（设安装路径为：/opt/apache-tomcat-8.5.31）（1）在 tomcat web 根目录里创建一个 jsp 测试文件：1vim /opt/apache-tomcat-8.5.31/webapps/ROOT/java_test.jsp内容如下：12345678910111213&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSP Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% Random rand = new Random(); out.println("&lt;h2&gt;Random number:&lt;/h2&gt;"); out.println(rand.nextInt(99)+100);%&gt;&lt;/body&gt;&lt;/html&gt;（2）运行 tomcat1sh /opt/apache-tomcat-8.5.31/bin/startup.sh¶2. 使用nginx配置静态资源和反向代理（1）创建一个 nginx 配置文件1vim /opt/nginx/conf/conf.d/dynamic_static.conf配置内容如下：123456789101112131415161718192021222324252627server &#123; listen 8080; server_name localhost; # 静态资源 location / &#123; root /opt/nginx/html; index index.html; &#125; # 动态资源 location ~ .*\.jsp$ &#123; proxy_pass http://192.168.60.102:8080; # 反向代理到 Tomcat #代理到tomcat等服务器时注意要设置请求参数，如果后端服务器设置有类似防盗链或者根据http请求头中的host字段来进行路由或判断功能的话，如果反向代理层的nginx不重写请求头中的host字段，将会导致请求失败，报400错误。故至少要包含proxy_set_header Host $http_host;为了方便，以下配置了跟多的请求参数。 proxy_set_header Host $http_host; # proxy_redirect default; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_connect_timeout 30; # proxy_send_timeout 60; # proxy_read_timeout 60; # proxy_buffer_size 32k; # proxy_buffering on; # proxy_buffers 4 128k; # proxy_busy_buffers_size 256k; # proxy_max_temp_file_size 256k; &#125;&#125;（2）上传一张静态资源文件图片（如：logo.jpg）到里 /opt/nginx/html 目录里。（3）为了能体现出动静分离的效果，可创建一个同时有静态资源内容又有静态资源内容的 html 测试文件，如下：1vim /opt/nginx/html/dynamic_static.html内容如下：123456789101112131415161718192021222324252627282930&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;测试nginx动静分离&lt;/title&gt;&lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $.ajax(&#123; type: "GET", url: "/java_test.jsp", success: function(data) &#123; $("#get_data").html(data) &#125;, error: function() &#123; alert("fail!!,请刷新再试!"); &#125; &#125;);&#125;);&lt;/script&gt;&lt;body&gt; &lt;h1 style="color: #0688e8;"&gt;测试动静分离&lt;/h1&gt; &lt;h2&gt;静态数据:&lt;/h2&gt; &lt;img src="/logo.jpg" height="200" width="200"&gt; &lt;h2&gt;动态数据:&lt;/h2&gt; &lt;div id="get_data"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;（4）配置防火墙和重载 nginx 配置123456#防火墙开放相关监听端口firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --reload#重载配置/opt/nginx/sbin/nginx -s reload¶3. 访问测试设服务器 IP 地址为：198.23.188.200，则测试如下：访问静态资源：http://198.23.188.200:8080/logo.jpg访问动态资源：http://198.23.188.200:8080/java_test.jsp访问动静分离页面：http://198.23.188.200:8080/dynamic_static.html¶九、配置ssl证书以使用https使用 https 就需要配置 ssl 证书。一般地，获取 ssl 证书有两种方式：自签名和购买 CA 颁发的 ssl 证书。自签名的证书可能会被浏览器拦截并提示不受信任，因此建议采用比较可靠的商业颁发机构购买（如 Comodo、Symantec 等）或者免费的 Let’s Encrypt 签发的证书。可以使用 certbot 工具来申请得到免费 Let’ s Encrypt SSL 证书。具体操作可参考《通过certbot工具生成ssl证书》。假设这里已经申请得到了 Let’ s Encrypt SSL 证书，下文将介绍如何在 nginx 中配置 ssl 证书以使用 https 。¶1. 创建nginx配置文件1vi /opt/nginx/conf/conf.d/https.conf配置内容如下：12345678910111213141516171819202122232425262728server &#123; listen 443 ssl; server_name example.com; #ssl_certificate /path/cert.pem; ssl_certificate /path/fullchain.pem; ssl_certificate_key /path/privkey.pem; #ssl_trusted_certificate /path/chain.pem; #ssl_trusted_certificate /path/fullchain.pem; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; charset utf-8; # http资源服务 location / &#123; root /opt/nginx/html; index index.html index.htm; &#125; # 反向代理 # location ^~ /app &#123; # proxy_pass http://127.0.0.1:8080; # proxy_set_header Host $host:$server_port; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header REMOTE-HOST $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # client_max_body_size 100m; # &#125;&#125;💁‍♂ nginx SSL 证书配置说明：ssl_certificate：SSL证书路径。（可配置为服务端证书或全链证书）ssl_certificate_key：私钥文件路径。ssl_trusted_certificate：可信任的证书链文件路径。（可配置为中间证书或全链证书）如果ssl_certificate配置的证书为服务端证书而不包含中间证书，则应该配置 ssl_trusted_certificate 来指定可信任的证书链文件，以便客户端能够正确验证服务端证书的真实性。但由于目前主流CA服务商（包括 Let’s Encrypt ）的根证书和中间证书都已经被大多数客户端（如：主流的浏览器）的证书信任列表所接受，所以服务端配置中即使缺少中间证书和根证书，客户端仍然可以正确地验证服务器证书的真实性，也就是说 ssl_certificate 配置 主流CA签发的 SSL 证书时，即使不是全链证书也能被大多数主流的客户端信任。💁‍♂ 关于证书链的说明：客户端验证服务器证书的真实性是通过证书链来实现的。如果证书链中最顶层的证书（即CA根证书）在客户端的信任列表里，客户端会从上往下按序验证每层证书的真实性，每一层都使用上一层证书的公钥来验证下一层证书的签名，直到验证到服务器证书为止。如果证书链缺少中间证书，则客户端无法验证该证书链的完整性，也就无法验证服务端证书的真实性。因此，必须包括所有中间证书以及根证书才能构建完整的证书链。只有在证书链完整且验证成功的情况下，客户端才能信任服务器证书并与其建立安全连接。客户端的信任列表一般包括有根证书、中间证书以及其他可信任的证书等。¶2. 配置防火墙和重载nginx配置123456#防火墙开放相关监听端口firewall-cmd --permanent --add-port=443/tcpfirewall-cmd --reload#重载配置（重新加载 nginx 配置以使得 SSL 证书生效）/opt/nginx/sbin/nginx -s reload¶3. 测试https访问创建一个待测试的html静态资源文件，如下：1echo "&lt;h1&gt;Hi, Nginx !&lt;/h1&gt;" &gt;&gt; /opt/nginx/html/test-https.html访问地址为：https://example.com/test-https.html¶十、配置nginx进程和其执行用户¶1. nginx进程在 Nginx 的主进程启动后，会创建多个子进程来处理客户端请求和其他任务。这些子进程通常由 Nginx 主进程负责管理、调度和监控。Nginx 子进程通常分为以下几种类型：master process（主进程）：Nginx 的主进程，负责管理所有子进程，接收和处理来自命令行的信号，并启动整个 Nginx 服务。worker process（工作进程）：Nginx 的工作进程，负责处理客户端请求和其他任务，每个工作进程都是一个独立的进程，可以同时处理多个请求。cache loader process（缓存加载进程）：用于加载和预热缓存数据的进程，只有在开启缓存功能时才会启动。cache manager process（缓存管理进程）：用于管理缓存数据和处理缓存清理的进程，只有在开启缓存功能时才会启动。通常配置工作进程以满足业务需求。1234567891011#指定启动的工作进程数量（默认值为：auto，表示以CPU核心数决定工作进程数量）worker_processes 2;events &#123; #设置每个工作进程与客户端之间的最大连接数（默认值为：512） worker_connections 1024;&#125;#以下为其他无关配置...http &#123; # 其他配置项...&#125;¶2. nginx进程执行用户默认情况下，Nginx 启动后会创建一个主进程和多个工作进程，其中主进程为运行nginx服务的linux用户（通常是 root 用户），而每个工作进程都是以指定用户身份来执行的，默认情况下是以 nobody 用户身份运行。可以通过修改配置文件中的 user 指令来改变工作进程的执行用户。具体操作如下：(1) 创建nginx工作进程的执行用户12#创建nginx用户和同名用户组，不自动创建用户主目录，禁止该用户登录系统useradd -U -M -s /usr/sbin/nologin nginx(2) 修改 nginx 主配置文件nginx.conf，如下：1vim /opt/nginx/conf/nginx.conf修改如下：12345678910111213#修改user指令即可user nginx; #nginx工作进程的执行用户#user nginx nginx; #指定用户和用户组，如果没有指定用户组，则使用默认用户组#以下为其他无关配置...worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; # 其他配置项...&#125;注意：修改 nginx 用户后需要注意也要同时修改一些 nginx 相关的临时文件权限：12chown -R nginx:nginx /opt/nginx/proxy_tempchown -R nginx:nginx /opt/nginx/logs（4）重载nginx配置12#重载配置/opt/nginx/sbin/nginx -s reload¶十一、配置文件模块化¶简要概述在 Nginx 配置文件中可以通过使用 include 指令来实现模块化。从而让配置文件具有可复用性和更易维护性。具体表现为：允许用户将配置文件拆分为更小的配置文件，使配置更加清晰和可维护。然后通过 include 指令来包含这些被拆分的配置文件到某个配置文件中。¶include 指令的语法1include file | mask;其中：file 是要包含的单个文件的路径，可以是绝对路径或相对于 Nginx 配置文件的路径。mask 是一个通配符表达式，用于匹配多个文件。可以使用通配符字符 * 和 ?。¶include 指令使用示例12345#包含单个文件include /path/to/file.conf;#包含多个文件，使用通配符匹配include /path/to/conf.d/*.conf;请注意，include 指令可以出现在任何适当的位置，以包含其他配置文件的内容。当 Nginx 读取配置文件时，它会按照指令的顺序逐行解析，并将包含的文件内容合并到最终的配置中。¶十一、配置日志Nginx 默认有两种日志文件的记录，即 error_log（错误日志）和 access_log（访问日志）。用户可以分别对这两种日志文件进行相关自定义配置。¶error_log 错误日志配置error_log 命令用于记录 Nginx 的错误信息，可以配置 off停止日志记录，或者配置日志路径和错误级别进行日志记录，默认支持的错误级别如下：error：记录错误消息。warn：记录警告消息和错误消息。notice：记录普通但重要的信息。info：记录更详细的信息，通常用于调试。debug：记录详细的调试信息，通常用于详尽的故障排除。使用格式如下：123error_log logs/error.log error;#error_log logs/error.log info;#error_log off; #停止错误日志记录¶access_log 访问日志配置access_log 命令用于记录客户端请求的访问日志，可以配置 off停止日志记录，或者配置日志路径和日志格式进行日志记录，默认支持：combined（默认，即都不配置日志的情况）、main（安装后通常自动使用的格式） 这些日志格式，当然用户可以自定义日志格式，如下：12345678log_format custom '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"';#log_format custom '请求时间=$time_iso8601 | 请求IP=$remote_addr | 请求URL=$request | 请求数据类型=$http_content_type | 请求代理=$http_user_agent | 请求头大小=$body_bytes_sent | 来源URL地址=$http_referer | 客户端的真实IP=$http_x_forwarded_for | 响应状态码=$status | 响应数据类型=$sent_http_content_type | 响应时间=$upstream_response_time';access_log logs/access.log custom;#access_log off; #停止访问日志记录¶按照日期格式配置日志文件名称随着 nginx 长时间运行，日志文件也会变得越来越多，甚至几个月就达到了几个 GB 的大小，这会导致在排查日志时会由于内容太多而不好定位。为了解决这个问题，可以配置 nginx 记录日志时按照日期记录到不同的文件里，从而实现日志切割的效果。如下：12345678log_format custom '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"';#log_format custom '请求时间=$time_iso8601 | 请求IP=$remote_addr | 请求URL=$request | 请求数据类型=$http_content_type | 请求代理=$http_user_agent | 请求头大小=$body_bytes_sent | 来源URL地址=$http_referer | 客户端的真实IP=$http_x_forwarded_for | 响应状态码=$status | 响应数据类型=$sent_http_content_type | 响应时间=$upstream_response_time';map $time_iso8601 $logdate &#123; '~^(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)' $year-$month-$day;&#125;access_log logs/access-$logdate.log custom;设 logs 目录路径为：/opt/nginx/logs，则需要给该目录赋予 worker 进程的用户权限和操作权限。12chown nginx:nginx /opt/nginx/logschmod 755 /opt/nginx/logs12#重载配置/opt/nginx/sbin/nginx -s reload]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 学习笔记]]></title>
    <url>%2Fjavaee%2Fspringboot.html</url>
    <content type="text"><![CDATA[¶一、Spring Boot 入门¶1. Spring Boot 简介简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案；¶2. 微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；单体应用：ALL IN ONE微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；详细参照微服务文档¶3. 环境准备http://www.gulixueyuan.com/ 谷粒学院环境约束jdk1.8：Spring Boot 推荐jdk1.7及以上maven3.x：maven 3.3以上版本IntelliJIDEA2018SpringBoot 1.5.9.RELEASE¶(1)MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt;¶(2)IDEA设置IDEA整合maven¶4. HelloWorld一个功能：浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；¶(1)创建一个maven工程¶(2)导入依赖1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_01_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- Spring Boot的版本仲裁中心--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--选择场景启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;1、父项目spring-boot-starter-parent是场景启动器的版本仲裁中心，控制着SpringBoot的版本，跟换版本再次修改。2、spring-boot-starter-web：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件。更多的场景启动器请查看官方文档3、Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器4、SpringBoot对J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar中¶(3)编写一个主程序12345678910111213141516package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 主程序类 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // 启动Spring Boot应用 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125;1、@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用2、Spring Boot会将主配置类（@SpringBootApplication标注的类）的所在包及该包下面所有子包里面的所有组件扫描到Spring容器中在本例中Spring Boot会到HelloWorldMainApplication所在的包即com.qcmoke包下和Controller包下扫描所有组件。由此就可以扫描到了com.qcmoke.Controller.HelloController组件¶(4)编写相关的Controller1234567891011121314package com.qcmoke.Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125;¶(5)运行主程序测试¶(6)简化部署将这个应用打成jar包，直接使用java -jar的命令可进行执行:1F:\myproject\springboot\spring_01_helloworld\target&gt;java -jar spring_01_helloworld-1.0-SNAPSHOT.jar部署完成在此过程中不需要安装tomcat,因为springboot会将tomcat服务器直接嵌入到了生产的jar包中了。当运行这个jar包的时候，嵌入的tomcat也同样运行了起来。浏览器输出http://localhost:8080/hello就可以访问部署的springboot应用了。¶5. 使用Spring Initializer快速创建Spring Boot项目¶（1）IDEA Spring Initializer使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目。选择需要的模块，向导会联网创建Spring Boot项目。选择场景启动器（依赖）默认生成的Spring Boot项目的特点：主程序已经生成好了，我们只需要我们自己的逻辑resources文件夹中目录结构static：保存所有的静态资源； js css images；templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；此外还会附带一些版本控制和markdown等文件，由于当前项目用不到，故我们可以选择将这些文件删除掉。编写相关的Controller123456789101112131415package com.qcmoke.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//@Controller@RestController //使用@RestController可以替换@Controller和@ResponseBody；直接返回数据给浏览器，如果返回的是对象，那么会转为json数据public class HelloController &#123; //@ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125;运行测试¶（2）STS使用 Spring Starter Project快速创建项目待完成…¶二、springboot配置¶1. 配置文件SpringBoot默认使用的配置文件是resources目录下的application.properties和application.yml。要求文件名称是不能变的。而通过Spring Initializer创建的项目默认只生成一个名称为application.properties的配置文件。¶（1）配置文件的作用SpringBoot在底层都给我们自动配置好了默认值，可以通过修改配置文件从而修改SpringBoot自动配置的默认值。这些默认值包括端口等。¶（2）配置文件语法介绍由于properties文件较为普遍使用，这里对其语法就不进行过多讲解。¶①YAML语法YAML（YAML Ain’t Markup Language）​ YAML A Markup Language：是一个标记语言​ YAML isn’t Markup Language：不是一个标记语言；标记语言：​ 以前的配置文件；大多都使用的是 xxxx.xml文件；​ YAML：以数据为中心，比json、xml等更适合做配置文件；¶②基本语法使用k:(空格)v：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的。123server: port: 8081 path: /hello注意：属性和值是大小写敏感的。¶③值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写；​ 字符串默认不用加上单引号或者双引号；​ &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思​ name: &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行 lisi​ ''：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi对象、Map（属性和值）（键值对）,有两种方式Ⅰ k: v：在下一行来写对象的属性和值的关系；注意缩进​ 对象还是k: v的方式123friends: lastName: zhangsan age: 20Ⅱ 行内写法：1friends: &#123;lastName: zhangsan,age: 18&#125;数组（List、Set）,有两种方式Ⅰ 用-值表示数组中的一个元素1234pets: - cat - dog - pigⅡ 行内写法1pets: [cat,dog,pig]¶（3）测试yaml文件获取值注入到组件中组件：Person.java配置文件：application.yml方案：通过在组件中添加注解@ConfigurationProperties(prefix = “配置文件中的某个属性名称”)来让组件能够与配置文件中的某个属性建立关联导入配置文件处理器依赖,让配置文件能够有提示12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;导入依赖完成需要重新运行springboot项目以生效。要注入的组件类Person.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.qcmoke.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 1、将配置文件中配置的每一个属性的值，映射到当前类组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 2、只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@Component@ConfigurationProperties(prefix = "person") //配置注入配置文件中person属性的值public class Person &#123; /*生成get set方法；Alt + Insert 组合,如果不生效，先按NumLk键*/ private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() &#123; return "Person&#123;" + "lastName='" + lastName + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125;Dog.java12345678910111213141516171819202122232425262728293031package com.qcmoke.bean;public class Dog &#123; private String name; private Integer age; @Override public String toString() &#123; return "Dog&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125;编写配置文件，将配置文件中的属性值注入到Person对象里。application.yml12345678910111213person: lastName: zhangsan #对于驼峰式的属性也可以改写成last-name: zhangsan age: 22 boss: false birth: 1996/08/27 maps: &#123;k1: zhangsan,age: 22&#125; #行内写法 lists: #数组写法 - 语文 - 数学 - 英语 dog: #对象换行写法 name: 旺财 age: 2编写单元测试类SpringBoot02ConfigApplicationTests.java123456789101112131415161718192021222324package com.qcmoke;import com.qcmoke.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/* spring boot的单元测试 使用SpringRunner驱动器来执行测试，而不要junit */@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02ConfigApplicationTests &#123; @Autowired Person person; //自动注入 @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125;¶（4）测试properties配置文件获取值注入到组件中组件：Person.java配置文件：application.properties方案：通过在组件中添加注解@ConfigurationProperties(prefix = &quot;配置文件中的某个属性名称&quot;)来让组件能够与配置文件中的某个属性建立关联对于properties文件，需要解决idea中默认utf-8可能会输出乱码的问题。➡️idea设置导入配置文件处理器依赖,让配置文件能够有提示12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;导入依赖完成需要重新运行springboot项目以生效。要注入的组件类Person.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.qcmoke.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 1、将配置文件中配置的每一个属性的值，映射到当前类组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 2、只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@Component@ConfigurationProperties(prefix = "person") //配置注入配置文件中person属性的值public class Person &#123; /*生成get set方法；Alt + Insert 组合,如果不生效，先按NumLk键*/ private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() &#123; return "Person&#123;" + "lastName='" + lastName + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125;Dog.java12345678910111213141516171819202122232425262728293031package com.qcmoke.bean;public class Dog &#123; private String name; private Integer age; @Override public String toString() &#123; return "Dog&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125;编写配置文件，将配置文件中的属性值注入到Person对象里。application.properties123456person.last-name=李四person.age=21person.birth=1996/08/27person.boss=falseperson.maps.k1=v1person.maps.k2=v2编写单元测试类SpringBoot02ConfigApplicationTests.java123456789101112131415161718192021222324package com.qcmoke;import com.qcmoke.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/* spring boot的单元测试 使用SpringRunner驱动器来执行测试，而不要junit */@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02ConfigApplicationTests &#123; @Autowired Person person; //自动注入 @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125;¶（5）@Value从配置文件获取值注入组件属性组件：Person.java配置文件：application.yml（或者application.properties）方案：通过在组件中添加注解@Value()来让组件能够与配置文件中的某个属性建立关联以下没有修改的文件同上⬆️Person.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.qcmoke.bean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Componentpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL即SpringB表达式语言&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ /*生成get set方法；Alt + Insert 组合,如果不生效，先按NumLk键*/ @Value("$&#123;person.last-name&#125;") private String lastName; @Value("#&#123;20+1&#125;") private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() &#123; return "Person&#123;" + "lastName='" + lastName + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125;¶（6）配置文件注入值数据校验组件：Person.java配置文件：application.properties（或者application.yml)方案：通过在组件中添加注解@ConfigurationProperties(prefix = “配置文件中的某个属性名称”)注入值来让组件能够与配置文件中的某个属性建立关联的同时使用@Validated和特定校验注解。以下没有修改的文件同上⬆️application.properties123456person.last-name=lisi@qq.comperson.age=21person.birth=1996/08/27person.boss=falseperson.maps.k1=v1person.maps.k2=v2Person.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.qcmoke.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.Email;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @Email //注入的值必须是邮箱格式 private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() &#123; return "Person&#123;" + "lastName='" + lastName + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125;¶（7）@Value获取值和@ConfigurationProperties获取值比较@ConfigurationProperties@Value功能批量注入配置文件中的属性一个个指定松散绑定（松散语法)，例如属性名称为驼峰或者横线不敏感支持不支持SpEL不支持支持JSR303数据校验支持不支持复杂类型封装支持不支持配置文件yml还是properties都能获取到值。@Value和@ConfigurationProperties的使用场景：如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，可选择使用@Value。如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接选择使用@ConfigurationProperties。¶（8）@PropertySource作用 : 加载指定的自定义配置文件。使用背景：@ConfigurationProperties默认加载的是全局配置文件,如果全部的配置都写到主配置文件里，那么主配置文件将会越来越难维护。我们可以将与框架无关的配置写在非主配置文件中，尽量解耦。使用方法：在组件中添加注解@PropertySource(value = {&quot;自定义配置文件路径&quot;})来指定自定义配置文件并且配合@ConfigurationProperties(prefix = &quot;属性名&quot;)指定具体属性。案例：以下所有未说明的文件同上次案例。①注释掉所有主配置文件的person相关配置。②person.properties(自定义配置文件)123456person.last-name=wangwu@qq.comperson.age=21person.birth=1996/08/27person.boss=falseperson.maps.k1=v1person.maps.k2=v2③Person.java（组件）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.qcmoke.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@PropertySource(value = &#123;"classpath:person.properties"&#125;)//加载指定的自定义配置文件@ConfigurationProperties(prefix = "person")@Componentpublic class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() &#123; return "Person&#123;" + "lastName='" + lastName + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125;¶（9）@ImportResource作用：导入spring配置文件(.xml)，让配置文件里面的内容生效；使用方法：自己编写的spring配置文件.xml配置文件，不能自动识别；想让xml配置文件生效,可使用@ImportResource(locations = {&quot;spring配置文件xml的路径&quot;})标注在一个配置类上加载进来。案例：以下没有修改的文件同上⬆️beans.xml1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="personService" class="com.qcmoke.service.PersonService"&gt;&lt;/bean&gt;&lt;/beans&gt;PersonService.java12345678910111213package com.qcmoke.service;import com.qcmoke.bean.Person;import org.springframework.beans.factory.annotation.Autowired;public class PersonService &#123; @Autowired Person person; public Person getPerson()&#123; return person; &#125;&#125;SpringBoot02Config5Application.java123456789101112131415package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)//在主配置类上加载beans.xml@SpringBootApplicationpublic class SpringBoot02Config5Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02Config5Application.class, args); &#125;&#125;SpringBoot02Config5ApplicationTests.java12345678910111213141516171819202122232425package com.qcmoke;import com.qcmoke.bean.Person;import com.qcmoke.service.PersonService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/* spring boot的单元测试 使用SpringRunner驱动器来执行测试，而不要junit */@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02Config5ApplicationTests&#123; @Autowired PersonService service; @Test public void contextLoads() &#123; System.out.println(service.getPerson()); &#125;&#125;¶（10）配置文件占位符在properties或yaml配置文件中是可以使用占位符的¶①随机数${random.value} - 类似uuid的随机数，没有&quot;-&quot;连接${random.int} - 随机取整型范围内的一个值${random.long} - 随机取长整型范围内的一个值${random.long(100,200)} - 随机生成长整型100-200范围内的一个值${random.uuid} - 生成一个uuid，有短杠连接${random.int(10)} - 随机生成一个10以内的数${random.int(100,200)} - 随机生成一个100-200 范围以内的数¶②占位符${key:defaultValue} - 若key 不存在，则将defaultValue的值赋值给取值的对象案例：除以下特别说明的文件需要修改，其他文件同上⬆️person.properties1234567891011121314151617181920person.last-name=$&#123;random.uuid&#125;@qq.com#随机生成从0到120的整型值person.age=$&#123;random.int(0,120)&#125;person.birth=1996/$&#123;random.int(12)&#125;/27person.boss=false#随机生成10以内得整型值person.maps.k1=$&#123;random.int(10)&#125;#类似uuid的随机数，没有"-"连接person.maps.k2=$&#123;random.value&#125;#获取配置属性的值进行占位person.dog.name=$&#123;person.last-name&#125;_dog#先取age的值给person.dog.age，如果上面没有age的属性和值，那么就取默认值2person.dog.age=$&#123;age:2&#125;¶2. 多环境配置springboot默认激活的的是主配置文件application.properties/yml。但很多场景的配置，比如数据库配置、Redis 配置、注册中心和日志配置等，在不同的环境，我们需要不同的包去运行项目，那么就需要有多种配置方案，而且希望不同配置文件管理不同的环境配置，这种情况，文件名只要是application-{profile}.properties/yml，然后在主配置文件application.properties/yml通过以下配置来激活即可。123spring: profiles: active: &#123;profile&#125;案例：多环境配置文件有：application-dev.yml （开发环境）12server: port: 8081application-prod.yml （生产环境）12server: port: 80激活不同环境下的配置文件(三种方式)（1）主配置文件指定方式application.yml123spring: profiles: active: dev（2）命令行：1java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；也可以直接在测试的时候，ide中配置传入命令行参数（3）虚拟机参数；1-Dspring.profiles.active=dev¶3. 多文档块配置要求配置文件是yml格式。12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境¶4. 配置文件加载位置¶4.1 加载优先级springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件,优先级由高到底，高优先级的配置会覆盖低优先级的配置；–file:./config/–file:./–classpath:/config/–classpath:/如果以上4个位置都有主配置文件，那么SpringBoot会从这四个位置全部加载主配置文件，达到互补配置的效果；¶4.2 自定义加载位置我们还可以通过spring.config.location来改变默认的配置文件位置项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties¶5. 外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。1.命令行参数所有的配置都可以在命令行上进行指定1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc多个配置用空格分开； --配置项=值2.来自java:comp/env的JNDI属性3.Java系统属性（System.getProperties()）4.操作系统环境变量*5.RandomValuePropertySource配置的random.属性值6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件10.@Configuration注解类上的@PropertySource11.通过SpringApplication.setDefaultProperties指定的默认属性¶6. 配置类在spring中，给spring容器添加组件有两种方式：通过配置文件添加组件 （前面已经介绍）通过配置类的方式添加组件而SpringBoot推荐给容器中添加组件的方式是使用全注解的方式，也就是配置类的方式。¶（1）配置类添加组件会用到两个重要的注解@Configuration 指明当前类是一个配置类，相当于spring.xml@Bean 将方法的返回值添加到容器中。默认的bean id就是方法名¶（2）案例以下没有修改的文件同上⬆️（1）创建配置类PersonConfig.java1234567891011121314151617package com.qcmoke.config;import com.qcmoke.service.PersonService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Configuration 指明当前类是一个配置类，相当于spring.xml * @Bean 将方法的返回值添加到容器中。默认的bean id就是方法名 */@Configurationpublic class PersonConfig &#123; @Bean public PersonService personService()&#123; return new PersonService(); &#125;&#125;（2）取消主配置文件的@ImportResource注解SpringBoot02Config5Application.java123456789101112131415package com.qcmoke;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;//@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)//在主配置类上加载beans.xml@SpringBootApplicationpublic class SpringBoot02Config5Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02Config5Application.class, args); &#125;&#125;¶三、日志¶1. 市面上的日志框架JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…日志门面 （日志的抽象层）日志实现JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-loggingLog4j JUL（java.util.logging） Log4j2 Logback左边选一个门面（抽象层）、右边来选一个实现；日志门面： SLF4J；日志实现：Logback；SpringBoot：底层是Spring框架，Spring框架默认是用JCL而SpringBoot选用 SLF4j和logback。每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；¶2. 遗留问题Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx统一日志记录，即使是别的框架和我一起统一使用slf4j进行¶3. 统一日志记录如何让系统中所有的日志都统一到slf4j；1、将系统中其他日志框架先排除出去2、用中间包来替换原有的日志框架3、我们导入slf4j其他的实现¶4. 使用日志SpringBoot底层也是使用slf4j+logback的方式进行日志记录。并且也把其他的日志都替换成了slf4j,并且都已经配有日志配置默认值。开发的时候直接使用即可。测试：SpringBoot03LogApplicationTests.java12345678910111213141516171819202122232425262728package com.qcmoke;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot03LogApplicationTests &#123; //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志..."); &#125;&#125;¶5. SpringBoot修改日志的默认配置application.properties123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%nlogging.file和logging.pathlogging.filelogging.pathExampleDescription(none)(none)只在控制台输出指定文件名(none)my.log输出日志到my.log文件(none)指定目录/var/log输出到指定目录的 spring.log 文件中查看springboot默认日志配置的目录spring-boot-2.1.4.RELEASE.jar!/org/springframework/boot/logging/logback/¶6. 自定义日志配置给类路径下放上日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了。以下表格是各类日志框架的配置文件名规范。Logging SystemCustomizationLogbacklogback-spring.xml, logback-spring.groovy, logback.xml or logback.groovyLog4j2log4j2-spring.xml or log4j2.xmlJDK (Java Util Logging)logging.properties对于Logback日志框架的另外说明，两种命名规则的差别。logback.xml：直接就被日志框架识别了。logback-spring.xml(建议使用)：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能。如12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt;如果使用logback.xml作为日志配置文件，还要使用profile功能,可能会报错logback-spring.xml配置详情解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="/app/log" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="atguigu-springboot"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; -----》 [%thread] 《----- %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式： --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出， false：表示只用当前logger的appender-ref，true： 表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;logger name="com.atguigu" level="debug" /&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="debug" additivity="false"&gt;&lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="stdout" /&gt; &lt;appender-ref ref="appLogAppender" /&gt; &lt;/root&gt;&lt;/configuration&gt;¶7. 切换日志框架¶四、web开发¶1. 静态资源的映射规则定义规则的类为：org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration和org.springframework.boot.autoconfigure.web.ResourceProperties所有/webjars/** ，都去classpath:/META-INF/resources/webjars/找资源​ webjars：以jar包的方式引入静态资源。http://www.webjars.org/例如引入jquery123456&lt;!--jquery-webjar--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt;那么访问jquery的地址是http://localhost:8080/webjars/jquery/3.3.1/jquery.js“/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射,以下就是springboot默认的静态资源目录。12345"classpath:/META-INF/resources/", "classpath:/resources/","classpath:/static/", "classpath:/public/" "/"：当前项目的根路径index.html页面会被&quot;/**“映射，默认匹配”/&quot;。所有的 **/favicon.ico（页面图标）都是在静态资源文件下找¶2. 自定义静态资源目录当启用自定义的静态资源目录后，那么默认的静态资源目录就会失效。如以下将classpath:/mystatic/和classpath:/mypublic/设置为静态资源目录，那么classpath:/META-INF/resources/, classpath:/resources/,classpath:/static/, classpath:/public/,/等静态资源目录就会失效。application.properties1spring.resources.static-locations=classpath:/mystatic/,classpath:/mypublic/¶3. 模板引擎JSP（由于springboot默认是以jar包的方式打包，所有默认不支持jsp）、Velocity、Freemarker、ThymeleafSpringBoot推荐的Thymeleaf；语法更简单，功能更强大；¶3.1 Thymeleaf¶(1)引入thymeleaf12345678910111213&lt;properties&gt; &lt;!--配置thymeleaf版本--&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序要layout2以上版本 --&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;完整pom.xml:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_03_web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_03_web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--配置thymeleaf版本--&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序要layout2以上版本 --&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springboot测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jquery-webjar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;注:以上thymeleaf需要springboot1.5.10.RELEASE版本，高版本可能会出错¶(2)表达式12345$&#123;...&#125; : 变量表达式。OGNL表达式*&#123;...&#125; : 选择表达式。#&#123;...&#125; : 消息 (i18n) 表达式。@&#123;...&#125; : 链接 (URL) 表达式。~&#123;...&#125; : 片段表达式。表达式都作为标签的属性值。更多表达式介绍可参阅官方文档或者https://www.e-learn.cn/thymeleaf/standard-dialects¶(3) 语法更多语法参阅官方文档或者https://www.kancloud.cn/cxr17618/springboot/428898¶(4)测试thymeleaf只要我们把编写有thymeleaf语法的HTML页面放在classpath:/templates/，thymeleaf就能自动渲染。①SuccessController.java(目的是给thymeleaf页面提供动态数据)12345678910111213141516171819package com.qcmoke.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Arrays;import java.util.Map;@Controllerpublic class SuccessController &#123; //查出用户数据，在页面展示 @RequestMapping("/success") public String success(Map&lt;String,Object&gt; map)&#123; map.put("hello","&lt;h1&gt;你好&lt;/h1&gt;");//动态数据 map.put("users",Arrays.asList("qcmoke","zhangsan","lisi")); return "success"; &#125;&#125;②success.html12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;!--导入thymeleaf的名称空间，有更好的thymeleaf语法提示效果--&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text不转译特殊字符--&gt;&lt;div th:utext="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;!--将div里面的文本内容设置为hello动态变量的值--&gt;&lt;!--th:text转译特殊字符--&gt;&lt;div th:text="$&#123;hello&#125;"&gt;&lt;/div&gt;&lt;!--th:each--&gt;&lt;h4 th:text="$&#123;user&#125;" th:each="user:$&#123;users&#125;"&gt;&lt;/h4&gt;&lt;!--每遍历一次就会生成一个h4标签--&gt;&lt;h4&gt; &lt;span th:text="$&#123;user&#125;" th:each="user:$&#123;users&#125;"&gt;&lt;/span&gt;&lt;!--每遍历一次就会生成一个span标签--&gt;&lt;/h4&gt;&lt;!--行内表达式，取值并显示--&gt;&lt;h4&gt; &lt;span th:each="user:$&#123;users&#125;"&gt; [[$&#123;user&#125;]] &lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;¶3.2 Jspspringboot内置servlet服务器默认不支持以启动springboot应用即main方法启动的方式解析器jsp。为了解决这种问题。有两种决绝方案。¶3.2.1 外置servlet服务器方案（1）创建项目的打包方式位war（2）添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;完整pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_03_web_support_jsp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring_boot_03_web_support_jsp&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--外置tomcat支持jsp方案--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;（3）完善项目结构和配置tomcat生成webapp生成web.xml修改web.xml路径为项目地址\src\main\webapp\WEB-INF\web.xml配置tomcat部署web项目（4）编写一个SpringBootServletInitializer的子类，并调用configure方法（必须），作用是在tomcat启动同时1234567891011121314package com.qcmoke;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;/*** Web程序启动类*/public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBoot03WebSupportJspApplication.class); &#125;&#125;（3）配置application.properties123# 配置视图解析器，配置jsp的路径和后缀spring.mvc.view.prefix=/WEB-INF/spring.mvc.view.suffix=.jsp（4）编写测试代码UserController.java1234567891011121314151617package com.qcmoke.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class UserController &#123; @RequestMapping("/tomain") public String tomain(Model model, Map&lt;String,Object&gt; map)&#123; model.addAttribute("name","qcmoke"); map.put("age",22); return "success"; &#125;&#125;WEB-INF/success.jsp12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: qcmoke Date: 2019/4/19 Time: 1:20 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello $&#123;name&#125;,your age is $&#123;age&#125; !&lt;/body&gt;&lt;/html&gt;（5）不以main方法启动，而是点击run按钮运行部署web项目¶3.2.2 内置servlet服务器加插件方案（1）打包方式为jar或者war（建议为jar）（2）添加依赖123456789101112&lt;!--内嵌tomcat支持jsp方案1（推荐）--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;或者1234567891011&lt;!--内嵌tomcat支持jsp方案2--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;8.5.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt; &lt;version&gt;8.5.16&lt;/version&gt;&lt;/dependency&gt;完整pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_web_jsp2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_web_jsp2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--内嵌tomcat支持jsp方案1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--内嵌tomcat支持jsp方案2--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;8.5.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt; &lt;version&gt;8.5.16&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;（3）完善项目结构和配置tomcat（同上）（4）配置application.properties123# 配置视图解析器，配置jsp的路径和后缀spring.mvc.view.prefix=/WEB-INF/spring.mvc.view.suffix=.jsp（5）编写测试代码UserController.java1234567891011121314151617package com.qcmoke.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class UserController &#123; @RequestMapping("/tomain") public String tomain(Model model, Map&lt;String,Object&gt; map)&#123; model.addAttribute("name","qcmoke"); map.put("age",22); return "success"; &#125;&#125;WEB-INF/success.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello $&#123;name&#125;,your age is $&#123;age&#125; !&lt;/body&gt;&lt;/html&gt;（6）运行main方法启动springboot应用¶3.3 jar和war打包方式启动区别jar包:执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器。war包: 先是启动外置Servlet服务器,服务器就会启动Springboot应用(springBootServletInitizer),然后Springboot应用再启动IOC容器。¶4. SpringMVC自动配置官方文档¶1. Spring MVC auto-configurationSpring Boot 默认已经自动配置好了SpringMVC，直接使用即可。自动配置了视图解析器自定义视图解析器（如需要）例如：12345678910111213141516171819202122232425262728293031323334353637package com.qcmoke.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; /** * 自定义视图解析器 */ public static class MyViewResolver implements ViewResolver&#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; return null; &#125; &#125; /** * 将自定义的视图解析器放到spring容器中 */ @Bean public ViewResolver myViewReolver()&#123; return new MyViewResolver(); &#125;&#125;自动注册了 Converter, GenericConverter, Formatter格式化器 等转换器.¶2. 如何修改SpringBoot的默认web配置¶2.1 模式​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如ViewResolver），那么SpringBoot会将用户配置的和自己默认的配置的组合起来。​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置¶2.2 默认访问首页12345678910111213141516171819202122232425//继承WebMvcConfigurerAdapter类可以来扩展SpringMVC的功能//@EnableWebMvc 配置不要完全接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125;¶五、持久层开发¶1. 常用数据源配置¶1.1 默认数据源springboot jdbcspringboot默认是使用org.apache.tomcat.jdbc.pool.DataSource作为连接池（数据源）。SpringBoot默认可以支持的连接池包括org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource。下面将介绍使用默认提供的org.apache.tomcat.jdbc.pool.DataSource作为连接池（数据源）测试数据库访问。¶（1）数据表resources/department.sql12345678910111213141516171819SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of department-- ----------------------------INSERT INTO `department` VALUES (1, '研发部');SET FOREIGN_KEY_CHECKS = 1;¶（2）引入依赖需要引入springboot jdbc依赖和数据库驱动包123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;完整依赖：pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_04_jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_04_jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;¶（3）配置数据库连接信息application.yml123456spring: datasource: username: root password: 123456 url: jdbc:mysql://127.0.0.1:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false driver-class-name: com.mysql.jdbc.Driver¶（4）测试数据库链接ApplicationTests.java1234567891011121314151617181920212223242526272829303132package com.qcmoke;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; /** * 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； */ @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; Connection connection = dataSource.getConnection(); System.out.println(connection!=null?"conn success":"conn fail"); connection.close(); &#125;&#125;¶1.2 Druid数据源¶（1）数据表resources/department.sql12345678910111213141516171819SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of department-- ----------------------------INSERT INTO `department` VALUES (1, '研发部');SET FOREIGN_KEY_CHECKS = 1;如果不配置，那么默认连接池为tomcat.jdbc.pool.DataSource。¶（2）引入依赖12345678910111213141516171819&lt;!--springboot jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--引入druid数据源--&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql 驱动包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- &lt;version&gt;8.0.11&lt;/version&gt;--&gt;&lt;!--mysql8.0需要指定高版本的驱动包--&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;完整依赖：pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_04_druid&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_04_jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springboot test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springboot jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入druid数据源--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- &lt;version&gt;8.0.11&lt;/version&gt;--&gt;&lt;!--mysql8.0需要指定高版本的驱动包--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;¶（3）配置数据库连接信息12345678910111213141516171819202122232425spring: datasource: username: root password: 123456 url: jdbc:mysql://47.101.174.33:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false driver-class-name: com.mysql.jdbc.Driver schema: #运行sql脚本文件，如果不存在则创建，如果存在不进行操作（可选） - classpath:department.sql type: com.alibaba.druid.pool.DruidDataSource #指定数据源类型，默认是使用org.apache.tomcat.jdbc.pool.DataSource作为连接池（数据源） #druid可选的属性配置，默认比不起作用，如果需要这些可选配置需要new DruidDataSource()到spring容器中覆盖掉原来默认的数据源。并通过@ConfigurationProperties(prefix = "spring.datasource")的方式将datasource的属性包括可选注入到这个新建的实例对象中 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true filters: stat,wall,log4j # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500druid可选的属性配置（如initialSize、minIdle等），默认比不起作用(但不会报错)，如果需要这些可选配置需要new DruidDataSource()到spring容器中覆盖掉原来默认的数据源。并通过@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)的方式将datasource的属性包括可选注入到这个新建的实例对象中。src/main/java/com/qcmoke/config/DruidConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.qcmoke.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; /** * 创建数据源 */ @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; /** * 配置Druid的监控web页面 * druid监控地址http://localhost:8080/druid/login.html * @return */ //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); //拒绝192.168.15.21访问 bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;这个类除了创建数据源到spring容器外，还配置了Druid的监控web页面（可选）。¶（4）测试数据库连接ApplicationTests.java12345678910111213141516171819202122232425262728293031package com.qcmoke;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * druid数据库连接池配置类 * 如果不配置，那么默认连接池为tomcat.jdbc.pool.DataSource */@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; System.out.println(dataSource);//查看数据源dataSource Connection connection = dataSource.getConnection(); System.out.println(connection!=null?"conn success":"conn fail"); connection.close(); &#125;&#125;¶2. 整合MyBatis¶（1）数据表resources/sql/mybatis.sql1234567891011121314151617181920212223242526272829303132SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gender` int(2) NULL DEFAULT NULL, `d_id` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of employee-- ----------------------------INSERT INTO `employee` VALUES (1, 'wen', '166@qq.com', 1, 1);SET FOREIGN_KEY_CHECKS = 1;¶（2）pojoEmployee.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qcmoke.bean;public class Employee &#123; private Integer id; private String lastName; private Integer gender; private String email; private Integer dId; public void setId(Integer id) &#123; this.id = id; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public void setdId(Integer dId) &#123; this.dId = dId; &#125; public Integer getId() &#123; return id; &#125; public String getLastName() &#123; return lastName; &#125; public Integer getGender() &#123; return gender; &#125; public String getEmail() &#123; return email; &#125; public Integer getdId() &#123; return dId; &#125; @Override public String toString() &#123; return "Employee&#123;" + "id=" + id + ", lastName='" + lastName + '\'' + ", gender=" + gender + ", email='" + email + '\'' + ", dId=" + dId + '&#125;'; &#125;&#125;Department.java1234567891011121314151617181920212223package com.qcmoke.bean;public class Department &#123; private Integer id; private String departmentName; public void setId(Integer id) &#123; this.id = id; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; public Integer getId() &#123; return id; &#125; public String getDepartmentName() &#123; return departmentName; &#125;&#125;¶（3）引入依赖123456789101112131415161718192021222324&lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--springboot jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;完整依赖pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_04_mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_04_mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springboot test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--springboot jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.minidev&lt;/groupId&gt; &lt;artifactId&gt;json-smart&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;¶（4）配置mybatis方式一：配置文件方式配置MyBatisresources/mybatis/mybatis-config.xml123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!--开启驼峰式命名规则支持--&gt; &lt;/settings&gt;&lt;/configuration&gt;方式二：配置类方式配置MyBatis123456789101112131415161718192021222324252627package com.qcmoke.config;import org.mybatis.spring.annotation.MapperScan;import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 配置类方式配置MyBatis */@MapperScan(value = "com.qcmoke.mapper") //批量扫描，在配置类中使用@MapperScan将某个包下的所有接口扫描装配到容器中,如果不扫描可以在mapper接口上使用@Mapper 注解扫描装配到容器中@Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; /** * 开启驼峰式命名规则支持 * @param configuration */ @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125;¶（5）配置springboot和数据源1234567891011121314151617181920212223242526272829303132333435spring:##配置druid连接池(数据源) datasource:# 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/mybatis type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500##配置mybatismybatis: config-location: classpath:mybatis/mybatis-config.xml # 指定全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指定sql映射文件位置# schema:# - classpath:sql/department.sql# - classpath:sql/employee.sqldruid可选的属性配置（如initialSize、minIdle等），默认比不起作用(但不会报错)，如果需要这些可选配置需要new DruidDataSource()到spring容器中覆盖掉原来默认的数据源。并通过@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)的方式将datasource的属性包括可选注入到这个新建的实例对象中。src/main/java/com/qcmoke/config/DruidConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.qcmoke.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; /** * 创建数据源 */ @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; /** * 配置Druid的监控web页面 * druid监控地址http://localhost:8080/druid/login.html * @return */ //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); //拒绝192.168.15.21访问 bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;这个类除了创建数据源到spring容器外，还配置了Druid的监控web页面（可选）。¶（6）mappercom.qcmoke.mapper.EmployeeMapper12345678910111213package com.qcmoke.mapper;import com.qcmoke.bean.Employee;import org.apache.ibatis.annotations.Mapper;//@Mapper //使用@Mapper注解指定操作数据库的mapper接口。如果不写这个@Mapper注解，可以在配置类中使用@MapperScan将某个包下的所有接口扫描装配到容器中public interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void insertEmp(Employee employee);&#125;配置mapper（配置文件版）resources/mybatis/mapper/EmployeeMapper.xml12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qcmoke.mapper.EmployeeMapper"&gt; &lt;!-- public Employee getEmpById(Integer id); public void insertEmp(Employee employee);--&gt; &lt;select id="getEmpById" resultType="com.qcmoke.bean.Employee"&gt; SELECT * FROM employee WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;insert id="insertEmp"&gt; INSERT INTO employee(lastName,email,gender,d_id) VALUES (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;) &lt;/insert&gt;&lt;/mapper&gt;配置mapper（注解版）com.qcmoke.mapper.DepartmentMapper1234567891011121314151617181920212223package com.qcmoke.mapper;import com.qcmoke.bean.Department;import org.apache.ibatis.annotations.*;import org.mybatis.spring.annotation.MapperScan;@Mapper //使用@Mapper注解指定操作数据库的mapper接口。如果不写这个@Mapper注解，可以在配置类中使用@MapperScan将某个包下的所有接口扫描装配到容器中public interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") //设置id自动增长 @Insert("insert into department(department_name) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set department_name=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125;¶（7）controllercom.qcmoke.controller.EmpController123456789101112131415161718192021package com.qcmoke.controller;import com.qcmoke.bean.Employee;import com.qcmoke.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class EmpController &#123; @Autowired EmployeeMapper employeeMapper; @GetMapping("/emp/&#123;id&#125;") public Employee getEmp(@PathVariable("id") Integer id)&#123; return employeeMapper.getEmpById(id); &#125;&#125;com.qcmoke.controller.DeptController123456789101112131415161718192021222324252627282930313233343536package com.qcmoke.controller;import com.qcmoke.bean.Department;import com.qcmoke.mapper.DepartmentMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DeptController &#123; @Autowired DepartmentMapper departmentMapper; /** * 根据id获取部门数据 * @param id * @return */ @GetMapping("/dept/&#123;id&#125;") public Department getDepartment(@PathVariable("id") Integer id)&#123; return departmentMapper.getDeptById(id); &#125; /** * 新增部门 * @param department * @return */ @GetMapping("/dept") public Department insertDept(Department department)&#123; departmentMapper.insertDept(department); return department; &#125;&#125;¶（8）测试ApplicationTests12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qcmoke;import com.qcmoke.mapper.DepartmentMapper;import com.qcmoke.mapper.EmployeeMapper;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Autowired ApplicationContext ac; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Test public void contextLoads() &#123; String[] names = ac.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; &#125; @Test public void getemp()&#123; System.out.println(employeeMapper.getEmpById(1));; &#125; @Test public void getdepts()&#123; System.out.println(departmentMapper.getDeptById(1)); &#125;&#125;security依赖包只要引入了，它会默认给项目加入密码。用户名是user 默认密码在控制台找下。¶六、整合Redis¶1. 引入Redis依赖12345&lt;!-- redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;¶2. 配置文件¶3. 添加Redis配置类不添加这个配置类的话，默认Redis是以jdk默认序列化的二进制方式进行存取的，这可能不太友好，所以这里有必要写一个配置类来实现Redis以json格式字符串进行自动存取。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.qcmoke.configuration;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;/** * Spring Boot2.X 对Redis的专用配置类 * 参考：https://blog.csdn.net/caojidasabi/article/details/83059642 * * @author qcmoke * @date 2019/6/16 15:34 */@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport &#123; private Duration timeToLive = Duration.ZERO; public void setTimeToLive(Duration timeToLive) &#123; this.timeToLive = timeToLive; &#125; /** * RedisTemplate配置 * * @param factory RedisConnectionFactory * @return RedisTemplate&lt;String, Object&gt; */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(getJackson2JsonRedisSerializer()); // hash的value序列化方式采用jackson template.setHashValueSerializer(getJackson2JsonRedisSerializer()); template.afterPropertiesSet(); return template; &#125; /** * 获取Jackson2JsonRedisSerializer * 序列化策略 */ private Jackson2JsonRedisSerializer&lt;Object&gt; getJackson2JsonRedisSerializer() &#123; Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); return jackson2JsonRedisSerializer; &#125; /***********注解时才需要以下配置，不用注解的话以上配置即可****************/ @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() //生成一个默认配置，通过config对象即可对缓存进行自定义配置 .entryTtl(timeToLive)//设置缓存的默认过期时间，也是使用Duration设置 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(getJackson2JsonRedisSerializer())) .disableCachingNullValues();//不缓存空值 return RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); &#125; @Override @Bean public KeyGenerator keyGenerator() &#123; return (target, method, params) -&gt; &#123; StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125;; &#125;&#125;¶4. 使用思路：查询的时候先查看redis缓存中有没有，有的话则直接从redis中获取数据返回，不经过dao层访问mysql了，如果redis中没有相应的缓存才调用dao层访问mysql。而进行删除的时候要把redis中的相应缓存删除掉，进行修改时也要修改相应的缓存。¶4.1 dao1234567891011121314151617181920package com.qcmoke.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.qcmoke.entity.Student;import org.apache.ibatis.annotations.*;import org.springframework.stereotype.Repository;import java.util.List;@Mapper@Repositorypublic interface StudentMapper extends BaseMapper&lt;Student&gt; &#123; @Delete("delete from student where sid=#&#123;0&#125;") Boolean deleteBySid(Integer sid); @Select("select * from student where sid = #&#123;0&#125;") Student selectOneBySid(Integer sid);&#125;¶4.2 service1234567891011121314151617package com.qcmoke.service;import com.qcmoke.entity.Student;import java.util.List;public interface IStudentService &#123; Student getOne(Integer sid); Student update(Student student); Boolean delete(Integer sid); Integer add(Student student); List&lt;Student&gt; getList();&#125;spring注解的方式进行缓存管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.qcmoke.service;import com.qcmoke.dao.StudentMapper;import com.qcmoke.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * TODO * * @author qcmoke * @date 2019/6/16 2:57 */@Service("iStudentServiceImpl")public class IStudentServiceImpl implements IStudentService &#123; @Autowired StudentMapper studentMapper; @Cacheable(cacheNames = "student", key = "#sid", unless = "#result == null") @Override public Student getOne(Integer sid) &#123; return studentMapper.selectOneBySid(sid); &#125; @Transactional @CachePut(cacheNames = "student", key = "#student.sid") @Override public Student update(Student student) &#123; studentMapper.updateById(student); return student; &#125; @Transactional @CacheEvict(cacheNames = "student", key = "#sid") @Override public Boolean delete(Integer sid) &#123; return studentMapper.deleteById(sid) &gt; 0; &#125; @Transactional @Override public Integer add(Student student) &#123; return studentMapper.insert(student); &#125; @Override public List&lt;Student&gt; getList() &#123; return null; &#125;&#125;使用RedisTemplate进行缓存管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.qcmoke.service;import com.qcmoke.dao.StudentMapper;import com.qcmoke.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service(value = "iStudentServiceImpl2")public class IStudentServiceImpl2 implements IStudentService &#123; @Autowired StudentMapper studentMapper; /** * 操作对象（key和value都是对象） */ @Autowired RedisTemplate redisTemplate; @Override public Student getOne(Integer sid) &#123; Student student = (Student)redisTemplate.opsForValue().get("student_"+sid); if (student == null) &#123; student = studentMapper.selectOneBySid(sid); if (student!=null)&#123; redisTemplate.opsForValue().set("student_"+sid, student); &#125; &#125; return student; &#125; @Transactional @Override public Student update(Student student) &#123; int flag = studentMapper.updateById(student); if (flag&gt;0)&#123; redisTemplate.opsForValue().set("student_"+student.getSid(), student); &#125; return student; &#125; @Transactional @Override public Boolean delete(Integer sid) &#123; boolean flag1 = studentMapper.deleteById(sid) &gt; 0; Boolean flag2 = false; if (flag1)&#123; flag2= redisTemplate.delete("student_" + sid); &#125; return flag1 &amp;&amp; flag2; &#125; @Transactional @Override public Integer add(Student student) &#123; return studentMapper.insert(student); &#125; @Override public List&lt;Student&gt; getList() &#123; return null; &#125;&#125;复杂的缓存注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.qcmoke.service;import com.qcmoke.dao.StudentMapper;import com.qcmoke.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@CacheConfig(cacheNames = "student") //抽取缓存的公共配置@Service("iStudentServiceImpl3")public class IStudentServiceImpl3 implements IStudentService &#123; @Autowired StudentMapper studentMapper; @Cacheable(key = "#sid") @Override public Student getOne(Integer sid) &#123; return studentMapper.selectOneBySid(sid); &#125; @Cacheable(key = "#root.method.name") @Override public List&lt;Student&gt; getList() &#123; return studentMapper.selectList(null); &#125; @Transactional @Caching( put = &#123; @CachePut(key = "#student.sid") &#125;, evict = &#123; @CacheEvict(key = "'getList'") &#125; ) @Override public Student update(Student student) &#123; studentMapper.updateById(student); return student; &#125; @Transactional @Caching( evict = &#123; @CacheEvict(key = "#sid"), @CacheEvict(key = "'getList'") &#125; ) @Override public Boolean delete(Integer sid) &#123; return studentMapper.deleteById(sid) &gt; 0; &#125; @Transactional @Caching( put = &#123; @CachePut(key = "#student.sid") &#125;, evict = &#123; @CacheEvict(key = "'getList'") &#125; ) @Override public Integer add(Student student) &#123; return studentMapper.insert(student); &#125;&#125;¶4.3 test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.qcmoke;import com.qcmoke.entity.Student;import com.qcmoke.service.IStudentService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;import java.util.List;/** * 一、快速体验缓存 * 步骤： * 1、在配置类开启基于注解的缓存 @EnableCaching * 2、标注缓存注解即可 * 3、默认springboot自带的SimpleCacheConfiguration使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在ConcurrentMap&lt;Object, Object&gt;中。但开发中却常常使用的是缓存中间件；redis、memcached、ehcache； * * 二、整合redis作为缓存，它是内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。） * 1、安装redis * 2、引入redis的starter依赖 * 3、配置redis * 4、测试缓存 * 原理：容器中保存的SimpleCacheConfiguration会被替换成RedisCacheConfiguration；缓存管理器ConcurrentMapCacheManager会被替换成RedisCacheManager； * 1）、引入redis的starter * 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；而RedisCache就是通过操作redis来缓存数据的 * 3）、默认使用的是 RedisTemplate&lt;Object, Object&gt;，所有存数据 k-v 都是Object，故默认是利用jdk的序列化机制来保存数据到Redis的。如果希望保存为json字符串，可以通过配置类进行配置 * 4）、自定义CacheManager； * 5）、使用注解实现缓存 * @Cacheable（缓存） * 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字和key获取； * 2、没有查到缓存就调用目标方法； * 3.将目标方法返回的结果，放进缓存中 * * 几个属性： * * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * * * * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * * getEmp[2] * * * * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * * key/keyGenerator：二选一使用; * * * * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * * * * condition：指定符合条件的情况下才缓存； * * ,condition = "#id&gt;0" * * condition = "#a0&gt;1"：第一个参数的值》1的时候才进行缓存 * * * * unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 * * unless = "#result == null" * * unless = "#a0==2":如果第一个参数的值是2，结果不缓存； * * sync：是否使用异步模式 * * @CacheEvict（缓存清除） * * key：指定要清除的数据 * * allEntries = true：指定清除这个缓存中所有的数据 * * beforeInvocation = false：缓存的清除是否在方法之前执行 * * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * * beforeInvocation = true： * * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 * * @CachePut（更新缓存） * 既调用方法，又更新缓存数据；同步更新缓存 * * 修改了数据库的某个数据，同时更新缓存； * * 运行时机： * * 1、先调用目标方法 * * 2、将目标方法的结果缓存起来 * * */@RunWith(SpringRunner.class)@SpringBootTestpublic class TestRedisCache &#123; @Resource(name = "iStudentServiceImpl") private IStudentService studentService; @Test public void getOne()&#123; System.out.println(studentService.getOne(1)); &#125; @Test public void update()&#123; Student student = studentService.getOne(1); student.setSname("xiaolifeidao"); System.out.println(studentService.update(student)); &#125; @Test public void delete()&#123; System.out.println(studentService.delete(1)); &#125; @Resource(name = "iStudentServiceImpl2") private IStudentService iStudentServiceImpl2; @Test public void getOne2()&#123; System.out.println(iStudentServiceImpl2.getOne(2)); &#125; @Test public void update2()&#123; Student student = iStudentServiceImpl2.getOne(2); student.setSname("zh"); System.out.println(iStudentServiceImpl2.update(student)); &#125; @Test public void delete2()&#123; System.out.println(iStudentServiceImpl2.delete(2)); &#125; @Resource(name = "iStudentServiceImpl3") private IStudentService iStudentServiceImpl3; @Test public void getOne3()&#123; System.out.println(iStudentServiceImpl3.getOne(2)); &#125; @Test public void update3()&#123; Student student = iStudentServiceImpl3.getOne(2); student.setSname("lisi"); System.out.println(iStudentServiceImpl3.update(student)); &#125; @Test public void getList()&#123; List&lt;Student&gt; list = iStudentServiceImpl3.getList(); System.out.println(list); &#125; @Test public void delete3()&#123; System.out.println(iStudentServiceImpl3.delete(3)); &#125;&#125;¶七、任务调度¶1.定时任务开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式。两个重要的注解：@EnableScheduling、@Scheduled(cron = “cron表达式”)cron表达式：字段允许值允许的特殊字符秒0-59, - * /分0-59, - * /小时0-23, - * /日期1-31, - * ? / L W C月份1-12, - * /星期0-7或SUN-SAT 0,7是SUN, - * ? / L C #特殊字符代表含义,枚举-区间*任意/步长?日/星期冲突匹配L最后W工作日C和calendar联系后计算过的值#星期，4#2，第2个星期四¶1.1 配置类12345678910package com.qcmoke.configuration;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;@EnableScheduling //开启基于注解的定时任务@Configurationpublic class ScheduledConfig &#123;&#125;¶1.2 使用1234567891011121314151617181920212223242526package com.qcmoke.service;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;@Servicepublic class ScheduledService &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */ // @Scheduled(cron = "0 * * * * MON-SAT") //@Scheduled(cron = "0,1,2,3,4 * * * * MON-SAT") // @Scheduled(cron = "0-4 * * * * MON-SAT") @Scheduled(cron = "0/4 * * * * MON-SAT") //每4秒执行一次 public void hello()&#123; System.out.println("hello ... "); &#125;&#125;在启动springboot应用后，每隔4秒钟就会打印&quot;hello ...&quot;。¶2. 异步任务¶2.1 配置类123456789package com.qcmoke.configuration;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableAsync;@Configuration@EnableAsync //开启异步注解功能public class AsyncConfig &#123;&#125;¶2.2 定义异步方法12345678910111213141516171819package com.qcmoke.service;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123; //告诉Spring这是一个异步方法 @Async public void async()&#123; try &#123; Thread.sleep(10000); System.out.println("处理异步数据中..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;¶2.3 使用1234567891011121314151617181920212223package com.qcmoke.controller;import com.qcmoke.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @ResponseBody @GetMapping("/testAsync") public String async()&#123; /** * ①和②是两条执行语句，由于①方法使用了@Async注解，所以①和②是异步进行的，也就是在这个方法体内①开辟了一条新的线程。②不需要等待①同步执行结束才执行 */ asyncService.async();//① 调用异步方法，需要10秒执行完 return "执行下一条语句";//② &#125;&#125;¶八. 邮件开发邮件任务是其实是一个客户端收发邮件的过程，这里以QQ邮箱为例，首先需要在项目中登录到配置好的QQ邮件服务器后，发送邮件给QQ邮件服务器，QQ邮服务器在中转你发送的邮件给接收邮件账号对应的邮件服务器，最后再通过该服务器发送给邮件接收者的账号。所以说只要你本地的主机可以连网那么就可以完成这个过程。¶1. 引入依赖12345&lt;!-- springboot mail --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;¶2. 配置12345spring: mail: username: 1667164190@qq.com password: fi*********gih host: smtp.qq.com注意：这里的password不是邮箱登录的密码，而是邮件服务器对指定邮件账号的登录授权码，对于QQ邮箱来说，授权码的获取可参考下图：¶3. 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qcmoke;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.test.context.junit4.SpringRunner;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestMail &#123; @Autowired JavaMailSenderImpl mailSender; /** * 发送简单邮件 */ @Test public void sendMail()&#123; SimpleMailMessage message = new SimpleMailMessage(); message.setSubject("通知-今晚开会");//设置邮件标题 message.setText("今晚7:30开会");//设置邮件内容 message.setTo("qcmoke@gmail.com");//设置收邮件的账号 message.setFrom("1667164190@qq.com");//设置发邮件的账号 mailSender.send(message); &#125; /** * 发送复杂邮件 */ @Test public void sendMail2() throws MessagingException &#123; //1、创建一个复杂的消息邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject("通知-今晚开会");//设置邮件标题 helper.setText("&lt;b style='color:red'&gt;今天 7:30 开会&lt;/b&gt;",true);//设置邮件内容 helper.setTo("qcmoke@gmail.com");//设置收邮件的账号 helper.setFrom("1667164190@qq.com");//设置发邮件的账号 //添加附件文件 helper.addAttachment("1.jpg",new File("src/main/resources/static/img/1.jpg")); helper.addAttachment("2.jpg",new File("src/main/resources/static/img/2.png")); mailSender.send(mimeMessage); &#125;&#125;¶九、热部署添加依赖123456 &lt;!--热部署依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;!-- optional=true,依赖不会传递，即子项目如果依赖当前项目，不会获取devtools，那么需要重新引入devtools --&gt;&lt;/dependency&gt;123456789101112&lt;build&gt; &lt;plugins&gt; &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;!--fork : 如果没有该项配置，肯定devtools不会起作用，即应用不会restart --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;添加以上依赖后，在eclipse中已经可以实现热启动，但是在idea中还需要做两处设置。（1）setting –&gt; compiler ，将 Build project automatically 勾选上（2）快捷键ctrl + shift + alt + /或者Ctrl+ shift + a搜索 registry后选第一个，弹出框后下拉找到compiler.automake.allow.when.app.running 勾选上即可。¶十 深入底层12345678910BeanPostProcessorhttps://www.jianshu.com/p/e6a6013ef0a0ApplicationListenerhttps://my.oschina.net/u/2931319/blog/1631740http://followtry.cn/2019-10-30/spring-custom-scanner-demo.htmlApplicationListener&lt;ContextRefreshedEvent&gt;https://www.shangmayuan.com/a/b9ea85ed208b46ac8c7c64b2.html待续…]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的hello world交叉编译实验]]></title>
    <url>%2Flinux%2Fcross_compilation.html</url>
    <content type="text"><![CDATA[交叉编译，简单地说，就是在一个平台上生成另一个平台上的可执行代码。下面就做一个简单的hello world实验来完成这一过程。¶0. 网络环境搭建本实验涉及两台主机。A主机：安装交叉编译环境，并用来编译源文件。在本次实验中使用的是虚拟机ubuntu系统环境B主机: arm架构平台开发板，用来运行A主机编译好的可执行文件，ip地址固定为192.168.1.230（1）首先使用直连线连接A主机对应的物理主机。（2）修改物理主机的ip地址(要求和B主机的网段一致)，子网掩码，网关(默认即可，不要配置)（3）修改虚拟机的网络连接方式为桥接（4）修改虚拟机的ip地址和子网掩码（5）重启虚拟机，以使网络配置可以1$ reboot重启完成后执行以下命令查看是否配置成功1$ ifconfig配置完成后虚拟机和开发板互ping，都ping通。¶1. 搭建交叉编译环境解压交叉编译gcc工具并放到共享目录里下载arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz1234#复制gcc到共享目录里qcmoke@qcmoke-virtual-machine:~/nfs/Linux$ cp arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz /home/qcmoke/nfs/#解压qcmoke@qcmoke-virtual-machine:~/nfs$ tar zxvf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz¶2. 编写hello.c测试文件1qcmoke@qcmoke-virtual-machine:~/nfs$ vim hello.c123456#include&lt;stdio.h&gt;int main()&#123; printf("Hello world!\n"); return 0;&#125;¶3. 编译hello.c1qcmoke@qcmoke-virtual-machine:~/nfs$ ./opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-gcc hello.c -o hello¶4. 登录arm主机1qcmoke@qcmoke-virtual-machine:~$ telnet 192.168.1.230¶5. 挂载共享目录需要在A主机搭建nfs服务器，以便快速共享编译好的可执行文件。具体搭建教程请参考ubuntu 16.04 nfs服务的搭建。在本次实验中搭建的nfs共享目录是A主机的/home/qcmoke/nfs/目录，而挂载点是B主机的/mnt/nfs/目录。通过在编译环境的主机执行以下命令查看共享目录地址123qcmoke@qcmoke-virtual-machine:~$ showmount -e localhostExport list for localhost:/home/qcmoke/nfs *根据查询结果挂载到arm主机某个目录,如/mnt/nfs12345#创建挂载点[root@FriendlyARM /]# mkdir /mnt/nfs#挂载[root@FriendlyARM /]# mount -o rw 192.168.1.232:/home/qcmoke/nfs/ /mnt/nfs/ -o nolock通过以下命令查看是否挂载成功1[root@FriendlyARM /]# df¶6. 在arm主机上运行hello可执行文件1[root@FriendlyARM /]# /mnt/nfs/hello运行成功，交叉编译完成！😄]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux搭建nfs服务]]></title>
    <url>%2Fdevops%2Fnfs.html</url>
    <content type="text"><![CDATA[NFS（Network File System）网络文件系统。它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。¶一、centos¶1. 服务端安装并配置¶1.1 安装1234#关闭防火墙$ service firewalld stop#安装nfs$ yum install nfs-utils nfs4-acl-tools net-tools -y¶1.2 配置123456789101112131415#创建共享目录，由于客户端挂载的用户是nfsnobody用户，如果要让客户端可读可写，需要这里是使用root用户建立的目录，所以要给其他用户 7 rwx 的权限$ mkdir -p /mnt/nfs &amp;&amp; chown -R root:root /mnt/nfs/ &amp;&amp; chmod 757 /mnt/nfs#配置NFS共享目录，共享本机/mnt/nfs目录给所有网络主机（共享给具体的网络主机的话，可以将*改成具体ip或者网段配置）##()里的配置参数可选，数量无关，位置无关，但是如果要配置名称一定要写对，多个参数用,分割$ cat &gt;&gt; /etc/exports &lt;&lt;EOF/mnt/nfs *(rw,no_root_squash,async)EOF#重新加载nfs服务配置（每次修改都要执行）$ exportfs -r #或者重启nfs服务systemctl restart nfs$ service nfs restart#显示共享详细情况$ exportfs -v #或者showmount -eexports文件配置介绍：1234567891011121314151617181920212223/home/nfs ：共享的目录* ：指定哪些用户可以访问 * 所有可以ping同该主机的用户 192.168.1.* 指定网段，在该网段中的用户可以挂载 192.168.1.12 只有该用户能挂载(rw,sync,no_root_squash)： 权限 选项说明 ro：共享目录只读； rw：共享目录可读可写； sync：同步，将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性； async：将数据先保存在内存缓冲区中，必要时才写入磁盘； all_squash：所有访问用户都映射为匿名用户或用户组； no_all_squash（默认）：访问用户先与本机用户匹配，匹配失败后再映射为匿名用户或用户组； root_squash（默认）：将来访的root用户映射为匿名用户或用户组； no_root_squash：来访的root用户保持root帐号权限； anonuid=&lt;UID&gt;：指定匿名访问用户的本地用户UID，默认为nfsnobody（65534）； anongid=&lt;GID&gt;：指定匿名访问用户的本地用户组GID，默认为nfsnobody（65534）； secure（默认）：限制客户端只能从小于1024的tcp/ip端口连接服务器； insecure：允许客户端从大于1024的tcp/ip端口连接服务器； wdelay（默认）：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率； no_wdelay：若有写操作则立即执行，应与sync配合使用； subtree_check（默认） ：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限； no_subtree_check ：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；exportfs命令工具：exportfs用于管理NFS文件系统的命令工具，可在不直接编辑/etc/exports文件的情况下方便的管理NFS。这命令还没研究透，后面有时间再好好补齐。-a 打开或者取消所有目录的共享-i &lt;文件&gt; 指定配置文件-r 更新配置,重新读取/etc/exports-u 卸载指定目录-o 使用指定参数-v 显示共享详细情况更多：exportfs命令维护NFS服务端当前导出表。其中导出主表存放在/var/lib/nfs/etab文件中(这个文件有最详细的配置，比如有的参数用户没有指定，那么nfs会自动生成对应的默认参数)。当客户端发送一个NFS MOUNT请求时，rpc.mountd进程会读取该文件。http://linux.51yip.com/search/exportfshttps://www.cnblogs.com/xzlive/p/9766388.html¶2. 客户端安装并挂载¶2.1 安装1234#关闭防火墙$ service firewalld stop#安装nfs$ yum install nfs-utils nfs4-acl-tools net-tools -y¶2.2 挂载12345678910111213141516171819202122232425#查看服务端的共享目录 showmount -e + nfs服务主机IP#比如服务端的IP为192.168.1.161$ showmount -e 192.168.1.161#创建挂载点（目录）$ mkdir /mnt/nfs/#将服务端的共享目录挂载到本地的创建挂载点（这样该目录实际存放的数据就只存储在服务端的磁盘里，而不会再客户端磁盘里）$ mount -o rw 192.168.1.161:/mnt/nfs /mnt/nfs/#测试挂载是否成功$ df文件系统 1K-块 已用 可用 已用% 挂载点devtmpfs 495636 0 495636 0% /devtmpfs 507412 0 507412 0% /dev/shmtmpfs 507412 6924 500488 2% /runtmpfs 507412 0 507412 0% /sys/fs/cgroup/dev/mapper/centos-root 3655680 2234020 1421660 62% //dev/sda1 1038336 138812 899524 14% /boottmpfs 101484 0 101484 0% /run/user/0192.168.1.161:/mnt/nfs 3655680 2157824 1497856 60% /mnt/nfs#在客户端测试创建文件，然后到服务端看共享的目录是否有客户端创建的文件即可$ touch /mnt/nfs/helloworld.txt$ ls -l /mnt/nfs/总用量 0-rw-r--r-- 1 root root 0 11月 28 23:34 helloworld.txt¶3. NFS权限服务端要共享目录，必定存在权限问题，该目录是否要公开，是否可读可写可执行，是否每个人都能看…等等这些都是重点考虑的事情。比如共享目录被设置成777，那么任意用户就都可读可写可执行。下面将设置为750权限，表示文件或目录所有者具有读、写和执行权限；所属组具有读和执行权限，但没有写权限；其他用户没有任何权限。¶3.1 服务端操作123456789101112131415#修改nfs配置文件（1、共享目录可读可写；2、将来访的root用户不保留root性质而是映射为nfsnobody匿名用户或用户组；3、将数据先保存在内存缓冲区中，必要时才写入磁盘）$ echo "/mnt/nfs *(rw,root_squash,async)" &gt; /etc/exports#重载nfs配置文件$ exportfs -r#创建tomcat用户组和用户 并指定gid和uid$ groupadd tomcat -g 501 &amp;&amp; useradd -m -g tomcat -u 501 tomcat &amp;&amp; passwd tomcat#给目录及其子目录所有文件tomcat权限$ chgrp -R tomcat /mnt/nfs/ &amp;&amp; chown -R tomcat:tomcat /mnt/nfs/#tomcat用户可读可写可执行，tomcat用户组可读可执行，其他用户无权限操作（注意：如果没有执行权限客户端无法cd进目录）$ chmod -R 750 /mnt/nfs/#切换到tomcat用户，然后创建一个测试文件$ su tomcat$ echo "tomcat server" &gt; /mnt/nfs/tomcat-server.txt说明：用户和组权限可使用 [user]:[group] 和 [user].[group] ，效果是一样。其中user和group可以是名称（如：tomcat），也可以是id（如：501）💁‍♂提示：1234#如果需要刪除用戶组，可执行如下命令$ groupdel tomcat#如果需要刪除用戶，可执行如下命令（刪除用戶及其主目录可执行userdel tomcat -r）$ userdel tomcat¶3.2 客户端操作123456789101112131415161718192021222324252627#客户端也要要创建同样的tomcat用户才能使用服务端中共享目录tomcat的所有权限$ groupadd tomcat -g 501$ useradd -m -g tomcat -u 501 tomcat &amp;&amp; passwd tomcat#此外为了测试还创建一个tomcat用户组的tomcat2用户，以及非tomcat用户组的test2用户$ useradd -m -g tomcat -u 502 tomcat2 &amp;&amp; passwd tomcat2$ groupadd test2 -g 5002 &amp;&amp; useradd -m -g test2 -u 5002 test2 &amp;&amp; passwd test2#然后进入/mnt/nfs/目录用不同用户测试$ su tomcat[tomcat@box-centos7x64-docker-1 mnt]$ cat /mnt/nfs/tomcat-server.txt tomcat server[tomcat@box-centos7x64-docker-1 mnt]$ echo "tomcat-client" &gt; /mnt/nfs/tomcat-client.txt[tomcat@box-centos7x64-docker-1 mnt]$$ su tomcat2[tomcat2@box-centos7x64-docker-1 mnt]$ cat /mnt/nfs/tomcat-server.txttomcat server[tomcat2@box-centos7x64-docker-1 mnt]$ echo "tomcat2-client" &gt; /mnt/nfs/tomcat2-client.txtbash: /mnt/nfs/tomcat2-client.txt: 权限不够[tomcat2@box-centos7x64-docker-1 mnt]$$ su test2[test2@box-centos7x64-docker-1 mnt]$ cat /mnt/nfs/tomcat-server.txtcat: /mnt/nfs/tomcat-server.txt: 权限不够[test2@box-centos7x64-docker-1 mnt]$ echo "test2-client" &gt; /mnt/nfs/test2-client.txtbash: /mnt/nfs/test2-client.txt: 权限不够[test2@box-centos7x64-docker-1 mnt]$💁‍♂提示：卸载掉挂载的目录12#根据挂载点卸载$ umount /mnt/nfs/💁‍♂ 拓展：如果共享目录有777权限且不保留客户端root用户性质权限的话，那么在客户端使用不存在于服务端的用户（比如test2）在共享目录中创建的文件或者目录时的，则改文件或目录的文件创建者将会被nfs设置为nfsnobody匿名用户。¶4. windows客户端挂载可直接使用windows10 自带的nfs客户端服务功能，打开控制面板&gt;&gt;程序&gt;&gt;程序和功能&gt;&gt;启动或关闭Windows功能1$ mount 192.168.1.161:/mnt/nfs k:卸载挂载12$ umount k: #卸载挂载点k盘#umount -f -a #会卸载全部挂载点（慎用，可能卸载掉其他非自己挂载的挂载点）¶5. 端口配置NFS 用到的服务有 portmapper nfs rquotad nlockmgr mountd 5个服务。通过命令 rpcinfo -p 可查看nfs使用的端口12345678910111213141516171819202122232425262728[root@0003 ~]# rpcinfo -p program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 100024 1 udp 15276 status 100024 1 tcp 59582 status 100005 1 udp 892 mountd 100005 1 tcp 892 mountd 100005 2 udp 892 mountd 100005 2 tcp 892 mountd 100005 3 udp 892 mountd 100005 3 tcp 892 mountd 100003 3 tcp 2049 nfs 100003 4 tcp 2049 nfs 100227 3 tcp 2049 nfs_acl 100003 3 udp 2049 nfs 100003 4 udp 2049 nfs 100227 3 udp 2049 nfs_acl 100021 1 udp 32769 nlockmgr 100021 3 udp 32769 nlockmgr 100021 4 udp 32769 nlockmgr 100021 1 tcp 32803 nlockmgr 100021 3 tcp 32803 nlockmgr 100021 4 tcp 32803 nlockmgr其中 portmapper nfs 服务端口是固定的分别是 111 2049另外 rquotad nlockmgr mountd 服务端口是随机的。由于端口是随机的，这导致防火墙无法设置。这时需要配置/etc/sysconfig/nfs使 rquotad nlockmgr（这个服务包含两个端口） mountd 的端口固定。123456$ vim /etc/sysconfig/nfs#找到以下几项，将前面的#号去掉。RQUOTAD_PORT=875LOCKD_TCPPORT=32803LOCKD_UDPPORT=32769MOUNTD_PORT=892重启nfs即可生效1$ service nfs restart最后将5个服务固定的6个端口配置到防火墙即可，端口包括：111、875、892、2049、32769、3280312345678910111213141516$ firewall-cmd --permanent --add-port=111/tcp$ firewall-cmd --permanent --add-port=875/tcp$ firewall-cmd --permanent --add-port=2049/tcp$ firewall-cmd --permanent --add-port=32769/tcp$ firewall-cmd --permanent --add-port=32803/tcp$ firewall-cmd --permanent --add-port=892/tcp$ firewall-cmd --permanent --add-port=111/udp$ firewall-cmd --permanent --add-port=875/udp$ firewall-cmd --permanent --add-port=2049/udp$ firewall-cmd --permanent --add-port=32769/udp$ firewall-cmd --permanent --add-port=32803/udp$ firewall-cmd --permanent --add-port=892/udp#重新加载配置$ firewall-cmd --reload参考：http://www.blogjava.net/envoydada/archive/2012/03/14/371875.htmlhttps://www.cnblogs.com/cheyunhua/p/12033457.htmlhttps://blog.csdn.net/qq43748322/article/details/98484637¶二、ubuntu123456789#1. 安装$ sudo apt-get install nfs-common nfs-kernel-server#2. 修改配置文件$ sudo vim /etc/exports/home/nfs *(rw,sync,no_root_squash)#3. 加载配置文件$ sudo exportfs -a#4. 重启nfs服务$ sudo /etc/init.d/nfs-kernel-server restart]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven学习笔记]]></title>
    <url>%2Fjavaee%2Fmaven.html</url>
    <content type="text"><![CDATA[¶一、安装和配置1.安装前提条件：已经安装好适配maven具体版本的jdk环境，本教程使用的是jdk8（Maven 3.3+ require JDK 1.7 or above）下载Apache Maven,访问 Maven官方网站;下载 Maven 的 zip 文件，例如： apache-maven-3.6.0-bin.zip，将它解压到你要安装 Maven 的文件夹。比如：D:\DevelopmentTools\apache-maven-3.6.02.配置添加环境变量12MAVEN_HOME:D:\DevelopmentTools\apache-maven-3.6.0PATH:%MAVEN_HOME%\bin3.安装验证1mvn –version4.优化配置编辑maven\conf\settings.xml ,如： D:\DevelopmentTools\apache-maven-3.6.0\conf\settings.xml。只做一下修改，其他地方不要动1234567891011121314151617181920212223242526272829 &lt;!-- 1.设置本地仓库 &lt;localRepository&gt;D:/maven/r2/myrepository&lt;/localRepository&gt; --&gt; &lt;mirrors&gt;&lt;!-- 2.修改为阿里云镜像地址 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;!-- 3.配置jdk环境,不代表安装的jdk版本 --&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; &lt;/profiles&gt;¶二、创建简单maven项目创建一个目录设为mavendemo，在里面添加一下内容，除了pom.xml，都是文件夹。必须要这样创建项目，maven才能识别。123456789.├── pom.xml└── src ├── main │ ├── java │ └── resources └── test ├── java └── resources创建两个java文件。src/main/java/com/qcmoke/Helloworld.java和src/test/java/com/qcmoke/HelloTest.java123456789101112131415.├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── qcmoke │ │ └── Helloworld.java └── resources └── test ├── java │ └── com │ └── qcmoke │ └── HelloTest.java └── resourcesHelloworld.java12345678package com.qcmoke;public class Helloworld &#123; public String sayHello(String val) &#123; System.out.println("hello "+val); return "hello "+val; &#125;&#125;HelloTest.java123456789101112131415package com.qcmoke;import org.junit.Test;import junit.framework.Assert;import com.qcmoke.Helloworld;public class HelloTest &#123; @Test public void testSayHello() &#123; Helloworld h = new Helloworld(); String result = h.sayHello("jack"); Assert.assertEquals("hello jack", result); &#125;&#125;pom.xml1234567891011121314151617181920212223242526&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;mavendemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mavendemo&lt;/name&gt; &lt;!--指定maven项目名称，不指定那么默认使用工程名称作为maven项目名称--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;12mvn compile #编译源代码mvn test #运行测试，包括编译源码mvn常用命令：123456mvn compile #编译源代码mvn test-compile #编译测试代码mvn test #运行测试，包括编译源码mvn clean #清除产生的项目mvn package #打包，根据pom.xml打成war或jar。如果pom.xml中设置 war，则此命令相当于mvn war:war；如果pom.xml中设置 jar，则此命令相当于mvn jar:jarmvn install #在本地Repository中安装jar（需要先打包）¶三、Eclipse创建maven项目给Eclipse配置maven找到Window--&gt;Preferences--&gt;Maven--&gt;Installations--&gt;add--&gt;External--&gt;Directory，将D:\DevelopmentTools\apache-maven-3.6.0添加到Eclipse中,然后Apply and Close找到Window--&gt;Preferences--&gt;Maven--&gt;User Setting，将Global Settings和User Settings的路径都修改为D:\DevelopmentTools\apache-maven-3.6.0\conf\settings.xml创建项目New--&gt;Other--&gt;Mavven Project选中Create project sinple name and location，然后Next，填写下图内容后Finish即可创建完成。创建包名和java文件Helloworld.java12345678package com.qcmoke;public class Helloworld &#123; public String sayHello(String val) &#123; System.out.println("hello "+val); return "hello "+val; &#125;&#125;HelloTest.java123456789101112131415package com.qcmoke;import org.junit.Test;import junit.framework.Assert;import com.qcmoke.Helloworld;public class HelloTest &#123; @Test public void testSayHello() &#123; Helloworld h = new Helloworld(); String result = h.sayHello("jack"); Assert.assertEquals("hello jack", result); &#125;&#125;pom.xml12345678910111213141516171819202122232425262728&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;mavendemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mavendemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;右键项目Run As 选择Maven Build…后，在Goals中输入compile后点击Run开始编译创建web工程创建项目New--&gt;Other--&gt;Mavven Project选中Create project sinple name and location，然后Next，填写下图内容后Finish即可创建完成。注意打包方式要选择war生成webapp相关文件。右键项目，选择properties&gt;Project Facets,先取消Dynamic Web Module勾选后点击Apply，然后再勾选，会多出来Further configuration available...的链接，点击这个链接，会看到下图的弹框。在Content directory输入框里的内容改为src/main/webapp修改好后，点击Ok，在点击Apply and Close即可创建webapp相关文件pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qcmoke&lt;/groupId&gt; &lt;artifactId&gt;mavenweb&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;!-- 编译字符集 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/properties&gt; &lt;!-- 依赖管理配置 --&gt; &lt;dependencies&gt; &lt;!-- Servlet API --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 优化el表达式提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1.3-b06&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 默认值为compile --&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;¶四、依赖范围compile范围:对主程序有效对测试程序有效参与打包参与部署test范围：对主程序无效对测试程序有效不参与打包参与部署provided范围：对主程序有效对测试程序有效不参与打包不参与部署]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn学习笔记]]></title>
    <url>%2Ftools%2Fsvn.html</url>
    <content type="text"><![CDATA[¶一、简要说明¶二、服务端搭建¶1. 安装1234#yum安装SVNyum install -y subversion#apt安装SVNapt install -y subversion各系统版本安装包下载：https://subversion.apache.org/packages.htmlwindows 系统可推荐安装 VisualSVN （如： Apache-Subversion-1.14.2.zip 或者 VisualSVN-Server-5.1.4-x64.msi）¶2. 创建版本仓库并启动svn服务器1234#创建版本库目录svnadmin create &lt;path仓库目录&gt;#启动svn服务器svnserve -d -r &lt;path仓库目录&gt;示例：12345678910111213#（1）Linux系统搭建svn服务器svnadmin create /opt/mysvnsvnserve -d -r /opt/mysvn#防火墙开放svn的监听端口（默认为3690）firewall-cmd --permanent --add-port=3690/tcpfirewall-cmd --reload#（2）Windows系统搭建svn服务器#建版本库svnadmin create D:\DevelopmentTools\SVN\mysvn#修改 conf/svnserve.conf 配置文件，修改：anon-access = write#启动服务svnserve -d -r D:\DevelopmentTools\SVN\mysvn注意：启动的路径决定访问地址的路径，如下：如果启动的路径为/opt，那么访问地址为：svn://ip/mysvn如果启动的路径为/opt/mysvn 那么访问地址为：svn://ip¶3. 配置版本仓库访问权限（1）授权访问配置12#修改指定版本库的服务配置文件vim /opt/mysvn/conf/svnserve.conf修改如下相关内容：1234anon-access = none #匿名访问权限， read表示只读，write表示读写，none表示无权访问auth-access = write #开启授权可读写入password-db = passwd #表示授权的用户名和密码放在passwd文件里authz-db = authz #设置权限文件（2）配置svn用户用户名和密码12#编辑用户密码文件vim /opt/mysvn/conf/passwd修改如下相关内容：123[users]zhangsan = 123456lisi = 123456（3）配置权限文件（设置svn用户和用户组的具体访问权限）12#编辑权限文件vim /opt/mysvn/conf/authz修改如下相关内容：12345678910111213[aliases]#配置用户组[groups]dev = zhangsan,lisi#配置用户组或用户对某个目录的执行权限[/]#用户组具有读写操作@dev = rw#配置其他用户没有任何权限* =¶三、客户端使用¶通过命令行使用SVN1234567891011121314151617#yum安装SVNyum install -y subversion#apt安装SVNapt install -y subversion#将服务端检出（下载）到本地的指定目录svn checkout --username zhangsan --password 123456 svn://192.168.60.156 /tmp/mysvn#进入本地检出的目录cd /tmp/mysvn#创建一个测试文件echo "hello" &gt; test.txt#添加文件至版本控制svn add test.txt#提交本地版本到服务端svn commit -m "first commit" test.txt#同步服务端版本到本地svn update各系统版本安装包下载：https://subversion.apache.org/packages.htmlwindows 系统可推荐安装 VisualSVN （如： Apache-Subversion-1.14.2.zip 或者 VisualSVN-Server-5.1.4-x64.msi）¶通过TortoiseSVN使用SVNTortoiseSVN 下载地址：https://tortoisesvn.net/downloads.html如：TortoiseSVN-1.14.5.29465-x64-svn-1.14.2.msiTortoiseSVN 安装好后，使用操作如下：¶通过Eclipse使用SVN¶（1）eclipse安装svn插件下载subclipse的site-1.10.13-1.9.x版本，并将site-1.10.13-1.9.x.zip将解压后放到***/eclipse/dropins里,并重启eclipse¶（2）提交首先创建好一个项目添加svn服务仓库地址如果是svn服务器设置允许匿名访问，那么就能成功。如果不能访问，可输入配置文件中的用户名和密码后即可完成提交。登录提交的方式可以方便看到提交文件的具体用户提交到svn服务器添加提交信息¶（3）SVN资源库研究目的：查看svn服务器的版本仓库情况以及历史版本¶（4）检出目的：从svn服务器导入（下载）项目添加svn服务仓库地址如果是svn服务器设置允许匿名访问，那么就能成功。如果不能访问，可输入配置文件中的用户名和密码后即可完成检出。点击finish¶（5）解决冲突设有两个人打开了不同的eclipse，分别对同一个版本的项目的DEMO.java进行修改（张三）第一个人：原版本（版本为6）1234567package demo;public class DEMO &#123; public static void main(String[] args) &#123; System.out.println("hello world!"); &#125;&#125;修改：12345678package demo;public class DEMO &#123; public static void main(String[] args) &#123; System.out.println("hello world!"); System.out.println("I am zhangsan"); &#125;&#125;修改好后提交（版本变为7）（李四）第二个人：原版本（版本为6）1234567package demo;public class DEMO &#123; public static void main(String[] args) &#123; System.out.println("hello world!"); &#125;&#125;修改：12345678package demo;public class DEMO &#123; public static void main(String[] args) &#123; System.out.println("hello world!"); System.out.println("I am lisi"); &#125;&#125;修改好后提交提交后发现失败，这就是所谓的提交冲突原因：原因是服务端仓库的版本比李四当前的版本新，李四的当前版本已经过时了。如何解决？需要跟新李四的冲突文件。编辑冲突：修改好后ctrl + s 保存标记已解决冲突我们发现多出来的文件不见了，并且版本也与服务端版本一致了，也就是说可以正常提交了。李四提交完成后打开SVN资源库研究即可发现服务端仓库的版本变成了更新的版本（原本服务端版本为7，现在变成了8）¶（6）恢复到历史某个版本右键某个版本，然后选择获取内容当前本地就会恢复到选择的版本恢复后再提交的话，服务端的仓库也会&quot;恢复到历史版本&quot;,这里打双引号的原因是服务端仓库只是恢复代码，但实际版本是再更新到了更加新的版本¶（7）提交忽略文件设置选择Team–&gt; Git下面的Ignoreed Resources –&gt;Add Pattern –&gt;一个一个的添加输入要忽略的文件.classpath.settings.projecttarget最后点击Apply– &gt;OK¶（8）避免冲突开发之前先更新，完成工作之后立即提交团队合作时不同人之间应该自己修改自己的文件，尽少编辑公共文件]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java高级框架学习笔记]]></title>
    <url>%2Fjavaee%2Fframeworks.html</url>
    <content type="text"><![CDATA[¶一、Spring¶1. 概念Spring 框架运行时1 test: spring 提供测试功能2 Core Container:核心容器.Spring 启动最基本的条件.2.1 Beans : Spring 负责创建类对象并管理对象2.2 Core: 核心类2.3 Context: 上下文参数.获取外部资源或这管理注解等2.4 SpEl: expression.jar3 AOP: 实现 aop 功能需要依赖4 Aspects: 切面 AOP 依赖的包5 Data Access/Integration : spring 封装数据访问层相关内容5.1 JDBC : Spring 对 JDBC 封装后的代码.5.2 ORM: 封装了持久层框架的代码.例如 Hibernate5.3 transactions:对应 spring-tx.jar,声明式事务使1.什么是Spring：Spring是一个基于IOC和AOP的结构J2EE系统的框架 。2.容器(Container): Spring可以理解成一个管理类对象的大容器.3 ApplicationContext 接口,是 BeanFactory 子接口.BeanFactory 的功能在 ApplicationContext 中都有.（BeanFactory 是老版本Spring的主要信息获得接口.）4.从 Spring3 开始把 Spring 框架的功能拆分成多个 jar. Spring2 及以前就一个 jar核心功能IoC/DI 控制反转(IoC)/依赖注入(DI) ——解耦AOP 面向切面编程 ——扩展声明式事务¶2. IoC/DI¶2.1 IoC控制反转不用通过new 实例化对象,而是将创建对象的控制权反转给Spring来处理。最大的作用: 解耦。IoC创建对象的三种方式（1）通过构造方法创建两种构造方法创建方式无参构造创建:默认情况有参构造创建:需要明确配置使用步骤：①需要在类中提供有参构造方法②在 applicationContext.xml中设置调用哪个构造方法创建对象，可以通过&lt;constructor-arg&gt;指定构造方法配置参数：index : 参数的索引,从 0 开始name: 参数名type:类型(区分开关键字和封装类，如： int 和 Integer)如果设定的条件匹配多个构造方法执行最后的构造方法（2）通过实例工厂创建需要先创建工厂,才能生产对象。使用步骤：①编写实例工厂②在applicationContext.xml中配置12&lt;bean id="factory" class="com.qcmoke.pojo.PeopleFactory"&gt;&lt;/bean&gt;&lt;bean id="peofactory" factory-bean="factory" factory-method="newInstance"&gt;&lt;/bean&gt;（3） 通过静态工厂创建不需要创建工厂,快速创建对象使用步骤：（1）编写一个静态工厂(在方法上添加 static)（2）在applicationContext.xml 中配置1&lt;bean id="peostatic" class="com.qcmoke.pojo.PeopleStaticFactory" factory-method="newInstance"&gt;&lt;/bean&gt;¶2.2 DI依赖注入可以为Bean注入普通数据类型属性值，还可以注入其他Bean的引用。¶2.3 案例①导包:四个核心包一个日志包(commons-logging)commons-logging-1.1.3.jarspring-beans-4.1.6.RELEASE.jarspring-context-4.1.6.RELEASE.jarspring-core-4.1.6.RELEASE.jarspring-expression-4.1.6.RELEASE.jar②在 src 下新建 applicationContext.xml (文件名称和路径自定义)12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="peo" class="com.qcmoke.pojo.People"/&gt; &lt;!-- 通过&lt;bean/&gt; 创建对象. id 表示获取到对象标识 class 需要创建实例的全限定类名 --&gt;&lt;/beans&gt;默认配置文件被加载时创建对象.③通过ApplicationContext容器调用applicationContext.xml 里配置的信息通过调用getBean(“bean标签 id 值”,返回值类型)来获取对象;如果没有第二个参数,默认是 Object12ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");People people = ac.getBean("peo",People.class);¶2. AOP¶2.1 概念AOP(Aspect Oriented Programming 面向切面编程)。 在程序原有纵向执行流程中,针对某一个或某一些方法添加通知,形成横切面的过程就叫做面向切面编程。传统程序执行流程都是纵向执行流程，在原有纵向执行流程中添加横切面，不需要修改原有纵向程序代码就能实现原程序的扩展。原有功能: 切点, pointcut前置通知: 在切点之前执行的功能. before advice后置通知: 在切点之后执行的功能,after advice如果切点执行过程中出现异常,会触发异常通知.throws advice所有功能总称叫做切面.织入: 把切面嵌入到原有功能的过程叫做织入特点：1.高扩展性 2.释放了部分逻辑.让职责更加明确¶2.3 实现方式有两种实现AOP的方式Schema-baedAspectJ依赖：aopalliance.jar aspectjweaver.jarcommons-logging-1.1.3.jarspring-aop-4.1.6.RELEASE.jarspring-aspects-4.1.6.RELEASE.jarspring-beans-4.1.6.RELEASE.jarspring-context-4.1.6.RELEASE.jarspring-core-4.1.6.RELEASE.jarspring-expression-4.1.6.RELEASE.jarspring-tx-4.1.6.RELEASE.jar¶2.3.1 Schema-based（1）配置applicationContext.xml导入xml约束（命名空间）：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;/beans&gt;（2）编写切点类Demo.java123456789101112131415161718192021222324252627package com.qcmoke.test;/** * 切点类 * * @author qcmoke * */public class Demo &#123; public void demo1() &#123; System.out.println("demo1"); &#125; public void demo2() &#123; //原有功能（切点） System.out.println("demo2"); &#125; public void demo3() &#123; System.out.println("demo3"); &#125; public void function(Demo demo) &#123; demo.demo1(); demo.demo2(); demo.demo3(); &#125;&#125;（3）编写通知类MyBeforeAdvice.java1234567891011121314151617181920212223package com.qcmoke.advice;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;/** * 前置通知类(需要实现 MethodBeforeAdvice接口) * * @author qcmoke */public class MyBeforeAdvice implements MethodBeforeAdvice &#123; /* 前置通知 * 第0个参数：切点方法对象 * 第1个参数：切点方法参数 * 第2个参数：切点方法所在的对象 * */ @Override public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable &#123; System.out.println("\n执行前置通知"); &#125;&#125;MyAfterAdvice.java123456789101112131415161718192021222324package com.qcmoke.advice;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;/** * 后置通知类(需要实现AfterReturningAdvice接口) * * @author qcmoke * */public class MyAfterAdvice implements AfterReturningAdvice &#123; /* 后置通知 * 第0个参数：切点方法返回值 * 第1个参数：切点方法对象 * 第2个参数：切点方法参数 * 第3个参数：切点方法所在的对象 * */ @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable &#123; System.out.println("执行后置通知\n"); &#125;&#125;（4） 在applicationContext.xml配置文件里配置&lt;aop:config&gt;配置12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置 Demo 类,测试使用 --&gt; &lt;bean id="demo" class="com.qcmoke.test.Demo"&gt;&lt;/bean&gt; &lt;!-- 配置通知类对象,在切面中引入 --&gt; &lt;bean id="mybefore" class="com.qcmoke.advice.MyBeforeAdvice"&gt;&lt;/bean&gt; &lt;bean id="myafter" class="com.qcmoke.advice.MyAfterAdvice"&gt;&lt;/bean&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression="execution(* com.qcmoke.test.Demo.demo2())" id="mypoint" /&gt;&lt;!-- 注意星号后要有空格 --&gt; &lt;!-- 通知 --&gt; &lt;aop:advisor advice-ref="mybefore" pointcut-ref="mypoint" /&gt; &lt;aop:advisor advice-ref="myafter" pointcut-ref="mypoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt;（5）编写测试类AopTest.java12345678910111213141516171819202122232425262728package com.qcmoke.test;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 要求：在不改动AopDemo类的情况下,在Demo#function()里添加其他功能。 * 比如：AopDemo#demo2()方法前后输出“\n执行前置通知”和“执行后置通知\n” * * @author qcmoke * */public class AopTest &#123; @SuppressWarnings("resource") @Test public void testUseAop() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Demo demo = ac.getBean("demo", Demo.class); demo.function(demo); &#125; @Test public void testNoAop() &#123; Demo demo = new Demo(); demo.function(demo); &#125;&#125;¶2.3.2 AspectJ（1）配置applicationContext.xml需要将xml约束加入到applicationContext.xml文件开头。12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;/beans&gt;（2）编写切点类PointObject.java1234567package com.qcmoke.test;public class PointObject &#123; public void function()&#123;// 原有功能（切点） System.out.println("执行原有功能（切点）"); &#125;&#125;（3）编写通知类MyAspectJAdvice.java1234567891011package com.qcmoke.advice;public class MyAspectJAdvice &#123; public void beforefunction() &#123; System.out.println("执行前置通知"); &#125; public void afterfunction() &#123; System.out.println("执行后置通知"); &#125;&#125;（4） 在applicationContext.xml配置文件里配置&lt;aop:config&gt;配置123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置切点类 --&gt; &lt;bean id="pointObject" class="com.qcmoke.test.PointObject"&gt;&lt;/bean&gt; &lt;!-- 配置通知类 --&gt; &lt;bean id="aspectJAdvice" class="com.qcmoke.advice.MyAspectJAdvice"&gt;&lt;/bean&gt; &lt;!-- 配置通知关联切点 --&gt; &lt;aop:config&gt; &lt;aop:aspect ref="aspectJAdvice"&gt; &lt;aop:pointcut expression="execution(* com.qcmoke.test.PointObject.function())" id="mypoint"/&gt; &lt;!-- 配置切点方法 --&gt; &lt;aop:before method="beforefunction" pointcut-ref="mypoint"/&gt;&lt;!-- 配置前置通知 --&gt; &lt;aop:after method="afterfunction" pointcut-ref="mypoint"/&gt;&lt;!-- 配置后置通知 --&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt;（5）编写测试类AopTest.java12345678910111213package com.qcmoke.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AopTest &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); PointObject demo = ac.getBean("pointObject", PointObject.class); demo.function(); &#125;&#125;¶2.4 注解方式使用AOP通过注解实现AOP的方式其实是基于AspectJ的方式。实现步骤：（1）导包:aopalliance.jaraspectjweaver.jarcommons-logging-1.1.3.jarspring-aop-4.1.6.RELEASE.jarspring-aspects-4.1.6.RELEASE.jarspring-beans-4.1.6.RELEASE.jarspring-context-4.1.6.RELEASE.jarspring-core-4.1.6.RELEASE.jarspring-expression-4.1.6.RELEASE.jarspring-tx-4.1.6.RELEASE.jar（2）配置applicationContext.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;/beans&gt;（3）编写切点类假设如下：PointObject.java12345678910111213141516171819202122package com.qcmoke.test;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 1. 需要通过@Component声明需要被扫描的类组件,相当于&lt;bean/&gt; * 如果没有参数: @Component 那么扫描后形成的Spring管理对象名称默认是首字母小写的类名 * 如果有参数: @Component("自定义的名称"),相当于&lt;bean id="自定义的名称"/&gt; * * 2. 需要通过@Pointcut("execution(* 切点名称)")指定切点方法,并给切点指定名称，一般就是方法的全限定路径 * @author qcmoke * */@Componentpublic class PointObject &#123; @Pointcut("execution(* com.qcmoke.test.PointObject.function())") public void function()&#123;// 原有功能（切点） System.out.println("执行原有功能（切点）"); &#125;&#125;（4）编写通知类MyAdvice.java12345678910111213141516171819202122232425262728package com.qcmoke.advice;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * 1. 需要通过@Component声明需要被扫描的类组件,相当于&lt;bean/&gt; * 如果没有参数: @Component 那么扫描后形成的Spring管理对象名称默认是首字母小写的类名 * 如果有参数: @Component("自定义的名称"),相当于&lt;bean id="自定义的名称"/&gt; * 2. 需要通过@Aspect。相当于&lt;aop:aspect/&gt;,表示通知方法在当前类中 * 3. 通过@Before("切点名称");@AfterReturning("切点名称").....等指定通知方法 * @author qcmoke * */@Component@Aspectpublic class MyAdvice &#123; @Before("com.qcmoke.test.PointObject.function()") public void beforefunction() &#123; System.out.println("执行前置通知"); &#125; @AfterReturning("com.qcmoke.test.PointObject.function()") public void afterfunction() &#123; System.out.println("执行后置通知"); &#125;&#125;（5） 配置applicationContext.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 扫描含有注解的包,将包路径放到base-package属性值里，如果需要扫描多个包，包路径之间可以通过逗号分隔 --&gt; &lt;context:component-scan base-package="com.qcmoke.advice,com.qcmoke.test"&gt;&lt;/context:component-scan&gt; &lt;!--注解都是使用cglib动态代理方式。 proxy-target-class的值为true表示cglib动态代理；为false表示jdk动态代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;（6）编写测试类AopTest.java123456789101112131415161718192021222324package com.qcmoke.test;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AopTest &#123; @Test public void viewAllNames() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); String[] names = ac.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; &#125; @Test public void testForAdvice() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); PointObject pointObject = (PointObject) ac.getBean("pointObject"); pointObject.function(); &#125;&#125;¶3. 声明式事务编程式事务和声明式事务的区别：¶3.1 概念编程式事务是由程序员编程事务控制代码，而声明式事务得事务控制代码已经由 spring 写好，程序员只需要简单声明出哪些方法需要进行事务控制和如何进行事务控制即可。声明式事务针对的都是 ServiceImpl 类下需要事务处理的方法.事务管理器基于通知(advice)的（即AOP）.¶3.2 实现步骤¶3.3 声明式事务中属性解释**name=”” *哪些方法需要有事务控制1.1 支持通配符**readonly=”boolean” **是否是只读事务.2.1 如果为 true,告诉数据库此事务为只读事务.数据化优化,会对性能有一定提升,所以只要是查询的方法,建议使用此数据.2.2 如果为 false(默认值),事务需要提交的事务.建议新增,删除,修改.propagation 控制事务传播行为.（针对多个增删改互相调用的情况）3.1 当一个具有事务控制的方法被另一个有事务控制的方法调用后,需要如何管理事务(新建事务?在事务中执行?把事务挂起?报异常?)3.2 REQUIRED (默认值): 如果当前有事务,就在事务中执行,如果当前没有事务,新建一个事务.3.3 SUPPORTS:如果当前有事务就在事务中执行,如果当前没有事务,就在非事务状态下执行.3.4 MANDATORY:必须在事务内部执行,如果当前有事务,就在事务中执行,如果没有事务,报错.3.5 REQUIRES_NEW:必须在事务中执行,如果当前没有事务,新建事务,如果当前有事务,把当前事务挂起.3.6 NOT_SUPPORTED:必须在非事务下执行,如果当前没有事务,正常执行,如果当前有事务,把当前事务挂起.3.7 NEVER:必须在非事务状态下执行,如果当前没有事务,正常执行,如果当前有事务,报错.3.8 NESTED:必须在事务状态下执行.如果没有事务,新建事务,如果当前有事务,创建一个嵌套事务.isolation=”” 事务隔离级别4.1 在多线程或并发访问下如何保证访问到的数据具有完整性的.4.2 脏读:4.2.1 一个事务(A)读取到另一个事务(B)中未提交的数据,另一个事务中数据可能进行了改变,此时A事务读取的数据可能和数据库中数据是不一致的,此时认为数据是脏数据,读取脏数据过程叫做脏读.4.3 不可重复读:4.3.1 主要针对的是某行数据.(或行中某列)4.3.2 主要针对的操作是修改操作.4.3.3 两次读取在同一个事务内4.3.4 当事务A第一次读取事务后,事务B对事务A读取的淑君进行修改,事务 A 中再次读取的数据和之前读取的数据不一致,过程不可重复读.4.4 幻读:4.4.1 主要针对的操作是新增或删除4.4.2 两次事务的结果.4.4.3 事务A按照特定条件查询出结果,事务B新增了一条符合条件的数据.事务 A 中查询的数据和数据库中的数据不一致的,事务 A 好像出现了幻觉,这种情况称为幻读.4.5 DEFAULT: 默认值,由底层数据库自动判断应该使用什么隔离界别4.6 **READ_UNCOMMITTED: **可以读取未提交数据,可能出现脏读,不重复读,幻读.4.6.1 效率最高.4.7 **READ_COMMITTED:**只能读取其他事务已提交数据.可以防止脏读,可能出现不可重复读和幻读.4.8 **REPEATABLE_READ: **读取的数据被添加锁,防止其他事务修改此数据,可以防止不可重复读.脏读,可能出现幻读.4.9 **SERIALIZABLE: **排队操作,对整个表添加锁.一个事务在操作数据时,另一个事务等待事务操作完成后才能操作这个表.4.9.1 最安全的4.9.2 效率最低的.rollback-for=”异常类型全限定路径”5.1 当出现什么异常时需要进行回滚5.2 建议:给定该属性值.5.2.1 手动抛异常一定要给该属性值.no-rollback-for=””6.1 当出现什么异常时不滚回事务.¶4. 常用注解总结注意：使用注解一定要添加扫描的类所在的包路径并且尽量开启cglib动态代理，（在使用AOP时，cglib兼容service接口接收代理对象，也兼容以service实现类接收代理对象；而jdk动态代理只兼容service接口接收代理对象）使用注解后default-autowire全局自动注入配置就不生效了。123456&lt;!-- 扫描含有注解的包,将包路径放到base-package属性值里，如果需要扫描多个包，包路径之间可以通过逗号分隔 --&gt;&lt;context:component-scan base-package="com.qcmoke.advice,com.qcmoke.test"&gt;&lt;/context:component-scan&gt; &lt;!--注解都是使用cglib动态代理方式。 proxy-target-class的值为true表示cglib动态代理；为false表示jdk动态代理 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;@Component 创建类对象,相当于配置&lt;bean/&gt;@Service 与@Component 功能相同.2.1 @Service一般写在 ServiceImpl类上.@Repository与@Component 功能相同.3.1 @Repository一般写在数据访问层类上.@Controller 与@Component 功能相同.4.1 @Controller一般写在控制器类上.@Resource(不需要写对象的 get/set)5.1 java 中jdk自带的注解5.2 默认按照 byName 注入,如果没有名称对象,按照 byType注入5.2.1 建议把对象名称和 spring 容器中对象名相同@Autowired(不需要写对象的 get/set)6.1 spring 自带的注解6.2 默认按照 byType 注入.@Value() 获取 properties 文件中内容@Pointcut()定义切点@Aspect() 定义切面类@Before()前置通知@After 后置通知@AfterReturning 后置通知,必须切点正确执行@AfterThrowing 异常通知@Arround 环绕通知¶二、SpringmvcMVC的概念：M指的是module（模型）V指的是view（视图）C指的是controller（控制器）传统的MVC开发模式中：​ M包括service，dao，pojo，bean等​ V包括jsp，html等​ C包括servlet而springmvc，不同的是springmvc是不包括传统mvc开发模型的service和dao的。而是对控制层进行mvc化封装。¶1. 重要核心组件DispatcherServlet 前端控制器(分发器、请求入口，负责分发请求，接收所有请求，如果配置/不包含 jsp)HandlerMapping 处理器映射器（解析url请求，负责请求和控制器建立一一对应的关系以此来查找Controller）HandlAdapter：处理器适配器（ 负责调用具体的法（Handler）.）Controller（Handler）后端控制器（后端处理器）ViewResolver 视图解析器（定位和跳转页面，解析不同的文件¶2 环境搭建¶2.1 纯配置文件配置（1）导包commons-logging-1.1.3.jarspring-aop-4.1.6.RELEASE.jarspring-aspects-4.1.6.RELEASE.jarspring-beans-4.1.6.RELEASE.jarspring-context-4.1.6.RELEASE.jarspring-core-4.1.6.RELEASE.jarspring-expression-4.1.6.RELEASE.jarspring-jdbc-4.1.6.RELEASE.jarspring-tx-4.1.6.RELEASE.jarspring-web-4.1.6.RELEASE.jarspring-webmvc-4.1.6.RELEASE.jar（2） 配置前端控制器 (在web.xml中)123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;!-- 由于spring不能控制servlet容器，故不能控制传统的servlet。 解决方式： 只需要在web.xml中配置前端控制器DispatcherServle生效 ,然后在DispatcherServle中获取所有前端发送的请求， 再将请求进行解析分配给对应的后端控制器，这些后端控制器由于不是直接受到servlet容器的控制，所以这些spring容器能够管理这些后端容器。 --&gt; &lt;servlet-name&gt;springmvc123&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springmvc文件路径和名称，让spring来管理后端控制器 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!-- 让前端控制器自启动 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc123&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;（3）创建后端控制器DemoController.java12345678910111213141516171819202122package com.qcmoke.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class DemoController implements Controller &#123; /** * http://localhost:8080/springmvc01_纯配置文件环境搭建/demo */ @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println("执行了springmvc的控制器"); //执行跳转，默认是转发到main.jsp ModelAndView mav = new ModelAndView("main"); return mav; &#125;&#125;（4）在src下配置springmvc.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 后端控制器 --&gt; &lt;bean id="demoController" class="com.qcmoke.controller.DemoController"&gt;&lt;/bean&gt; &lt;!-- 处理器映射器（解析请求) --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="urlMap"&gt; &lt;!-- key:控制器逻辑名，相当于servlet类的@WebServlet("/key") value-ref:控制器对象,相当于servlet对象 --&gt; &lt;map&gt; &lt;entry key="demo" value-ref="demoController"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 处理器适配器（ 负责调用具体的方法.），需要创建Controller（Handler）后端控制器来让处理器适配器来执行 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 视图解析器（定位和跳转页面） --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;¶2.2 注解搭建环境（1）导包commons-logging-1.1.3.jarspring-aop-4.1.6.RELEASE.jarspring-aspects-4.1.6.RELEASE.jarspring-beans-4.1.6.RELEASE.jarspring-context-4.1.6.RELEASE.jarspring-core-4.1.6.RELEASE.jarspring-expression-4.1.6.RELEASE.jarspring-jdbc-4.1.6.RELEASE.jarspring-tx-4.1.6.RELEASE.jarspring-web-4.1.6.RELEASE.jarspring-webmvc-4.1.6.RELEASE.jar（2）配置前端控制器 (在web.xml中)12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;myspringmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;myspringmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;（3）创建后端控制器DemoController.java1234567891011121314151617181920212223package com.qcmoke.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DemoController &#123; /* 返回值表示跳转到的页面 */ @RequestMapping("demo") public String demo() &#123; System.out.println("执行了demo"); return "/main.jsp"; &#125; @RequestMapping("demo2") public String demo2() &#123; System.out.println("执行了demo2"); return "/main.jsp"; &#125;&#125;（4）在src下配置springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 1. 配置spring-mvc xml约束 2. 注解扫描包名 3. 配置注解驱动 --&gt; &lt;!-- 注解扫描包名 扫描后对象放置到springmvc容器中。 注意：springmvc是spring容器的子容器 --&gt; &lt;context:component-scan base-package="com.qcmoke.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 配置注解驱动相当于配置以下： 1.HandlAdapter 2.HandlerMapping --&gt; &lt;!-- 放行静态资源，防止把静态文件当作控制器来处理 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location="/css/" mapping="/css/**"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location="/images/" mapping="/images/**"&gt;&lt;/mvc:resources&gt;&lt;/beans&gt;¶3. 传参针对于后端控制器处理方法的参数默认要求前端传入的name名称要和控制器HandlerMethod的参数名称相同。返回值表示跳转到的页面spring会自动将请求的数据值注入到方法的参数中，即使是bean对象，也同样会根据bean对象的get/set 方法进行注入。参数是基本数据类型：默认保证参数名称和请求中传递的参数名相同即可注入如果请求参数名和方法参数名不对应使用@RequestParam(“请求的数据名称”)赋值，此外@RequestParam(defaultValue=“值”)可以设置参数默认值@RequestParam(required=true)要求请求必须传入值，否则出错参数是对象类型根据请求参数名和对象中属性名对应(get/set 方法)进行注入参数是集合类型（请求数据为多个同名参数，如复选框）参数使用集合即可获取注入的请求数据必须使用@RequestParam()¶4. 设置字符编码需要在web.xml文件中添加以下过滤器配置1234567891011121314&lt;!-- 配置字符编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;¶三、Mybatis¶spring整合mybatis¶1.5.1 环境搭建:(1) 导包导 入 mybatis 所 有 jar 和 spring 基 本包,还有spring-jdbcspring-txspring-aopspring-web另外还要spring 整合 mybatis 的包mybatis-spring等(2)配置 web.xml目的是让tomcat启动时加载web.xml后自动加载applicationContext.xml文件(3)编写 spring 配置文件 applicationContext.xml目的是让spring IOC/DI的作用来管理mybatis和service¶1.5.2 编写代码(1)正常编写 pojo(2)编写 mapper,必须使用接口绑定方案或注解方案(必须有接口)(4)正常编写 Service 接口和 Service 实现类(5)需要在 Service 实现类中声明 Mapper 接口对象,并生成get/set 方法¶四、Strutsstruts执行流程简单描述图:搭建步骤：1.拷贝Struts2的核心Jar包到WEB-INF/lib/下asm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarcommons-fileupload-1.3.1.jar 用于实现文件上传功能的jar包。commons-io-2.2.jarcommons-lang3-3.2.jarfreemarker-2.3.22.jar reemarker是比jsp更简单好用，功能更加强大的表现层技术，用来替代jsp的。 在Struts2中提倡使用 freemarker模板，但实际项目中使用jsp也很多。javassist-3.11.0.GA.jarlog4j-api-2.2.jarlog4j-core-2.2.jarognl-3.0.6.jar 用来支持ognl表达式的，类似于EL表达式，功能比EL表达式强大的多。struts2-core-2.3.24.jar 核心包xwork-core-2.3.24.jar Struts2核心包，是WebWork内核。2.在web.xml配置前端控制器FilterDispatcher前端控制器实际上是一个过滤器，是所有请求的入口。123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置前端控制器 --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;3.在src下配置名称为struts.xml名称一定要是struts.xml，这是约束条件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN" "http://struts.apache.org/dtds/struts-2.1.7.dtd"&gt;&lt;struts&gt; &lt;!-- package：包，用于对Action进行封装。 1、name：包名，根元素下可以有多个包，彼此之间不能重名。 2、extends：继承，用于指定继承的包，相当于将继承包下的配置信息复制到了当前包下。 3、namespace：命名空间，用于规定Action的访问路径，可以是"/",也可以是"/路径名"必须以“/”开头。 4、请求Action时，按照如下格式拼写URL： --&gt; &lt;package name="day01" namespace="/demo" extends="struts-default"&gt; &lt;!-- action：业务控制器，用于注册业务控制器组件（类）。 1、name：action名称，用于规定Action的访问路径。 一个包下可以有多个action，彼此之间不能重名。 namespace属性值和action标签里面的name属性值构成访问路径 如果命名空间是"/"时：http://IP:PORT/ProjectName/NAMESPACE/ACTIONNAME或者http://IP:PORT/ProjectName/NAMESPACE/ACTIONNAME.action 如果命名空间是"/NAMESPACE"时：http://IP:PORT/ProjectName/NAMESPACE/ACTIONNAME或者http://IP:PORT/ProjectName/NAMESPACE/ACTIONNAME.action 2、class：业务控制器组件，用于指定业务控制器对应的类。 3、method：方法，用于指定访问当前action时要调用的方法。如果不配置默认执行的方法execute方法--&gt; &lt;action name="hello" class="com.qcmoke.action.HelloAction" method="sayHello"&gt; &lt;!--配置action方法返回值对应的页面 result：输出组件，用于转发、重定向、直接输出。 1、name：名称，一个action下可以有多个result，彼此之间不能重名。 2、默认做转发，标记内容设置成转发的页面。--&gt; &lt;result name="success" type="dispatcher"&gt; &lt;!-- name属性：和方法返回值一样，默认值为 success type属性：指定转发或者重定向，默认值做转发操作 dispatcher（请求转发） redirect（重定向到页面） redirectAction（重定向到Action） chain（解决重定向request作用域失效） --&gt; /hello.jsp &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;!-- 由于day02的包继承自day01，并且没有扩展功能，故day01和day02是等价的，即以下链接效果是一样的 http://localhost:8080/struts02/demo/hello.action?realName=zhangsan&amp;age=21&amp;user.userName=zhangsan&amp;user.password=123456 http://localhost:8080/struts02/demo2/hello.action?realName=zhangsan&amp;age=21&amp;user.userName=zhangsan&amp;user.password=123456 --&gt; &lt;package name="day02" namespace="/demo2" extends="day01"&gt;&lt;/package&gt; &lt;/struts&gt;4.创建action123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qcmoke.action;import com.qcmoke.pojo.User;// 案例1 public class HelloAction &#123; // 定义实体对象属性，接收表单参数：用户名、密码 private User user; public void setUser(User user) &#123; System.out.println("注入对象user..."); this.user = user; &#125; public User getUser() &#123; return this.user; &#125; public HelloAction() &#123; System.out.println("实例化Action..."); &#125; // 定义基本类型属性，接收表单参数：姓名 private String realName; private Integer age; public String getRealName() &#123; return realName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setRealName(String realName) &#123; System.out.println("注入参数realName..."); this.realName = realName; &#125; /** * 在业务方法中输出“Hello，Action.” */ public String sayHello() &#123; System.out.println("Hello,Action."); // 输出基本类型数据 System.out.println("姓名：" + realName); // 输出域模型方式注入的参数 System.out.println("用户名：" + user.getUserName()); System.out.println("密码：" + user.getPassword()); return "success"; &#125;&#125;用到的pojo类：12345678910111213141516171819202122package com.qcmoke.pojo;public class User &#123; private String userName;// 用户名 private String password;// 密码 public String getPassword() &#123; return password; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;转发到的页面：1234567891011&lt;%@page pageEncoding="utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello,Struts2.&lt;/h1&gt; &lt;h1&gt;姓名：$&#123;realName&#125;&lt;/h1&gt; &lt;h1&gt;用户名：$&#123;user.userName &#125;&lt;/h1&gt; &lt;h1&gt;密码：$&#123;user.password &#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;¶五、Hibernate¶1. 定义Hibernate是一个开源，轻量级的ORM(对象关系映射)工具（框架）对象关系映射技术ORM简化了数据创建，数据处理和数据访问。它是将对象映射到数据库中存储的数据(表)的编程技术。 不需要编写数据库特定的sql语句就能完成对数据库数据的操控，一定程度上摆脱了不同数据库sql差异带来的不便。orm思想（1）让实体类和数据库表进行一一对应关系（使用配置文件完成对应联系）让实体类和数据库表对应让实体类属性和表字段对应（2）不需要用sql语句直接操作数据库表，而是通过操控实体类对象间接操控数据表。¶2. 环境搭建下面以用户管理的案例搭建java工程项目的方式来说明步骤。项目结果如下：¶2.1 数据库准备这里使用的是mysql作为数据库来进行讲解。首先在数据库中创建一个数据库用来存Hibernate生成的表。sql:1mysql&gt; create database ssh;¶2.2 导包antlr-2.7.7.jardom4j-1.6.1.jargeronimo-jta_1.1_spec-1.1.1.jarhibernate-commons-annotations-5.0.1.Final.jarhibernate-core-5.0.7.Final.jarhibernate-entitymanager-5.0.7.Final.jarhibernate-jpa-2.1-api-1.0.0.Final.jarjandex-2.0.0.Final.jarjavassist-3.18.1-GA.jarjboss-logging-3.3.0.Final.jarlog4j-1.2.16.jarmysql-connector-java-5.0.4-bin.jarslf4j-api-1.6.1.jarslf4j-log4j12-1.7.2.jar¶2.3 创建实体类和对应的映射文件实体类src/com/qcmoke/entity/User.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.qcmoke.entity;public class User &#123; /* hibernate要求实体类有一个属性唯一的 */ private int uid; private String username; private String password; private String address; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125;映射配置文件src/com/qcmoke/entity/User.hbm.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 1 配置类和表对应 class标签 name属性：实体类全路径 table属性：数据库表名称 --&gt; &lt;class name="com.qcmoke.entity.User" table="t_user"&gt; &lt;!-- 2 配置实体类id和表id对应 hibernate要求实体类有一个属性唯一值 hibernate要求表有字段作为唯一值 --&gt; &lt;!-- id标签 name属性：实体类里面id属性名称 column属性：生成的表字段名称 --&gt; &lt;id name="uid" column="uid"&gt; &lt;!-- generator:设置数据库表id增长策略 native:生成表id值就是主键自动增长 uuid:使用uuid生成的不同随机值作为增长策略，需要实体类id属性是String类型--&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;!-- &lt;generator class="uuid"&gt;&lt;/generator&gt; --&gt; &lt;/id&gt; &lt;!-- 配置其他属性和表字段对应 name属性：实体类属性名称 column属性：生成表字段名称;column属性可以省略的,不写默认和name属性值一样的 type属性:设置生成表字段的类型(Java类型，也可以是Hibernate预置的类型)，不写默认自动对应类型,一般不会去配置 --&gt; &lt;property name="username" column="username"&gt;&lt;/property&gt; &lt;property name="password" column="password" type="string"&gt;&lt;/property&gt; &lt;property name="address" column="address"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;¶2.4 核心配置文src/hibernate.cfg.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///ssh&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;&lt;!-- 配置hibernate.hbm2ddl.auto之后，hibernate会自动创建表 。update: 如果已经有表，更新，如果没有，创建--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- 配置数据库方言。让hibernate框架识别不同数据库的自己特有的语句，比如分页语句--&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource="com/qcmoke/entity/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;¶2.5 测试类src/com/qcmoke/hibernatetest/HibernateTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.qcmoke.hibernatetest;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;import com.qcmoke.entity.User;public class HibernateTest &#123; @Test public void testAddUser() &#123; /** 第一步 加载hibernate核心配置文件 */ // 到src下面找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件标签放到对象里面 Configuration cfg = new Configuration(); cfg.configure(); /** 第二步 创建SessionFactory对象 */ // 读取hibernate核心配置文件内容，创建sessionFactory;在过程中，根据映射关系，在配置数据库里面把表创建。一个项目一般创建一个sessionFactory对象 SessionFactory sessionFactory = cfg.buildSessionFactory(); /** 第三步 使用SessionFactory创建session对象，session对象是单线程对象,常用方法有（1）添加 save方法;（2）修改 update方法（3）删除 delete方法（4）根据id查询 get方法 */ Session session = sessionFactory.openSession(); // 类似于连接 /** 第四步 开启事务 */ Transaction tx = session.beginTransaction(); /** 第五步 写具体逻辑 crud操作 */ // 添加功能 try &#123; User user = new User(); user.setUsername("qcmoke"); user.setPassword("123456"); user.setAddress("贵州"); // 调用session的方法实现添加 session.save(user); /** 第六步 提交事务 */ tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); // 回滚事务 e.printStackTrace(); &#125; finally &#123; /** 第七步 关闭资源 */ session.close(); sessionFactory.close(); &#125; &#125;&#125;¶3. 三大查询对象QueryCriteriaSQLQuery¶3.1 Query1 使用query对象，可以不写sql语句，但是写hql语句（1）hql：hibernate query language，hibernate提供查询语言，这个hql语句和普通sql语句很相似（2）hql和sql语句区别：使用sql操作表和表字段使用hql操作实体类和属性2 查询所有hql语句：（1）from 实体类名称3 Query对象使用（1）创建Query对象（2）调用query对象里面的方法得到结果]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
        <tag>高级框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows那些操作玩意]]></title>
    <url>%2Fwindows%2Fwin.html</url>
    <content type="text"><![CDATA[¶一、进程处理1234567891011121314#查看所有端口：netstat -ano#只查看8080 端口：netstat -aon|findstr "8080"#杀死进程，假如对应的PID是“11388”taskkill /F /PID 11388#当然，如果如果不知道8080 端口是什么的进程,担心误操作，可以先通过以下命令查一下进程的名称tasklist|findstr "17484"#可以通过进程名称关键字查看进程号tasklist|findstr "QQPY"¶二、系统常用快捷键¶1. 批量多选长按Ctrl后按鼠标左键以选择或反选¶2. 确定首尾后批量多选先左键选中首个文件（文件夹），然后按住Shift键不松手，再移动鼠标左键选中末尾的文件（文件夹），那么就能够实现确定首尾后批量多选。¶3. 撤销或重回撤销前撤销上一步的操作 CTRL+Z (重回上一步被撤销的操作 CTRL+Y)¶4. 快速定位到行首（尾）快速定位到行首 Shift+HOME （快速定位到行尾Shift+END)¶5. 快速定位到词首（尾）快速定位到词首CTRL+Left （快速定位到词尾CTRL+Right)¶三、解决windows10 时间轴灰色的活动历史记录无法删除的问题在Windows10上的日常办公过程中系统会记录很多活动历史记录信息，但如果你是一个注重隐私的人，你可能和我一样选择删除掉这些信息，并且禁用windows10的记录服务。方法是：打开任务栏，设置—&gt;隐私—&gt;活动历史记录—&gt;将“允许Windows从电脑中收集我的活动”和“允许Windows将我的活动从此电脑同步到云”关闭掉，然后点击下方的“清除活动历史记录”，如此便能禁用windows10的活动历史记录服务并且删除掉当前产生的活动历史记录信息。但有一些变成了灰色的活动历史记录可能无法删除，这里我就给大家一个解决方法。Windows+R后输入“gpedit.msc”打开本地组策略编辑器，定位至“计算机配置 - 管理模板 - 系统 - OS策略”。双击该项打开“启用活动源”配置窗口，修改为“已禁用”。注销或重启系统后设置生效。然后你再点击Win10任务栏中的“任务视图”按钮，就会发现时间轴上这些无法删除的活动历史记录已经不见了。然后我们可以选择再恢复时间轴的功能，只需把“启用活动源”配置为“未配置”或“已启用”，然后再看时间轴上灰色的活动历史记录也没有再出现，问题自然迎刃而解。¶四、hiberfil.sys、pagefile.sys、swapfile.sysWindows系统中，在C盘根目录有三个隐藏的受保护的操作系统文件：hiberfil.sys、pagefile.sys、swapfile.sys 。这几个文件通常都无法手动删除，因为他们都是系统某些功能下使用到的数据文件，对应功能的系统程序会在后台占用它们，所以无法手动删除。并且为了相关功能能够正常使用都是不建议删除的，但如果用户明确知道不需要这些功能也是可以通过系统设置来间接删除，同时还能根据用户需求来修改文件的存放位置或者文件的大小等。💁‍♂ 提示：通常hiberfil.sys、pagefile.sys、swapfile.sys这些文件是无法手动删除，即使通过PE系统等常规手段强制删除了但是重启电脑，这些文件又会自动重新生成，所以删与不删并没有什么意义。¶hiberfil.sys系统休眠文件。其是Windows休眠功能使用的文件，它保存了计算机的内存内容以便于在恢复时重新加载。其大小最大值等于计算机物理内存大小，实际大小等于计算机物理内存中活动的内存的大小。用户可以通过开关系统休眠功能来操控该文件的生成和删除。以管理员身份运行终端，然后输入如下命令：1234#开启powercfg.exe /hibernate on#关闭powercfg.exe /hibernate off¶pagefile.sys虚拟内存分页文件。其是Windows虚拟内存使用的文件，它充当了物理内存的备用存储器，并用于缓解系统内存压力。其大小最大值通常设置为物理内存大小的1.5倍或2倍，实际大小通常会随着计算机的使用情况而变化。用户可以通过手动配置虚拟内存来删除分页文件、设置分页文件大小或存放位置等。¶虚拟内存默认系统配置默认系统使用C盘托管虚拟内存并存储分页文件，并且自动管理虚拟内存和分页文件大小。如下图：¶禁用虚拟内存禁用虚拟内存即取消虚拟内存在系统分区的托管。（禁用完成并重启系统后，系统将自动删除pagefile.sys分页文件）。¶修改虚拟内存位置首先取消虚拟内存在原本分区（如C盘）上的托管，然后再设置托管到其他盘符（比如D盘），操作如下：¶自定义虚拟内存大小可以自定义虚拟内存初始大小以及最大值（对应的分页文件得大小也会随着虚拟内存实际活动大小变化而自动变化）。操作如下：以上自定义了虚拟内存的初始大小为2048MB（2GB），最大值为4096MB（即4GB）。虚拟内存的大小应该根据计算机的硬件配置和实际需求进行适当调整。如果将虚拟内存设置得太小，则可能会导致系统崩溃或者运行某些应用程序时出现错误。而如果将虚拟内存设置得太大，则可能会浪费磁盘空间并影响系统性能。以下是一些建议的虚拟内存设置大小：如果有4GB或更少的RAM，那么建议将虚拟内存设置为RAM大小的1.5倍。如果有8GB或更多的RAM，那么建议将虚拟内存设置为RAM大小的1倍。如果使用计算机上的大型程序或进行大量数据处理工作，那么建议将虚拟内存设置为RAM大小的2至3倍。需要注意的是，虚拟内存设置的大小对于每个计算机都可能不同，因此您应该根据自己的实际需求进行适当调整。在设置虚拟内存大小之前，建议先了解自己的计算机硬件配置、正在运行的应用程序和任务以及可用磁盘空间，从而确定合适的虚拟内存大小。虚拟内存的设置也可以通过让Windows自动管理来避免手动设置大小。Windows通常会根据计算机的硬件配置和使用情况自动管理虚拟内存，以确保系统的稳定性和性能。¶swapfile.sys虚拟内存压缩文件（虚拟内存交换文件）。这个文件是Windows 10之后引入的另一个虚拟内存使用的文件，它也充当了物理内存的备用存储器，并用于缓解系统内存压力。系统启用“压缩内存”功能后会创建swapfile.sys文件来存储压缩的内存页面。其大小最大值通常设置为物理内存大小的一半，实际大小通常会随着计算机的使用情况而变化。由Windows自动管理不能手动配置维护。swapfile.sys通常是无法手动删除的，即使能够强制删除了但是重启电脑又会自动重新生成，所以删与不删并没有什么意义。¶说明（1）pagefile.sys和swapfile.sys的区别pagefile.sys中存储的数据并没有被压缩。而swapfile.sys存储的数据是经过压缩了的。pagefile.sys可以被用户手动配置维护，而swapfile.sys则由Windows自动管理不能手动配置维护。（2）交换页面交换页面（paging）是指将内存中不活动的数据移动到计算机硬盘等辅助存储器中，从而释放物理内存以供其他程序使用的过程。这个过程是操作系统的一项重要功能，它可以帮助更有效地使用可用内存，并允许计算机同时运行更多的程序。在Windows操作系统中，当物理内存不足时，系统会自动将部分内存中不活动的数据转移到虚拟内存文件（如pagefile.sys和swapfile.sys），以便为正在使用的程序提供更多的内存。交换页面对于系统性能和稳定性都非常重要，因为它可以避免由于内存不足导致的系统崩溃和错误，同时也可以加速系统响应时间。然而，当交换页面频繁发生时，可能会出现性能问题，因为硬盘的访问速度远不及内存的访问速度。因此，更好的方法是尽可能增加计算机的物理内存，这样系统就不需要频繁地进行交换页面操作了。（3）禁用虚拟内存为什么还会有pagefile.sys文件？当您禁用虚拟内存时，系统会尽量避免将数据写入pagefile.sys文件。但是不一定会自动删除该文件，这是因为该文件不仅用作虚拟内存的备份存储器，还可以包含一些临时数据和系统状态信息，例如崩溃转储文件、核心转储文件等。在某些情况下，例如运行某些应用程序、安装更新或进行系统维护操作时，系统可能需要在pagefile.sys文件中写入数据。此外，即使您禁用了虚拟内存并删除了pagefile.sys文件，系统也可以重新创建该文件。例如，如果您启用了系统还原功能，则系统可能会使用pagefile.sys文件来存储还原点数据。¶参考https://www.zhihu.com/tardis/zm/art/87565681?source_id=1003]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习笔记]]></title>
    <url>%2Fmobile%2Fwx.html</url>
    <content type="text"><![CDATA[¶2. 环境准备¶2.1 注册账号建议使用全新的邮箱，没有注册过其他小程序或者公众号的。访问注册页面，耐心完成注册即可。¶2.2 获取APPID由于后期调用微信小程序的接⼝等功能，需要索取开发者的小程序中的 APPID，所以在注册成功后，可登录，然后获取APPID。登录，成功后可看到如下界⾯。¶2.3 开发工具下载地址微信小程序自带开发者工具，集开发、预览、调试、发布、于一身的完整开发环境。¶3. 第一个微信小程序注意：打开微信开发者工具，第⼀次登录的时候是需要微信扫码登录的。¶4. 小程序项目结构¶4.1 文件类型小程序框架提供了自己的视图层描述语⾔WXML、WXML、 WXSS以及JavaScript，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。结构传统web微信小程序标签语言HTMLWXML样式CSSWXSS逻辑JavascriptJavascript配置无JSON¶4.2 项目目录¶4.3 配置文件一个小程序应⽤程序会包括最基本的两种配置⽂件。全局配置文件app.json和页面配置文件page.json注意：配置文件中不能出现注释¶4.3.1 全局配置全局配置可以定义所有页面的⼀些共同属性，如顶部颜色、是否允许下拉刷新等等。app.json1234567891011121314&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Weixin", "navigationBarTextStyle":"black" &#125;, "style": "v2", "sitemapLocation": "sitemap.json"&#125;（1）pages用于描述当前小程序所有页面的路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个⽬录。（2）window定义小程序所有页面的顶部背景颜色，文字颜色定义等。（3）tabBar如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。属性类型必填默认值描述最低版本colorHexColor是tab 上的文字默认颜色，仅支持十六进制颜色selectedColorHexColor是tab 上的文字选中时的颜色，仅支持十六进制颜色backgroundColorHexColor是tab 的背景色，仅支持十六进制颜色borderStylestring否blacktabbar 上边框的颜色， 仅支持 black / whitelistArray是tab 的列表，详见 list 属性说明，最少 2 个、最多 5 个 tabpositionstring否bottomtabBar 的位置，仅支持 bottom / topcustomboolean否false自定义 tabBar，见详情2.5.0其中 list 接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：属性类型必填说明pagePathstring是页面路径，必须在 pages 中先定义textstring是tab 上按钮文字iconPathstring否图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 position 为 top 时，不显示 icon。selectedIconPathstring否选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 position 为 top 时，不显示 icon。下面是一个简单的tabBar配置案例：123456789101112131415161718192021222324252627282930&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Weixin", "navigationBarTextStyle":"black" &#125;, "tabBar": &#123; "list": [&#123; "pagePath": "pages/index/index", "text": "主页", "iconPath": "icon/_home.png", "selectedIconPath": "icon/home.png" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志", "iconPath": "icon/_img.png", "selectedIconPath": "icon/img.png" &#125;], "color": "#0094ff", "selectedColor": "#ff9400" &#125;, "style": "v2", "sitemapLocation": "sitemap.json"&#125;¶4.3.2 页面配置每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 app.json 的 window 中相同的配置项。下面是pages/index/index.json简单的配置案例：123456789&#123; "usingComponents": &#123;&#125;, "navigationBarBackgroundColor": "#0094aa", "navigationBarTextStyle": "black", "navigationBarTitleText": "首页", "enablePullDownRefresh": true, "backgroundTextStyle": "light", "backgroundColor": "#2894FF"&#125;页面配置中只能设置 app.json 中 window 对应的配置项，以决定本页面的窗口表现，所以无需写 window 这个属性。完整配置信息可参考官网page.json配置。¶4.4 sitemap小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引。详细介绍见官网：sitemap 配置¶5. 模板语法WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。¶5.1 数据绑定¶5.1.1 简单绑定数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：内容1&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;12345Page(&#123; data: &#123; message: 'Hello MINA!' &#125;&#125;)¶5.1.2 组件属性(需要在双引号之内)1&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt; &lt;/view&gt;12345Page(&#123; data: &#123; id: 0 &#125;&#125;)¶5.1.3 控制属性(需要在双引号之内)12&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; hi &lt;/view&gt;&lt;checkbox checked="&#123;&#123;condition&#125;&#125;"&gt; &lt;/checkbox&gt;12345Page(&#123; data: &#123; condition: true &#125;&#125;)¶5.1.4 综合案例pages/index/index.js1234567891011Page(&#123; /** * 页面的初始数据 */ data: &#123; message: 'Hello MINA!', id: 0, condition: true &#125;&#125;)pages/index/index.wxml12345&lt;!--index.wxml--&gt;&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt; &lt;/view&gt;&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; hi &lt;/view&gt;&lt;checkbox checked="&#123;&#123;condition&#125;&#125;"&gt; &lt;/checkbox&gt;¶5.2 列表渲染¶5.3 条件渲染]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyUI学习笔记]]></title>
    <url>%2Ffront%2Flearn_easyui.html</url>
    <content type="text"><![CDATA[¶EasyUI 简介easyui是一种基于jQuery、Angular.、Vue和React的用户界面插件集合（本教程只讲解基于jQuery的easyui）。easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。easyui是个完美支持HTML5网页的完整框架。easyui节省您网页开发的时间和规模。easyui很简单但功能强大的。EasyUI官网下载地址:http://www.jeasyui.net/download/jquery.html官方文档:http://www.jeasyui.net/plugins如何在javaweb项目中导入easyui？以eclipse为例：¶1. 导入easyui¶2. 在html或者jsp页面代码中导入相关css和js。在&lt;head&gt;标签里导入一下代码：12345678910&lt;!-- 导入主题样式 --&gt;&lt;link rel="stylesheet" type="text/css" href="easyui-1.6.11/themes/default/easyui.css"&gt;&lt;!-- 导入图标样式 --&gt;&lt;link rel="stylesheet" type="text/css" href="easyui-1.6.11/themes/icon.css"&gt;&lt;!-- 导入jqury --&gt;&lt;script type="text/javascript" src="easyui-1.6.11/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 导入easyui --&gt;&lt;script type="text/javascript" src="easyui-1.6.11/jquery.easyui.min.js"&gt;&lt;/script&gt;&lt;!-- 导入语言设置 --&gt;&lt;script type="text/javascript" src="easyui-1.6.11/locale/easyui-lang-zh_CN.js"&gt;&lt;/script&gt;¶3. 创建和初始化组件easyui有两种方式可以声明和使用 UI 组件。¶第一种创建组件： 给元素标签添加类样式属性 class（用来指定组件类型）原理:easyui会去页面上寻找每一个元素，看是否含有easyui开头的class属性，如果有则将这个元素安装该class属性将元素渲染为对应的组件。格式：1&lt;div class="easyui-组件名" &gt;&lt;/div&gt;如下：1&lt;div class="easyui-window" &gt;&lt;/div&gt;初始化组件： 给元素标签添加数据选项属性data-options（用来初始化组件）格式：1&lt;div class="easyui-window" data-options="key1:value1,key2:value2"&gt; &lt;/div&gt;如下：123&lt;div class="easyui-window" data-options="title:'测试窗口',width:500,height:400,iconCls:'icon-save',minimizable:false,left:500"&gt; test EasyUI window&lt;/div&gt;data-options属性可以定义各种组件的样式和内容及事件,可以通过data-options来实例化组件¶第二种创建组件： 编写 JS 代码来创建组件格式：1$("#mydiv").方法名();如下：1234567&lt;div id="mydiv"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; //页面加载完(不包括图片加载) $("#mydiv").window(); &#125;);&lt;/script&gt;初始化组件：格式：1$("#mydiv").方法名(&#123;key1:value1,key2:value2&#125;);此处方法名一般就为组件名，方法传递的是一个json对象，json对象的属性是以键值对的形式存在，多个属于之间用逗号隔开。如下：1234567891011121314151617&lt;div id="mydiv"&gt;test EasyUI window&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#mydiv").window( //window()方法参数里写json数据类似于标签指定data-options属性 &#123; title : '测试窗口', width : 500, height : 400, iconCls : 'icon-save', //窗口图标 minimizable : false, //能否最小化 left : 500, top : 200, modal : true //模式窗口,true表示在当前窗口没有关闭前不能操作其他窗口 &#125;); &#125;);&lt;/script&gt;¶4. 给组件加事件1234$("#mydiv").组件方法(&#123; 事件名1:function()&#123;&#125;, 事件名2:function()&#123;&#125;&#125;);1234567891011&lt;div id="mydiv"&gt;test EasyUI window&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#mydiv").window(&#123; onOpen : function() &#123;//window继承自Panel，很多事件也来自于Panel。比如onOpen事件 alert("hello"); &#125; &#125;); &#125;);&lt;/script&gt;¶5. 调用组件的方法格式：1$("#mydiv").组件方法("函数名","参数值"或者json对象);如下：1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id="mydiv" class="easyui-window" data-options="width:500,height:400"&gt;&lt;/div&gt; &lt;a class="easyui-linkbutton" data-options="iconCls:'icon-tip'" href="javascript:closeWin()"&gt;关闭窗口&lt;/a&gt; &lt;a class="easyui-linkbutton" data-options="iconCls:'icon-tip'" href="javascript:setTitleWin()"&gt;修改窗口标题&lt;/a&gt; &lt;a class="easyui-linkbutton" data-options="iconCls:'icon-tip'" href="javascript:resizeWin()"&gt;改变窗口大小&lt;/a&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //给window组件传入一个close的方法 function closeWin() &#123; $("#mydiv").window("close"); &#125; //给window组件传入一个setTitle的方法,并指定setTitle方法的参数，参数只有一个，可以直接以字符串的形式传入。 function setTitleWin() &#123; $("#mydiv").window("setTitle", "我的窗口"); &#125; //给window组件传入一个resize的方法,并指定resize方法的参数，参数有多个的时候，可以用json对象的形式传入。 function resizeWin() &#123; $("#mydiv").window("resize", &#123; width : 500, height : 500, top : 0 &#125;); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>easyui</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 安装vsftpd服务器]]></title>
    <url>%2Fdevops%2Fvsftpd_ubuntu.html</url>
    <content type="text"><![CDATA[¶1. 安装并启动 FTP 服务安装 VSFTPD对于Debian类系统: 使用apt-get 安装apt-get安装1apt-get install vsftpd -y对于Redhat类系统：1yum install vsftpd -y启动 VSFTPD安装完成后，启动 FTP 服务：1service vsftpd start启动后，可以看到系统已经：1netstat -nltp | grep 21此时，访问 ftp://&lt;您的 CVM IP 地址&gt;可浏览机器上的 /var/ftp 目录了。FTP 协议默认使用 21 端口作为服务端口¶2. 配置访问目录和新建用户新建用户主目录1mkdir /home/uftp执行完后，在这里 /home/uftp 就能看到新建的文件夹 uftp 了。创建登录欢迎文件 ：1touch /home/uftp/welcome.txt设置主目录访问权限（只读）：1chmod a-w /home/uftp新建公共目录，并设置权限（读写）：1mkdir /home/uftp/public &amp;&amp; chmod 777 -R /home/uftp/public新建用户 uftp 并设置密码创建一个用户 uftp :1useradd -d /home/uftp -s /bin/bash uftp为用户 uftp 设置密码1passwd uftp限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器1usermod -s /sbin/nologin uftp¶3. 配置vsftpd删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：1rm /etc/pam.d/vsftpd修改 vsftpd 配置1chmod a+w /etc/vsftpd.conf修改 /etc/vsftpd.conf 文件中的配置修改:1234# 禁用匿名用户anonymous_enable=NO# 禁止切换根目录chroot_local_user=YES将如下配置添加到配置文件最下方123456789101112131415161718# 限制用户对主目录以外目录访问chroot_local_user=YES# 指定一个 userlist 存放允许访问 ftp 的用户列表userlist_deny=NOuserlist_enable=YES# 记录允许访问 ftp 用户列表userlist_file=/etc/vsftpd.user_list# 不配置可能导致莫名的530问题seccomp_sandbox=NO# 允许文件上传write_enable=YES# 使用utf8编码utf8_filesystem=YES新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：12touch /etc/vsftpd.user_listchmod a+w /etc/vsftpd.user_list修改 /etc/vsftpd.user_list ，加入刚刚创建的用户：12vim vsftpd.user_listuftp重启vsftpd 服务：1service vsftpd restart¶4. 访问 FTP 服务FTP 服务已安装并配置完成，下面我们来使用该 FTP 服务根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务通过 FTP 客户端工具访问FTP 客户端工具众多，下面推荐两个常用的：FileZilla - 跨平台的 FTP 客户端，支持 Windows 和 MacWinSCP - Windows 下的 FTP 和 SFTP 连接客户端下载和安装 FTP 客户端后，使用下面的凭据进行连接即可：主机：119.29.174.183 (vps的ip)用户：uftp输入密码后，如果能够正常连接，那么大功告成，您可以开始使用属于您自己的 FTP 服务器了！接下来，请上传任意一张图片到您的 FTP 服务器上的 uftp 的 public 目录下，然后，就可以在 /home/uftp/public 中看到了。通过 Windows 资源管理器访问Windows 用户可以复制下面的链接到资源管理器的地址栏访问：ftp://uftp:你的密码@119.29.174.183如果您申请了域名，可以将Ip 地址替换为对应的域名作为访问凭据如果您申请了域名，可以将链接中的 Ip 地址替换为对应的域名访问 FTP 服务大功告成恭喜！您已经成功完成了搭建 FTP 服务器的实验任务。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache配置ssl证书]]></title>
    <url>%2Fdevops%2Fapache_ssl.html</url>
    <content type="text"><![CDATA[¶1. 安装apache、openssl和mod_ssl1$ yum install httpd openssl mod_ssl -y¶2. 启动apache服务12$ systemctl start httpd # 启动服务$ systemctl enable httpd # 设置开机启动¶3. 检查apache是否启动12$ systemctl start httpd # 看到Active: active (running),表示启动成功$ systemctl is-active httpd #输出active表示启动成功¶4. 查看apache服务器网站根目录1grep -ri DocumentRoot /etc/httpd查看到如下没有打#的项就是网页(文档)根目录了，即/var/www/html/etc/httpd/conf.d/ssl.conf:#DocumentRoot &quot;/var/www/html&quot;/etc/httpd/conf/httpd.conf:# DocumentRoot: The directory out of which you will serve your/etc/httpd/conf/httpd.conf:DocumentRoot &quot;/var/www/html&quot;/etc/httpd/conf/httpd.conf: # access content that does not live under the DocumentRoot.¶5. 域名解析设置解析域名(如：example.com)到服务器的ip地址上，比如我这里添加了两条解析记录。1、解析记录为：记录类型为A ，主机记录为为@ ，记录值为144.34.145.102、解析记录为：记录类型为A ，主机记录为为www ，记录值为144.34.145.10¶6. 配置 SSL 证书以使用 https一般地，获取 SSL 证书有两种方式：自签名和购买 CA 颁发的 SSL 证书。自签名的证书可能会被浏览器拦截并提示不受信任，因此建议采用比较可靠的商业颁发机构购买（如 Comodo、Symantec 等）或者免费的 Let’s Encrypt 签发的证书。可以使用 certbot 工具来申请得到免费 Let’ s Encrypt SSL 证书。具体操作可参考《通过certbot工具生成ssl证书》。假设这里已经申请得到了 Let’ s Encrypt SSL 证书，下文将介绍如何在 apache 中配置 SSL 证书以使用 https 。123456#创建一个目录来表示网站的根目录mkdir -p /var/www/test#创建一个html静态文件以待测试echo "&lt;h1&gt;Hi, Nginx !&lt;/h1&gt;" &gt;&gt; /var/www/test/index.html#编辑 apache web虚拟主机配置文件vi /etc/httpd/conf.d/vhost.conf添加以下内容：123456789101112131415161718192021222324252627282930&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/test" ServerName example.com ServerAlias www.example.com &lt;Directory "/var/www/test"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;RewriteEngine onRewriteCond %&#123;SERVER_NAME&#125; =example.com [OR]RewriteCond %&#123;SERVER_NAME&#125; =www.example.comRewriteRule ^ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [END,NE,R=permanent]&lt;/VirtualHost&gt;&lt;IfModule mod_ssl.c&gt;&lt;VirtualHost *:443&gt; DocumentRoot "/var/www/test" ServerName example.com ServerAlias www.example.com &lt;Directory "/var/www/test"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;SSLCertificateFile /path/cert.pemSSLCertificateKeyFile /path/privkey.pemSSLCertificateChainFile /path/chain.pem&lt;/VirtualHost&gt;&lt;/IfModule&gt;如果想要访问 example.com 域名地址时自动重定向到 www.example.com 域名地址，只需要修改&lt;VirtualHost&gt;中相关变量的即可，修改如下：123&gt;RewriteEngine on # url重定向开启&gt;RewriteCond %&#123;SERVER_PORT&#125; !^443$ # 指定跳转至443端口&gt;RewriteRule ^/?(.*)$ https://www.%&#123;SERVER_NAME&#125;/$1 [L,R] # 跳转至https://www.域名.com的url¶7. 重启apache服务器1service httpd restart]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建邮件服务器]]></title>
    <url>%2Fdevops%2Fmail.html</url>
    <content type="text"><![CDATA[拥有一台服务器，用来干嘛？放着吃灰不就等于花冤枉钱吗？何不充分发挥它的价值，比如搭建一个自己的邮件服务器。拥有一个自己域名的邮箱是可以装X的哦🙅‍♂ …¶一、预备知识¶1. 概述邮件收、发服务器是分开的，也就是我们需要搭建一个邮件发送服务器和一个邮件收取服务器。本文会搭建收、发两个服务器，并用邮件客户端（Foxmail）做测试。¶2. 协议协议就是定义规则，这里是邮件协议，定义邮件收发的规则，了解规则有助于理解软件的配置文件。邮件发送协议 SMTP（Simple Mail Transfer Protocol），默认端口为25。邮件收取协议 POP，默认端口为110；还有个常用邮件收取协议 IMOP，默认端口为143。¶3. 服务软件¶PostfixPostfix 是实现 SMTP 协议的软件，也叫做邮件发送服务器。上面说的邮件客户端将邮件扔给它，由它对邮件进行转发，至于怎么转发，SMTP 协议制定了规则，而 Postfix 负责具体事情，我们只需要修改 Postfix 配置文件要求它按照我们的想法去做。¶DovecotDovecot 实现了 POP 和 IMOP 协议，也叫做邮件收取服务器。如果只搭建了 Postfix 而没有它，不好意思，你是收不到邮件的。¶SaslSas l登陆验证服务，在下面的介绍可以看到 Postfix 作为邮件发送服务器，不能无限制的转发任意邮件，应当只转发它信任的发件人发送的邮件，这一点体现在 Postfix 的配置文件要配置它认为安全的主机（mynetworks 参数）。但这样会显得很麻烦，Sasl 通过其它方式也可以帮助 Postfix 完成信任邮件的认证。¶二、搭建及测试¶1. 设置域名域名或自建DNS照下面方式设置即可DNS 解析，新增两条记录：记录类型主机记录记录值Amail10.10.10.10（你的服务器ip）MX@mail.example.com¶2. 安装软件postfix、dovecot、cyrus-sasl12345yum -y install postfix dovecot cyrus-sasl $ postconf -a #验证是否支持cyrus dovecot功能cyrusdovecotpostfix主要是为发件服务，端口:25 ;devocot为收件服务,端口为:110和145 ; cyrus-sasl登陆验证服务。如果你的服务器有开启防火墙，那么还需要开放这几个必要的端口。如果你只是为了测试，你可以直接先关闭防火墙，测试成功后再对防火墙做配置。我们下面也是用关闭防火墙这种方式讲解。关闭防火墙1service firewalld stop修改postfix主配置文件，启动服务1234567891011121314151617181920212223vim /etc/postfix/main.cf#修改以下配置，注意下面的变量不要重复，如果发现与原来的变量重名，那就将原来的变量给注释掉#邮件服务器的主机名myhostname = mail.example.com#邮件域mydomain = example.com#往外发邮件的邮件域myorigin = $mydomain#监听的网卡 inet_interfaces = allinet_protocols = all#服务的对象mydestination = $myhostname, $mydomain#邮件存放的目录home_mailbox = Maildir/ #新添加以下配置#--------自定义（下面可以复制粘贴到文件最后面，用于设置服务器验为主，第一行设置发送附件大小）#message_size_limit = 100000smtpd_sasl_auth_enable = yessmtpd_sasl_security_options = noanonymousmynetworks = 127.0.0.0/8smtpd_recipient_restrictions = permit_mynetworks,permit_sasl_authenticated,reject_unauth_destination配置补充说明smtpd_sasl_auth_enable = yes 表示开启认证smtpd_sasl_security_options = noanonymous 表示不允许匿名发信mynetworks = 127.0.0.0/8 表示//允许的网段，如果增加本机所在网段就会出现允许不验证也能向外域发信smtpd_recipient_restrictions = permit_mynetworks,permit_sasl_authenticated,reject_unauth_destination表示允许本地域以及认证成功的发信，拒绝认证失败的发信123postfix check #修改保存后检查配置文件是否有错systemctl start postfix #开启postfix服务systemctl enable postfix #设置postfix服务开机启动修改dovecot主配置文件，启动服务123456789101112vim /etc/dovecot/dovecot.conf#修改以下配置protocols = imap pop3 lmtplisten = *, ::#新添加以下配置#-----------自定义------------!include conf.d/10-auth.confssl = nodisable_plaintext_auth = nomail_location = maildir:~/Maildir12systemctl start dovecotsystemctl enable dovecot修改cyrus-sasl主配置文件1234vim /etc/sasl2/smtpd.conf #这个是空文件，直接添加下面配置（配置认证方式）pwcheck_method: saslauthdmech_list: plain loginlog_level:312vim /etc/sysconfig/saslauthd #修改下面配置项（本地用户认证）MECH=shadow12systemctl start saslauthdsystemctl enable saslauthd¶3. 创建用户，安装telnet进行邮件收发测试123456yum -y install telnet-server telnetuseradd wen -s /sbin/nologinuseradd qcmoke #此用户为本人主机用户，需要登录，故没有禁止登录echo '123123' | passwd --stdin qcmokeecho '123123' | passwd --stdin wen¶3.1 发送本地邮件测试--------------连接服务器的25端口进行简单发信测试-----------123456789telnet mail.example.com 25//连接成功，开始写信helo mail.example.com //声明本机的主机mail from:example.com //声明发件人地址rcpt to:wen@example.com //声明收件人地址data //写正文HI THis is qcmoke, Good day! . //记住这里是以点作为正文结束标记quit // 退出到这里信件就已经发送了，接下来是验证收取邮件了。收取邮件验证---------------收信验证---------------123456telnet mail.example.com 110user wen //收件人登录pass 123456 //邮箱密码list //列表查看邮件retr 1 //读取编号为1的邮件quit //退出邮箱查看到了发送的内容，那这里就算是收件成功了¶3.2发送邮件到其它邮箱服务器测试这里用mailx这个软件来测试发送安装mailx1yum install mailx -y12su - qcmoke #切换用户，要求此用户具有登录权限echo '这是测试' | mail -s '你好，黔城陌客' 1667164190@qq.com再登陆到qq邮箱发现接收成功即可。到里邮箱的收发功能就都具备了。¶4. 客户端邮箱软件测试我这里用windows的Foxmail邮件代理接收发送客户端作演示我这是登陆设置好的了，收信和发信账号及密码就是在linux系统那里创建的账号和对应的密码。设置验证成功后就可以畅发邮件了。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7安装kafka]]></title>
    <url>%2Fdevops%2Fmq.html</url>
    <content type="text"><![CDATA[Kafka 是一个分布式的基于发布/订阅模式的消息队列，其订阅者的消费类型为主动拉取的模式。概念：1）Broker ：即一个正在运行中的kafka服务进程。一个集群由多个 broker 组成。由于broker是无状态的，所以需要通过zookeeper来维护集群状态。2）Producer ：消息生产者，就是向broker发送topic的客户端；3）Consumer ：消息消费者，向broker的topic中拉取数据的客户端；4）Consumer Group （CG）：消费者组，由多个 consumer 组成。组内的消费者共同消费某个主题里的所有分区数据（注意是共同消费而非独立消费），组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内的其中一个消费者消费（但该分区可以被其他组的消费者消费）；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。9）follower：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的 follower。¶一、安装前提条件：安装kafka之前需要有java环境。123456su rootwget https://archive.apache.org/dist/kafka/0.11.0.0/kafka_2.11-0.11.0.0.tgztar -zxvf kafka_2.11-0.11.0.0.tgz -C /usr/local/mv /usr/local/kafka_2.11-0.11.0.0/ /usr/local/kafkacd /usr/local/kafkamkdir logs¶二、配置kafka1vim config/server.properties1234567891011121314151617181920212223242526272829#broker 的全局唯一整形id，集群下该值注意不能重复broker.id=0#删除 topic 功能使能delete.topic.enable=true# 允许外部端口连接listeners=PLAINTEXT://0.0.0.0:9092# 外部代理地址(服务器物理机对外ip)advertised.listeners=PLAINTEXT://10.223.117.77:9092#处理网络请求的线程数量num.network.threads=3#用来处理磁盘 IO 的现成数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#kafka 运行日志存放的路径log.dirs=/usr/local/kafka/logs#topic 在当前 broker 上的分区个数num.partitions=1#用来恢复和清理 data 下数据的线程数量num.recovery.threads.per.data.dir=1#segment 文件保留的最长时间，超时将被删除log.retention.hours=168#配置连接 Zookeeper 集群地址zookeeper.connect=127.0.0.1:2181#zookeeper.connect=192.168.1.10:2181,192.168.1.11:2181,192.168.1.13:2181¶三、常用命令123456789101112131415161718192021222324252627cd /opt/kafka/kafka_2.11-0.11.0.0#以守护进程启动bin/kafka-server-start.sh -daemon config/server.properties#关闭bin/kafka-server-stop.sh config/server.properties# 查看当前服务器中的所有 topicbin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --list# 创建 topic（topic里有分区，有主题）# --topic:主题的名字# --zookeeper: 注册中心的地址# --replication-factor:副本数# --partitions:分区数bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --create --topic appServerLoginForced --replication-factor 1 --partitions 1#删除topicbin/kafka-topics.sh --delete --zookeeper 127.0.0.1:2181 --topic appServerLoginForced#测试bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic appServerLoginForced --from-beginningbin/kafka-console-producer.sh --broker-list localhost:9092 --topic appServerLoginForced]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用denyhosts防止ssh暴力破解]]></title>
    <url>%2Fdevops%2Fdenyhosts.html</url>
    <content type="text"><![CDATA[当你的 Linux 服务器暴露在互联网之中,该服务器将会遭到互联网上的扫描软件进行扫描,并试图猜测SSH登录口令。你会发现,每天会有多条SSH登录失败纪录。那些扫描工具将对你的服务器构成威胁,你必须设置复杂登录口令,并将尝试多次登录失败的IP给阻止掉,让其在一段时间内不能访问该服务器。¶1. denyhosts介绍denyhosts是Python语言写的一个程序，它会分析sshd的日志文件（/var/log/secure），当发现重 复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏IP的功能。¶2. 下载和安装123456789$ wget https://nchc.dl.sourceforge.net/project/denyhosts/denyhosts/2.6/DenyHosts-2.6.tar.gz #下载$ tar -zxvf DenyHosts-2.6.tar.gz #解压$ cd DenyHosts-2.6 #进入解压目录$ python setup.py install #编译安装#拷贝和修改默认配置文件的名称$ cd /usr/share/denyhosts/ #进入安装目录$ cp denyhosts.cfg-dist denyhosts.cfg$ cp daemon-control-dist daemon-control¶3. 配置此配置为可选项，因为原本就已经有默认的配置了。12345678#3.编辑配置文件denyhosts.cfg$ vim denyhosts.cfg #该配置文件结构比较简单，如果不想瞎折腾可以参照如下配置即可：PURGE_DENY = 1d #ip被禁止之后，多久可以释放(w表示周，d表示天，h表示小时，m表示分钟)DENY_THRESHOLD_INVALID = 5 #无效用户名限制登陆次数DENY_THRESHOLD_VALID = 10 #有效用户名限制登陆次数DENY_THRESHOLD_ROOT = 5 #root限制登陆次数AGE_RESET_ROOT = 1d #root用户登录失败计数归零的时间更多配置说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051############ THESE SETTINGS ARE REQUIRED #############sshd的日志文件SECURE_LOG = /var/log/secure #将阻止IP写入到hosts.deny,所以这个工具只支持 支持tcp wrapper的协议 HOSTS_DENY = /etc/hosts.deny #当一个IP被阻止以后，过多长时间被自动解禁。可选如3m（三分钟）、5h（5小时）、2d（两天）、8w（8周）、1y(一年)PURGE_DENY = 1w #阻止服务名 BLOCK_SERVICE = sshd#定义了某一IP最多被解封多少次。即某一IP由于暴力破解SSH密码被阻止/解封达到了PURGE_THRESHOLD次，则会被永久禁止；PURGE_THRESHOLD = 20#允许无效用户登录失败的次数 DENY_THRESHOLD_INVALID = 5#允许普通有效用户登录失败的次数 DENY_THRESHOLD_VALID = 10 #允许root登录失败的次数 DENY_THRESHOLD_ROOT = 1 #设定 deny host 写入到该资料夹 DENY_THRESHOLD_RESTRICTED = 1#将deny的host或ip记录到work_dir中 WORK_DIR = /var/lib/denyhosts SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YES#是否做域名反解 HOSTNAME_LOOKUP=YES #将DenyHost启动的pid记录到LOCK_FILE中，已确保服务正确启动，防止同时启动多个服务 LOCK_FILE = /var/lock/subsys/denyhosts ############ THESE SETTINGS ARE OPTIONAL #############设置管理员邮件地址 例如****@163.comADMIN_EMAIL = rootSMTP_HOST = localhostSMTP_PORT = 25SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;SMTP_SUBJECT = DenyHosts Report from $[HOSTNAME]# 有效用户登录失败计数归零的时间AGE_RESET_VALID=5d # ROOT用户登录失败计数归零的时间AGE_RESET_ROOT=25d # 用户的失败登录计数重置为0的时间(/usr/share/denyhosts/restricted-usernames)AGE_RESET_RESTRICTED=25d # 无效用户登录失败计数归零的时间AGE_RESET_INVALID=10d######### THESE SETTINGS ARE SPECIFIC TO DAEMON MODE ###########denyhost服务日志文件DAEMON_LOG = /var/log/denyhosts DAEMON_SLEEP = 30s #该项与PURGE_DENY 设置成一样，也是清除hosts.deniedssh 用户的时间,区别是以daemon模式运行时跟PURGE_DENY配合使用，自动解禁才能生效DAEMON_PURGE = 1h¶4.启动denyhosts1$ ./daemon-control start可以使用命令ps -ef | grep denyhosts查看是否运行成功。如下结果表示运行成功。1234[root@host denyhosts]# ps -ef | grep denyhostsroot 17588 1 0 11:57 ? 00:00:00 python /usr/bin/denyhosts.py --daemon --config=/usr/share/denyhosts/denyhosts.cfgroot 17611 24100 0 12:07 pts/1 00:00:00 grep --color=auto denyhosts[root@host denyhosts]#¶5.设置开机自动启动让denyhosts每次重启后自动启动。设置自动启动可以通过两种方法进行。第一种是将denyhosts作为守护进程服务运行，这种方法可以通过/etc/init.d/denyhosts命令来控制其状态。方法如下：123$ cd /etc/init.d$ ln -s /usr/share/denyhosts/daemon-control denyhosts$ service denyhosts start或者用以下命令通过chkconfig工具来管理更方便。123$ cd /etc/init.d$ chkconfig --add denyhosts$ chkconfig --level 2345 denyhosts on第二种是将denyhosts直接加入rc.local中自动启动（类似于Windows中的“启动文件夹”）：1$ echo '/usr/share/denyhosts/daemon-control start' &gt;&gt; /etc/rc.local如果想查看已经被阻止的IP，查看/etc/hosts.deny 文件即可。如下：1234567891011121314151617[root@host ~]# cat /etc/hosts.deny## hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a 'deny' option instead.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrappers## DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27sshd: 120.35.33.27[root@host ~]#¶6. 解禁ip编辑/etc/hosts.deny。然后删除或者注释掉对应的sshd即可。如以下用注释的方式解禁：12345678910111213141516[root@host ~]# vim /etc/hosts.deny# hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a 'deny' option instead.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrappers## DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27#sshd: 120.35.33.27[root@host ~]#如果想删除一个已经禁止的主机IP,只在/etc/hosts.deny删除是没用的。需要进入/usr/share/denyhosts/data/ 目录对以下文件一个个删除你想取消的主机IP才行。/usr/share/denyhosts/data/hosts/usr/share/denyhosts/data/hosts-restricted/usr/share/denyhosts/data/hosts-root/usr/share/denyhosts/data/hosts-valid/usr/share/denyhosts/data/users-hosts你可以执行命令sudo grep 120.35.33.27 /usr/share/denyhosts/data/*查看具体文件ip为“120.35.33.27”的具体位置但如果这样一个有个操作确实很麻烦，不过机智的我在网上找了一个脚本(denyhosts_removeip.sh)，这个脚本可以快速的解决这个问题。其内容如下：1234567891011121314151617181920212223#!/bin/bash# Author:licess# Website:https://www.vpser.net &amp; https://lnmp.orgHOST=$1if [ -z "$&#123;HOST&#125;" ]; then echo "Usage:$0 IP" exit 1fi echo "Remove IP:$&#123;HOST&#125; from denyhosts..."/etc/init.d/denyhosts stopecho '/etc/hosts.deny/usr/share/denyhosts/data/hosts/usr/share/denyhosts/data/hosts-restricted/usr/share/denyhosts/data/hosts-root/usr/share/denyhosts/data/hosts-valid/usr/share/denyhosts/data/users-hosts' | grep -v "^$" | xargs sed -i "/$&#123;HOST&#125;/d" #iptables -D INPUT -s $&#123;HOST&#125; -p tcp -m tcp --dport 22 -j DROPecho " done"/etc/init.d/denyhosts start执行脚本清除denyhosts某个IP的命令如下：1bash denyhosts_removeip.sh 10.10.10.10参考教程：http://coolnull.com/2068.htmlhttps://www.spamcage.com/denyhosts.html]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>denyhosts</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建nextcloud私有云盘]]></title>
    <url>%2Ftools%2Fnextcload.html</url>
    <content type="text"><![CDATA[搭建一套自己的私有云盘，让数据存储更加方便、可靠。Nextcloud是一个开源的云存储网盘，内置了Office文档、视频播放器、图片相册、日历联系人、两步验证、文件管理、RSS阅读等丰富的应用，Nextcloud已经仅仅可以用作个人或者团队存储与共享，还可以打造成为一个个人办公平台。¶0. 前置环境CentOS 7PHP 7.2MariaDB 5.5.60nextcloud 15首先安装在安装过程中需要的一些依赖项，但这些依赖项在每天使用情况下也很有用：12yum install -y epel-release yum-utils unzip curl wget \bash-completion policycoreutils-python mlocate bzip2现在确保您的系统是最新的：1# yum update -y¶1. 安装Apache1# yum install -y httpd确保启用并启动了apache Web服务：12# systemctl enable httpd.service# systemctl start httpd.service¶2. 安装 MariaDB1# yum install mariadb-server -y12345# systemctl start mariadb # 启动服务# systemctl enable mariadb # 设置开机启动设置 MySQL 账户 root 密码：mysqladmin -u root password '******'¶3. 安装php如果php使用的是php7.2以前的老版本，需要卸载老版本而装新版本。1# yum remove php* php-common #卸载php123456# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# yum install -y php72w php72w-cli php72w-common php72w-curl php72w-gd \php72w-mbstring php72w-mysqlnd php72w-process php72w-xml php72w-zip \php72w-opcache php72w-pecl-apcu php72w-intl php72w-pecl-redis# systemctl restart httpd如果php7解析php文件失败，可以执行yum -y install php* --skip-broken后再执行以上php7安装命令¶4. 安装nextcloud1234# cd var/www/html/# wget https://download.nextcloud.com/server/releases/nextcloud-15.0.0.zip# yum -y install wget unzip# unzip nextcloud-15.0.0.zip12[root@host html]# chown -R apache:apache /var/www/html/nextcloud[root@host html]# chmod -R 775 /var/www/html/nextcloud¶5. 配置apache虚拟目录1[root@host html]# vim /etc/httpd/conf.d/vhost.conf12345678910&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/html" ServerName example.com ServerAlias www.example.com &lt;Directory "/var/www/html/"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;1[root@host html]# systemctl restart httpd #重启apache¶6. 配置nextcloud用户名和密码一定要记住，数据目录默认即可，数据库的用户名和密码根据自身情况而定;数据库名任意，nextcloud会自动创建这个数据库，不必要人为创建；数据库如果是在操作的vps上，url可写成localhost:3306你可以添加外部存储到nextcloud中，例如谷歌云，这样的话你就可以轻松地同步nextcloud和谷歌云了，想要完成这个挂载的过程，先决条件是先将谷歌云挂载到vps中，让nextcloud可以访问谷歌云。具体教程可参考之前写过的一篇文章《通过Rclone挂载Google Drive到VPS》。挂载完成后就可以添加外部存储到nextcloud了，具体步骤如下：1.开启外部存储功能，2.配置外部存储目录。如下图 :更多内容请查看https://docs.nextcloud.com/server/15/admin_manual/installation/source_installation.html#example-installation-on-centos-7-server]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>rclone</tag>
        <tag>nextcloud</tag>
        <tag>centos7</tag>
        <tag>私有云盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Rclone挂载Google Drive到VPS]]></title>
    <url>%2Ftools%2Frclone.html</url>
    <content type="text"><![CDATA[Rclone 是一款的命令行工具，支持在不同对象存储、网盘间同步、上传、下载数据。例如它可以轻松挂载Google Drive到你的VPS（当然，他还能够挂载其他服务商的网盘，具体查看官网文档），让你可以方便的使用云盘里的资源。¶1. 安装 Rclone12[root@host ~]# yum -y install unzip[root@host ~]# curl https://rclone.org/install.sh | sudo bash¶2. 配置Rclone123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117[root@host ~]# rclone config #输入rclone config命令进行配置2019/01/02 22:07:50 NOTICE: Config file "/root/.config/rclone/rclone.conf" not found - using defaultsNo remotes found - make a new onen) New remotes) Set configuration passwordq) Quit confign/s/q&gt; n #选择n创建新的远端name&gt; mydriver #给创建的远端命名，比如mydriverType of storage to configure.Enter a string value. Press Enter for the default ("").Choose a number from below, or type in your own value 1 / A stackable unification remote, which can appear to merge the contents of several remotes \ "union" 2 / Alias for a existing remote \ "alias" 3 / Amazon Drive \ "amazon cloud drive" 4 / Amazon S3 Compliant Storage Providers (AWS, Ceph, Dreamhost, IBM COS, Minio) \ "s3" 5 / Backblaze B2 \ "b2" 6 / Box \ "box" 7 / Cache a remote \ "cache" 8 / Dropbox \ "dropbox" 9 / Encrypt/Decrypt a remote \ "crypt"10 / FTP Connection \ "ftp"11 / Google Cloud Storage (this is not Google Drive) \ "google cloud storage"12 / Google Drive \ "drive"13 / Hubic \ "hubic"14 / JottaCloud \ "jottacloud"15 / Local Disk \ "local"16 / Mega \ "mega"17 / Microsoft Azure Blob Storage \ "azureblob"18 / Microsoft OneDrive \ "onedrive"19 / OpenDrive \ "opendrive"20 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \ "swift"21 / Pcloud \ "pcloud"22 / QingCloud Object Storage \ "qingstor"23 / SSH/SFTP Connection \ "sftp"24 / Webdav \ "webdav"25 / Yandex Disk \ "yandex"26 / http Connection \ "http"Storage&gt; 12 #选择要挂载到vps上的第三方云盘，由于这里挂载的是谷歌云盘，故选择12** See help for drive backend at: https://rclone.org/drive/ **Google Application Client IdLeave blank normally.Enter a string value. Press Enter for the default ("").client_id&gt; #回车Google Application Client SecretLeave blank normally.Enter a string value. Press Enter for the default ("").client_secret&gt; #回车Scope that rclone should use when requesting access from drive.Enter a string value. Press Enter for the default ("").Choose a number from below, or type in your own value 1 / Full access all files, excluding Application Data Folder. \ "drive" 2 / Read-only access to file metadata and file contents. \ "drive.readonly" / Access to files created by rclone only. 3 | These are visible in the drive website. | File authorization is revoked when the user deauthorizes the app. \ "drive.file" / Allows read and write access to the Application Data folder. 4 | This is not visible in the drive website. \ "drive.appfolder" / Allows read-only access to file metadata but 5 | does not allow any access to read or download file content. \ "drive.metadata.readonly"scope&gt; 1 #选择1，赋予rclone操作云盘可读可写的权限ID of the root folderLeave blank normally.Fill in to access "Computers" folders. (see docs).Enter a string value. Press Enter for the default ("").root_folder_id&gt; #回车Service Account Credentials JSON file path Leave blank normally.Needed only if you want use SA instead of interactive login.Enter a string value. Press Enter for the default ("").service_account_file&gt; #回车Edit advanced config? (y/n)y) Yesn) Noy/n&gt; n #是否高级配置，选n不配置Remote configUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine or Y didn't worky) Yesn) Noy/n&gt; n #是否使用自动配置，选n不配置If your browser doesn't open automatically go to the following link: https://accounts.google.com/o/oauth2/auth?access_type=offline&amp;client_id=202264815644.apps.googleusercontent.com&amp;redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;response_type=code&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fdrive&amp;state=8b3264ffe950d2e850968a091bffd93e#打开浏览器输入以上https://....链接并以挂载的谷歌云盘对应的账号登陆验证，如下图：1234567891011121314151617181920212223242526272829303132Log in and authorize rclone for accessEnter verification code&gt; 4/xw**************************nyI #复制以上获得的验证码到此处Configure this as a team drive?y) Yesn) Noy/n&gt; y #输入y确认Fetching team drive list...No team drives found in your account--------------------[mydriver]type = drivescope = drivetoken = &#123;"access_token":"ya29.GluGBpBlg_NP0xWOUyj75-nT0LH2-kEuVlMtGESyZSxWbMqELF3uB5dAVfl9L8voIaMT2bRBYS2x15mG175TIb5yk08wWqH2DCwLBmhy_podqrtfl5q6TNoIRKRB","token_type":"Bearer","refresh_token":"1/0jso0O697nu0nBYKZZXRwCD50b6o97uCbeB_Sbt2E8aj3ZKDkik9OlzKe-0GvLGh","expiry":"2019-01-02T23:11:47.082006585-05:00"&#125;--------------------y) Yes this is OKe) Edit this remoted) Delete this remotey/e/d&gt; y #输入y确认Current remotes:#添加名称为mydriver的谷歌云盘到vps成功Name Type==== ====mydriver drivee) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; q #输入q退出¶3. vps挂载谷歌云盘123456789101112131415161718192021[root@host ~]# mkdir -p /data/GoogleDrive #先创建一个目录作为云盘的挂载点[root@host ~]# rclone mount mydriver:share /data/GoogleDrive --allow-other --allow-non-empty --vfs-cache-mode writes &amp; #执行挂载命令，其中mydriver是配置Rclone时设置的远端云盘名称；share是谷歌云（mydriver）上的一个目录(确保先创建一个这样类似的目录)；/data/GoogleDrive是vps上的挂载点，或者说是共享文件夹[1] 8327[root@host ~]# 2019/01/02 22:14:30 Fatal error: failed to mount FUSE fs: fusermount: exec: "fusermount": executable file not found in $PATH#遇到以上错误执行此命令安装fuse[root@host ~]# yum -y install fuse[root@host ~]# rclone mount mydriver:share /data/GoogleDrive --allow-other --allow-non-empty --vfs-cache-mode writes &amp; #再次执行挂载命令[1] 8337[root@host ~]# df -h #查看是否挂载成功Filesystem Size Used Avail Use% Mounted ondevtmpfs 238M 0 238M 0% /dev......mydriver:share 1.0P 33G 1.0P 1% /data/GoogleDrive #表示挂载成功📚 更多挂载命令请查看官方文档¶4. 设置开机自动挂载执行完以上操作虽然已经挂载成功，但是只是临时挂载，如果重启服务器或者关机就失效了，所以还有要完成以下任务。如果rclone不在/usr/bin/目录的话（可以通过which rclone命令查询是否在这个目录），需要先把rclone的可执行文件复制到/usr/bin。新建一个rclone.service文件：1vi /usr/lib/systemd/system/rclone.service写入：12345678910[Unit]Description = rclone[Service]User = rootExecStart = /usr/bin/rclone mount mydriver:share /data/GoogleDrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000Restart = on-abort[Install]WantedBy = multi-user.target注意：以上ExecStart的内容&quot;mydriver:share /data/GoogleDrive&quot;要结合你挂载的情况来定。123456#重载daemon，让新的服务文件生效systemctl daemon-reload#启动rclonesystemctl start rclone#设置开机启动：systemctl enable rclone重启你的VPS，然后查看一下rclone的服务起来没，接着查看一下盘子挂上去没：123456789#重启reboot#查看状态systemctl status rclone#查看磁盘挂载情况df -h#如果需要可以通过下面的命令关闭rclone#systemctl stop rclone¶5. 测试1234[root@host ~]# echo "hello world" &gt; /data/GoogleDrive/hello.txt[root@host ~]# ls /data/GoogleDrive/hello.txt/data/GoogleDrive/hello.txt[root@host ~]#在 Google Drive 刷新看看]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>rclone</tag>
        <tag>nextcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习笔记]]></title>
    <url>%2Flinux%2Fto_learn_linux.html</url>
    <content type="text"><![CDATA[这个笔记比较全面的记录了本人学习Linux的过程，内容还是比较系统、全面的。学习参考的文档以及教程来源繁多，但都吸取了其中比较好的精华，并在此基础上有所拓展深入。本次笔记更多还是在于Linux命令使用上的总结，对于日后的运维学习必定有所帮助…¶一、概念Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。但大体上分类为RedHat系列和Debian系列。所以本文档主要是使用CentOS并辅助性地掺杂Ubuntu一起进行讲述的。¶1. 终端命令格式Linux 刚面世时并没有图形界面，所有的操作全靠命令完成。对于命令的使用需要注意其格式。1command [-options] [parameter]说明：command：命令名，相应功能的英文单词或单词的缩写[-options]：选项，可用来对命令进行控制，也可以省略parameter：传给命令的参数，可以是 零个、一个 或者 多个[] 代表可选¶2. 查阅命令的帮助文档信息可通过在命令后加--help选项或者在命令的前面添加man命令来查看相关命令的帮助文档信息。¶2.1 --help1234#显示command命令的帮助信息command --help#--help可简写为-hcommand -h¶2.2 man12#查阅command命令的使用手册man commandman 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明使用 man 时的操作键：操作键功能空格键显示手册页的下一屏Enter 键一次滚动手册页的一行b回滚一屏f前滚一屏q退出/word搜索 word 字符串💡 提示：初级阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索¶二、基础命令由于Linux命令实在太多，下面先介绍最最常用的通用基本操作命令。后面章节会扩展性地讲述其他命令。1234567891011121314151617181920#查看当前文件夹下的内容,listls#查看当前所在文件夹,print wrok directorypwd#切换文件夹,change directorycd [目录名]#如果文件不存在，新建文件,touchtouch [文件名]#创建目录,make directorymkdir [目录名]#删除指定的文件名,removerm [文件名]#清屏,clearclear¶三、命令操作技巧在使用终端命令的过程中，使用一些操作技巧可以辅助我们更有效率地完成工作。¶1. 放大终端窗口的字体显示ctrl + shift + =¶2. 缩小终端窗口的字体显示ctrl + -¶3. 自动补全在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键。如果输入的没有歧义，系统会自动补全，如果还存在其他 文件／目录／命令，再按一下 tab键，系统会提示可能存在的命令。¶4. 终端历史命令切换按 上／下 光标键可以在曾经使用过的命令之间来回切换¶5. 退出执行中的命令如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c¶四、文件管理¶1. 文件系统¶Windows 文件系统在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符：每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：¶Linux 文件系统¶Linux目录结构在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）：Ubuntu 没有盘符这个概念，只有一个根目录 /，所有子目录和文件都在它下面¶Linux主要目录介绍/：根目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始，当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录。/bin、/usr/bin：可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。/boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱。/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有：/etc/inittab/etc/fstab/etc/init.d/etc/X11/etc/sysconfig/etc/xinetd.d/home：存放系统中用户的主目录。新增用户账号时，用户的主目录默认为/home目录下的一个用户同名的子目录中。如Linux系统存在用户test，则test用户的主目录为： /home/test~ 符号表示当前用户的主目录路径。/lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。/mnt 、/media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom下，但也不一定，可以选择任意位置进行挂载。/opt：给主机额外安装软件所摆放的目录/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo/proc/interrupts/proc/dma/proc/ioports/proc/net//root：系统管理员root的主要目录。/sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount等。与/bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。/usr：应用程序存放目录：/usr/bin：存放应用程序/usr/share：存放共享数据/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件/usr/local：存放软件升级包/usr/share/doc：系统说明文件存放目录/usr/share/man：程序说明文件存放目录/var：放置系统执行过程中经常变化的文件：/var/log：随时更改的日志文件/var/spool/mail：邮件存放的目录/var/run：程序或服务启动后，其 PID 存放在该目录下¶2. 常用命令¶1）列出目录文件（ls、tree）123456#列出目录文件ls#树状形式列出目录文件#选择-d：只显示目录treels 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS下的 dir 命令常用选项：-a：显示指定目录下所有子目录与文件，包括隐藏文件-l：以列表方式显示文件的详细信息-h：配合 -l 以人性化的方式显示文件大小通配符的使用：*：代表任意个数个字符?：代表任意一个字符，至少 1 个[abc]：匹配 a、b、c 中的任意一个[a-f]：匹配从 a 到 f 范围内的的任意一个字符Linux 下文件和目录的特点：Linux 文件 或者 目录 名称最长可以有 256 个字符以 . 开头的文件为隐藏文件，需要用 -a参数才能显示.代表当前目录.. 代表上一级目录计算机中文件大小的表示方式单位英文含义字节B（Byte）在计算机中作为一个数字单元，一般为 8 位二进制数千K（Kibibyte）1 KB = 1024 B，千字节 （1024 = 2 ** 10）兆M（Mebibyte）1 MB = 1024 KB，百万字节千兆G（Gigabyte）1 GB = 1024 MB，十亿字节，千兆字节太T（Terabyte）1 TB = 1024 GB，万亿字节，太字节拍P（Petabyte）1 PB = 1024 TB，千万亿字节，拍字节艾E（Exabyte）1 EB = 1024 PB，百亿亿字节，艾字节泽Z（Zettabyte）1 ZB = 1024 EB，十万亿亿字节，泽字节尧Y（Yottabyte）1 YB = 1024 ZB，一亿亿亿字节，尧字节¶2）切换目录（ cd ）12345678910#切换到/usr/local/share目录里cd /usr/local/share#切换到当前用户的主目录(/home/用户目录)cd ~ #或：cd#保持在当前目录不变cd .#切换到上级目录cd ..#在最近两次工作目录之间来回切换cd -cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一。注意：Linux 所有的 目录 和 文件名 都是大小写敏感的。关于相对路径和绝对路径的说明：相对路径 在输入路径时，最前面不是 / 或者**~**，表示相对 当前目录 所在的目录位置绝对路径 在输入路径时，最前面是 /或者~，表示从 根目录/家目录 开始的具体目录位置¶3）创建和删除操作（touch、mkdir、rm）1234567891011#创建文件touch filename.txt#创建目录mkdir test-dir#删除文件或目录#-f：强制删除，忽略不存在的文件，无需提示#-r：递归地删除目录下的内容，删除文件夹时必须加此选项rm -f filename.txt #强制删除filename.txt文件rm -rf test-dir #强制删除目录以及其内容¶4）拷贝和移动文件（cp、mv）1234567891011121314151617##复制文件或者目录#-i：覆盖文件前提示#-r：若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名cp 源文件 目标文件##移动文件或者目录 或 重命名# mv命令（mv英文：move）可以用来移动文件或目录，也可以给文件或目录重命名#-i：覆盖文件前提示mv 源文件 目标文件#示例 1：将一个目录移动为另一个目录 #如果目标目录已经存在，则将原目录移动到已存在的目标目录里面 #如果目标目录不存在，则将原目录移动为一个新的目标目录（即目录重命名）mv source_dir dest_dir #移动过程包括所有文件（含隐藏文件）#示例 2：将一个目录中的所有文件（包括隐藏文件）移动到另一个目录mv source_dir/* dest_dir/ #移动过程包括仅包括所有非隐藏文件mv source_dir/.* dest_dir/ #移动过程包括仅包括所有隐藏文件¶5）查看文件内容（cat、more 、grep、tail）¶（1）cat 查看文件的所有内容cat （concatenate）命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能。cat 会一次显示所有的内容，适合 查看内容较少 的文本文件。12#查看hello.txt文件的所有内容cat hello.txt常用选项：-b：覆对非空输出行编号-n：对输出的所有行编号Linux 中还有一个 nl 的命令和 cat -b 的效果等价¶（2）more 分屏显示文件内容more 命令可以用于分屏显示文件内容，每次只显示一页内容适合于 查看内容较多的文本文件12#分屏显示hello.txt文件内容more hello.txt使用 more 的操作键：操作键功能空格键显示手册页的下一屏Enter 键一次滚动手册页的一行b回滚一屏f前滚一屏q退出/word搜索 word 字符串¶（3）grep 搜索文本文件内容Linux 系统中 grep 命令是一种强大的文本搜索工具。grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式。12#显示匹配包含qcmoke字符串的行及行号grep -n qcmoke hello.txt命令选项：-n：显示匹配行及行号-v：显示不包含匹配文本的所有行（相当于求反）-i：忽略大小写常用的两种模式查找：^a： 行首，搜寻以 a 开头的行ke$：行尾，搜寻以 ke 结束的行¶（4）tail 取出文件后面几行12345678#取出文件后面10行tail hello.txt# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：tail -n 20 /etc/nginx/nginx.conf#侦测文件尾部10行tail -n 10 -f ~/logs/web2019-10-10.log命令选项：-n：后面接数字，代表显示几行的意思-f：侦测文件尾部，要等到按下[ctrl]-c才会结束tail的侦测即，如果文件尾部内容被更改，也会随着显示最新尾部内容，常用于查看日志。¶6）查找文件（ find ）find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件1234567891011121314151617181920#搜索主目录下，文件名包含hello的文件find ~ -name "hello*"#搜索/etc目录下，所有以.conf为扩展名的文件find /etc -name "*.conf"#搜索/home目录下，以数字1开头的文件find /home ~ -name "1*"#-type f: 只查找普通文件；-not -name 排除文件名包含 “test” 字符串的文件find /path/to/dir -type f -name "*.txt" -not -name "*test*"#使用 -not -path 参数排除不符合条件的目录find . -name "node_modules" -not -path "./test/*"#查找出当前目录及所有子目录下的文件大小大于1G且小于3G的所有文件，并显示出其文件大小 # -type d 表示查找的对象是目录 # -exec du -h &#123;&#125; \; 表示对找到的每个目录执行 du -h 命令，&#123;&#125; 会被替换为找到的目录路径。find . -type f -size +1G -size -3G -exec du -h &#123;&#125; \;说明：-name pattern: #按照文件名匹配模式查找文件。例如 -name “*.txt” 查找扩展名为 .txt 的文件。-iname pattern: #类似 -name，但是不区分大小写。-type type: #根据文件类型查找文件，type 可以为 f (普通文件)、d (目录)、l (符号链接) 等。-mtime n: #查找在 n 天前被修改过的文件，n 为负数表示查找 n 天内被修改过的文件。-size n[bck]: #查找文件大小为 n 的文件，单位为字节（默认）、块或千字节。b 表示块，c 表示千字节。-user name: #查找属于指定用户名的文件。-group name: #查找属于指定用户组的文件。-perm mode: #查找权限与指定参数 mode 匹配的文件。mode 可以为类似 644 这样的八进制数，也可以为类似 u=rw,g=r,o=r 这样的符号表示法。-exec command {} \;: #对每个找到的文件执行 command 命令。其中 {} 表示当前匹配到的文件名，; 表示命令结束。-not expr: #对表达式 expr 求反，即排除满足条件的文件。-path pattern: #查找路径名匹配模式的文件。例如 -path “/home/user/*.txt” 查找 /home/user/ 目录下所有扩展名为 .txt 的文件。如果省略路径，表示在当前文件夹下查找¶7）查看目录或文件占用大小（ du ）12345678910#递归查看目录及其子目录的大小（不含非目录的文件大小）du -h [目录名]#查看指定目录的总大小（不含子目录和文件大小）du -sh [目录名]#查看目录、子目录、文件的大小du -ah [目录名]#查看目录下所有一级子目录、文件的大小du -ah --max-depth=1 [目录名]#查看目录下所有一级子目录、文件的大小，并进行倒序排序du -ah --max-depth=1|sort -nr [目录名]说明：-s：只显目录的总大小，不显示每个子目录和文件的大小。-a：列出所有文件和子目录的大小，而不仅仅是目录。-h：以人类可读的方式显示文件大小，例如：1K、4.5M、2G 等。-b：以字节为单位显示文件大小。-c：同时显示多个文件或目录的总大小。-x：不递归处理指定目录下的子目录。¶8）链接（ ln ）¶简要概述¶软链接123#创建文件的软链接，用通俗的方式讲类似于Windows下的快捷方式。#删除软链接不会影响源文件，但源文件被删除了，那么软连接就不可用了ln -s &lt;被链接的源文件绝对路径&gt; &lt;链接文件路径&gt;软链接的特点：（1）软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式（2）软链接可以 跨文件系统 ，硬链接不可以（3）软链接可以对一个不存在的文件名进行链接（4）软链接可以对目录进行链接注意：（1）没有 -s 选项建立的是一个 硬链接文件（对于硬链接文件，两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接）（2）被链接的源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用¶硬链接12#删除硬链接，不会影响源文件,同样的删除源文件也不会影响硬链接,只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放ln 被链接的源文件 链接文件硬链接的特点：（1）硬链接，以文件副本的形式存在。但不占用实际空间。（2）不允许给目录创建硬链接（3）硬链接只有在同一个文件系统中才能创建说明：在 Linux 中，文件名 和 文件的数据 是分开存储的在 Linux 中，只有文件的 硬链接数 == 0 才会被删除使用 ls -l 可以查看一个文件的硬链接的数量在日常工作中，几乎不会建立文件的硬链接，知道即可¶9）打包 和 解包（ tar ）tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件12345# 打包文件（不压缩）tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar选项说明c：生成档案文件，创建打包文件x：解开档案文件v：列出归档解档的详细过程，显示进度f：指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后注意：f 选项必须放在最后，其他选项顺序可以随意¶10）压缩 和 解压缩¶（1）gzipgzip 是linux中常见的压缩/解压工具，最常见的使用对象是*.gz格式的文件。OPTIONS-c --stdout --to-stdout 结果写到标准输出，原文件保持不变-d --decompress --uncompress 解压-k --keep 压缩或者解压过程中，保留原文件-r --recursive-t --test 检查压缩文件的完整性-v --verbose 显示每个文件的名子和压缩率-&lt;压缩效率&gt; 压缩效率是一个介于1－9的数值，预设值为&quot;6&quot;，指定愈大的数值，压缩效率就会愈高。–best 此参数的效果和指定&quot;-9&quot;参数相同。–fast 此参数的效果和指定&quot;-1&quot;参数相同。示例1，压缩文件原文件名为file1.txt，压缩后原文件消失，压缩后文件名为file1.txt.gz12345root@ubuntu:/tmp# ls -l file1.*-rw-r--r-- 1 root root 12383865 Aug 21 08:08 file1.txtroot@ubuntu:/tmp# gzip file1.txtroot@ubuntu:/tmp# ls -l file1.*-rw-r--r-- 1 root root 134416 Aug 21 08:08 file1.txt.gz示例2，解压文件123root@ubuntu:/tmp# gzip -d file1.txt.gzroot@ubuntu:/tmp# ls -lh file1.*-rw-r--r-- 1 root root 12M Aug 21 08:08 file1.txt示例3，压缩的时候，显示压缩率12root@ubuntu:/tmp# gzip -v file1.txtfile1.txt: 98.9% -- replaced with file1.txt.gz示例4，一条命令压缩多个文件，压缩之后，是各自分开的：12345root@ubuntu:/tmp# gzip file1.txt file2.txtroot@ubuntu:/tmp# ls -ltotal 1348-rw-r--r-- 1 root root 134416 Aug 21 08:08 file1.txt.gz-rw-r--r-- 1 root root 392 Aug 21 08:15 file2.txt.gz示例5，压缩过程中，保留原文件123root@ubuntu:/tmp# gzip -k file1.txtroot@ubuntu:/tmp# ls file1.*file1.txt file1.txt.gz示例6，压缩到标准输出中可以连接两个文件123root@ubuntu:/tmp# cat file1.txt file2.txt | gzip &gt; foo.gz或者root@ubuntu:/tmp# gzip -c file1.txt file2.txt &gt; foo.gz¶（2）gunzip解压gz格式文件（不保留压缩文件）12345[root@localhost test]# lstest1.txt.gz test2.txt.gz[root@localhost test]# gunzip test1.txt.gz test2.txt.gz [root@localhost test]# lstest1.txt test2.txt¶（3）tar 和 gzip命令结合可以使用实现文件打包和压缩tar 只负责打包文件，但不压缩用 gzip 压缩 tar 包后，其扩展名一般用 xxx.tar.gz在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能命令格式如下：1234567891011121314151617#压缩文件gzip test1.txt test2.txt #会生成 test1.txt.gz test2.txt.gz#压缩tar包gzip 打包文件名.tar #从tar包变成tar.gz压缩包，这个过程不会保留原来放入tar包# 打包并压缩文件tar -zcvf 打包文件名.tar.gz 被压缩的文件／路径... #自动先完成将各个文件打包生成xxx.tar，后压缩生成xxx.tar.gz# 解压缩并解包tar -zxvf 打包文件名.tar.gz #自动先完成将xxx.tar.gz解压缩生成xxx.tar，后完成解包生成各个文件# 解压缩并解包，解压时去除一个顶级目录层次tar -zxvf 打包文件名.tar.gz --strip-components=1# 解压缩并解包到指定路径tar -zxvf 打包文件名.tar.gz -C 目标路径常用选项：-C：解压缩到指定目录，注意：要解压缩的目录必须存在--strip-components=1：解压时去除一个顶级目录层次¶（4）bzip2tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 类似）tar 只负责打包文件，但不压缩，用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能命令格式如下：12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...# 解压缩文件tar -jxvf 打包文件.tar.bz2¶（5）zip 和 unzipzip 是一个常用的命令行工具，用于在 Linux 和类Unix系统上创建和管理ZIP压缩文件。命令常用选项-r：递归压缩，即压缩目录-j：仅存储文件，不包含目录路径。在压缩包中只保留文件名。-u：仅更新压缩包中的新文件和修改过的文件。-d：从压缩包中删除指定的文件或目录。-l：显示压缩包中的文件列表，不解压缩。-q：安静模式，不显示任何输出。-v：显示详细的压缩过程信息。-C &lt;目录&gt;：在创建压缩包之前切换到指定目录。-x &lt;模式&gt;：排除匹配模式的文件或目录。-z：压缩时显示进度百分比。-e：加密压缩包。-P &lt;密码&gt;：设置压缩包的密码。-T：测试压缩包的完整性。123456789101112131415161718192021#压缩文件zip test.zip test1.txt test2.txt#递归压缩目录zip -r test.zip /opt/test/#注意压缩目录，压缩包里的目录结构会默认保留目标目录的完整路径，如果希望使用想对路径，那么应该cd到目标目录后再通过相对路径来压缩cd /opt &amp;&amp; zip -r test.zip test/#加密压缩zip -r -e -P 123456 my_archive.zip my_directory#实战示例cd /optrm -f backup-*zip -r -e -P 123456 "backup-$(date +'%Y%m%d%H%M%S').zip" \./* \-x "./containerd/*" \-x "./blog/*" \-x "./temp/*" \-x "*/logs/*" \-x "*/log/*"unzip 是一个常用的命令行工具，用于解压缩 ZIP 压缩包常用选项：-d &lt;目标目录&gt;：指定解压缩的目标目录，将压缩包中的文件提取到指定目录。-l：显示压缩包中的文件列表，不解压缩。-o：覆盖目标目录中已存在的文件，而不进行确认提示。-q：安静模式，减少输出信息。-v：显示详细的解压缩过程信息。-x &lt;模式&gt;：排除匹配模式的文件，不进行解压缩。-P &lt;密码&gt;：指定密码来解压缩。-j：解压缩时跳过目录路径，将文件直接提取到当前目录。1234567#默认解压到当前目录unzip test.zip#解压到指定目录unzip test.zip -d path#解密并解压缩unzip -P 123456 my_archive.zip¶11）重定向（ &gt; 和 &gt;&gt; ）Linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出或者追加到指定文件中。1234#覆盖输出内容到文件中echo "hello" &gt; test.txt#追加内容到文件中echo "hello" &gt;&gt; test.txt&gt; 表示输出，会覆盖文件原有的内容&gt;&gt; 表示追加，会将内容追加到已有文件的末尾¶12）管道（ | ）Linux 允许将 一个命令的输出可以通过管道做为另一个命令的输入。使用操作如下：12ps -ef | grep nginxmore test.txt | grep hello可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读）¶13）统计（ wc ）wc（Word Count）命令用于统计文件的行数、单词数和字节数等信息12345678910111213141516wc [选项] 文件列表##示例1：wc example.txt#输出如下：# 2 5 28 example.txt#分别表示 2 行、5 个单词、28 个字节。#如果执行 wc -l example.txt，则只输出行数，如下：# 2 example.txt##示例2：#统计某个目录下的所有以 .mp4 结尾的文件数量ls -l /path/to/dir | grep '\.mp4$' | wc -l#递归地统计某个目录下的所有以 .mp4 结尾的文件数量find /path/to/dir -type f -name "*.mp4" | wc -l常用选项：-l：只显示行数。-w：只显示单词数。-c：只显示字节数。¶3. 文件权限管理在 Linux 系统中，不同的用户对于不同的系统资源拥有不同的使用权限。在 Linux 中，可以指定每一个用户针对不同的文件或者目录的不同权限。文件(目录)的权限包括如下：序号权限英文缩写数字代号01读readr402写writew203执行excutex1¶1. 文件的详细信息12#查看文件夹下文件的详细信息（目录也是一种文件）ls -l打印结果从左到右依次是：权限，第 1 个字符如果是 d 表示目录硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件拥有者，家目录下 文件／目录 的拥有者通常都是当前用户组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲大小最后修改时间名称¶2. 设置文件权限12345678# 设置文件或目录的所属用户和用户组chown user:group file# 递归修改文件|目录所属的用户组chgrp -R group file# 递归修改文件或目录的操作权限chmod -R 755 filechmod 在设置操作权限时，可以简单地使用三个数字分别对应：所属用户、所属用户组、 和其他用户的权限12# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx file常见数字组合有（u表示用户／g表示组／o表示其他）：777 ===&gt; u=rwx,g=rwx,o=rwx755 ===&gt; u=rwx,g=rx,o=rx644 ===&gt; u=rw,g=r,o=r¶3. 文件属性模式¶lsattrlsattr 命令用于显示文件的属性，使用方式如下1234# 查看file.sh 文件的属性lsattr file.sh# 查看当前目录下所有文件以及文件夹的属性lsattr详细说明请参考：📚https://www.runoob.com/linux/linux-comm-lsattr.html¶chattrchattr 用于修改文件属性。1chattr [-RV][-v&lt;版本编号&gt;][+&#x2F;-&#x2F;&#x3D;&lt;属性&gt;][文件或目录...]选项：-R 递归处理，将指定目录下的所有文件及子目录一并处理。-v &lt;版本编号&gt; 设置文件或目录版本。-V 显示指令执行过程。+&lt;属性&gt; 开启文件或目录的该项属性。-&lt;属性&gt; 关闭文件或目录的该项属性。=&lt;属性&gt; 指定文件或目录的该项属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下几种模式：a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。该命令请切换至 root 用户下使用。12345678# 为 file.sh 文件增加 i 标识chattr +i file.sh# 为 file.sh 文件去除 i 标识chattr -i file.sh# 为 file.sh 增加 i, a 两个标识chattr +ia file.sh# 为 file.sh 文件移除 i, a 两个标识chattr -ia file.sh详细说明请参考：📚https://baike.baidu.com/item/chattr/9841067?fr=aladdin📚https://www.runoob.com/linux/linux-comm-chattr.html¶文件属性模式相关问题Linux 文件/文件夹无法删除问题解决方案服务器黑客攻击后，如果他们对某些文件（例如病毒文件）的属性模式进行修改，导致我们无法轻易删除这些文件，同时采用 root 用户也可能无法使用rm命令删除，那么这就会带来巨大的隐患问题。案例：假设黑客使用如下命令对文件的属性模式进行了修改。1chattr +ia file.sh那么使用如下rm命令是没有权限删除的。即使是 root 用户也无法删除。1rm -rf file.sh这种情况就涉及到chattr命令相关的文件属性模式了。由上文中得知当文件设置 i 和 a 任意一个属性我们就无法对文件进行删除操作，那么只要我们移除掉 i, a 属性，然后执行rm命令删除就可以了。123456# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 删除文件rm -rf file.sh如果文件还未删除成功，则我们需要考虑文件所属的文件夹是否设置了 i 或 a 属性（这一点确实很难发现）12345# 退回上一级cd ..# 直接使用 lsattr 命令，这样可以列出当前文件夹下所有文件和文件夹的属性# 不要使用 lsattr 文件夹 这样的语法，这样是列出该文件夹下的文件的属性lsattr如果文件夹被设置则对文件夹的属性执行移除操作，然后再删除文件夹里面的文件¶五、用户管理¶1. 基本概念在 Linux 系统中，不论是本机或是远程登录系统，每个系统都必须拥有至少一个用户。用户是 Linux 系统工作中重要的一环，用户管理包括用户与组管理。为了方便用户管理，Linux有组的概念，组的意义在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限。¶2. 用户组维护12345678#添加组groupadd 组名#删除组groupdel 组名#查看组信息cat /etc/group提示：用户组信息保存在 /etc/group 文件中。在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限。¶3. 用户维护¶1）创建用户1234567891011121314151617181920212223242526272829303132333435#创建用户useradd 用户名#显式创建用户时自动创建用户同名的用户组并添加用户到该组中useradd -U 用户名#创建用户时不自动创建用户同名的用户组，则系统会默认添加用户到系统默认的组中useradd -N 用户名#系统默认的组配置在/etc/default/useradd里，可通过如下命令查看：cat /etc/group | grep ":$(grep .*GROUP /etc/default/useradd | sed 's/.*GROUP=//'):"#创建用户时指定用户组 #-g: 指定将用户添加到的组（默认为用户同名的用户组） #-G: 指定将用户添加到的多个组useradd -g 组 用户名useradd -G 组1,组2 用户名#创建用户时自动创建用户主目录useradd -m 用户名#创建用户时不自动创建用户主目录useradd -M 用户名#创建用户时配置登录的Shell路径useradd -s /bin/bash 用户名#创建用户时进行密码设置useradd -p 密码#创建用户时指定用户的主目录，可以使用-d或--home参数，后面跟上想设定的主目录路径，如下：useradd -m -d /你的路径/用户名 用户名#创建用户和同名用户组，不自动创建用户主目录，禁止该用户登录系统useradd -U -M -s /usr/sbin/nologin 用户名关于useradd命令说明：自动创建用户同名的用户组：在Redhat类系统和Debain类系统中，都默认会自动创建用户同名的用户组并添加用户到该组中（如果不需要自动创建则需加选项：-N，则系统会默认添加用户到系统默认的组中）。自动创建用户主目录：在Redhat类系统中，默认会自动创建用户主目录（如果不需要创建则加选项：-M），而Debain类系统中不会自动创建（如果需要自动创建则需加选项：-m）。自动配置登录的 Shell 路径：在Redhat类系统和Debain类系统中，都默认会自动配置登录的 Shell 路径（默认为：/bin/bash，自定义登录的 Shell 路径可加选项及参数：-s &lt;path&gt;）密码设置：在Redhat类系统和Debain类系统中，都默认不会进行密码设置（如果需要设置可加选项及参数：-p &lt;password&gt;）。关于adduser命令的说明：在Redhat类系统中，adduser与useradd两个命令是相同的。在Debain类系统中，adduser与useradd有所不同，adduser是基于useradd的上层命令，主要表现在adduser默认会自动创建用户主目录，默认会提示密码设置。¶2）设置用户密码12#设置用户密码，如果是普通用户，直接用 passwd 可以修改自己的账户密码passwd 用户名¶3）查看系统的用户信息12345#查看系统中的所有用户信息cat /etc/passwd #新建用户后，用户信息会保存在 /etc/passwd 文件中cat /etc/passwd | grep 用户名提示：/etc/passwd 是用于保存用户信息的文件；而/usr/bin/passwd 是用于修改用户密码的程序。/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是用户名密码（x，表示加密的密码）UID（用户标识）GID（组标识）用户全名或本地帐号家目录登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash¶4）删除用户12345#删除用户时（默认不会自动删除用户的主目录，默认会删除用户的同名用户组）userdel 用户名#删除用户时自动删除用户的主目录userdel -r 用户名¶5）查看系统用户信息12345678#查看用户 UID 和 GID 信息,默认当前用户id [用户名]#查看当前所有登录的用户列表who#查看当前登录用户的账户名whoami¶6）修改用户组和登录的Shellusermod命令可以用来设置 用户的主组、附加组和登录的Shell，命令格式如下：12345678# 修改用户的主组,通常在新建用户时指定，在/etc/passwd的第4列GID对应的组usermod -g 组 用户名# 修改用户的附加组,在/etc/group中最后一列表示该组的用户列表，用于指定用户的附加权限usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 用户名提示：设置了用户的附加组之后，需要重新登录才能生效！¶7）切换用户12345678## 1、切换用户（su） #su 是 substitute user 的缩写，表示切换用户，默认为 root #切换用户后，将启动新的 shell 会话，可通过命令 echo $$ 查看“当前会话 ID”的方式来验证 #可指定 -, -l, --login 表示使用登录方式启动一个新的 shell 会话来来切换用户。 #示例：su - 或 su - test1 #如果不指定，则切换用户后新的 shell 会话仍然属于前一个用户，可通过命令 echo $USER 来查看“当前用户”的方式验证su [username]#如：su test1 或 su - test1su 切换用户示意图如下：¶4. 超级用户权限维护Linux 系统中的 root 用户是超级用户，通常用于系统的维护和管理，对操作系统的所有资源具有所有访问权限，在大多数版本的 Linux 中，都不推荐直接使用 root 账号登录系统，在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户称为 “标准用户”。1234567891011121314151617181920## 1、以超级用户权限执行（sudo） #sudo 表示以超级用户权限执行，即允许普通用户在不切换到超级用户（root）的情况下以 root 用户权限执行命令 #执行 sudo 命令时，要求当前用户必须为 sudo 用户组 #使用 sudo 命令时，必须先输入 root 用户的密码 #使用 sudo 后有 5 分钟的有效期限，超过期限则必须重新输入密码sudo &lt;command&gt;#如：sudo ls /root## 2、添加某用户到 sudo 用户组 #在 Debian 系列系统中，默认使用名为 sudo 的用户组来管理 sudo 访问权限；在 Red Hat 系列系统中，默认使用名为 wheel 的用户组来管理 sudo 访问权限 #具体管理 sudo 访问权限的用户组名称可在 /etc/sudoers 文件中确定（可通过 visudo 命令直接打开该文件) #由于 Debian 系列系统和 Red Hat 系列系统管理 sudo 访问权限的用户组名称不同，所以对于不同发行版系统操作类似但不一定相同，具体如下：#（1）先切换到 root 用户su#（2）对于 Debian 系列系统 apt install -y sudo #如果没有 sudo 命令，则需要先安装usermod -a -G sudo &lt;username&gt; #添加某用户到 sudo 用户组，如：usermod -a -G sudo test1#（3）对于 Redhat 系列系统 yum install -y sudo #如果没有 sudo 命令，则需要先安装usermod -a -G wheel &lt;username&gt; #添加某用户到 sudo 用户组，如：usermod -a -G wheel test1¶5. 用户登录维护¶1）查看当前登录到系统上的用户信息12#查看当前登录到系统上的用户信息who示例：1234[root@vm35218 ~]# whoroot pts/0 2023-06-17 09:45 (183.11.72.163)root pts/1 2023-06-17 09:45 (183.11.72.163)qcmoke pts/2 2023-06-17 10:00 (183.11.72.163)¶2）查看系统中所有用户的最近登录信息lastlog命令可用于显示每个用户最后一次登录的日期、时间、终端位置和IP地址等信息。1234567#查看系统中所有用户的最近登录信息lastlog#如果执行命令失败，提示：/var/log/lastlog: 没有那个文件或目录。则如下解决：touch /var/log/lastlogchgrp utmp /var/log/lastlogchmod 664 /var/log/lastlog示例：1234567891011121314151617181920212223242526[root@vm35218 ~]# lastlog用户名 端口 来自 最后登陆时间root pts/1 183.11.72.163 六 6月 17 09:45:58 +0800 2023bin **从未登录过**daemon **从未登录过**adm **从未登录过**lp **从未登录过**sync **从未登录过**shutdown **从未登录过**halt **从未登录过**mail **从未登录过**operator **从未登录过**games **从未登录过**ftp **从未登录过**nobody **从未登录过**systemd-network **从未登录过**dbus **从未登录过**polkitd **从未登录过**sshd **从未登录过**postfix **从未登录过**chrony **从未登录过**gluster **从未登录过**git **从未登录过**qcmoke pts/2 183.11.72.163 六 6月 17 10:00:40 +0800 2023dockremap **从未登录过**nginx **从未登录过**¶3）查看系统中用户的完整登录历史记录last命令可用于显示每个用户最后一次登录的日期、时间、终端位置和IP地址等信息。12345#查看系统中所有用户的完整登录历史记录last#查看系统中指定用户的完整登录历史记录last root示例：123456789101112131415161718192021222324252627282930313233343536[root@vm35218 ~]# lastqcmoke pts/2 183.11.72.163 Sat Jun 17 10:00 still logged in root pts/1 183.11.72.163 Sat Jun 17 09:45 still logged in root pts/0 183.11.72.163 Sat Jun 17 09:45 still logged in root pts/1 183.11.73.129 Thu Jun 15 23:39 - 00:22 (00:43) root pts/0 183.11.73.129 Thu Jun 15 23:39 - 00:22 (00:43) root pts/1 183.11.72.5 Mon Jun 12 21:54 - 21:54 (00:00) root pts/0 183.11.72.5 Mon Jun 12 21:54 - 21:54 (00:00) root pts/1 183.11.72.5 Mon Jun 12 21:32 - 21:32 (00:00) root pts/0 183.11.72.5 Mon Jun 12 21:32 - 21:32 (00:00) root pts/1 183.11.72.5 Mon Jun 12 12:45 - 15:02 (02:16) root pts/0 183.11.72.5 Mon Jun 12 12:45 - 15:02 (02:16) root pts/1 183.11.72.5 Mon Jun 12 02:38 - 06:33 (03:54) root pts/0 183.11.72.5 Mon Jun 12 02:38 - 06:33 (03:54) root pts/1 183.11.75.79 Sun Jun 11 19:03 - 19:03 (00:00) root pts/0 183.11.75.79 Sun Jun 11 19:03 - 19:03 (00:00) root pts/1 183.11.75.79 Sun Jun 11 18:43 - 18:43 (00:00) root pts/0 183.11.75.79 Sun Jun 11 18:43 - 18:43 (00:00) qcmoke pts/2 183.11.75.79 Sun Jun 11 03:49 - 03:49 (00:00) root pts/1 183.11.75.79 Sun Jun 11 02:12 - 04:32 (02:19) root pts/0 183.11.75.79 Sun Jun 11 02:12 - 04:32 (02:19) root pts/1 183.11.75.79 Sun Jun 11 00:18 - 02:12 (01:53) root pts/0 183.11.75.79 Sun Jun 11 00:18 - 02:12 (01:53) reboot system boot 5.13.5-1.el7.elr Sun Jun 11 00:18 - 10:17 (6+09:59) root pts/2 183.11.75.79 Sun Jun 11 00:01 - down (00:16) root pts/0 183.11.75.79 Sun Jun 11 00:01 - down (00:16) root pts/2 183.11.75.79 Sat Jun 10 19:31 - 00:01 (04:30) root pts/0 183.11.75.79 Sat Jun 10 19:31 - 00:01 (04:30) root pts/2 183.11.75.79 Sat Jun 10 16:08 - 19:31 (03:22) root pts/0 183.11.75.79 Sat Jun 10 16:08 - 19:31 (03:22) root pts/2 183.11.75.79 Sat Jun 10 15:53 - 16:06 (00:12) root pts/0 183.11.75.79 Sat Jun 10 15:53 - 16:06 (00:12) root pts/2 183.11.75.79 Sat Jun 10 14:25 - 15:48 (01:23) root pts/0 183.11.75.79 Sat Jun 10 14:25 - 15:48 (01:23) root pts/2 183.11.75.79 Sat Jun 10 11:01 - 12:37 (01:36) root pts/0 183.11.75.79 Sat Jun 10 11:01 - 12:37 (01:36)¶4） 踢出登录用户12345#选择登录终端并强制踢出，例如选择踢出使用终端pts/1登录的用户。#方法一：pkill -kill -t pts/1#方法二：fuser -k /dev/pts/1案例1234567#先列举当前登录的系统用户[root@VM_0_6_centos ~]# whoroot pts/0 2020-02-28 10:50 (163.125.117.95)root pts/1 2020-02-28 10:49 (163.125.117.95)#选择登录终端并强制踢出,可以给他发送后再踢出[root@VM_0_6_centos ~]# echo "你被管理员踢出了" &gt; /dev/pts/1 &amp;&amp; fuser -k /dev/pts/1/dev/pts/1: 23381¶六、软件管理¶1. 软件管理简介¶1.1 包全名与包名包全名：操作的包是没有安装的软件包时，使用包全名。包名：操作已经安装的软件包时使用的包名。linux安装后包名都存在/var/lib/rpm/中的数据库¶1.2 Linux包依赖性树形依赖：a&gt;b&gt;c环形依赖：a&gt;b&gt;c&gt;a模块依赖：模块依赖软件安装的过程：（1）cp类库到系统目录中（2）cp可执行程序和配置文件到系统目录中（3）根据需要选择性配置和启动服务（程序）对于windows系统还会多出一个步骤，那就是到把启动配置或者程序依赖的配置放到注册表中。¶1.3 常见软件包命名原则（1）Debian 软件包格式：apache2_2.4.18-2ubuntu3_amd64.debapache2：软件包名2.4.18 ：软件版本2：软件发布的次数ubuntu3：适合的系统版本amd64：适合的硬件平台deb：Debian 软件包扩展名（2）RPM 软件包格式：httpd-2.2.15-15.el6.centos.1.i686.rpmhttpd：软件包名2.2.15：软件版本15：软件发布的次数el6.centos：适合的系统版本i686：适合的硬件平台.rpm：RPM 软件包扩展名¶1.4 linux软件包优先级Required该级别软件包是保证系统正常运行所必须的，如果缺失，系统将毁坏系统工具，比如bash，mount…Important若缺少该软件包，系统讲运行困难实现系统底层功能的一些程序，比如aptitude,apt-getStandardlinux系统的标准件常规安装软件，如telnet.tpOptional该软件包是否安装不影响linux运行用于用户特定的需求，比如×11，mysql，openofice，自开发软件等Extra该级别可能与高级软件包存冲突¶2. Debain 系列系统的软件管理¶1）dpkg 本地包管理器¶（1）安装12#i表示installdpkg -i 软件包全名¶（2）卸载12#r表示removedpkg -r 软件包名 #移除包不移除配置文件12#-P等价于--purg，表示移除包和配置文件dpkg -P 软件包名 #移除包和配置文件¶（3）查询12345dpkg -l 软件包名 #列出当前系统中已经安装的包，包括软件的版本，可以使用dpkg -l | grep 关键字来查询dpkg -L 软件包名 #列出已安装的包的内容，或者安装位置dpkg -c 软件包全名 #列出deb包的内容dpkg -s 软件包名 #查看系统中软件的详细信息 （包含依赖信息）dpkg --info 软件包全名 #查看未安装的包的信息（包含依赖信息）¶2）apt 在线包管理器APT（Advanced Package Tool）是基于 dpkg 的在线包管理工具，它提供了高级的软件包管理功能，包括包的安装、升级、删除和依赖解决等。APT 通过与软件包仓库进行交互，从远程仓库获取软件包信息并管理软件包的安装和更新。APT 提供了一些常用的命令行工具：apt-get：用于安装、升级、卸载软件包，以及处理依赖关系和软件包的下载等。apt-cache：用于查询软件包的信息，如版本、依赖关系、提供的文件等。apt-config：用于管理 APT 的配置文件。apt-key：用于管理软件包的数字签名和密钥。apt-file：用于查询软件包中的文件列表。aptitude：一个功能更强大的终端界面的包管理工具，提供交互式的软件包管理功能。由于 APT 提供的工具集太多，使用太繁杂，故而新版 Debian 系列系统使用 apt 命令来包含囊括apt-get 、apt-cache 命令，故而现在推荐使用apt命令来替代apt-get等命令。¶（1） apt 软件源¶（1.1）修改 Ubuntu 软件源为国内源123456789101112131415161718192021222324252627282930##切换到root用户sudo -i##安装相关依赖（如系统未安装）apt updateapt install -y ca-certificates##备份cp /etc/apt/sources.list /etc/apt/sources.list_backup##替换软件源（支持所有ubuntu18.04或更高的系统版本）MIRRORS_URL=https://mirrors.aliyun.com #阿里源（推荐）#MIRRORS_URL=https://mirrors.163.com #网易源VERSION_CODENAME=$(cat /etc/os-release | grep VERSION_CODENAME | sed 's/.*=//') #系统版本代号cat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb $MIRRORS_URL/ubuntu/ $VERSION_CODENAME main restricted universe multiversedeb-src $MIRRORS_URL/ubuntu/ $VERSION_CODENAME main restricted universe multiversedeb $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-security main restricted universe multiversedeb-src $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-security main restricted universe multiversedeb $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-updates main restricted universe multiversedeb-src $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-updates main restricted universe multiverse# deb $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-proposed main restricted universe multiverse# deb-src $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-proposed main restricted universe multiversedeb $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-backports main restricted universe multiversedeb-src $MIRRORS_URL/ubuntu/ $VERSION_CODENAME-backports main restricted universe multiverseEOF##更新软件源apt update参考：https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.1ecc1b11jbngYS通过apt update更新软件源到本地并在本地建立新远程软件库所有软件包对应的索引表(数据库形式)，所有存放在/var/lib/apt/lists/*¶（1.2）修改 Debian 软件源为国内源1234567891011121314151617181920212223242526272829##切换到root用户#如果sudo命令没有，则通过root用户安装sudo，如：apt install sudosudo -i##安装相关依赖（如系统未安装）apt updateapt install -y ca-certificates##备份cp /etc/apt/sources.list /etc/apt/sources.list_backup##替换软件源（支持所有debian系统版本）MIRRORS_URL=https://mirrors.aliyun.com #阿里源（推荐）#MIRRORS_URL=https://mirrors.163.com #网易源#MIRRORS_URL=http://deb.debian.org #官方源VERSION_CODENAME=$(cat /etc/os-release | grep VERSION_CODENAME | sed 's/.*=//') #系统版本代号cat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb $MIRRORS_URL/debian/ $VERSION_CODENAME main non-free contribdeb-src $MIRRORS_URL/debian/ $VERSION_CODENAME main non-free contribdeb $MIRRORS_URL/debian-security/ $VERSION_CODENAME-security maindeb-src $MIRRORS_URL/debian-security/ $VERSION_CODENAME-security maindeb $MIRRORS_URL/debian/ $VERSION_CODENAME-updates main non-free contribdeb-src $MIRRORS_URL/debian/ $VERSION_CODENAME-updates main non-free contribdeb $MIRRORS_URL/debian/ $VERSION_CODENAME-backports main non-free contribdeb-src $MIRRORS_URL/debian/ $VERSION_CODENAME-backports main non-free contribEOF##更新软件源apt update参考：https://www.cnblogs.com/liuguanglin/p/debian11_repo.htmlhttps://developer.aliyun.com/article/765348https://developer.aliyun.com/mirror/debian?spm=a2c6h.13651102.0.0.7fb11b11YdBUCMhttps://mirrors.ustc.edu.cn/repogen/¶（2）查询1234567891011121314151617181920212223242526272829#根据关键字搜索可用软件包（等价：apt-cache search 软件包关键字）apt search 软件包关键字#查询某个命令所属的安装包（命令所属的软件包安装或未安装都可以查询）apt install apt-fileapt-file updateapt-file search 命令路径 #如：apt-file search /sbin/ifconfig（注意：apt-file search 不支持使用通配符查询）#列出所有可用软件包apt list#列出已经安装的所有软件包apt list --installed#列出已经安装的指定软件包apt list --installed &lt;package-name&gt; #或者apt list --installed | grep 关键字#列出可更新的所有软件包apt list --upgradable##查看安装包的信息（包括：名称、版本、安装源、包大小、依赖关系、描述等）apt show &lt;package-name&gt;##查看软件包政策（包括版本信息、源信息等）apt policy &lt;package-name&gt;#检查当前apt的依赖情况apt check#查看系统中软件的依赖（正向依赖）apt depends &lt;package-name&gt;#查看系统中软件的依赖（反向依赖）apt rdepends &lt;package-name&gt;可使用apt-cache子命令来实现查询功能，推荐使用apt命令来查询，其兼容apt-cache。¶（3） 安装12345678910#安装指定的软件包（选项：-y 自动回答yes） #该命令安装包前不会自动检测软件源的本地缓存，故安装前最好手动执行apt update命令apt install &lt;package-name&gt;#修复系统中存在的依赖关系问题（尝试安装缺失的依赖包、删除不再需要的依赖包、修复已损坏的依赖关系等）apt -f install#获得包的源码apt source &lt;package-name&gt;apt install工作步骤扫描本地软件列表软件包依赖检查从软件包指定的 apt 源中下载软件包解压软件包并完成配置默认情况下，apt install 在成功安装软件包后会自动删除下载的软件包文件。如果需要获取软件包文件可如下操作：1234567891011121314151617#方式1：下载软件包 #下载路径为：/var/cache/apt/archives/ （不能修改） #该命令下载软件包会强制包括依赖包 #该命令只下载不安装 #只有在系统未安装有软件包时才能下载，如果已经安装了，则无法下载。如果非要下载则只能改用apt download命令，或者卸载包后再下载。apt install -d &lt;package-name&gt;#等同：apt install --download-only &lt;package-name&gt;#方式2：下载软件包 #下载路径为：当前目录（不能修改） #该命令下载软件包不会包括依赖包，如需下载依赖包请选用apt install -d &lt;package-name&gt; #无论系统是否已经安装有软件包都能下载apt download &lt;package-name&gt;#示例：apt install -d nginxapt download nginx¶（4） 更新12345678#更新软件源的本地缓存（本地缓存：源的软件列表和包的元数据，元数据：包的信息和包的依赖关系，包的信息：版本号、更新日期、作者、描述等）apt update#升级更新指定软件包apt upgrade &lt;package-name&gt;#升级更新系统所有软件包（升级已安装的软件包，但不会删除或安装其他依赖包）apt upgrade#升级更新系统所有软件包（除了升级已安装的软件包，会删除或安装其他依赖包）apt dist-upgrade💁‍♂ 提示：以上更新升级操作只是升级当前系统版本的软件包（包括内核版本，通常升级的默认内核版本一般都较低，如需升级更高版本的内核则需要手动安装）。需要说明的是不会升级系统的版本，如果要升级系统版本则需要使用新版本的系统镜像重装系统。¶（5） 卸载12345678910111213#卸载软件包（不含配置文件）apt remove &lt;package-name&gt;#卸载软件包（含配置文件）,命令等价：apt remove --purge &lt;package-name&gt;apt purge &lt;package-name&gt;#卸载指定的软件包，并自动删除其依赖包中不再需要的依赖包apt remove --auto-remove &lt;package-name&gt;#卸载系统中所有不再需要的依赖包apt auto-remove#清除已下载的软件包文件的缓存 #这些包文件通常被存储在 /var/cache/apt/archives 目录下。执行 apt clean 会删除该目录中的所有 .deb 文件 #在Debian系列系统中，通过apt安装或更新的软件，默认会自动保留.deb包缓存文件在缓存目录中。如果希望自定义是否默认保留包缓存文件可参考：https://blog.csdn.net/FoxBryant/article/details/123226245apt clean💁‍♂ 提示：不再需要的依赖包是指不再被其他软件包所依赖的包。¶3. Redhat 系列系统的软件管理¶1）rpm 本地包管理器¶（1）安装12#-i（install）安装; -v（verbose）显示详细信息; -h（hash）显示进度; -nodeps 不检测依赖性rpm -ivh &lt;package-name&gt;¶（2）升级12#-U（upgrade）升级(更新的是已安装版本的包)rpm -Uvh &lt;package-name&gt;¶（3）卸载12#-e（erase）卸载; -nodeps 不检查依赖性rpm -e &lt;package-name&gt;¶（4）查询包是否安装123#-q 查询（query）; -a 所有（all）rpm -q &lt;package-name&gt; #查询已经安装的具体包（不能使用通配符）rpm -qa #查询所有已经安装的包（可使用通配符筛选查询，如：rpm -qa kernel* 或 rpm -qa kernel kernel-*）¶（5） 查询软件包详细信息123456#-q 查询（query）; -i 查询软件信息（information）; -p 查询未安装包信息（package）rpm -qi &lt;package-name&gt; #例如：rpm -qi zip #查看系统中已经安装存在的包信息rpm -qip zip-3.0-23.fc29.x86_64.rpm #查看未安装包信息¶（6）查询软件包安装位置123#-q 查询（query）-l 列表（list）; -p 查询未安装包信息，用来查看未安装的软件包打算安装到哪些目录里rpm -ql &lt;package-name&gt; #查询已安装的软件安装到了哪些目录里rpm -qlp &lt;package-name&gt; #查询未安装的软件包打算安装到哪些目录里如果忘记包名，可以通过rpm -qa | grep 包名关键字先查看系统中已经安装的相关软件，然后再执行rpm -ql 包名来查看具体路径¶（7）查询系统文件所属的软件包123456#-f 查询系统文件属于哪个软件包（file）rpm -qf 系统文件名#示例：rpm -qf /usr/bin/bashrpm -qf /etc/yum.conf¶（8） 查询软件包的依赖性123#-R 查询软件包的依赖性（requires）;-p 查询未安装包信息（package）rpm -qR &lt;package-name&gt; #查询已安装包信息rpm -qRp &lt;package-name&gt; #查询未安装包信息¶（9） 软件包完整性校验123456789#比较已安装软件包的文件与原始软件包中的文件属性（例如文件大小、权限、MD5 校验和等）差异，如果有任何文件被修改、删除或者权限被更改，命令会显示出这些变化。#选项：-V 校验指定软件包中的文件（verify）rpm -V &lt;package-name&gt;# 示例：修改httpd的配置文件后，查看是否被修改$ yum install -y httpd$ echo "" &gt;&gt; /etc/httpd/conf/httpd.conf$ rpm -V httpdS.5....T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下：S：文件大小是否改变M：文件的类型或文件的权限（rwx）是否被改变5：文件MD5校验和是否改变（可以看成文件内容是否改变）D：设备的中，从代码是否改变L：文件路径是否改变U：文件的属主（所有者）是否改变G：文件的属组是否改变T：文件的修改时间是否改变文件类型c：配置文件（config file）d：普通文档（documentation）g：幽灵文件（ghost file），幽灵文件是指在 RPM 数据库中存在记录但在实际文件系统中不存在的文件l：授权文件（license file）r：描述文件（read me）软件包文件的完整性验证（注意和软件包完整性校验的区别）：12#验证软件包文件的完整性（注意是软件包文件，即：“.rpm文件”，主要检查软件包的签名）rpm --checksig &lt;package_file.rpm&gt;¶（10）从RPM包中提取文件12#提取软件包中的指定文件到当前目录rpm2cpio .rpm包文件的文件路径 | cpio -idv .rpm包文件中所需提取的文件的路径（可解压查看）rpm2cpio 是将rpm包转换为cpio格式的命令，cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件从RPM包中提取文件可以用来解决误删除系统文件后的补救方法，如下示例：123456789101112131415#查看ls命令文件所属的软件包（如：coreutils-8.22-24.el7_9.2.x86_64）rpm -qf /bin/ls#将ls命令到临时目录里，造成误删假象mv /bin/ls /tmp/#下载指定版本的软件包到当前目录yumdownloader coreutils-8.22-24.el7_9.2.x86_64# 可通过 yumdownloader -q --urls coreutils-8.22-24.el7_9.2.x86_64 获得软件包URL地址。#提取ls命令文件到当前目录下（-idv 后接的路径必须与rpm包中的路径相对应）rpm2cpio ./coreutils-8.22-24.el7_9.2.x86_64.rpm | cpio -idv ./usr/bin/ls#把ls命令复制/bin/目录，恢复丢失的文件cp ./usr/bin/ls /bin/¶2）yum 线包管理器yum 是基于 rpm 的在线包管理工具，它提供了高级的软件包管理功能，包括包的安装、升级、删除和依赖解决等。yum 通过与软件包仓库进行交互，从远程仓库获取软件包信息并管理软件包的安装和更新。¶（1）yum软件源centos 默认软件源改为阿里源（以 centos7 为例）123456789101112131415#先确保安装wget用于下载yum源文件yum install -y wget#备份旧的配置文件mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak#下载阿里源的文件#centos7wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#或者 curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.reposed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo#清理本地缓存（可选）#yum clean all#更新软件源的本地缓存（本地缓存：源的软件列表和包的元数据，元数据：包的信息和包的依赖关系，包的信息：版本号、更新日期、作者、描述等）yum makecache参考：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.534d1b11Q4rbUOyum 源配置说明：[base] 容器名称，一定要放在[ ]中,从以上文件可以看出centos7默认配置有4个容器，一般是第一个起作用name 容器说明，可以自己随便写mirrorlist 镜像站点，这个可以注释掉baseurl 我们的yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址enabled 此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效gpgkey 数字证书的公钥文件保存位置。不用修改安装 epel 源123456789yum install -y epel-releaseyum makecache#以上默认安装的 epel 源是国外的，速度比较慢，推荐改用国内的 epel 源（可选，推荐）cd /etc/yum.repos.d/mkdir backupmv epel*.repo backupwget -O epel.repo http://mirrors.aliyun.com/repo/epel-7.repoyum makecache参考：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11oOAPGqhttps://developer.aliyun.com/mirror/epel?spm=a2c6h.13651102.0.0.1d2e1b11NAraP4¶（2）查询123456789101112131415161718#根据关键字搜索可用软件包yum search 关键字#查询某个命令所属的安装包（命令所属的软件包安装或未安装都可以查询）yum provides 命令路径 #如：yum provides */ifconfig#列出所有可用软件包yum list#列出已安装的所有软件包yum list installed#列出已安装的指定软件包（可用于查看软件包是否已安装）yum list installed &lt;package-name&gt; #或者 yum list | grep 关键字##列出可更新的所有软件包yum list updates#查看安装包的信息（包括：名称、架构、版本、安装源、包大小、简介、描述等）yum info &lt;package-name&gt;¶（3）安装123#安装指定的软件包（选项：-y 自动回答yes） #该命令安装包前会自动检测软件源的本地缓存，如果过期则会自动更新软件源的本地缓存，故而不需要再手动执行yum makecache命令yum install &lt;package-name&gt;默认情况下，yum install 在成功安装软件包后会自动删除下载的 rpm 软件包文件。如果需要获取 rpm 软件包文件可如下操作：12345678910111213#方式1：下载软件包 #如不指定下载路径，则默认下载路径为当前目录 #该命令下载软件包默认不会包括依赖包，如需依赖包则加选项：--resolveyumdownloader --destdir=/path/to/directory &lt;package-name&gt;yumdownloader --destdir=/path/to/directory --resolve &lt;package-name&gt;#获得软件包URL地址yumdownloader -q --urls &lt;package-name&gt;#方式2：下载软件包 #如不指定下载路径，则默认下载路径为：/var/cache/yum/的子目录中，如centos764位系统为：/var/cache/yum/x86_64/7/updates/packages/ #该命令下载软件包会强制包括依赖包 #该命令只下载不安装yum install --downloadonly --downloaddir=/path/to/directory &lt;package-name&gt;¶（4）更新12345678910111213141516#升级更新指定的软件包（选项：-y 自动回答yes）yum update &lt;package-name&gt;#升级更新系统所有软件包（默认自动删除旧版包） #是否自动删除旧版包由/etc/yum.conf配置文件的obsoletes决定，1表示更新旧的rpm包的同时会删除旧包，0表示更新的时候不会删除旧包，yum update#升级更新系统所有软件包（自动删除旧版包） #yum upgrade等价于打开obsoletes配置的yum updateyum upgrade#升级更新系统所有软件包并排除某些包的更新#以下是单次更新时排除更新包，如果需要不加参数自动排除的话需要编辑/etc/yum.conf配置文件。在[main]的作用域内里加上这样一句话exclude=*NetworkManager*yum --exclude=exclude=*NetworkManager*,*firewalld* update💁‍♂ 提示：以上更新升级操作只是升级当前系统版本的软件包（包括内核版本，通常升级的默认内核版本一般都较低，如需升级更高版本的内核则需要手动安装）。需要说明的是不会升级系统的版本，如果要升级系统版本则需要使用新版本的系统镜像重装系统。💁‍♂ 提示：更新升级常见失败问题：如：yum update 出现 Multilib version problems 问题的解决方法123456789101112131415161718192021222324252627282930313233343536373839&gt;# 1、安装yum-complete-transaction&gt;yum install yum-utils&gt;# 2、运行yum-complete-transaction&gt;yum-complete-transaction –cleanup-only&gt;# 3、清除重复的包&gt;package-cleanup --dupes&gt;#清除重复包的老版本：&gt;package-cleanup --cleandupes&gt;# 4、清除损坏的包&gt;package-cleanup --problems&gt;#5、解决依赖冲突：如出现：firewalld-filesystem-0.6.3-13.el7_9.noarch 有已安装冲突 firewalld &lt; ('0', '0.3.13', None): firewalld-0.3.9-7.el7.noarch&gt;# 查询出重复的软件包,会查出来两个包含版本的完整包名&gt;rpm -q 冲突的包名称&gt;# 删除冲突包（一般是旧版本）&gt;rpm -e 包含版本的完整包名&gt;## 以下是示例：&gt;# 查询重复的软件包(假设systemd-libs出现了冲突)&gt;$ rpm -q systemd-libs&gt;systemd-libs-219-30.el7.x86_64&gt;systemd-libs-219-42.el7_4.1.x86_64&gt;# 删除旧版&gt;$ rpm -e systemd-libs-219-30.el7.x86_64&gt;error: Failed dependencies:systemd-libs = 219-30.el7 is needed by (installed) libgudev1-219-30.el7.x86_64&gt;# 仍然出现依赖问题，继续查询libgudev1的版本信息&gt;$ rpm -q libgudev1&gt;libgudev1-219-30.el7.x86_64&gt;# 发现只有一个版本，升级试一下&gt;$ yum update libgudev1&gt;......&gt;Updated:libgudev1.x86_64 0:219-42.el7_4.1 &gt;Complete!&gt;$ rpm -q libgudev1&gt;libgudev1-219-42.el7_4.1.x86_64&gt;# 升级完成后，删除旧版本的systemd-libs&gt;$ rpm -e systemd-libs-219-30.el7.x86_64&gt;$ rpm -q systemd-libs¶（5） 卸载12345678#卸载指定的软件包 #提示： #该命令会自动删除其依赖包中不再需要的依赖包（类似于：apt remove --auto-remove &lt;package-name&gt; ） #该命令默认情况下不会自动删除软件包的配置文件。如果希望删除则只能进行手动删除操作（配置文件通常位于/etc目录下）yum remove -y &lt;package-name&gt;#卸载系统中所有不再需要的依赖包yum autoremove💁‍♂ 提示：不再需要的依赖包是指不再被其他软件包所依赖的包。¶（6）软件组安装卸载组名可以由grouplist查询出来1234567891011121314#列出所有可用的软件组yum grouplist#安装指定软件组yum groupinstall 软件组名#如：yum groupinstall "Development tools"#卸载指定软件组yum groupremove 软件组名#清除已下载的软件包文件的缓存（可选） #删除/var/cache/yum目录里所有软件源对应packages目录里的RPM包文件 #提示：与Debian系列系统不同，在Redhat系列系统中，通过yum安装或更新的软件，默认会自动删除掉RPM包缓存文件，而不会保留在缓存目录里。是否保留由/etc/yum.conf配置文件里的keepcache字段决定（1：保留，0：不保留，默认）#yum clean packages¶4. Snap 在线包管理器¶1）安装 Snap12345678910111213141516171819202122232425##（1）安装snapd# apt安装（提示：ubuntu16.04之后的版本已经内置了snap，在debian系统上则需要手动安装）apt updateapt install -y snapd# yum安装（操作命令相对会多一些）yum install -y epel-releaseyum install -y snapd##（2）启动snad的套接字单元# 启动snapd套接字单元（注意套接字单元是snapd.socket，而不是snapd.service，其中snapd.service可简写为snapd）systemctl enable --now snapd.socket #等同于 systemctl enable snapd.socket &amp;&amp; systemctl start snapd.socket# 查看是否成功启动snapdsystemctl status snapd.socket##（3）需要注销并重新登录（重新打开终端即可）或重新启动系统以确保正确更新snap的路径##（4）安装snap核心包# 安装snap核心包snap install coresnap refresh core##（5）配置支持snap经典模式安装（仅yum安装snap时需要）# 说明：由于snap经典模式安装需要操作/snap目录。通过yum安装snapd时，snap所安装的经典包存放在/var/lib/snapd/snap目录中而非/snap目录，所以需要创建一个符号链接/snap指向到/var/lib/snapd/snap，否则snap只能安装标准包而无法安装经典包。而使用apt安装snapd时，snap所安装的经典包就存放在/snap目录中，故而不需要创建符号链接。ln -s /var/lib/snapd/snap /snapSnap 安装参考：https://snapcraft.io/docs/installing-snapd¶2）Snap 常用命令1234567891011121314151617181920212223242526272829303132333435#搜索 Snap 软件包snap find package-name##安装标准的 Snap 软件包#Snap 软件包通常是以沙箱方式运行的，这意味着它们受到严格的限制以增强安全性和隔离性。使用此命令安装的软件包将按照 Snap 的默认策略进行沙箱化。snap install package-name##安装经典 Snap 软件包#经典 Snap 软件包是一种特殊类型的 Snap 软件包，它们不会受到严格的沙箱限制。它们可以访问系统上的更多资源和文件，因此更接近传统的非 Snap 软件包。这种类型的 Snap 软件包通常用于需要更多系统级访问权限的应用程序，比如开发工具或服务器软件。snap install --classic package-name#卸载 Snap 软件包snap remove package-name#列出已安装的 Snap 软件包snap list#更新所有已安装的 Snap 软件包snap refresh#查看 Snap 版本信息snap version#查看 Snap 软件包信息snap info package-name#管理 Snap 服务snap enable service-name #启用 Snap 服务snap disable service-name #禁用 Snap 服务snap services #查看 Snap 服务#管理 Snap 用户权限snap connections package-name # 查看 Snap 软件包的连接信息snap connect package-name:interface-name # 允许 Snap 软件包访问特定接口snap disconnect package-name:interface-name # 禁止 Snap 软件包访问特定接口¶3）卸载 Snap12345678910111213#关闭snapd套接字单元（卸载前先停掉snapd套接字单元，否则卸载失败）systemctl stop snapd.socket##卸载snap#1、yum卸载yum remove -y snapd#删除残余目录或文件rm -rf /var/lib/snapd /snap ~/snap#2、apt卸载apt remove --purge -y snapd #如果不加--purge则需要手动删除/var/lib/snapd和/snap#删除残余目录或文件rm -rf ~/snap¶5. 源码包安装卸载（待续···）¶6. 通用更换系统软件源脚本（支持大部分 Linux 系统）1234567891011121314151617181920212223# 中国大陆（默认）# 执行命令后会交互式地提示选择软件源（可选源：阿里云、网易、清华大学源等）bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh)#或者：#bash &lt;(curl -sSL https://raw.githubusercontent.com/SuperManito/LinuxMirrors/main/ChangeMirrors.sh)# 中国大陆教育网（可选源：清华大学、北京大学、南京大学等）bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh) --edu# 海外地区（可选源：亚洲|香港|xTom、北美|美国|Linux Kernel、欧洲|英国|Vorboss Ltd 等）bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh) --abroad##常见选项说明：--abroad #使用海外软件源（选项值：无）--edu #使用中国大陆教育网软件源（选项值：无）--abroad #使用海外软件源（选项值：无）--use-official-source #使用操作系统官方软件源（选项值：无）--install-epel #安装 EPEL 附加软件包（选项值：true 或 false）--only-epel #仅更换 EPEL 软件源模式（选项值：无）--clean-cache #清理下载缓存（选项值：true 或 false）#更多选项参考：https://linuxmirrors.cn/use/command-options/适配 Linux 系统：Debian（8.0 ~ 13）、Ubuntu（14.04 ~ 24）、CentOS（7.0 ~ 8.5 / Stream 8 ~ 9）、 Rocky Linux（8 ~ 9）、Deepin（all）等参考：项目地址：https://github.com/SuperManito/LinuxMirrors官方文档：https://linuxmirrors.cn¶七、进程管理所谓 进程，通俗地说就是当前正在执行的一个程序。¶1. 列出当前进程信息 ps123456789101112#列出当前进程信息#-a或者-e:显示终端上的所有进程，包括其他用户的进程；-u:显示进程的详细状态；-x:显示没有控制终端的进程；-f:显示程序间的关系ps -auxps -ef#根据进程号查看进程的文件路径、启动命令的完整路径等等信息（比如nginx）ps -ef | grep nginxls -l /proc/10383#有几个主要的文件我们可以关注下：#cwd：文件所在目录#exe：执行命令的完整路径#environ：执行命令时的环境变量提示：ps 默认只会显示当前用户通过终端启动的应用程序。ps 命令主要显示的信息：PID：进程 ID，每个进程都有一个唯一的 PID。TTY：与进程关联的终端设备或伪终端。TIME：已经使用的 CPU 时间（或者启动时间），显示该进程占用 CPU 的时间量。CMD：命令名称或完整的命令行。选项说明：-a：显示所有用户的进程。这包括与终端关联的进程以及与其他用户关联的进程。-x：显示没有控制终端的进程。-u：显示指定用户的进程信息-e：显示系统中所有的进程-f：显示完整的格式，包括命令行-l：使用长格式显示进程信息aux：显示系统中所有用户的所有进程¶2. 查看系统内存使用情况 free123#显示系统的内存使用情况 #以更易读的方式展示出来。参数 -h 用于以人类可读的格式显示输出，例如以 GB、MB 等为单位。free -h¶3. 系统负载监控 top可实时查看系统的 CPU 使用率、内存使用量（含 Swap 虚拟内存使用量）、进程列表（程序允许命令）等，12345#top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于top 在执行一段时间可以更新正在运行的的进程。#要退出可以直接输入qtop#每隔10秒自动更新top -d 10常用的 top 快捷键：切换排序：P（即：Shift + p）：按 CPU 使用率进行排序M（即：Shift + m）：按内存使用量进行排序（按 e 键可以调整内存占用单位，比如以 MB 或 GB 为单位展示会更人性化 ）进程操作：k：杀死一个进程（需要输入相应的 PID）r：更改进程的优先级布局和显示：f：打开字段管理器，可以选择要显示的字段o：更改排序字段b：切换是否显示底部摘要信息全局操作：q：退出 top 命令¶4. 通过监听端口查询对应进程信息12345678##使用 netstat 命令来查看端口的对应进程信息（如：名称、PID 等） #-tuln 选项用于显示 TCP 和 UDP 监听状态的端口netstat -tuln | grep &lt;port&gt;##使用 lsof 命令来查看端口的占用情况apt install lsof # Debian/Ubuntuyum install lsof # Red Hat/CentOSlsof -i :&lt;port&gt;¶5. 终止进程 kill12#-9表示强行终止kill [-9] 进程代号提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃。¶6. 通过 PID 找出进程的对应文件路径12345678ls -l /proc/&lt;port&gt;/exe#示例（查询 sshd 服务的 PID，然后通过 PID 查询出 sshd 的完整文件路径）：$ ps -ef | grep sshd#root 14368 1 0 08:21 ? 00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups$ ls -l /proc/14368/exe#lrwxrwxrwx 1 root root 0 Jan 19 03:45 /proc/14368/exe -&gt; /usr/sbin/sshd¶7. 查看命令路径 which12345which 命令名称#例如：$ which useradd/usr/sbin/useradd在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin/bin（binary）是二进制执行文件目录，主要用于具体应用/sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理/usr/bin（user commands for applications）后期安装的一些软件/usr/sbin（super user commands for applications）超级用户的一些管理程序提示：cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置¶8. 查看进程树 pstree12345678#安装pstree安装包apt install psmisc#yum install psmisc#-p :显示进程的PID -u :显示进程的所属用户#树状的形式显示进程和pidpstree -p#树状的形式进程和对应操作用户¶9. 系统监控实用工具¶1）iftopiftop可测量通过每一个套接字连接传输的数据。iftop使用pcap库来捕获进出网络适配器的数据包，然后汇总数据包大小和数量，搞清楚总的带宽使用情况。虽然iftop报告每个连接所使用的带宽，但它无法报告参与某个套按字连接的进程名称/编号（ID）。不过由于基于pcap库，iftop能够过滤流量，并报告由过滤器指定的所选定主机连接的带宽使用情况。12345#安装apt install iftop#yum install iftop#使用iftop -nn选项可以防止iftop将IP地址解析成主机名，解析本身就会带来额外的网络流量。¶2）nloadnload是一个命令行工具，让用户可以分开来监控入站流量和出站流量。它还可以绘制图表以显示入站流量和出站流量，视图比例可以调整。用起来很简单。12345#安装apt install nload#yum install nload#使用nload¶3）htophtop是top的扩展版本，有更丰富的概貌（例如全命令、可视化、图形用户界面gui和用户界面ui），有鼠标点击交互（译者注：看下面的截图，指的是最上面的列标题如CPU%、MEM%等可以通过鼠标点击切换以显示不同的功能），也有许多的指导教你如何做进程管理。12345#安装apt install htop#yum install htop#运行htop¶4）iotopiotop – 简单的类似top的I/O监控器。iotop是IO实时监控器。使用它们附属的详细输入输出（IO）使用方法可以展示出你系统中每个进程线程的信息。该命令可以与$ tcpdump（响应网络流量的命令）一起使用。如果你发现你的web服务器上有程序在运行，你可以，比如运行$ tcpdump port 80检查端口80（标准的http端口）的网络流量来观察细节。最有用的信息可能是DISK WRITE这一列，从该列你可以准确的看到每个IO使用了多少个进程，单位为K/s。12345#安装apt install iotop#yum install iotop#运行 iotop¶5）glancesglances是一款由python开发的系统监控工具，可以实时查看CPU、内存、网络、IO、进程、磁盘空间使用率的使用情况，并且支持三种运行模式，个人感觉比top命令使用更便捷，有三种运行模式：Standalone、Client/Server、Web server。¶安装多种安装方式可选，如下：12345678#yum 安装yum -y install glances#apt 安装apt install glances #提示：如果 Debain 无法找到软件包，需添加 bullseye-backports 源#pip 安装pip install --user 'glances[all]'#一键脚本安装curl -L https://bit.ly/glances | /bin/bash参考：https://github.com/nicolargo/glances¶Standalone 模式可以查看系统运行详细情况。在运行glances时可以使用h键来查看glances快捷键使用方法。运行过程中，直接按回车键可以对进程进行过滤，查看指定进程。¶Client / Server 模式Server端：glances -s -B 192.168.1.1Client端：glances -c 192.168.1.1无须去指定服务器上运行，通过Client/Server端模式快速查看。-B：指定绑定的IP地址，如果不指定Server端运行端口默认端口为：61209，如果使用默认端口则用-c指定客户端时不需要额外使用-P参数来指定Server端的端口号。需要注意的是防火墙设置，确认两台主机之间端口可通。¶Web server 模式glances -w这个功能就很贴心了，我可以将集群中所有服务器上后台运行Web Server端，后续防火墙开放指定IP查看集群中服务器的运行状态，美滋滋。如果启动Web Server端时出现**“Bottle module not found. Glances cannot start in web server mode.”**报错，执行安装bottle即可解决。1pip install bottle¶配置文件glances是支持设置配置文件的，但是不一定要有配置文件才能使用glances，Linux中配置文件可以新建位置到/etc/glances/glances.conf，窗口中的不同颜色是由阈值来设定的，我们可以在配置文件中修改各监控项的阈值来实现不同级别不同颜色的展示情况。¶颜色级别定义绿色：正常(OK)蓝色：小心(CAREFUL)，需要注意紫色：警告（WARNING）红色：问题严重（CRITICAL）¶配置文件示例1234567891011vim /etc/glances/glances.conf[quicklook]cpu_careful=50cpu_warning=70cpu_critical=1mem_careful=50mem_warning=1mem_critical=90swap_careful=1swap_warning=70swap_critical=90这里我们为了展示出颜色的差异，特别修改了几个为1的值，实际使用中修改到需要的值即可。最终展示界面如上图所示。¶八、系统管理¶1. 关机和重启123456789101112131415161718# shutdown命令可用于关闭或重启系统（-r表示重启，不指定则表示1分钟后自动关闭系统）shutdown [-r] [时间]# 例如：#不指定-r则表示1分钟后自动关闭系统shutdown# 重新启动操作系统，其中 now 表示现在shutdown -r now# 立刻关机，其中 now 表示现在shutdown now# 系统在今天的 20:25 会关机shutdown 20:25# 系统再过十分钟后自动关机shutdown +10# 取消之前指定的关机计划shutdown -c# reboot命令可用于重启系统reboot #等效于shutdown -r now¶2. 查看系统配置查看CPU信息：使用lscpu命令可以显示有关CPU架构和相关信息。使用cat /proc/cpuinfo命令可以查看更详细的CPU信息。查看内存信息：使用free -h命令可以查看系统中的内存使用情况。使用cat /proc/meminfo命令可以获取更多的内存详细信息。查看磁盘信息：使用df -h命令可以查看系统中各个磁盘分区的使用情况。使用lsblk命令可以显示磁盘和分区的详细信息。¶3. 环境变量¶简要概述在 Linux 操作系统中设置环境变量，通常使用export 命令来实现。它可以将一个或多个变量从本地 shell （命令行解释器）的环境传递到子进程的环境中，以便让这些子进程也可以使用这些变量。在 Linux 中，每个进程都有一组环境变量。这些变量存储在进程空间中，并且可以在运行时由进程读取和修改。当您启动一个新的 shell 会话或者在当前 shell 会话中运行一个新的脚本时，该会话会继承父 shell 的环境变量。然而，如果您希望将变量传递给子进程，那么您需要将其标记为“导出”。💁‍♂ 变量和环境变量的区别：变量是 Shell 编程中最基本的元素之一。它们是用户定义的名称，用于保存一个或多个值或字符串，并在 Shell 脚本或命令中进行引用。变量的值可以是数字、字符串、文件名、路径名等。例如，在 Bash shell 中，您可以通过以下语法来定义变量：1name="Alice"这将创建一个名为 name 的变量，并将其设置为 “Alice”。环境变量是 Shell 环境中的特殊类型的变量，它们具有全局范围并可以被所有子进程访问。环境变量通常用于存储 Shell 和其他程序所需的共享信息，例如路径、语言设置、用户信息等。例如，在 Bash shell 中，您可以使用以下语法来设置环境变量：1export PATH=$PATH:/usr/local/bin这会将 /usr/local/bin 目录添加到系统的 PATH 环境变量中，以便 Shell 可以搜索该目录中的可执行文件。因此，变量和环境变量具有不同的作用和范围，并且通常用于不同的目的。在 Linux 中设置环境变量的方法有多种，下面将主要讲其中两种常见的方法。¶临时设置环境变量要在当前 shell 会话中设置一个临时环境变量，可以使用 export 命令。例如，要将 MY_VAR 的值设置为 my_value，可以执行以下命令：1export MY_VAR=my_value这将在当前 shell 会话中设置一个名为 MY_VAR 的环境变量，并将其值设置为 my_value。该变量只在当前会话中有效，关闭终端窗口或重启系统后就会自动清除。¶永久设置环境变量要在系统中永久设置一个环境变量，可以将其添加到 ~/.bashrc 、 ~/.bash_profile、/etc/profile 等脚本文件中，这样系统在某个特定情况下将会自动执行这些脚本以让脚本里设置的环境变量生效。下面以添加环境变量到~/.bashrc脚本文件为例讲解配置过程：12345678910#在文件最后加入变量cat &gt;&gt; ~/.bashrc &lt;&lt; 'EOF'export MY_VAR=my_valueEOF#使配置文件修改生效source ~/.bashrc#测试echo $MY_VAR💁‍♂ /etc/profile 等脚本文件说明：~/.bashrc：打开新的 Bash shell 会话时自动执行该脚本。该文件只适用于当前用户的 Bash shell，通常用于设置用户环境变量等配置。~/.bash_profile：如果系统默认shell是bash，用户登录时将自动执行该脚本。该文件只适用于当前用户的 Bash shell，通常用于设置用户环境变量等配置。/etc/profile：在系统引导时自动执行该脚本。该文件适用于所有用户和所有 Bash shell，通常用于设置全局环境变量等配置。💁‍♂ 注意：只要执行bash命令就会打开新的 Bash shell 会话。💁‍♂ 总结：开机启动系统，在系统引导时将自动执行/etc/profile脚本文件。等系统启动完成后用户就可以进行登录操作了，如果系统默认shell是bash，那么在用户登录时系统会自动执行bash命令来打开新的 Bash shell 会话，故而会自动执行~/.bash_profile和~/.bashrc脚本文件。但如果系统默认shell是sh、zsh等其他类型的shell，那么登录时将不会自动执行~/.bash_profile脚本，但当用户手动执行bash命令时是会自动执行~/.bashrc脚本文件的。💁‍♂ 建议：在 Linux 中，虽然~/.bashrc 、 ~/.bash_profile、/etc/profile 等脚本文件都能配置环境变量，但通常使用的话建议将环境变量配置到 ~/.bashrc 文件中。¶4. 系统版本和内核版本¶1）查看系统版本1234567891011121314151617181920212223##（1）通过 lsb_release 命令查看方式#安装依赖apt install lsb-release #Debian 系列系统（如：Debian、Ubuntu 等）yum install redhat-lsb-core #Red Hat 系列系统（如：CentOS、Fedora 等）#查看系统版本（通用，含系统名称、系统版本号、版本代号、描述等）lsb_release -a##（2）通过系统配置文件查看方式#查看系统版本（通用，含系统名称（ID）、系统版本号、版本代号、描述等）cat /etc/os-release#仅查看系统名称（ID）cat /etc/os-release | grep -oP '^ID=\K\S+'#仅查看系统版本号cat /etc/os-release | grep VERSION_ID | cut -d '=' -f 2 | sed 's/"//g'#仅查看系统版本代号cat /etc/os-release | grep VERSION_CODENAME | cut -d '=' -f 2#cat /etc/os-release | grep VERSION_CODENAME | awk -F '=' '&#123;print $2&#125;'#cat /etc/os-release | grep VERSION_CODENAME | sed 's/.*=//'¶2）查看内核版本1uname -r¶3）升级内核版本¶简要说明通过系统默认官方源在线升级的内核版本一般都不会太新，特别是一些老版本的系统（如：CentOS 7、Ubuntu 18.04 等）。由于为了让系统稳定，通常 Linux 发行商官方都会选择一些经过长期测试和使用的老版本内核，所以官方的软件源都不会提供太新的内核版本，如果非要使用更高版本的内核则应该通过其他方式安装升级，主要为如下几种方式：下载 Linux 新版内核进行编译安装使用第三方源进行在线安装（如：elrepo 源、XanMod 源等）使用已编译好的二进制包进行安装（建议通过一键脚本安装）温馨提示：使用非官方源安装的内核可能会导致系统不稳定，非必要情况当然更推荐使用官方源支持的内核版本，通常更高版本内核在对应 LInux 新版本中会得到更新的支持（如 Ubuntu 22.04 的官方源内核版本会比 Ubuntu 18.04 更新，如需更新内核版本应该考虑升级系统版本）。参考：Linux 内核在线升级、离线升级、定制升级https://zhuanlan.zhihu.com/p/75669680¶方式一：通过系统默认官方源在线升级的内核版本这种方式升级的版本为系统发行方维护的版本，通常版本较低12345678910111213141516171819202122232425262728293031323334353637383940414243##（1）CentOS/RedHat#更新内核版本yum update kernel#更新引导加载程序（必选，即设置使用新版内核启动，CentOS/RedHat 安装新版内核不会自动更新引导加载程序为最新内核） #如果需要使用其他版本内核可通过执行：egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \' 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面）grub2-set-default 0grub2-mkconfig -o /boot/grub2/grub.cfg #用于传统的BIOS引导#grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg #用于UEFI引导（如果使用的是 UEFI 引导，则应该更新的是 UEFI GRUB 配置）#重启服务器以使新版内核生效（必选）reboot##删除无用的旧内核版本（可选，为了节省磁盘空间建议删除）#查看已安装的所有内核版本rpm -qa kernel kernel-*#确认当前正在使用的内核uname -r#删除不需要的内核版本（将 &lt;kernel-package&gt; 替换为要删除的包名）yum remove &lt;kernel-package&gt;#更新引导加载程序配置（如果使用 GRUB 引导）grub2-mkconfig -o /boot/grub2/grub.cfg##（2）Ubuntu/Debian#列出可升级内核版本apt list --upgradable | grep linux-image#安装支持的新版内核apt install linux-image-generic#apt install linux-generic-hwe-18.04-edge #对于Ubuntu，在版本系统中可以安装指定系统版本（如Ubuntu 18.04）的hwe内核包，其版本通常比默认内核包版本高，但可能不稳定#更新引导加载程序（可选，即设置使用新版内核启动，Ubuntu/Debian 安装新版内核会自动更新引导加载程序为最新内核） #通常情况下，新内核的 GRUB 引导项会自动成为默认的引导项。 #如果需要使用其他版本内核可通过执行：grep 'menuentry' /boot/grub/grub.cfg 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面），然后修改 /etc/default/grub 中的 GRUB_DEFAULT 值（设要修改的内核索引顺序为 2，则修改为：GRUB_DEFAULT="1&gt; 2"），最后执行 update-grub 并 reboot 重启系统即可。参考：https://www.cnblogs.com/zzugyl/p/14588114.html #关机重启时一般会进入grub菜单，在菜单中可以选择指定版本的内核启动，如果启动时跳过不展示grub菜单，则可以在启动时按住Shift键或Esc键，直到出现GRUB菜单。update-grub#重启服务器以使新版内核生效（必选）reboot##删除无用的旧内核版本（可选，为了节省磁盘空间建议删除）#查看已安装的所有内核版本dpkg --list | grep linux-image#确认当前正在使用的内核uname -r#删除不需要的内核版本（将 &lt;kernel-package&gt; 替换为要删除的包名）apt purge &lt;kernel-package&gt;#更新引导加载程序配置update-grub¶方式二：使用第三方源在线安装较新版本的内核12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152##（1）CentOS/RedHat #参考：http://elrepo.org/tiki/HomePage、https://www.cccitu.com/oos583vx2.html#安装 elrepo 第三方软件源yum install -y elrepo-release#rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org #导入公钥#yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm #安装 CentOS7/RedHat7 的 elrepo 源#yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm #安装 CentOS8/RedHat8 的 elrepo 源#查看可更新内核版本yum --disablerepo="*" --enablerepo="elrepo-kernel" list available#安装最新版本内核（elrepo源有ml、lt两种内核。ml(mainline)为最新版本的内核，lt为长期支持的内核。）yum --enablerepo=elrepo-kernel install -y kernel-lt#更新引导加载程序（必选，即设置使用新版内核启动，CentOS/RedHat 安装新版内核不会自动更新引导加载程序为最新内核） #如果需要使用其他版本内核可通过执行：egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \' 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面）grub2-set-default 0grub2-mkconfig -o /boot/grub2/grub.cfg #用于传统的BIOS引导#grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg #用于UEFI引导（如果使用的是 UEFI 引导，则应该更新的是 UEFI GRUB 配置）#重启服务器以使新版内核生效（必选）reboot##删除无用的旧内核版本（可选，为了节省磁盘空间建议删除）#查看已安装的所有内核版本（仅含yum或rpm管理器安装的包，不含手动编译安装的包）rpm -qa kernel kernel-*#确认当前正在使用的内核uname -r#删除不需要的内核版本（将 &lt;kernel-package&gt; 替换为要删除的包名）yum remove &lt;kernel-package&gt;#更新引导加载程序配置（如果使用 GRUB 引导）grub2-mkconfig -o /boot/grub2/grub.cfg##（2）Ubuntu/Debian #参考：https://xanmod.org#安装 XanMod 源wget -qO - https://dl.xanmod.org/archive.key | gpg --dearmor -o /usr/share/keyrings/xanmod-archive-keyring.gpgecho 'deb [signed-by=/usr/share/keyrings/xanmod-archive-keyring.gpg] http://deb.xanmod.org releases main' | tee /etc/apt/sources.list.d/xanmod-release.list#安装最新版本内核apt updateapt install linux-xanmod-x64v3#更新引导加载程序（可选，即设置使用新版内核启动，Ubuntu/Debian 安装新版内核会自动更新引导加载程序为最新内核） #通常情况下，新内核的 GRUB 引导项会自动成为默认的引导项。 #如果需要使用其他版本内核可通过执行：grep 'menuentry' /boot/grub/grub.cfg 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面），然后修改 /etc/default/grub 中的 GRUB_DEFAULT 值（设要修改的内核索引顺序为 2，则修改为：GRUB_DEFAULT="1&gt; 2"），最后执行 update-grub 并 reboot 重启系统即可。参考：https://www.cnblogs.com/zzugyl/p/14588114.html #关机重启时一般会进入grub菜单，在菜单中可以选择指定版本的内核启动，如果启动时跳过不展示grub菜单，则可以在启动时按住Shift键或Esc键，直到出现GRUB菜单。update-grub#重启服务器以使新版内核生效（必选）reboot##删除无用的旧内核版本（可选，为了节省磁盘空间建议删除）#查看已安装的所有内核版本dpkg --list | grep linux-image#确认当前正在使用的内核uname -r#删除不需要的内核版本（将 &lt;kernel-package&gt; 替换为要删除的包名）apt purge &lt;kernel-package&gt;#更新引导加载程序配置update-grub¶方式三：使用已编译好的二进制包进行安装123456789101112131415#这里使用一键脚本安装方式 #脚本项目地址：https://github.com/ylx2016/Linux-NetSpeed #原功能是一键安装 BBR/BBRplus/锐速，可用于升级系统内核 #支持 CentOS 7/8，Debian/Ubuntu，OracleLinux #在国内执行脚本时可能无法正常下载新版内核等文件，故需要挂代理，并执行如下命令： # export http_proxy=http://192.168.31.74:1081 # export https_proxy=http://192.168.31.74:1081 #安装新版内核只需要选择 1. 安装 BBR原版内核，脚本会自动卸载旧版内核并安装最新版内核#下载脚本wget -O tcp.sh "https://github.com/ylx2016/Linux-NetSpeed/raw/master/tcp.sh"#执行脚本chmod +x tcp.sh./tcp.sh#删除脚本（升级完成内核后可选择删除脚本）rm -f ./tcp.sh¶方式四：下载内核源码手动编译安装这种方式可安装最新版或任意版本内核。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#1、安装依赖#Debian 系列系统安装所需依赖apt updateapt install build-essential #包含 make、gcc、g++ 等基础编译工具apt install libncurses-dev bison flex libssl-dev libelf-dev dwarves bc#RedHat 系列系统安装所需依赖yum groupinstall "Development Tools" #包含 make、gcc、g++ 等基础编译工具yum install ncurses-devel flex bison openssl openssl-devel elfutils-libelf-devel bc#2、下载指定版本的内核源码并解压 #到 Linux 内核官网 https://www.kernel.org 下载指定版本的内核源码包，建议下载 stable（稳定版）或者 longterm（长期维护版） #可使用代理下载：wget -e "https_proxy=http://192.168.31.74:1081" https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.5.8.tar.xzwget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.5.8.tar.xz tar xvf linux-6.5.8.tar.xzcd linux-6.5.8#3、配置所编译的内核（交互式操作生成编译配置文件.config） #centos7 等 yum 默认安装的 gcc 版本太低可能无法编译新内核，则需要手动安装更新 gcc 版本，建议使用 scl 工具管理多版本 gcc，参考：https://cloud.tencent.com/developer/article/1626791 #包括驱动、网络、文件系统等等 #勾选说明：* 表示为编译到内核镜像（主要生成的文件如：arch/x86/boot/bzImage、vmlinux 等），M 表示编译到内核模块，空表示不编译。（内核模块的作用是启动内核镜像时按需从镜像文件外部加载内核模块，这样可以有效减小内核镜像的大小和启动时间） #通常执行该命令时会自动参考当前系统内核（即原版本内核，当前系统内核配置：/boot/config-&lt;当前系统内核&gt;）自动勾选配置，也就是说原版本内核有的功能或模块在编译选项里将会被勾选，而如果原本没有则不会自动勾选。故而即使是同一个版本的内核源码在不同内核的 Linux 系统中所展示的默认配置勾选也可能不同。 # 1）通常使用原版本内核默认勾选的功能配置即可。 # 2）编译的内核通常都默认带有调试信息，那么内核和模块的文件将会很大，占用很多磁盘空间。建议去除这些内核调试信息，可有效减小内核模块和内核大小，节省存储空间。菜单导航：Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt; Disable debug information inking，按空格选择设置为 X 表示关闭调试信息，然后选择 Save -&gt; OK # 3）如果原本的系统内核功能不满足需求则需要额外勾选配置，常见功能如下： #（1）TCP BBR：需要内核为 4.9+，菜单导航：Networking support -&gt; Networking options -&gt; TCP: advanced congestion control -&gt; BBR TCP，按空格选择设置为 M 表示编译到内核模块，然后选择 Save -&gt; OK #（2）WireGuard：需要内核版本为 5.6+，菜单导航：Device Drivers -&gt; Network device support -&gt; Network core driver support -&gt; WireGuard secure network tunnel，按空格选择设置为 M 表示编译到内核模块，然后选择 Save -&gt; OK #自定义内核版本名称（可选，如：linux-6.5.8-test，默认为内核原始版本号，如：6.5.8），菜单导航：General setup -&gt; Local version - append to kernel release，输入自定义的内核版本名称并保存即可 # 4）菜单勾选确定后，选择 Exit 退出，选择 YES 保存配置到当期目录的 .config 文件里。make menuconfig#4、编译内核 #根据 .config 配置文件选择性进行编译 #可使用 -j 指定线程数加快编译，或者通过处理器核心数指定线程数：make -j$(nproc) #如果之前编译过，再编译则会很快 #可以通过 make clean 清理编译生成的临时文件（或者使用 make mrproper，区别是 make mrproper 会删除 .config 文件，而 make clean 不会） #内核编译时间通常都会比较久（通常需要几个小时，差不多2-3小时左右，计算机配置越高编译会越快，主要是CPU，如果使用虚拟机，最好分配多点核心数，如4个） #注意通常要求系统的磁盘剩余空间不低于 25G，否则编译产生的临时文件可能太多导致磁盘不够用而编译失败，建议总磁盘大小 40G 以上，当然，对于精简配置或者去除调试信息的情况对磁盘空间要求更低（如除调试信息的情况就只需要 10G 左右大小的磁盘剩余空间即可）。参考：https://forums.debiancn.org/t/topic/3120make -j4#5、安装内核make modules_install #安装内核模块（将相应的内核模块复制到系统/lib/modules/&lt;version&gt;目录里）make install #安装内核镜像（将.config，vmlinuz，initrd.img（make install时会自动用mkinitramfs生成），System.map复制到系统/boot目录里，得到vmlinuz-&lt;version&gt;、initrd.img-&lt;version&gt;、System.map-&lt;version&gt;、config-&lt;version&gt;）#6、更新引导加载程序配置#（1）Ubuntu/Debian#更新引导加载程序（可选，即设置使用新版内核启动，Ubuntu/Debian 安装新版内核会自动更新引导加载程序为最新内核） #通常情况下，新内核的 GRUB 引导项会自动成为默认的引导项。 #如果需要使用其他版本内核可通过执行：grep 'menuentry' /boot/grub/grub.cfg 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面），然后修改 /etc/default/grub 中的 GRUB_DEFAULT 值（设要修改的内核索引顺序为 2，则修改为：GRUB_DEFAULT="1&gt; 2"），最后执行 update-grub 并 reboot 重启系统即可。参考：https://www.cnblogs.com/zzugyl/p/14588114.html #关机重启时一般会进入grub菜单，在菜单中可以选择指定版本的内核启动，如果启动时跳过不展示grub菜单，则可以在启动时按住Shift键或Esc键，直到出现GRUB菜单。update-grub#（2）CentOS/RedHat#更新引导加载程序（必选，即设置使用新版内核启动，CentOS/RedHat 安装新版内核不会自动更新引导加载程序为最新内核） #如果需要使用其他版本内核可通过执行：egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \' 命令查看已安装所有版本内核顺序（从0开始，默认最高版本在最前面）grub2-set-default 0grub2-mkconfig -o /boot/grub2/grub.cfg #用于传统的BIOS引导#grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg #用于UEFI引导#7、启服务器以使新版内核生效（必选）reboot#8、卸载编译安装的内核（如需要） #将 &lt;version&gt; 替换为对应内核版本号#删除内核映像文件rm /boot/vmlinuz-&lt;version&gt;rm /boot/initrd.img-&lt;version&gt;rm /boot/System.map-&lt;version&gt;rm /boot/config-&lt;version&gt;#删除模块文件 #提示：实际模块文件在 /usr/lib/modules 目录里，由于 /lib 目录是 /usr/lib 目录的符号链接，故可以通过删除 /lib 里的内容从而实现删除 /usr/lib 里的内容rm -r /lib/modules/&lt;version&gt;##更新引导加载程序配置#Debian 系列系统更新引导加载程序配置（可选）update-grub#RedHat 系列系统更新引导加载程序配置（必选）grub2-set-default 0grub2-mkconfig -o /boot/grub2/grub.cfg #用于传统的BIOS引导#grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg #用于UEFI引导#重启reboot提示：（1）Ubuntu 编译报错提示：make[2]: *** No rule to make target 'debian/canonical-certs.pem', needed by 'certs/x509_certificate_list'（注意这个报错提示可能是出现在上文，应该终端中搜索查询一下），解决办法如下：1234&gt;scripts/config --set-str SYSTEM_TRUSTED_KEYS ""&gt;scripts/config --set-str SYSTEM_REVOCATION_KEYS ""&gt;##对于Ubuntu，最好在 make menuconfig 执行完成后进行如上操作，防止编译报错以上命令执行后，然后重新编译。参考：https://askubuntu.com/questions/1329538/compiling-the-kernel-5-11-11。（2）Ubuntu 编译安装内核完成并重启后，出现错误：end Kernel panic - not syncing: System is deadlocked on memory，这个原因通常是因为编译的内核过大，需要更多的内存加载。临时解决方法：在虚拟机选项中将内存改大一些，我改成 4GB 再重启就可以了。彻底解决办法：减小内核大小，通常是去除内核的调试信息即可。（3）编译的内核通常都默认带有调试信息，那么内核和模块的文件将会很大，占用很多磁盘空间。去除这些内核调试信息，可有效减小内核模块和内核大小，节省存储空间。实现方式如下：方式1：如果尚未编译，则可以在 make menuconfig 时，在交互菜单界面中选择关闭调试信息，菜单导航：Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt; Disable debug information inking，按空格选择设置为 X 表示关闭调试信息，然后选择 Save -&gt; OK。方式2：如果尚未编译，则可以在 make menuconfig 生成.config 文件后，修改其调试参数来去除调试信息，然后再编译。（这种方式编译出来的内核和模块都会占用更小的空间）12345678&gt;scripts/config --undefine GDB_SCRIPTS&gt;scripts/config --undefine DEBUG_INFO&gt;scripts/config --undefine DEBUG_INFO_SPLIT&gt;scripts/config --undefine DEBUG_INFO_REDUCED&gt;scripts/config --undefine DEBUG_INFO_COMPRESSED&gt;scripts/config --set-val DEBUG_INFO_NONE y&gt;scripts/config --set-val DEBUG_INFO_DWARF5 n&gt;scripts/config --disable DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT参考：https://superuser.com/questions/925079/compile-linux-kernel-deb-pkg-target-without-generating-dbg-package方式3：如果已经编译得到带有调试信息的内核和模块了，那么可以在安装内核和内核模块时加上 INSTALL_MOD_STRIP=1 参数来剥离调试信息，减小内核模块和内核大小，节省存储空间。123&gt;#安装时指定 INSTALL_MOD_STRIP=1 可剥离调试信息，减小内核模块和内核大小，节省存储空间&gt;make INSTALL_MOD_STRIP=1 modules_install&gt;make INSTALL_MOD_STRIP=1 install（4）更多问题和解决办法：https://blog.51cto.com/u_15127511/4320481¶参考Ubuntu22.04 编译内核Ubuntu18.04 编译内核5.4.0编译Ubuntu 20.04内核代码https://www.youtube.com/watch?v=uJ4HFAmOQCM （Ubuntu 更新内核）https://www.youtube.com/watch?v=TVmQhwSWuiM （CentOS 更新内核，含 NTFS 支持）¶5. 服务管理¶1）服务相关概念服务(service) 是一种开机自启动的后台运行程序，也称为守护进程（运行中的程序就叫进程）。通常会在系统启动时自动运行，并一直保持运行状态，以便用户和其他程序可以随时使用。常见的服务程序有 sshd、mysqld、httpd 等。💁‍♂ 程序的运行模式：计算机程序的运行模式是指程序在计算机系统中的运行方式和状态。根据程序的运行模式不同，可以分为以下几种：前台模式前台模式（Foreground Mode）是指程序需要在用户界面上显示输出信息，等待用户输入或响应操作的模式。这些程序运行时会占用当前终端或图形界面的屏幕空间，并且随着用户的注销或关闭终端而结束。例如，文本编辑器、Web 浏览器、音乐播放器等都是前台模式下运行的程序。后台模式后台模式（Background Mode）是指程序不需要在用户界面上显示输出信息，它们会在系统后台默默地执行任务，不会占用当前终端或图形界面的屏幕空间，并且在用户注销或关闭终端时仍然可以继续运行。例如，服务程序、守护进程、定时任务等都是后台模式下运行的程序。守护进程模式守护进程模式（Daemon Mode），也称为服务模式（Service Mode），是一种特殊的后台模式，在系统启动时自动启动并一直保持运行状态，以提供某种特定的服务或功能。守护进程通常会监听某个网络端口或 Unix 套接字，等待客户端连接并处理请求。例如，Web 服务器、数据库服务器、邮件服务器等都是守护进程模式下运行的程序。嵌入式模式嵌入式模式（Embedded Mode）是指程序被嵌入到其他程序或系统中执行，以完成特定的任务或提供服务。嵌入式模式下运行的程序通常具有轻量化、高效性和实时性等特点，例如，操作系统内核、驱动程序、嵌入式应用程序等都是嵌入式模式下运行的程序。总之，计算机程序的运行模式与程序本身的功能、特点和用途密切相关。不同的运行模式可以满足不同的需求和场景，理解这些运行模式对于程序设计、开发和管理都有重要作用。💁‍♂ 关于服务程序的补充说明：应用程序是否为服务程序，取决于其在系统中的运行模式是否是守护进程模式。也就是说只需设置为守护进程模式的应用程序才是服务程序。有些应用程序在安装时会自动设置为守护进程模式以实现开机程序自启动，并监听某些端口以供用户请求处理。例如通过包管理器默认安装方式安装sshd时（sshd属于openssh-server软件包的组件），会自动设置为守护进程模式以实现开机程序自启动，并监听默认的22端口以供用户通过ssh远程登录。¶2）启动框架相关概念启动框架（Boot framework）是计算机操作系统启动时用于管理和控制服务、程序和进程的一组工具和机制。简单的说：启动框架就是一组服务管理工具。它能够帮助用户在系统启动过程中加载和启动必要的服务和程序，并确保这些服务和程序能够以正确的顺序和方式运行。启动框架包含有一些管理工具用于实现：查看服务运行状态、查看服务自启动状态、启动服务、关闭服务、开启服务自启动（即所谓的设置开机自启动）、关闭服务自启动 等功能。在 Linux 操作系统中，启动框架通常被称为引导框架（boot loader），其作用类似于 Windows 系统中的 BOOTMGR 或 NTLDR。启动框架通常会在操作系统内核初始化之后自动启动，并负责加载和管理其他服务和程序。它们还会根据预定义的运行级别或用户自定义的配置来控制有哪些服务、程序和进程需要在系统启动时自动运行。常见的启动框架包括：SysVinit、Upstart、Systemd 和 OpenRC 等。SysVinit：SysVinit 是一种较早的 Linux 启动框架，它使用 /etc/init.d/ 目录下的脚本文件来控制系统服务的启动和停止。在 SysVinit 中，服务的运行状态与系统运行级别（runlevel）直接关联，用户可以使用 service 和 chkconfig 等命令来管理服务。Upstart：Upstart 是 Canonical 公司开发的一种 Linux 启动框架，其设计目标是提高启动速度并改善系统事件处理。Upstart 使用基于事件的模型代替了传统的 SysVinit 模型，并支持自动重启、故障恢复和进程监控等功能。Systemd：Systemd 是一种由 Lennart Poettering 开发的 Linux 启动框架，已经成为许多主流 Linux 发行版的默认启动框架。与 SysVinit 不同，Systemd 使用单一的 .service 文件来描述服务，并支持依赖关系、并行启动、延迟启动和日志记录等功能。用户可以使用 systemctl 命令来管理服务和控制系统状态。OpenRC：OpenRC 是 Gentoo Linux 发布版使用的一种 Linux 启动框架，也可以在其他 Linux 发行版中使用。OpenRC 使用 /etc/init.d/ 目录下的脚本文件来控制服务的启动和停止，并支持并行启动、依赖关系和自定义运行级别等功能。提示：在 CentOS7.0 后 很多应用程序不再使用 SysVinit 而是使用 Systemd 来管理服务。¶3）SysVinit 服务管理¶简要概述SysVinit 是一种较早的 Linux 启动框架，它使用 /etc/init.d/ 目录下的脚本文件来控制系统服务的启动和停止。在 SysVinit 中，服务的运行状态与系统运行级别（runlevel）直接关联，用户可以使用 service 和 chkconfig 等命令来管理服务。¶Linux系统运行级别的概念在SysVinit中有Linux系统运行级别的概念，Linux系统运行级别指的是系统启动时所处的运行状态，它决定了哪些服务、进程和资源会被启动或关闭。在 Linux 中，通常使用 SysV 初始化系统来管理运行级别。SysV 初始化系统其提供了 7 个运行级别，如下：运行级别 0：系统停机状态，即关机。运行级别 1：单用户模式，只有 root 用户可以登录终端，通常用于系统修复或恢复。运行级别 2：多用户模式，但不带 NFS 功能。运行级别 3：完全的多用户模式，通常是支持网络连接的服务器模式。运行级别 4：保留，未使用。运行级别 5：完全的多用户图形化模式，通常是桌面应用程序运行的模式。运行级别 6：系统重启，即重新启动操作系统。在 Linux 中，Linux 系统的默认运行级别通常是 3 或 5，具体取决于 Linux 发行版和系统配置。如果用户需要修改系统启动时默认的运行级别，可对 /etc/inittab 文件中的 initdefault 参数进行配置。1234#修改系统启动时默认的运行级别。配置initdefault参数vi /etc/inittab#查看当前系统的运行级别runlevel¶常用命令（service 和 chkconfig、update-rc.d）提示：service 命令原本是用于管理 SysVinit 初始化管理的服务，但现在很多新系统改用 Systemd 初始化管理服务后，为了兼顾 service 的使用习惯，也同样支持用于管理 Systemd 启动的服务。12345678910111213141516171819202122232425262728#查看SysVinit管理的服务service --status-all #或者：ls -l /etc/init.d#启动服务service 服务名 start#关闭服务service 服务名 stop#重启服务service 服务名 restart#重载服务配置service 服务名 reload#查看服务运行状态service 服务名 status#Debian系列系统#开启服务自启动（即所谓的设置开机自启动）update-rc.d 服务名 defaults#关闭服务自启动（-f: force）update-rc.d -f 服务名 remove#Redhat系列系统#设置服务的自启动状态（可通过--level指定某运行级别下服务的自启动状态，不指定--level选项则默认作用于所有运行级别）chkconfig --level &lt;level&gt; &lt;service_name&gt; &lt;on|off&gt; #如：chkconfig --level 3 httpd on#开启服务自启动（即所谓的设置开机自启动）chkconfig 服务名 on#关闭服务自启动chkconfig 服务名 offservice命令详解service 命令是一种用于管理系统服务的工具。它可以启动、停止、重启以及查询系统服务的状态，作用于 /etc/init.d 目录下的服务脚本。是一种用于管理系统服务的工具。它可以启动、停止、重启以及查询系统服务的状态，作用于 /etc/init.d 目录下的服务脚本。基本语法如下：1&gt;service &lt;service_name&gt; &lt;action&gt;其中，&lt;service_name&gt; 表示要操作的服务名称，例如 httpd、sshd 等；&lt;action&gt; 表示要执行的操作，例如 start、stop、restart、status 等。chkconfig命令详解chkconfig 命令是 Linux 系统中用于管理 SysV 初始化脚本的命令之一。它可以让用户方便地设置某个服务在不同运行级别下的启动状态。基本语法如下：1&gt;chkconfig --level &lt;level&gt; &lt;service_name&gt; &lt;on|off&gt;其中，--level 选项表示要设置的运行级别，例如 3 表示完全的多用户模式，不指定--level选项则默认作用于所有运行级别；&lt;service_name&gt; 表示要操作的服务名称；&lt;on|off&gt; 表示要执行的操作，即将服务设置为启动或停止状态。实现原理：根据/etc/init.d目录的服务脚本创建相应的符号链接（软链接），然后把这个符号链接放到表示不同运行级别的目录里，系统启动时 SysV 根据当前运行级别情况运行对应目录里的服务脚本。常规Linux 发行版会把符号链接会被存放在/etc/rcN.d 目录里，RHEL 等一些特定的 Linux 发行版会把符号链接会被存放在/etc/rc.d/rcN.d 目录里。其中N表示运行级别。这些链接文件通常以 K 或 S 字母开头，后面跟着服务名称和数字序列号，例如 K01httpd 或 S99sshd。其中，K 表示停止服务，S 表示启动服务，数字序列号表示启动或停止的先后顺序。例如：如果想要在运行级别 3 中启动 Apache 服务，可以将 /etc/init.d/httpd 复制到 /etc/rc3.d 目录，并将其重命名为 S80httpd，命令操作如：cp /etc/init.d/httpd /etc/rc3.d/S80httpd。这样，在系统进入运行级别 3 时，就会自动启动 Apache 服务。💁‍♂ 注意：restart和reload的区别：restart = stop + start，而 reload = 重新读取配置文件¶自定义服务在 SysVinit 启动框架下自定义服务，可以按照以下步骤进行：编写服务脚本（启动脚本）在 /etc/init.d 目录下创建一个服务脚本文件，文件名为自定义的服务名称。如：/etc/init.d/my_custom_service1234567891011121314151617181920212223#!/bin/bash# chkconfig: 345 99 10# description: My Custom Servicecase "$1" in start) /usr/bin/my_custom_service &amp; ;; stop) pkill my_custom_service ;; restart) $0 stop sleep 5 $0 start ;; *) echo "Usage: $0 &#123;start|stop|restart&#125;" exit 1 ;;esacexit 0其中，chkconfig: 345 99 10 指定了运行级别和启动顺序。345 表示服务将在运行级别 3、4 和 5 中启动；99 表示启动顺序（数字越小越先启动）；10 表示停止顺序（数字越大越后停止）。启用服务使用 chkconfig 命令将服务添加到系统启动项，并将其设置为开机自动启动。123chmod +x /etc/init.d/my_custom_servicechkconfig --add my_custom_servicechkconfig my_custom_service on启动服务使用 service 命令启动服务。1service my_custom_service start¶4）Systemd 服务管理¶简要概述Systemd 是一种由 Lennart Poettering 开发的 Linux 启动框架，已经成为许多主流 Linux 发行版的默认启动框架。与 SysVinit 不同，Systemd 使用单一的 .service 文件来描述服务，并支持依赖关系、并行启动、延迟启动和日志记录等功能。用户可以使用 systemctl 命令来管理服务和控制系统状态。¶常用命令（systemctl）提示：systemctl 命令不可以用于管理 SysVinit 启动的服务。1234567891011121314151617181920212223242526#查看Systemd管理的服务（Systemd会从以下目录中加载Systemd单元文件，如果存在同名文件，Systemd将使用较高优先级路径里的单元文件配置）ls /etc/systemd/system #优先级最高（包含用户自定义的单元文）ls /run/systemd/system #比以上优先级低（包含运行时生成的单元文件）ls /lib/systemd/system #比以上优先级低（包含Linux系统自带的单元文件和第三方服务安装的单元文件）ls /usr/lib/systemd/system #比以上优先级低（默认和/lib/systemd/system文件内容一致）#启动服务systemctl start 服务名#关闭服务systemctl stop 服务名#重启服务systemctl restart 服务名#查看服务运行状态systemctl status 服务名#查看所有服务自启动状态systemctl list-unit-files #systemctl list-unit-files | grep 服务名#开启服务自启动（即所谓的设置开机自启动）systemctl enable 服务名#关闭服务自启动systemctl disable 服务名#查询某个服务是否是自启动的systemctl is-enabled 服务名#查看服务日志journalctl -u 服务名💁‍♂ 说明：systemctl命令自带有服务自启动管理功能，可直接使用该命令来维护服务的自启动状态。💁‍♂ 关于/lib/systemd/system 目录和 /usr/lib/systemd/system 目录默认文件相同的说明：在 Linux 操作系统中，/usr/lib 目录和 /lib 目录都是用于存储共享库文件的目录。事实上，/usr/lib 目录中的大部分内容都可以在 /lib 目录中找到相应的文件。这是因为，早期版本的 Linux 发行版将所有的用户空间程序和库文件都安装在 /usr 目录中，而 /lib 目录只包含内核和驱动程序所需的库文件。随着 Linux 发行版的不断发展和演变，为了提高兼容性和可移植性，一些 Linux 发行版开始将某些库文件安装在 /lib 目录中，以避免某些应用程序无法正常工作。但是，出于向后兼容的考虑，又不能将所有的库文件都直接移到 /lib 目录下。这就导致了 /usr/lib 和 /lib 目录中的内容存在大量重复的情况。总之，在现代 Linux 系统中，/usr/lib 目录中的大部分内容都可以在 /lib 目录中找到相应的文件。这是由于历史原因和兼容性考虑所导致的，用户不需要过多关注这个问题，只需要根据需要使用相应的库文件即可。¶自定义服务在 Systemd 中管理自定义服务的步骤如下：编写服务文件创建一个描述服务的配置文件，并将其保存到 /etc/systemd/system 目录中，文件名以 .service 结尾。如：my_custom_service.service12345678910[Unit]Description=My Custom ServiceAfter=network.target[Service]ExecStart=/usr/bin/my_custom_serviceRestart=always[Install]WantedBy=multi-user.targetSystemd 服务单元文件的一些常见配置选项及其详细说明：[Unit] 部分：Description：描述该服务的文字说明。Documentation：提供有关该服务的文档链接或路径。Requires 和 Wants：指定该服务所依赖的其他单元，要求它们在该服务之前启动。After：指定该服务应该在哪些其他单元之后启动。[Service] 部分：Type：指定服务的类型，如 simple、forking、oneshot、dbus 等。ExecStart：指定启动该服务时要执行的命令或脚本。ExecStop：指定停止该服务时要执行的命令或脚本。WorkingDirectory：指定服务的工作目录。User 和 Group：指定服务运行的用户和组。Environment：设置服务运行时的环境变量。Restart：指定服务在异常退出时的重启策略。no：表示不进行重启，默认情况下，当服务停止或退出时不会自动重启。on-failure：表示仅在服务发生非正常的退出（即退出状态不为零）时才重启。这是默认的重启策略。always：表示无论服务退出的状态如何（无论是正常还是非正常），都进行重启。on-abnormal：表示仅在服务发生异常退出时才重启，例如由于收到未捕获的信号导致服务终止。on-success：表示仅在服务正常退出（即退出状态为零）时才重启。on-watchdog：表示仅在由 Systemd 监控的 watchdog 定时器触发时才重启。on-abort：表示仅在服务启动过程中遇到致命错误时才重启。RestartSec：指定在重启服务之前等待的时间间隔。ExecReload：指定重新加载服务时要执行的命令或脚本。[Install] 部分：WantedBy：指定该服务应该在哪些目标（target）中启用。通常为 multi-user.target 或类似的目标。重新加载 Systemd 配置使用 systemctl 命令重新加载 Systemd 配置，使之生效。1systemctl daemon-reload启用开机自启动使用 systemctl 命令将服务添加到开机自启动项，并设置为开机自动启动。1systemctl enable my_custom_service.service启动服务使用 systemctl 命令启动服务。1systemctl start my_custom_service.service至此，自定义服务已经成功地添加到 Linux 系统中，并且可以通过 systemctl 命令来管理它。需要注意的是，在编写服务文件时，要遵循规范，确保服务能够正确地启动、停止和重启。在使用 Systemd 进行服务管理时，还可以使用其他一些命令来管理服务，例如 systemctl stop、systemctl restart、systemctl status 和 journalctl 等。¶6. 分配 swap 空间¶简要概述在安装 Linux 系统时在分区时可以分配 swap 空间（交换空间，即虚拟内存），而系统安装后（在运行中）如何创建或调整 swap 空间呢？在装完 Linux 系统之后，分配 swap 空间有两种方式。提示：可通过命令 free -h 查看当前系统的 swap 空间大小。¶方式1：新建磁盘分区作为 swap 分区123456789101112#停止所有的 swap 分区swapoff -a# 用 fdisk 命令对某个磁盘进行分区，添加 swap 分区，新建分区，在 fdisk 中用 t 命令将新添的分区 id 改为 82（Linux swap 类型），最后用 w 将操作实际写入硬盘（没用 w 之前的操作是无效的）。如下：fdisk /dev/sdb#格式化 swap 分区，这里的 sdb2 要看加完后 p 命令显示的实际分区设备名mkswap /dev/sdb2#激活启用新的 swap 分区swapon /dev/sdb2#为了让系统启动时能自动启用这个交换分区，可以编辑 /etc/fstab 加入下面一行/dev/sdb2 swap swap defaults 0 0# 启用 /etc/fstab 里的所有 swap 分区（可选）# swapon -a停用 swap 分区，操作如下：1234#停用指定 swap 分区swapoff /dev/sdb2#删除或注释 /etc/fstab 中之前添加的相关挂载 swap 分区的开机自启动内容#/dev/sdb2 swap swap defaults 0 0¶方式2：用虚拟磁盘分区作为 swap 分区（推荐）1234567891011#创建一个新的虚拟磁盘分区（即文件）mkdir /swapdd if=/dev/zero of=/swap/swapfile bs=1M count=1024 #大小可自己调整（文件大小 = bs * count）#格式化为交换分区文件mkswap /swap/swapfile #设置拟磁盘分区的文件系统#设置文件权限（可选）chmod 600 /swap/swapfile#激活启用新的 swap 分区swapon /swap/swapfile#使系统开机时自启用，可以编辑 /etc/fstab 加入下面一行/swap/swapfile swap swap defaults 0 0提示：系统的 swap 空间总容量由一个或多个 swap 分区来共同组成，停掉某些 swap 分区，系统的 swap 空间总容量也会随着减少掉相应的大小。所以想要增加 swap 空间总容量，只需要创建激活 swap 分区即可，减少容量则关停并删除某些 swap 分区即可停用 swap 分区，操作如下：123456#停用指定 swap 分区swapoff /swap/swapfile#删除 swap 分区文件rm /swap/swapfile#删除或注释 /etc/fstab 中之前添加的相关挂载 swap 分区的开机自启动内容#/swap/swapfile swap swap defaults 0 0¶参考https://blog.csdn.net/lovemysea/article/details/78306558https://www.jianshu.com/p/30cd53ed056c¶九、网络管理¶1. 查看网卡配置信息 ifconfigifconfig 可以查看当前的网卡配置信息（主要含网卡名称、IP 信息等）12345# 查看网卡配置信息ifconfig# 查看网卡对应的 IP 地址ifconfig | grep inet提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示网卡是一个专门负责网络通讯的硬件设备。IP 地址是设置在网卡上的地址信息。每台联网的电脑上都有 P 地址，是保证电脑之间正常通讯的重要设置。我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常¶2. 检测网络连通性 ping 和 telnetping 一般用于检测当前计算机到目标计算机之间的网络是否连通，time数值越大，速度越慢123456789101112## 测试 IP 连通性# 检测到目标主机是否连接正常ping IP地址# ping 本机 IPping baidu.comping 127.0.0.1 #等同：ping localhost## 测试端口连通性 #在 telnet 会话连通后，如果不自动退出，需输入 Ctrl+] 组合键，在出现的提示符下输入 quit，然后按 Enter 键即可退出。telnet IP地址 端口telnet baidu.com 443ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C¶3. 配置主机名123456789101112#查看主机名hostname##持久化修改主机名#方式1（推荐）：hostnamectl set-hostname "主机名称"#如：hostnamectl set-hostname "centos7-test"#方式2：echo "主机名称" &gt; /etc/hostname#如：echo "centos7-test" &gt; /etc/hostnamereboot #注意，如果修改配置文件的方式设置主机名，则需要重启系统¶4. 配置 hosts 映射12#编辑/etc/hosts然后配置ip和对应域名即可vim /etc/hosts¶5. 配置主机 IP¶1）配置临时 IP1234567891011121314151617181920##设置临时IP（ifconfig 命令） #ifconfig 命令设置IP，会把替换掉原网络接口的IP #&lt;interface_name&gt; 为网络接口名称（如：eth0 或 ens33 等，可通过执行 ip addr 命令查看） #格式：ifconfig &lt;interface_name&gt; &lt;IP&gt;/&lt;子网掩码&gt; 或者 ifconfig &lt;interface_name&gt; &lt;IP&gt; netmask &lt;子网掩码&gt;#示例：# 首先，禁用网络接口（如果已经启用）ifconfig ens33 down# 配置IP地址和子网掩码ifconfig ens33 192.168.60.100/24# 启用网络接口ifconfig ens33 up#临时设置网关IP #格式：ip route add default via &lt;gateway_ip&gt; #或者：route add default gw &lt;gateway_ip&gt;（一些旧版的Linux系统仅支持route add default gw &lt;gateway_ip&gt;）ip route add default via 192.168.60.2#临时设置DNS服务器 #格式：echo "nameserver &lt;dns-ip&gt;" &gt;&gt; /etc/resolv.confecho "nameserver 8.8.8.8" &gt;&gt; /etc/resolv.conf其他相关命令123456789101112131415161718192021222324##添加临时IP（ip addr add 命令） #ip addr add 命令用于添加IP（即如果之前网络接口已经存在默认IP，则该命令会在保留原IP的情况下添加一个新的IP，使得多个IP可用） #&lt;interface_name&gt; 为网络接口名称（如：eth0 或 ens33 等，可通过执行 ip addr 命令查看） #格式：ip addr add &lt;IP&gt;/&lt;子网掩码&gt; dev &lt;interface_name&gt;#示例：ip addr add 192.168.60.100/24 dev ens33##移除临时IP（ip addr del 命令） #&lt;interface_name&gt; 为网络接口名称（如：eth0 或 ens33 等，可通过执行 ip addr 命令查看） #格式：ip addr del &lt;IP&gt;/&lt;子网掩码&gt; dev &lt;interface_name&gt;#示例：ip addr del 192.168.60.100/24 dev ens33#还原IP（重启网络接口方式） #&lt;interface_name&gt; 为网络接口名称（如：eth0 或 ens33 等，可通过执行 ip addr 命令查看）ifconfig &lt;interface_name&gt; downifconfig &lt;interface_name&gt; up#或#ip link set &lt;interface_name&gt; down#ip link set &lt;interface_name&gt; up#还原IP（重启网络服务方式）service network restart¶2）配置静态 IP说明：静态 IP 即重启系统或者网络后不会改变的 IP。¶（一）环境准备如果 Linux 系统设置自动配置网络 IP （即 DHCP），那么虚拟机系统的 IP 将会默认由网关动态随机分配，所以重启系统或者网络的情况，这个 IP 可能会发生改变。如果希望重启系统或者网络后 IP 固定不变的话，则需要手动对网卡配置固定的静态 IP。（1）确定要配置静态 IP 的子网、子网掩码、网关 IP要配置静态 IP 就要提前先确定静态 IP 的子网、子网掩码、网关 IP。这里以 VMware 的 Linux 虚拟机在 NAT 模式下配置静态 IP 为例进行讲解，操作如下：确定子网：对于 NAT 模式，VMware 使用 VMnet8 这个宿主机虚拟网卡来管理 IP 的，其默认子网在安装 VMware 时初始化为一个默认值，通常为 192.168.x.0（如：192.168.60.0），不同设备该值可能不同，具体可以通过查看宿主机的 VMnet8 网卡配置来确定，或者在 VMware 的 “虚拟网络编辑器” 中查看，操作如下：提示：如对默认设置的子网不满意，则可以点击 “更改设置” 来进行修改，修改子网后，网关 IP 也会自动跟着改变。如果发现虚拟网络配置的子网段和宿主机的 VMnet8 网卡的配置不一致，需要点击 “更改设置” 以修改为同网段。确定子网掩码：子网掩码默认都为 255.255.255.0确定网关 IP：默认 VMnet8 的网关 IP 为子网的一个 IP，通常为 x.x.x.2（如：192.168.60.2）（2）配置虚拟机的网络连接方式为&quot; NAT 模式&quot;。（3）进入 Linux 虚拟机终端，编辑 Linux 网卡配置文件，对于不同发行版 Linux 的网卡配置文件路径和名称可能不同，可通过ifconfig命令来查看网卡名称。12345678910111213141516171819[root@localhost ~]# ifconfig# ens33 即网卡名称ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.60.112 netmask 255.255.255.0 broadcast 192.168.60.255 inet6 fe80::20c:29ff:fe09:6067 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:09:60:67 txqueuelen 1000 (Ethernet) RX packets 256 bytes 39985 (39.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 151 bytes 19628 (19.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 0 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0然后编辑网卡配置文件Red Hat 系列系统的配置文件路径为：/etc/sysconfig/network-scripts/ifcfg-&lt;网络接口名称&gt;（如：/etc/sysconfig/network-scripts/ifcfg-ens33）Debian 系统的配置文件路径为：/etc/network/interfacesUbuntu 系统的配置文件路径为：/etc/netplan/&lt;xxx&gt;-config.yaml（如：/etc/netplan/00-installer-config.yaml）¶（二）Red Hat / CentOS 系统配置静态 IP12vi /etc/sysconfig/network-scripts/ifcfg-&lt;网络接口名称&gt;#如：vi /etc/sysconfig/network-scripts/ifcfg-ens33修改如下:12345678910111213141516171819202122TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"-BOOTPROTO="dhcp"+BOOTPROTO="static"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="4f676de2-5673-431b-b8fc-2dc4ad9accfc"DEVICE="ens33"-ONBOOT="no"+ONBOOT="yes"+IPADDR="192.168.60.100"+GATEWAY="192.168.60.2"+NETMASK="255.255.255.0"+DNS1="223.5.5.5"+DNS2="8.8.8.8"💡 提示：网卡配置文件里的变量可能不同系统的也不同。但是以上修改的部分是必须的。📚 主要变量说明：HWADDR：表示mac地址TYPE：网络类型BOOTPROTO：表示为网卡配置静态还是动态IP地址(none:表示无须启动协议；bootp:表示使用BOOTP协议；dhcp ：使用dhcp协议动态获取ip地址； static：表示手工设置静态IP地址)ONBOOT：表示启动系统时是否激活网卡，yes为激活，no不激活（如果默认为no需要改成yes）HWADDR：表示网卡的MAC地址GATEWAY：表示该网关地址。填虚拟虚拟机网卡VMnet8对应的网关ip。NETMASK：表示子网掩码。填填和VMnet8对于的子网掩码IPADDR：表示网卡的静态IP地址。比如上面的网关是192.168.60.2并且子网掩码是255.255.255.0，那么表示固定ip的值需要是192.168.60.x（这个x是除了网关外3~254的任意数填，其中0表示网络，255一般用来做掩码，而1和2已经被VMnet8使用，所以0、1、2和255不用）DNS1（可选）：表示第一个DNS服务器的地址。值可以是任意能使用的dns ip地址（用于解析域名）。这里使用google通过的dns ip8.8.8.8即可。（注意：如果 Vmware 虚拟机使用“仅主机模式”的话，不要设置 DNS ，否则可能会出现 SSH 登录超时的问题。）DNS2（可选）：表示第二个DNS服务器的地址。重启网络服务以生效1234#重启网络服务service network restart#如果上面命令重启 ip 没变，可以尝试重启系统试试reboot执行后如果报如下错误：Restarting network (via systemctl): Job for network.service failed because the control process exited with error code. See “systemctl status network.service” and “journalctl -xe” for details.💁‍♂ 出现上面错误的大概率是mac地址和vmware配置的不一致。如下一定要一致：¶（三）Debian 系统配置静态 IP1vi /etc/network/interfaces配置内容如下:123456789101112131415161718192021222324252627282930# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interface#allow-hotplug ens33#iface ens33 inet dhcp#允许网卡接口热插拔allow-hotplug ens33#开机启动时自动激活网卡接口auto ens33#static表示使用固定IP，dhcp表述使用动态IP#iface ens33 inet dhcpiface ens33 inet static#设置静态IP地址address 192.168.60.201#设置子网掩码netmask 255.255.255.0#设置网关gateway 192.168.60.2#设置DNS服务器（可选）dns-nameservers 223.5.5.5 8.8.8.8重启网络服务以生效12345#重启网络服务service networking restart#如果上面命令重启 ip 没变，可以尝试重启系统试试reboot¶（四）Ubuntu 系统配置静态 IP12vi /etc/netplan/&lt;xxx&gt;-config.yaml#如：vi /etc/netplan/00-installer-config.yaml配置内容如下：123456789101112131415network: version: 2 renderer: networkd #指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd ethernets: ens33: #配置的网卡的名称 dhcp4: no #关闭DHCP，如果需要打开DHCP则写yes #dhcp6: no addresses: - 192.168.60.130/24 #配置的静态ip地址和掩码 #- 可配置 IPV6 地址 routes: - to: default via: 192.168.60.2 #网关地址 nameservers: addresses: [223.5.5.5, 8.8.8.8] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开重新加载配置以生效1netplan apply参考：https://www.cnblogs.com/liujiaxin2018/p/16287463.htmlhttps://code84.com/810353.htmlhttps://www.myfreax.com/how-to-configure-static-ip-address-on-ubuntu-20-04/https://ld246.com/article/1593929878472¶（五）Rocky Linux 系统配置静态 IP参考：网卡配置文件修改法：https://www.cnblogs.com/liujiaxin2018/p/17379440.htmlhttps://docs.rockylinux.org/zh/gemstones/network/RL9_network_manager/#_2交互式配置法：https://docs.rockylinux.org/zh/guides/network/basic_network_configuration/¶6. 配置 DNS 服务器¶1）公共 DNS 服务器介绍国内的常用 DNS 服务阿里云公共 DNS：IPv4：223.5.5.5、 223.6.6.6IPv6：2400:3200::1、2400:3200:baba::1腾讯云公共 DNS：IPv4：119.29.29.29、119.28.28.28IPv6：2402:4e00::、2402:4e00:1:: （参考）南京信风公共 DNS | 114DNS：IPv4：114.114.114.114、114.114.115.115IPv6：暂无百度公共 DNS：IPv4：180.76.76.76IPv6：2400:da00::6666清华大学 TUNA 协会公共 DNS | DNS666：IPv4：101.6.6.6IPv6：2001:da8::666国外常用 DNS 服务Google Public DNS：IPv4：8.8.8.8、8.8.4.4IPv6：2001:4860:4860::8888、2001:4860:4860::8844Cloudflare DNS：IPv4：1.0.0.1、1.1.1.1IPv6：2606:4700:4700::1111、2606:4700:4700::1001OpenDNS：IPv4：208.67.222.222、208.67.220.220IPv6：2620:119:35::35、2620:119:53::53 （参考）最佳实践推荐：解析国内站点推荐使用阿里 DNS 和腾讯 DNSPod（注重稳定请用前者、注重准确请用后者）；解析海外网站推荐主 DNS 1.0.0.1 或 208.67.222.222，备 DNS 8.8.8.8 或 8.8.4.4参考：https://www.51cto.com/article/715641.htmlhttps://www.bilibili.com/read/cv24699923/¶2）查看当前使用的 DNS 服务器123456789##查看当前使用的 DNS 服务器（通用命令）cat /etc/resolv.conf##查看当前使用的 DNS 服务器（系统使用 systemd-resolved 维护 DNS 的情况） #在 Ubuntu 16.10 或更新的版本中，/etc/resolv.conf 文件通常由 systemd-resolved 服务动态生成和管理。因此，直接查看 /etc/resolv.conf 文件可能不会显示 DNS 服务器的配置，需要通过 resolvectl status 命令进行查看resolvectl status##查看当前使用的 DNS 服务器（系统使用 resolvconf 维护 DNS 的情况）resolvconf -l将看到一个或多个 nameserver 行，每行后面跟着 DNS 服务器的 IP 地址¶3）Linux 系统配置 DNS 服务器¶（1）临时配置系统 DNS 服务器Linux 系统的 DNS 配置由 /etc/resolv.conf 配置文件的 DNS 配置内容决定的，临时情况只需要在该文件里配置一个或多个 nameserver 即可使用自定义的 DNS 服务器（没有 nameserver 则表示不使用 DNS 服务器），修改该文件后会立即生效（不需要重启网络等操作），配置如下：1234567#添加或修改 nameserver 行以指定 DNS 服务器的 IP 地址#可配置一个或多个 nameserver 行，每行后面跟着 DNS 服务器的 IP 地址vi /etc/resolv.conf#配置内容如下：search localdomainnameserver 223.5.5.5nameserver 8.8.8.8¶（3）永久配置 DNS 服务器¶方式 1、维护网络接口配置文件的 DNS 配置（推荐）提示：在网络接口配置文件中，如果获取 IP 的方式为静态的，则需要手动配置 DNS 服务器，这些配置会自动更新到 /etc/resolv.conf 文件中。如果获取 IP 的方式为 DHCP，则可以不用手动设置 DNS 服务器，系统会自动使用 DHCP 分配的 DNS 服务器并更新到 /etc/resolv.conf 文件中，而在 DHCP 的情况下又手动自定义了 DNS 服务器，那么自定义的 DNS 服务器和 DHCP 分配的 DNS 服务器都会同时更新到 /etc/resolv.conf 文件中。对于 Redhat 系列系统，操作如下：12345678910111213#（1）编辑网络接口配置文件vi /etc/sysconfig/network-scripts/ifcfg-&lt;网络接口名称&gt;#如：vi /etc/sysconfig/network-scripts/ifcfg-ens33#添加或修改如下 DNS 配置DNS1="223.5.5.5"DNS2="8.8.8.8"#（2）重启网络服务以生效service network restart#（3）查看当前使用的 DNS 服务器（编辑网络接口的 DNS 配置会自动更新到 /etc/resolv.conf 文件中）cat /etc/resolv.conf对于 Debain 系统，操作如下：123456789101112131415161718#（1）编辑网络接口配置文件vi /etc/network/interfaces#添加或修改如下 DNS 配置dns-nameservers 223.5.5.5 8.8.8.8#（2）安装 resolvconf 服务 #以上 dns-nameservers 配置在最小化安装的 Debian 系统中可能不会生效（即不会自动更新到 /etc/resolv.conf 中），如需使其生效，可如下操作：#安装 resolvconfapt install -y resolvconf#启用 resolvconf 服务自启动并立即允许服务systemctl enable --now resolvconf.service#（3）重启网络服务以生效service networking restart#（4）查看当前使用的 DNS 服务器（编辑网络接口的 DNS 配置会自动更新到 /etc/resolv.conf 文件中）cat /etc/resolv.conf对于 Ubuntu 系列系统，操作如下：1234567891011121314151617181920#（1）编辑网络接口配置文件vi /etc/netplan/&lt;xxx&gt;-config.yaml#如：vi /etc/netplan/00-installer-config.yaml#添加或修改如下 DNS 配置（关注：nameservers）network: #其他配置 ethernets: #其他配置 ens33: #配置的网卡的名称 #其他配置 nameservers: addresses: [223.5.5.5, 8.8.8.8] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开#（2）重新加载配置以生效netplan apply#（3）查看当前使用的 DNS 服务器（编辑网络接口的 DNS 配置会自动更新到 /etc/resolv.conf 文件中）cat /etc/resolv.conf¶方式 2、禁止其他网络配置工具自动更新 DNS由于这种方式修改的内容较多，所以不推荐手动修改 /etc/resolv.conf 配置文件默认只能临时生效，通常重启网络或重启系统后，自定义的配置内容将会被重置，这是因为该文件的配置内容会被系统的一些其他网络配置工具（如：dhclient-script、NetworkManager 服务等）所默认维护，例如：dhclient-script、systemd-resolved、NetworkManager 等默认都会获取 DHCP 服务器的 IP 并自动追加到 /etc/resolv.conf 里，如果网络接口配置文件中还定义了其他的 DNS 配置，那么这些 DNS 配置也会被追加到 /etc/resolv.conf 中。如果不希望 /etc/resolv.conf 文件所手动自定义的内容被其他网络配置工具所影响，通常只需如下操作：对于 Redhat 系列系统，操作如下：123456789101112131415161718192021222324252627282930313233#1、禁止 NetworkManager 服务自动更新 DNSecho -e "[main]\ndns=none" &gt; /etc/NetworkManager/conf.d/no-dns.confsystemctl restart NetworkManager.service#2、禁止网络接口自动更新 DNS #在网络接口配置文件中添加：PEERDNS="no"，其表示禁止网络接口自动更新 /etc/resolv.conf 文件中的 DNS 服务器，默认 PEERDNS 的值为 truevi /etc/sysconfig/network-scripts/ifcfg-&lt;网络接口名称&gt; #如：vi /etc/sysconfig/network-scripts/ifcfg-ens33#3、清空 /etc/resolv.conf 文件的配置内容echo "" &gt; /etc/resolv.conf#4、重启网络服务以生效systemctl restart network#5、自定义 DNS 服务器，之后配置将会永久有效（不会被其他网络配置工具所重置）cat &gt; /etc/resolv.conf &lt;&lt; EOFsearch localdomainnameserver 223.5.5.5nameserver 8.8.8.8EOF##如需恢复 NetworkManager 和网络接口来维护 /etc/resolv.conf，则如下操作：#1、允许 NetworkManager 服务自动更新 DNSrm -f /etc/NetworkManager/conf.d/no-dns.confsystemctl restart NetworkManager.service#2、允许网络接口自动更新 DNS #删除或注释掉 PEERDNS="no"相关的行vi /etc/sysconfig/network-scripts/ifcfg-&lt;网络接口名称&gt; #如：vi /etc/sysconfig/network-scripts/ifcfg-ens33#3、重启网络服务以生效 #重启网络后 /etc/resolv.conf 的内容将会自动被 NetworkManager 和网络接口重置systemctl restart network对于 Debain 系统，操作如下：123456789101112131415161718#1、禁用并立即停止 resolvconf 服务systemctl disable --now resolvconf.service#2、重启网络服务以生效service networking restart#3、清空 /etc/resolv.conf 文件的配置内容echo "" &gt; /etc/resolv.conf#4、自定义 DNS 服务器，之后配置将会永久有效（不会被其他网络配置工具所重置）cat &gt; /etc/resolv.conf &lt;&lt; EOFsearch localdomainnameserver 223.5.5.5nameserver 8.8.8.8EOF#如需恢复 resolvconf 来维护 /etc/resolv.conf，则如下操作：systemctl enable --now resolvconf.service#重启网络服务以生效service networking restart对于 Ubuntu 系统，操作如下：1234567891011121314#1、禁用并立即停止 systemd-resolved 服务systemctl disable --now systemd-resolved.service#2、清空 /etc/resolv.conf 文件的配置内容echo "" &gt; /etc/resolv.conf#3、自定义 DNS 服务器，之后配置将会永久有效（不会被其他网络配置工具所重置）cat &gt; /etc/resolv.conf &lt;&lt; EOFsearch localdomainnameserver 223.5.5.5nameserver 8.8.8.8EOF#如需恢复 systemd-resolved 来维护 /etc/resolv.conf，则如下操作：systemctl enable --now systemd-resolved.service参考：https://cloud.tencent.com/developer/article/1710514¶4）Windows 系统配置 DNS 服务器具体操作可参考：https://developer.aliyun.com/article/872704补充说明：大部分情况下是直接生效，如未生效可尝试下面的办法，可通过如下命令刷新 DNS1ipconfig /flushdns¶7. DNS 域名解析查询1234567891011121314#使用 nslookup 命令查询 #查询结果含如下内容： #（1）查询到的 IP 解析结果 #（2）查询域名时使用的 DNS 服务器（默认为系统配置的 DNS 服务器），可在使用时指定 DNS 服务器，如：nslookup example.com 8.8.8.8 #该命令可适用于 Windows 系统nslookup example.com#使用 dig 命令查询 #查询结果含如下内容： #（1）查询到的 IP 解析结果 #（2）查询域名时使用的 DNS 服务器（默认为系统配置的 DNS 服务器），可在使用时指定 DNS 服务器，如：dig example.com @8.8.8.8 #（3）域名的 DNS 记录类型dig example.com¶8. 配置防火墙¶1）简要概述Linux 中常见的防火墙软件有 IPtables、UFW、FirewallD，通过这些工具可以对网络流量进行管理和控制，保障系统的安全性和稳定性。注意：IPtables、UFW、FirewallD 这三种防火墙软件并不是独立的，而是存在联系和依赖关系。FirewallD 和 UFW 都是基于 IPtables 的前端工具，可以帮助用户更方便地配置和管理 iptables 规则。同时，IPtables 仍然是 Linux 系统中默认的防火墙软件之一，为其他防火墙软件提供了底层支持和功能。用户可以根据实际需求和环境选择合适的防火墙软件，并进行适当的配置和管理，以确保系统的安全性和高可用性。¶2）IPtables 防火墙IPtables 是 Linux 发行版中内置的基于 Netfilter 内核模块的防火墙软件，可用于控制和过滤网络流量。在 iptables 中，有四个主要的表（table）和五个预定义的链（chain），分别是：filter 表：这是默认情况下使用的表，用于进行最常见的防火墙操作，例如过滤数据包、禁止或允许特定端口或 IP 地址等。它包含了三个主要的链：INPUT、OUTPUT 和 FORWARD 链。nat 表：这个表用于进行网络地址转换（NAT）操作，例如将私有 IP 地址映射到公共 IP 地址、修改源或目标 IP 地址等。它包含了三个主要的链：PREROUTING、POSTROUTING 和 OUTPUT 链。mangle 表：这个表用于修改数据包的头部信息，例如修改 TTL 值、标记数据包、更改 QoS 信息等。它包含了五个主要的链：PREROUTING、OUTPUT、INPUT、FORWARD 和 POSTROUTING 链。raw 表：这个表用于处理数据包之前的连接追踪（connection tracking）操作，例如禁止或允许特定协议、配置 ICMP 参数等。它包含了两个主要的链：PREROUTING 和 OUTPUT 链。其中，五个预定义的链是：INPUT 链：这个链用于对传入到本机的入站数据包进行处理。OUTPUT 链：这个链用于对本机发起的出站数据包进行处理。FORWARD 链：这个链用于对通过本机进行转发的数据包进行处理。PREROUTING 链：这个链用于对通过网络接口的入站数据包进行处理。POSTROUTING 链：这个链用于对通过网络接口的出站数据包进行处理。提示：Debain 等系统以及一些较旧版本的 Linux 发行版系统（例如：CentOS 6、Red Hat Enterprise Linux (RHEL) 6、Ubuntu 14.04 LTS 等）默认只安装有 iptables 防火墙软件，而未安装 UFW、FirewallD 等。如果系统中安装有这些上层的防火墙软件，但又希望只使用 iptables 来管理防火墙，则一定要卸载掉这些上层的防火墙软件。¶（1）语法格式1iptables [-t 表名] 命令选项 [链名] [参数选项] [-j 动作][-t 表名]：可选参数，用于指定要操作的表名称。表定义了特定类型的规则集合。常见的表有filter、nat和mangle。如果不指定表名，则默认为filter表。命令选项：指定要执行的操作命令。通常单字母命令选项为大写字母表示，常见的命令包括：-A（--append）：在指定链的末尾添加一条新规则。（如 ：-A &lt;chain&gt;）-D（--delete）：删除指定链中的一条规则。-I（--insert）：在指定链的开头或指定位置插入一条新规则。（如：-I &lt;chain&gt; [num] ，num 表示链的行号（编号）位置，如果不指定则为链的开头）-R（--replace）：替换指定链中的一条规则。-L（--list）：列出指定链或表中的规则。-F（--flush）：清除指定链中的所有规则。-Z（--zero）：将指定链中的数据包和字节计数器归零。[链名]：可选参数，用于指定要操作的链名称。链是规则的集合，它们决定了数据包的流向和处理方式。根据具体的表和命令，可能需要指定链名。[参数选项]：用于指定规则的匹配条件和其他参数。通常单字母参数选项为小写字母表示，常见的参数选项包括：[!] -s：指定匹配数据包的源地址或地址范围。表示方式：单个 IP 地址（如：-s 192.168.0.1）、CIDR 表示法（-s 192.168.0.0/24）、主机名（如：-s host1）、网络接口（如：-s eth0）[!] -d：指定匹配数据包的目标地址或地址范围。地址表示方式类比 -s。[!] -p：指定要匹配的协议类型，如：tcp、udp、icmp、all（默认值，表示匹配所有协议）等。[!] -i（--in-interface）：指定数据包进入防火墙的网络接口，用于匹配数据包的输入接口。[!] -o（--out-interface）：指定数据包离开防火墙的网络接口，用于匹配数据包的输出接口。[!] --sport：指定要匹配的单个源端口号。表示方式：单个端口（如：--sport 80）[!] --dport：指定要匹配的单个目标端口号。表示方式类比 --sport。[!] --sports：指定要匹配的多个源端口号。表示方式：单个端口（如：--sports 80）、逗号分隔的多个端口列表（如：--sports 80,443）、端口范围（如：--sports 8000:9000 ，表示匹配端口在 8000 到 9000 范围内的）[!] --dports:指定要匹配的多个目标端口号。表示方式类比 --sports。[!] -m state --state 连接状态：匹配连接状态。NEW（新建的连接）、ESTABLISHED（已建立的连接）、RELATED（已关联连接，即已建立的连接）、INVALID（无效的连接）说明：!（取反操作符）用于对匹配条件进行取反操作。它可以在规则中用于否定某个条件，从而选择与该条件不匹配的数据包。-j 动作：用于指定规则匹配后要执行的动作。动作可以是接受、丢弃、拒绝、转发等。常见的动作包括：ACCEPT：接受（允许）放行数据包，允许数据包通过防火墙。DROP：丢弃（拒绝）数据包，直接丢弃匹配到的数据包，不给予任何响应。REJECT：拒绝（拒绝访问）数据包，发送一个拒绝的响应给源主机，通知其访问被拒绝。LOG：记录数据包信息，将匹配到的数据包的相关信息记录到系统日志中，以便后续分析。DNAT：目标网络地址转换，用于目标地址的修改，通常与网络地址转换（NAT）一起使用。SNAT：源网络地址转换，用于源地址的修改，通常与网络地址转换（NAT）一起使用。MASQUERADE：网络地址转换（NAT）的一种特殊形式，将内部网络的数据包源地址修改为防火墙的外部接口地址。REDIRECT：重定向数据包，将匹配到的数据包重定向到指定的目标地址和端口。MARK：标记数据包，可以在匹配到的数据包上设置一个特定的标记，以供后续处理使用。¶（2）添加规则12345678910111213141516#示例1：放行指定端口 # -t filter可省略 # 添加 “目标端口为80的TCP数据包允许传入” 的规则iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT#示例2：拒绝某IP访问#添加 “拒绝并丢弃源IP为192.168.100.10的传入数据包” 的规则iptables -A INPUT -s 192.168.100.10 -j DROP#设置常规安全的防火墙默认规则（即允许所有输出流量，但阻止所有输入和转发流量，另外允许ssh默认22端口的输入流量） #iptables默认情况下没有设置任何规则，以确保网络安全推荐设置默认规则，然后再根据需要添加其他规则iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPTiptables --policy INPUT DROPiptables --policy FORWARD DROPiptables --policy OUTPUT ACCEPT¶（3）删除规则123##示例1：删除放行指定端口规则#删除 “目标端口为80的TCP数据包允许传入” 的规则iptables -t filter -D INPUT -p tcp --dport 80 -j ACCEPT该命令会删除指定端口的 iptables 规则。其中 -D 表示从链中删除规则。¶（4）修改规则12#示例1：修改指定端口规则iptables -t filter -R INPUT &lt;num&gt; -p tcp --dport &lt;port&gt; -j DROP该命令会用新规则替换指定编号的旧规则，并拒绝传入 TCP 流量到指定端口。其中 -R 表示替换指定规则编号的规则。¶（5）查看防火墙规则123456789#列出默认的filter表中所有链的所有规则iptables -Liptables -nvLiptables -nvL --line-numbers#列出filter表中INPUT链的所有规则（通常用于查看流量进入服务器时的端口放行规则和IP放行规则）iptables -t filter -L INPUT -nv#列出nat表中POSTROUTING链的所有规则（通常用于查看NAT地址转换规则）iptables -t nat -L POSTROUTING -nv参数说明：-n：禁止将 IP 地址和端口号解析为主机名和服务名称。默认情况下，iptables会尝试解析 IP 地址和端口号为可读的主机名和服务名称，但使用-n参数可以避免此解析过程，以提高显示速度与可读性。-L：列出规则。[chain]：指定要操作的链名称（可选，默认为 filter 链）--line-numbers：在每个规则前面显示规则的行号（编号）。-v：以详细模式显示。该参数会在输出结果中显示规则的数据包和字节数统计信息。该命令可以列出当前 iptables 的所有规则，包括链（chain）、策略（policy）和规则（rule）等信息。¶（6）重置 iptables 规则1234567891011iptables --policy INPUT ACCEPT # 将输入链设置为默认接受所有数据包iptables --policy FORWARD DROP # 将转发链设置为默认拒绝所有数据包iptables --policy OUTPUT ACCEPT # 将输出链设置为默认接受所有数据包iptables -F # 清除所有防火墙规则iptables -X # 删除所有用户定义的链iptables -Z # 清除所有计数器和数据包计数器#注意，以上将会重置所有iptables规则，如果系统安装有Docker，则Docker相关的iptables规则也会被清空，为了保留Docker相关的iptables规则，可以通过重启Docker服务来自动添加回Docker相关的iptables规则，如下：systemctl restart docker#查看是否包含Docker相关的iptables规则iptables -nvL¶（7）防火墙规则持久化默认通过 iptables 命令操作防火墙规则会立刻生效，但这些iptables规则还在本次系统运行时有效，一旦系统重启，iptables规则将会重置为默认设置，为了使iptables规则在系统重新启动后仍然有效，用户需要将规则保存到某个文件中，并在启动时加载这些规则。操作如下：1234567891011121314151617181920#导出当前的iptables规则并保存（可选择保存为任何文件路径）mkdir -p /etc/sysconfigiptables-save &gt; /etc/sysconfig/iptables#系统重启后，需要手动执行如下命令以重新导入配置文件中的iptables规则（导入后，规则会立刻生效）iptables-restore &lt; /etc/sysconfig/iptables#如果不希望每次重启都手动导入，则可以将导入命令配置到系统启动加载配置文件中（使其能够开机自启动并自动导入 iptables 规则），如下：#提示：/etc/network/if-pre-up.d目录下的脚本将会在系统重启过程网络接口启动之前自动执行。（重启网络服务也会自动执行）cat &gt; /etc/network/if-pre-up.d/iptablesload &lt;&lt; EOF#!/bin/bashiptables-restore &lt; /etc/sysconfig/iptablesEOF#赋予执行权限chmod +x /etc/network/if-pre-up.d/iptablesload#重启测试reboot以上是手动维护配置文件和 iptables 持久化规则文件，操作比较麻烦，由此可以使用一些通用的工具简化实现，如下：1234567891011121314151617181920212223##对于Debian/Ubuntu类系统，可以安装 iptables-persistent 工具包，使其以守护进程的方式来运行，这样系统重启后可以自动将保存的内容加载到 iptables 中，如下：apt install -y iptables-persistent#保存规则service iptables-persistent save#重启测试reboot##对于RHEL/CentOS类系统，可以安装 iptables-service 工具包,使其以守护进程的方式来运行，这样系统重启后可以自动将保存的内容加载到 iptables 中，如下：#在 centos6 中默认有该工具包了，但在 centos7 中已经不能再使用类似 service iptables start 这样的命令了，所以 service iptables save 也无法执行，同时，在 centos7中，使用 firewall 替代了原来的 iptables service，不过不用担心，我们只要通过 yum 源安装 iptables与iptables-services 即可（iptables 一般会被默认安装，但是iptables-services 在 centos7 中一般不会被默认安装），在centos7 中安装完 iptables-services 后，即可像 centos6 中一样，通过 service iptables save 命令保存规则了，规则同样保存在 /etc/sysconfig/iptables 文件中#配置好yum源以后安装iptables-serviceyum install -y iptables-services#停止firewalldsystemctl stop firewalld#禁止firewalld自动启动systemctl disable firewalld#启动iptablessystemctl start iptables#将iptables设置为开机自动启动，以后即可通过iptables-service控制iptables服务systemctl enable iptables#保存规则service iptables save#重启测试reboot参考：https://www.cnblogs.com/big-cousin/p/17007533.htmlhttps://salogs.com/news/2015/08/20/iptables-save/¶（8）使用 IPtables 实现 TCP/UDP 端口转发参考：https://www.cnblogs.com/paul8339/p/14688156.htmlhttps://www.youtube.com/watch?v=qQej5kv868g¶（9）参考https://blog.csdn.net/lvoelife/article/details/129101416¶3）UFW 防火墙UFW 是 Debian 系列 Linux 系统中 IPtables 防火墙的前端工具。旨在简化 iptables 的配置。如果系统默认没有安装 UFW，则可执行命令安装：apt install ufw¶（1）查看 ufw 服务状态1systemctl status ufw¶（2）查看 ufw 的状态12#该命令可以看到ufw的状态（inactive是关闭，active是开启），ufw开启时还会列出当前配置的策略。ufw status注意：新安装 Ubuntu 系统，UFW 防火墙默认是不开启的。¶（3）开启、重启、关闭、ufw 服务123456789101112131415# 启用服务（开机启动）ufw enable# 开启服务systemctl start ufw# 重启服务systemctl restart ufw# 重新加载UFW的配置文件（即 /etc/ufw/*.rules）ufw reload# 禁用服务（开机禁用）ufw disable# 关闭服务systemctl stop ufw¶（4）查看防火墙规则1ufw status¶（5）防火墙端口规则维护123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354## 放行访问规则#放行指定端口号访问（如果不带有TCP或者UDP，则默认两种都可以）ufw allow 端口号ufw allow 端口号/tcpufw allow 端口号/udp#允许2200到2222端口的TCP流量允许访问ufw allow 2200:2222/tcp#设置特定的IP允许访问ufw allow from xx.xx.xx.xx#指定特定IP连接到特定端口允许访问ufw allow from xx.xx.xx.xx to any poart 端口号#设置特定的子网xx.xx.xx网段ip允许访问ufw allow from xx.xx.xx.0/24## 阻止访问规则#阻止指定端口号访问（如果不带有TCP或者UDP，则默认两种都可以），注意如果之前有该端口的allow规则，那么只是改规则为deny，而不会删除规则ufw deny 端口号ufw deny 端口号/tcpufw deny 端口号/udp#阻止2200到2222端口的tcpufw deny 2200:2222/tcp#阻止特定IP访问ufw deny from xx.xx.xx.xx#阻止特定IP通过端口ufw deny from xx.xx.xx.xx to any poart 端口号#阻止特定子网xx.xx.xx网段ip允许访问ufw deny from xx.xx.xx.0/24#禁止外部访问smtp服务，#以服务名代表端口，可以使用less /etc/services列出所有服务信息, 其中包括该服务使用了哪个端口和哪种协议ufw deny smtp#删除上面建立的某条规则，或者ufw delete allow 80/tcp，如果出现无法删除，可以用序号：ufw status numbered，然后通过序号删除ufw delete 1ufw delete allow smtp#要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22## 配置出入（默认的规则都是进来的，我们可以通过in和out配置）ufw allow in 2222 #允许2222端口的流量进来ufw denty in 2222 #阻止2222端口的流量进来ufw allow out 2222 #允许2222端口的流量出去ufw denty out 2222 #阻止2222端口的流量出去## 删除规则（两种方式）#方式1：通过在规则前面加上delete删除规则#删除放行的某端口规则ufw delete allow 端口号#方式2：通过查看规则序列号来删除#查看规则序列号ufw status numbered#删除第3条规则ufw delete 3## 重置规则（恢复初始规则配置）ufw reset💁‍♂ 说明：一旦启用 UFW 之后，默认情况防火墙将不允许所有入栈连接访问，包括 SSH 连接，所以在开启防火墙之后，建议将 SSH 的监听端口设置为允许访问，操作如：ufw allow ssh （等价于：ufw allow 22）在 UFW 中的所有修改都会立刻生效，不需要重新加载配置以来生效。📖 参考：https://wiki.ubuntu.org.cn/Ufw使用指南https://zhuanlan.zhihu.com/p/571124400¶4）FirewallD 防火墙FirewallD 是 Red Hat 系列 Linux 系统中 IPtables 防火墙的前端工具。旨在简化 iptables 的配置。¶（1）查看 firewall 服务状态1systemctl status firewalld¶（2）查看 firewall 的状态1firewall-cmd --state¶（3）开启、重启、关闭、firewalld.service 服务123456789101112# 开启服务systemctl start firewalld# 开机自启动服务systemctl enable firewalld# 重启systemctl restart firewalld# 关闭systemctl stop firewalld# 禁止开机自启动服务systemctl disable firewalld¶（4）查看防火墙规则1firewall-cmd --list-all¶（5）防火墙端口规则维护1234567891011121314151617#查询端口是否放行firewall-cmd --query-port=8080/tcp#放行80端口firewall-cmd --permanent --add-port=80/tcp#删除放行的80规则firewall-cmd --permanent --remove-port=80/tcp#放行端口区间firewall-cmd --zone=public --add-port=4400-4600/tcp --permanentfirewall-cmd --zone=public --add-port=4400-4600/udp --permanent#删除放行的端口区间规则firewall-cmd --zone=public --remove-port=4400-4600/tcp --permanentfirewall-cmd --zone=public --remove-port=4400-4600/udp --permanent#重新加载配置以使修改生效firewall-cmd --reload参数解释：--permanent：表示设置为持久--add-port：标识添加的端口提示：FirewallD 没有类似 ufw reset 重置规则的命令，如需恢复初始规则配置只能手动维护。¶9. 查看系统程序对应网络信息 netstat般用于检验本机各端口的网络连接情况12345678#安装net-tools（包含ifconfig、netstat等网络命令的工具包）yum install -y net-toolsapt install -y net-toolsnetstat #命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等netstat -lt #列出所有处于监听状态的tcp端口netstat -tunlp #查看所有的监听端口(包括tcp和udp)信息, 同时含 PID 和进程名称netstat -tunlp|grep 端口号 #用于查看指定监听端口号的进程情况-a：显示所有连接和监听端口-t：仅显示 TCP 连接-u：仅显示 UDP 连接-n：以数字形式显示 IP 地址和端口号，而不进行反向域名解析-l：仅显示监听状态的连接-p：显示建立相关连接的进程 ID¶10. 网络测试工具 nc12345678910111213141516171819202122232425262728293031##安装ncyum install -y nc # CentOS/RedHatapt install -y netcat # Ubuntuapt install -y netcat-openbsd # Debian##检查服务器端口是否通nc -zv ip 端口#如下：$ root@ubuntu18:~# nc -zv 192.168.30.100 80Connection to 192.168.30.100 80 port [tcp/http] succeeded!##启动一个tcp端口（默认仅支持 IPv4，可添加 -4 -6 来同时支持 IPv4 和 IPv6）nc -l -p 端口#如下：$ nc -l -p 8989 #服务端开启一个8989端口tcp进程$ telnet 192.168.60.149 8989 #客户端通过telnet连接测试端口##扫描端口(扫描指定ip某范围下启动的端口)nc -v -w 1 ip -z 扫描起始的端口-扫描终止的端口#如下：$ nc -v -w 1 example.com -z 80-443Connection to example.com 80 port [tcp/http] succeeded!nc: connect to example.com port 81 (tcp) timed out: Operation now in progressConnection to example.com 82 port [tcp/*] succeeded!nc: connect to example.com port 83 (tcp) timed out: Operation now in progressnc: connect to example.com port 84 (tcp) timed out: Operation now in progress##验证UDP端口连通性nc -l -u 8989 #服务端开启一个82端口udp进程nc -uvz example.com 8989 #客户端连接服务端验证udp端口是否可用#echo "hello" | nc -u -w1 example.com 8989 #客户端连接服务端udp端口并发生消息报文¶11. 路由追踪 traceroute现实世界中的网络是由无数的计算机和路由器组成的一张的大网，应用的数据包在发送到服务器之前都要经过层层的路由转发。而Traceroute是一种常规的网络分析工具，用来定位到目标主机之间的所有路由器1234567891011121314151617181920212223242526#-U 使用UDP协议（默认）发送数据包测试路由追踪（因为大部分的应用服务器都不提供UDP服务（或者被防火墙挡掉），所以会拿不到服务器的任何返回，所以不建议使用UDP测试）#-T 使用TCP协议的SYN发送数据包测试路由追踪#-I 使用icmp协议发送数据包测试路由追踪（ICMP即Internet控制报文协议，用于在IP主机、路由器之间传递控制消息的一种网络层协议，ICMP是IP协议的一部分，因此，ICMP协议的报文包含在IP数据报的数据部分。ICMP不像TCP或UDP有端口，只要服务器不禁止icmp消息，都是可以拿到路由应答的）#-p 指定UDP端口。缺省值为 33434。如果 UDP 端口不可用，那么该选项可以用于选择一个未曾使用的端口范围。#-m 指定最大ttl，默认30，即最大跳数traceroute [参数] ip# 测试（向baidu.com发送icmp数据包并追踪路由）$ traceroute -I -m 100 baidu.comtraceroute to baidu.com (110.242.68.66), 30 hops max, 60 byte packets 1 _gateway (192.168.60.2) 0.075 ms 0.040 ms 0.037 ms 2 * * * 3 * * * 4 * * * 5 * * * 6 * * * 7 * * * 8 * * * 9 * * *10 * * *11 * * *12 * * *13 * * *14 * * *15 * * * #***的路由表示该路由服务屏蔽了ICMP消息16 110.242.68.66 (110.242.68.66) 42.452 ms 42.450 ms 42.423 ms #共经历16跳后到达服务器Windows系统中也有路由追踪工具，那就是tracert，tracert采用的是icmp协议实现的，故不需要指定消息的协议。12#-h 指定最大ttl，默认30，即最大跳数tracert ip参考：《Traceroute（路由追踪）的原理及实现》《ICMP协议 详解，ICMP协议的功能及实现原理，ICMP协议报文类型》¶十、远程操作¶1. 远程操作网络基础域名：由一串“”用点分隔“”的名字组成，例如：www.baidu.com；是IP 地址的别名，方便用户记忆。IP地址：IP 地址是网络中计算机的唯一网络标识。端口号：是某台计算机上运行的应用程序的唯一网络标识。常见服务端口号列表：序号服务端口号01SSH 服务器2202Web 服务器8003HTTPS44304FTP 服务器21windows系统可以打开cmd输入以下命令检测网络互连的其他主机的端口号是否放行。1telnet ip 端口提示：有关 端口号的详细内容，待续补充······ssh协议： SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。特点：利用SSH协议可以有效防止远程管理过程中的信息泄露；通过SSH 协议可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗；此外它还具有一个优点，就是是传输的数据可以是经过压缩的，所以可以加快传输的速度。要搭建ssh环境，需要分别安装服务端和客户端程序。SSH服务端是安装在服务器中提供ssh协议远程操控的服务软件。只有ssh服务端运行了才能通过ssh客户端连接服务器。¶2. 远程登录¶2.1 ssh服务端安装和配置123456789101112131415161718192021222324252627282930313233343536373839404142##切换到root用户sudo -i##安装ssh服务（如没有安装）#Debian系列系统安装ssh服务apt install openssh-server#Redhat系列系统安装ssh服务yum install openssh openssh-clients openssh-server -y#编辑 sshd_config 配置文件 #将 PermitRootLogin 的值设置为 yes，表示允许 root 用户登录。 #将 PasswordAuthentication 的值设置为 yes，表示允许使用密码认证，如果为 no，则表示不允许使用密码认证，只能使用公钥认证。 #注意：如果在 sshd_config 配置文件中有导入其他配置文件，则需要注意导入的配置文件是否会覆盖配置内容，例如：Ubuntu22.04 中就会导入 /etc/ssh/sshd_config.d/50-cloud-init.conf 配置内容vi /etc/ssh/sshd_config##sshd服务管理命令 #systemctl start|stop|restart|enable|status &lt;service&gt; #Redhat系列系统启动sshd服务，并设置开机自启动systemctl start sshd #启动服务（通常安装后默认都已启动）#或：service sshd startsystemctl enable sshd #开机自启动服务#或：chkconfig --level 3 sshd onsystemctl restart sshd #重启服务（可选，如修改sshd_config配置，则需要重启服务）#或：service sshd restart#Redhat系列系统启动ssh服务，并设置开机自启动systemctl start ssh #启动服务#或：service ssh startsystemctl enable ssh #开机自启动服务#或：chkconfig --level 3 ssh onsystemctl restart ssh #重启服务（可选，如修改sshd_config配置，则需要重启服务）#或：service ssh restart##配置root用户密码认证（只需设置root用户密码即可）passwd root##配置root用户公钥认证（只需将客户端的ssh公钥内容导入到root用户的ssh配置即可）#清除root用户的默认ssh配置（防止一些默认脚本影响使用，如authorized_keys文件原本就没有脚本内容则无需操作）echo "" &gt; /root/.ssh/authorized_keys#将客户端的ssh公钥内容导入到root用户的ssh配置中（客户端可通过 cat ~/.ssh/id_rsa.pub 命令获取ssh公钥内容）echo "ssh公钥内容" &gt;&gt; /root/.ssh/authorized_keys¶2.2 ssh客户端安装和使用SSH 客户端是一种使用SSH协议连接到远程计算机的软件程序，通过SSH 客户端我们可以连接到运行了 SSH 服务器的远程机器上。12#默认系统已经安装，如果没有可通过命令来安装apt install openssh-client(1) Linux下SSH 客户端的简单使用12345##ssh远程连接服务器#user是在远程机器上的用户名，如果不指定的话默认为当前用户#remote是远程机器的地址，可以是IP或者域名#port是SSH Serve监听的端口，如果不指定，就为默认值22ssh [-p port] user@remote注意：如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可。提示：使用 exit 退出当前用户的登录(2) Windows 下 SSH 客户端的安装Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.htmlXShell http://xshellcn.com建议从官方网站下载正式的安装程序¶1）ssh免密码登录实现方式：使用公钥认证进行登录。原理：使用非对称加密原理进行登录认证。首先由ssh客户端生成密钥对，然后用户将公钥添加到服务端的某认证配置文件里。当用户登陆时，会通过私钥对请求数据进行签名，并将已经签名的数据发送给ssh服务端，ssh服务端会去认证配置文件拿到公钥并进行验签,如果验签成功则允许登入，否则拒绝。由于私钥只有保存在用户自己的客户端中，因此入侵者就算得到用户公钥，也不能登陆到服务器。非对称加密算法：使用 公钥 加密的数据，只能使用 私钥 解密使用 私钥 加密的数据，只能使用 公钥 解密实现步骤（1）SSH客户端生成密钥对12345# 生成密钥对，一路回车即可。会在~/.ssh下生成一个私钥文件（id_rsa）和一个公钥文件（id_rsa.pub）ssh-keygen# 默认 ssh 秘钥标识为 “root@主机名”，如果希望自定义标识可如下实现：ssh-keygen -t rsa -C "youremail@example.com"终端会提示一些问题：第一个问题是设置私钥和公钥的文件名，如果不设置默认是id_rsa和id_rsa.pub第二个问题是要不要对私钥设置口令（passphrase），如果担心私钥的安全则可以设置。关于多个客户端使用同一个 ssh key 的实现方式：每个客户端连接服务器都需要配置该客户端自己的 ssh key 到服务器中。通常情况下，不同的客户端会使用不同的 ssh key，这样虽然更能保护私钥的安全，但也会导致多密码管理麻烦。如果用户能确保多个客户端都是自己的，那么可以让这些客户端使用同一个 ssh key，这样就只需要设置一个 ssh key 到服务器，多个客户端就能免密连接服务器了。虽然可以直接复制 ssh key 到其他的客户端中，但在 Linux 客户端中使用时可能会提示失败：WARNING: UNPROTECTED PRIVATE KEY FILE!，解决办法是：对复制的文件重新设置操作权限，命令如下：12chmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pub（2）上传公钥到服务器方式1：直接copy客户端的~/.ssh/id_rsa.pub内容直接追加到服务端的~/.ssh/authorized_keys里。方式2：SSH客户端执行以下命令上传 到服务端：12#执行完命令即可上传客户端公钥到指定的服务器的~/.ssh/authorized_keys里（其实就是追加了id_rsa.pub的内容）ssh-copy-id -p port user@remote执行完以上操作后，远程服务器即可认证客户端，客户端也有了ssh免密登录的权限。示意图:¶3）配置ssh服务别名客户端每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆。而给客户端配置别名可以解决这个问题，譬如用：ssh myserver 来替代上面这么一长串。要实现这个功能需要在客户端的 ~/.ssh/config （没有这个文件则手动创建）里面追加以下内容：1234Host myserver HostName 服务器ip地址 User 服务器用户名 Port 22例如：1234Host myserver HostName 192.168.1.130 User qcmoke Port 22保存之后，即可用 以下命令实现快速远程登录了1234$ ssh myserver#此外对于scp命令同样可以使用myserver替代-P port user@remote了$ scp -r demo myserver:/home注意：ssh客户端会把你每次登陆过的计算机的公钥(public key)都记录在~/.ssh/known_hosts中。当下次登陆相同计算机时，ssh服务端会核对公钥。如果公钥不同，ssh服务端会发出警告给客户端。一台客户端连接多个Linux系统，会经常切换，但客户端使用同一个ip，客户端登录过一次后就会把ssh信息记录在客户端本地的~/.ssh/known_hsots文件中，客户端切换其他系统后再用ssh访问原来登陆的系统就会出现冲突警告。解决办法： 客户端直接把~/.ssh/known_hosts文件删除即可。¶3. 远程文件传输通过使用ssh客户端可以登录控制服务器了，但是想要在客户端和服务器之间进行文件传输还得需要其他的传输工具。有的是基于ssh协议的，有的基于ftp协议的，还有的是基于sftp协议等的，各有千秋。下面介绍三种工具：即SCP、FileZilla、Xftp 。¶3.1 scpscp 就是 secure copy，是基于ssh登陆进行安全的远程文件拷贝命令。只要服务器安装有ssh服务软件，客户端安装有ssh客户端软件，并建立起了连接，则可以直接使用。它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的。12345678910111213# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo选项含义-r若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名-P若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口注意：scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输¶3.2 FileZilla官方网站：https://www.filezilla.cn/download/clientFileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21。使用FTP服务的时候，我们都知道默认是21号端口，其实还有一个20号端口。FTP使用两个TCP连接，21号端口负责控制连接，20号端口负责数据连接。¶3.3 Xftp官方网站：https://www.netsarang.com/products/xfp_overview.htmlXftp除了使用FTP服务还使用了SFTP服务，通过使用SFTP协议连接服务器传输文件会更安全。SFTP是SSH的一部分，在SSH软件包中，已经包含了一个SFTP(Secure File Transfer Protocol)的安全文件传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作。由于这种传输方式使用了加密/解密技术，文件传送相对来说是很安全的，但是是有代价的，它的传输效率比FTP要低得多。¶3.4 lrzsz基于命令操作的上传下载的工具 lrzsz，目前主流的SSH连接工具 ( SecureCRT、XShell 等 ) 都支持这些协议。1234567#服务器安装yum install -y lrzsz #centosapt install lrzsz #ubuntu#在客户端执行弹窗选择文件上传rz#在服务端执行选择文件下载（多文件sz 1.txt 2.txt）sz a.txt¶十一、磁盘管理¶1. 相关基础命令123456#显示磁盘分区使用情况 -h：使用人类可读的格式 -T：显示磁盘分区文件系统类型df -h#查看可用设备（包括磁盘等）-f 查看文件系统相关设备 -S 查看scsi设备相关设备lsblklsblk -f1234567891011121314151617181920[root@localhost ~]# lsblk #TYPE：disk表示磁盘，part表示标准分区，lvm逻辑卷分区#MOUNTPOINT：挂载点NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda #第一个磁盘 8:0 0 20G 0 disk ├─sda1 #第一个磁盘下的第一个分区 8:1 0 500M 0 part &#x2F;boot└─sda2 #第一个磁盘下的第二个分区 8:2 0 19.5G 0 part ├─centos-swap 253:0 0 2G 0 lvm [SWAP] └─centos-root 253:1 0 17.5G 0 lvm &#x2F;sdb #第二个磁盘（没有分区） 8:16 0 10G 0 disk#磁盘格式化后就会有文件系统类型和uuid [root@localhost ~]# lsblk -fNAME FSTYPE（文件系统类型）LABEL UUID MOUNTPOINTsda ├─sda1 xfs be642956-78fe-4538-a3ab-840d6de853b7 &#x2F;boot└─sda2 LVM2_member dCCxeE-hgqX-XBLU-6AXZ-ikIJ-va94-Q5IF2D ├─centos-swap swap 653b8409-ce8f-4f98-904a-a1745d6568cc [SWAP] └─centos-root xfs c6387d81-0587-4548-9a06-6c406ad9034a &#x2F;sdb¶2. 标准分区管理当添加了一块新磁盘后，系统是不能直接使用的，需要对磁盘进行创建分区、格式化分区、挂载分区三个步骤后才能正常使用。¶1）创建分区1234#可通过如下命令查看新加的磁盘其所在linux系统中的名称，假设为/dev/sdbfdisk -l#创建分区，对新磁盘进行分区（执行命令之后将会进行手工命令交互过程）fdisk /dev/sdb创建分区示例123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# fdisk /dev/sdb Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x5a23d71f.Command (m for help): m #查看输入选项菜单Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only)Command (m for help): n #创建新分区Partition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): p #分区类型选择为主分区Partition number (1-4, default 1): 1 #指定分区号，如果输入1，那么分区为/dev/sdb2，2则为/dev/sdb2First sector (2048-20971519, default 2048): 2048 #指定第一个扇区地址（2048默认值，表示从磁盘的第一个扇区，可直接回车选默认）Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): 20971519 #最后一个扇区地址（默认磁盘的最大可存储地址，可直接回车选默认，如果该磁盘需要创建多个分区的话可以按照需求修改）Partition 1 of type Linux and of size 10 GiB is setCommand (m for help): w #写入分区并退出The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.默认使用DOS（即MBR）作为磁盘分区方案，如果需要使用GPT，那么需要在输入“n”创建分区之前先输入“g”指定为GPT分区方案，如需改回MBR方案，只需创建分区之前先输入“o”指定为MBR分区方案。MBR只能支持最多4个主分区或3个主分区和1个扩展分区。每个主分区最多可以有一个逻辑分区，而一个扩展分区可以创建多个逻辑分区。它使用了一个512字节的扇区来存储分区表信息，由于分区表大小的限制所以只能支持到最多4个主分区。GPT能够支持更多的分区（理论无限）。GPT没有主分区和扩展分区的概念，所有分区都是相等的，可以理解为所有的分区都是主分区。它使用64个扇区（32KB）来存储分区信息，相比之下，MBR分区表只有512字节。这使得GPT分区表能够存储更多的分区信息。¶2）格式化分区123#格式化分区mkfs -t ext4 /dev/sdb1#或者mkfs.ext4 -F /dev/sdb1¶3）挂载分区挂载即将一个分区与一个目录进行关联，使操作该目录文件即操作对应的磁盘分区。123456789101112131415161718#先创建需要挂载的目录mkdir /data#将分区挂载到对应目录（临时挂载）mount /dev/sdb1 /data#最后查看挂载是否成功df -h#设置开机自动挂载echo "/dev/sdb1 /data ext4 defaults 1 1" &gt;&gt; /etc/fstab#或者通过分区的uuid进行挂载（查看所有分区的对应UUID，可通过命令blkid查看），如下：echo "UUID=6f74be84-76e7-4177-a387-e2e711329c33 /data ext4 defaults 1 1" &gt;&gt; /etc/fstab#挂载 /etc/fstab 配置文件里的所有文件系统以立即生效mount -a#或者通过重启以生效：reboot#查看系统磁盘挂载情况df -h注意：如果需挂载的目录在挂载前存在文件，那么挂载后这些文件将会&quot;消失&quot;，但卸载后这些文件就又会显现，原因是挂载前文件是存在于原来的磁盘分区上的，如果同一目录挂载了新的磁盘分区，那么该目录显示的是新磁盘分区的内容，而新分区并没有这些文件所以文件会&quot;消失&quot;。当卸载后，挂载目录又会回到原磁盘分区上，自然就会把原本的文件显现出来。¶4）卸载及删除分区12345678910111213##卸载umount /dev/sdb1 #或者 umount /data#如果是开机自动挂载的话还需要删除/etc/fstab文件对应的挂载配置##删除分区fdisk /dev/sdbmd1 d #删除w #输入 w 保存，这个时候分区以及删除了，可以重新创建了¶参考：https://www.cnblogs.com/zishengY/p/7137671.htmlhttps://www.iplayio.cn/post/80157¶3. LVM分区管理¶1）相关概念标准分区是指将磁盘分割成若干个区域，每个区域被称为分区。每个分区都被视为一个独立的逻辑单元，并且可以格式化为不同的文件系统类型。标准分区方案的优点是简单、直观，易于管理和维护。但是，如果需要调整分区大小或添加新的分区，则需要重新分区，并且可能需要重装操作系统，这会导致数据丢失和系统停机时间较长等问题。LVM是一种更加灵活的磁盘分区方案，它允许将多个物理磁盘或分区设置为物理卷（PV）， 然后将它们组合成一个或多个逻辑卷组（VG），然后将逻辑卷组划分为一个或多个逻辑卷（LV）。逻辑卷是一个虚拟的磁盘分区，它可以动态地调整大小和移动，而不需要重新分区或重装操作系统。此外，LVM还支持在线扩容和快照等高级特性。与标准分区相比，LVM的优点在于它提供了更高的灵活性和可扩展性，可以动态地分配和管理存储空间，避免了重新分区和重装操作系统的繁琐过程。但是，LVM也存在一些缺点，比如它可能会降低磁盘性能，增加系统复杂度和学习成本等。因此，在选择分区方案时，需要根据实际需求和环境来进行权衡和选择。说明：物理卷逻辑上可划分为多个大小相同的物理拓展PE，PE是LVM中的最小分配单元，每个 PE 的大小通常为 4MB，可以在创建pv的时候指定其大小，如创建一个PE大小为8MB的物理卷/dev/sdb1：pvcreate -s 8M /dev/sdb1LV大小为PE的整数倍，组成LV的PE可能来自不同的物理磁盘。在LVM中，物理卷（PV）的可用大小可能小于其底层设备的大小，其中一些原因包括：LVM会在物理卷上保留一部分空间作为元数据区域，用于存储逻辑卷组（VG）和逻辑卷（LV）的元数据信息。这些元数据占用了一定的空间，从而减少了物理卷的可用空间。物理卷使用的文件系统可能也会在设备上分配一些空间，例如ext4文件系统会在物理卷上保留一部分空间用于存储文件系统元数据和碎片信息。这些空间也会使得物理卷的可用空间减少。如果物理卷上还有其他分区或文件系统，则它们也会占用一些空间，从而减少了物理卷的可用空间。因此，当创建物理卷时，应该考虑到这些因素，并为物理卷预留足够的空间以供元数据和其他用途使用。¶2）查看12345678#查看物理卷pvs、pvdisplay、pvscan#查看卷组vgs、vgdisplay、vgscan#查看逻辑卷lvs、lvdisplay、lvscan#查看磁盘分区fdisk -L¶3）创建 pv、vg、lv123456789101112#创建pv物理卷(设备路径可以是磁盘设备路径（/dev/sdb）或者分区设备路径（/dev/sdb1）)pvcreate 设备路径#如：pvcreate /dev/sdb#还可以同时创建多个pv，如：pvcreate vg名 pv1路径 pv2路径 pv3路径#创建vg卷组vgcreate vg名 pv路径#如：vgcreate myvg /dev/sdb#创建lv逻辑卷（大小可以用计量单位，比如5G，2048M等，如果设置的大小不满足pe大小的整数倍将自动进行四舍五入处理）lvcreate -n lv名 -L 大小 vg名#如：lvcreate -n mylv -L 5G myvg¶4）格式化和挂载 lv1234567891011#格式化lv（lv完整路径可以通过命令lvdisplay查看）mkfs.ext4 lv完整路径#如：mkfs.ext4 /dev/myvg/mylv#挂载（挂载点即需要挂载的目录，需要提前创建）mount lv完整路径 挂载点目录路径#如：mount /dev/myvg/mylv /mnt/mylv#开机自动挂载echo "lv完整路径 挂载点目录路径 ext4 defaults 1 1" &gt;&gt; /etc/fstab#如：echo "/dev/myvg/mylv /mnt/mylv ext4 defaults 1 1" &gt;&gt; /etc/fstab¶5）卸载 lv123#（如果有开机自动挂载配置还需要删除/etc/fstab文件对应的挂载配置）umount lv完整路径#如：umount /mnt/mylv¶6）删除 lv、vg、pv1234567891011#删lv（注意：删除lv前要先将其卸载）lvremove lv完整路径 #如：lvremove /dev/myvg/mylv#删vgvgremove vg名#如：vgremove myvg#删PVpvremove 设备完整路径 去硬盘#如：pvremove /dev/sdb¶7）扩容扩容 l v的时如果 vg 容量不够，需要添加 pv 并加到 vg 中然后再给 lv 扩容，否则不需要这个步骤。1234567#添加新的pvpvcreate 设备路径#如：pvcreate /dev/sdc#扩展vgvgextend vg名 新增pv路径#如：vgextend myvg /dev/sdc123#扩容lv（扩展量可以用计量单位，比如3G，通过+表示扩展多少，而如果不用+则表示扩展到多少）lvextend -L +扩展量 lv完整路径#如：lvextend -L +3G /dev/myvg/mylv以上只是对lv进行扩容，但文件系统是无法识别的，故需要调整文件系统容量123#调整文件系统容量（将文件系统扩展到逻辑卷的整个大小）resize2fs lv完整路径 #如：resize2fs /dev/myvg/mylv¶8）缩容12345678910111213141516171819#首先进行卸载umount lv完整路径#如：umount /dev/myvg/mylv#检查文件系统e2fsck -f lv完整路径#如：e2fsck -f /dev/myvg/mylv#减少文件系统resize2fs lv完整路径 减少到的大小#如：resize2fs /dev/myvg/mylv 2G#减少lv卷大小（注意:文件系统的减小后大小一定要和lv卷最终大小相等）lvreduce -L 减少到的大小 lv的完整路径#如：lvreduce -L 2G /dev/myvg/mylv#重新挂载使用mount lv完整路径 挂载点#如：mount /dev/myvg/mylv /mnt/mylv¶9）替换磁盘在 LVS 中，替换磁盘即替换 PV，注意新 PV 容量要大于等于原 PV。1234567891011#设将原sda磁盘替换为新的sdb磁盘，并移除原sda磁盘，操作如下：#先准备一个新的磁盘 pv 加入搭配 vg 中pvcreate /dev/sdbgextend myvg /dev/sdb#通过pvmove命令移动原pv的数据到新的pv中pvmove /dev/sda /dev/sdb#从vg中移除原pvvgreduce myvg /dev/sda#删除原pvpvremove /dev/sda#如果新pv容量比原pv大，则还可以通过lvextend和resize2fs命令进行扩容¶参考：https://www.cnblogs.com/linuxprobe/p/5381538.html¶十二、时间管理¶1. 查看时间1234567#查看当前系统时间date#指定格式查看当前系统时间date +"%Y-%m-%d %H:%M:%S"#查看日历，-y选项可以查看一年的日历calcal 2022¶2. 修改时间1234567891011121314#修改时分秒date -s 11:11:11#修改年月日date -s 2019-11-11#修改年月日时分秒date -s "2019-11-11 11:11:11"#保存为bios时间(RTC)（同步BIOS时钟，强制将系统时间写入CMOS，使之永久生效，避免系统重启后恢复成原时间。）hwclock -w#或者clock -w#查看bios时间hwclock -r¶3.设置时区1234567#查看当前系统配置的时区timedatectl | grep "Time zone" #或者：cat /etc/timezone#显示系统中支持的所有时区列表timedatectl list-timezones#设置当前系统为Asia/Shanghai上海时区timedatectl set-timezone Asia/Shanghai¶4. 时间同步¶4.1 单机版123456#安装ntpdateyum install ntpdate -y#同步网络时间（要求服务器可访问外网）ntpdate ntp1.aliyun.com#保存为bios时间(RTC)hwclock -w¶4.2 集群版方案：集群中，要求有一台能访问外网的服务器作为时间服务器，其余内网服务器通过这台时间服务器来实现时间同步。有两种常用的服务工具实现：ntp和chrony注意：这里ntp和chrony相比于ntpdate的区别在于，ntpdate只能手动单次同步时间（除非编写cronp配置），其同步时间的速度是很快的。而ntp和chrony本身就可以自己定时同步时间，其同步时间的速度可能需要几分钟以上。全球相关ntp时间服务器：https://www.ntppool.org/zh/¶4.2.1 ntp（1）安装和环境准备12345678#安装ntpyum install ntp -y#开放123端口防火墙作为客户端访问的端口firewall-cmd --permanent --add-port=123/udpfirewall-cmd --reload#使用前可以把其他时间同步服务关掉，比如chrony（如果有使用的话）systemctl stop chronyd &amp;&amp; systemctl disable chronyd（2）修改ntp参数配置文件🙆‍♂对于ntpd，发现这里不做配置也可以自动同步硬件时间。123vim /etc/sysconfig/ntpd#可选择修改，是让ntpdate同步时候时写到硬件vim /etc/sysconfig/ntpdate修改或者追加如下配置12#同步时间后，写到硬件中SYNC_HWCLOCK=yes（3）修改ntp配置文件12#修改ntp配置文件（只做以下相关配置修改，其余保持不变）vim /etc/ntp.conf服务端配置1234567891011#允许192.168.60.0网段内所有机器从本机同步时间restrict 192.168.60.0 mask 255.255.255.0 nomodify notrap#时间服务器地址server 0.centos.pool.ntp.org iburstserver ntp1.aliyun.com iburst#允许上层时间服务器主动修改本机时间restrict 0.centos.pool.ntp.org nomodify notrap noqueryrestrict ntp1.aliyun.com nomodify notrap noquery#外部时间服务器不可用时，以本地时间作为时间服务server 127.127.1.0fudge 127.127.1.0 stratum 10客户端配置1234567#从node1中同步时间server 192.168.60.101 iburst#允许node01修改本地时间restrict 192.168.60.101 nomodify notrap noquery#如果node01不可用，用本地的时间服务server 127.127.1.0fudge 127.127.1.0 stratum 10（4）启动和测试12345678910111213141516171819202122232425262728293031#ntpd进程进行同步时，可能需要5-10分钟的时间才能同步，另外ntpd开启后，则无法使用ntpdate，所以可以提前先手动同步ntpdate ntp1.aliyun.com#ntpdate 192.168.60.101hwclock -w#启动服务systemctl start ntpd#开机启动systemctl enable ntpdnetstat -tunlp |grep ntpd##上层 ntp 的状态 #*表示目前使用的ntp server #remote：用于同步的远程节点或服务器。“LOCAL”表示本机（当没有远程服务器可用时会出现） #refid：远程的服务器进行同步的更高一级服务器 #st：即stratum阶层，值越小表示ntp serve的精准度越高 #when：最后一次同步到现在的时间 #Poll表示，每隔多少毫秒与ntp server同步一次 #reach：已经成功更新的次数 #delay：从本地到远程节点或服务器通信的往返时间 #offset：主机与远程节点或服务器时间源的时间偏移量，offset 越接近于0，主机和 NTP 服务器的时间越接近(以方均根表示，单位为毫秒) #jitter：与远程节点同步的时间源的平均偏差（多个时间样本中的 offset 的偏差，单位是毫秒），这个数值的绝对值越小，主机的时间就越精确ntpq -p#可通过watch来实时监控watch ntpq -p#ntp 同步状态（等待5-10分钟后，查看同步状态）ntpstat#查看日志tail -f /var/log/messages¶4.2.2 chrony（1）安装和环境准备123456789#安装chronyyum install chrony -y#开放123端口防火墙作为客户端访问的端口firewall-cmd --permanent --add-port=123/udpfirewall-cmd --permanent --add-port=323/udpfirewall-cmd --reload#使用前可以把其他时间同步服务关掉，比如ntp（如果有使用的话）systemctl stop ntpd &amp;&amp; systemctl disable ntpd（2）修改chrony配置文件12#修改配置文件（只做以下相关配置修改，其余保持不变）vim /etc/chrony.conf服务端配置假设服务端ip为192.168.60.101123456789#外网ntp时间服务器地址server 0.centos.pool.ntp.org iburstserver ntp1.aliyun.com iburst#同步到bios时间(RTC)rtcsync#限制允许192.168.60网段ip的客户端同步allow 192.168.60.0/24#即使未与时间源同步也可提供本地时间local stratum 10客户端配置1234# 删除其它server，并添加如下serverserver 192.168.60.101 iburst#同步到bios时间(RTC)rtcsync（3）启动和测试1234567891011121314#启动服务systemctl start chronyd#测试时间同步的时候（假设手动设置了错误的时间）如果chronyd已经启动了的话，需要重启以下才能看效果systemctl restart chronyd#开机启动systemctl enable chronydnetstat -tunlp |grep chronyd#强制快速同步系统时间chronyc -a makestephwclock -w#chrony兼容ntpdate，客户端也可以使用ntpdate手动快速同步时间ntpdate 192.168.60.101¶5. 定时任务¶1）用户定时任务每个用户都可以创建自己的定时任务，这些任务仅对该用户可见和执行。用户定时任务通常存储在/var/spool/cron目录里。都是以用户名命名的子目录里。在 RedHat 系列系统里，用户的定时任务配置文件（也称为 crontab 文件）存储在 /var/spool/cron/ 目录中。每个用户的定时任务都保存在相应的用户名文件中，例如，root 用户的定时任务文件位于/var/spool/cron/root。在 Debian 系列系统里，用户的定时任务配置文件同样是 crontab 文件，存储在 /var/spool/cron/crontabs/ 目录中。每个用户的定时任务都保存在相应的用户名文件中，例如，root用户的定时任务文件位于 /var/spool/cron/crontabs/root。1234567891011121314151617181920212223##用户定时任务的配置格式m h dom mon dow command#编辑用户定时任务crontab -e##示例：#（1）每天凌晨2点执行命令0 2 * * * command#（2）每周一到周五的上午9点执行命令0 9 * * 1-5 command#（3）每个月的1号和15号的下午3点执行命令0 15 1,15 * * command#（4）每小时的第10分钟执行命令10 * * * * command#（5）每隔5分钟执行命令*/5 * * * * command#每1分钟执行一次任务* * * * * command #同：*/1 * * * * command💁‍♂ cron 表达式说明：定时任务的语法由五个时间字段和一个命令字段组成，用于指定任务执行的时间间隔和要执行的命令。m：分钟（minute：0-59）h：小时（hour：0-23）dom：月份中的某一天（day of month：1-31）mon：月份（month：1-12）dow：星期中的某一天（day of week：0-7，其中0和7都表示星期日）command：要执行的命令或脚本路径特殊的字符和符号：星号(*)：通配符，表示匹配所有可能的值。例如，*表示每分钟、每小时、每天、每月、每周都执行。逗号(,)：用于列举多个值。例如，1,5,10表示1、5和10这三个值。连接符(-)：用于定义范围。例如，3-6表示从3到6的连续值。斜线(/)：用于定义步长。例如，*/5表示每隔5个单位执行一次。对于分钟字段，*/5表示每隔5分钟执行一次。💁‍♂ 注意：用户定时任务只能强制以用户身份运行，不能指定执行任务的用户¶2）系统定时任务系统定时任务对整个系统生效。这些任务只有 root 用户或具有 sudo 权限的用户才能管理维护，系统级别的 crontab 文件通常存储在 /etc/crontab 或 /etc/cron.d/ 目录中。123456789101112131415##系统定时任务的配置格式m h dom mon dow user command#编辑系统定时任务vi /etc/crontab##示例：#（1）每天凌晨2点执行命令0 2 * * * root command#（2）每周一到周五的上午9点执行命令0 9 * * 1-5 root command#（3）每个月的1号和15号的下午3点执行命令0 15 1,15 * * root commanduser：执行命令的用户（默认以 root 用户身份运行，但可以指定其他用户身份运行）¶十三、Shell编程¶1. sed 命令工具偏向场景是以流处理的方式编辑文档处理方式：以行处理sed是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。¶1.1 格式1sed [选项] '[ 匹配地址 [!] 动作]' 文件名!表示对匹配地址的行不执行动作匹配地址可以是:（1）模式匹配地址，即正则表达式（2）行数范围，写数字常用选项-n： 一般sed命令会把所有数据都输出到屏幕 ，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。-e： 允许对输入数据应用多条sed命令编辑-i： 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出（即会修改源数据）动作(作用于行)a \： 追加，在当前行后添加一行或多行。添加多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。c \： 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。i \： 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。d： 删除，删除指定的行。p： 打印，输出指定的行。s：字串替换，用一个字符串替换另外一个字符串。格式为“行范。（作用于行中的字符串）围s/旧字串/新字串/g”（和vim中的替换格式类似）¶1.2 在第二行后追加一行内容1$ sed -i '2a s003,\tlisi,\tjava,\t100,\tok,' student.txt #不加-i则会输出到屏幕（即不修改原文件的内容），加了-i则会输出会原文件以覆盖原内容¶1.2 在第二行前追加两行内容123$ sed '2i \s004,\twangwu,\tjava,\t100,\tok, \s005,\tzhaosi,\tc++,\t100,\tok,' student.txt\表示输入未结束¶1.3 打印行1$ sed -n '2 p' student.txt #只打印第二行，-n防止打印第二行后还会打印所有行 #此处的2是行数匹配地址¶1.4 删除行删除第二行到第三行（不改变源文件的数据，只输出删除后剩余的结果）1$ sed '2,3d' student.txt删除第一行并修改文本源数据（将输出结果覆盖作用的文件内容）1$ sed -i '1d' student.txt¶1.5 字符串替换sed ' 匹配地址 s/旧字串/新字串/g' 文件名此处匹配地址如果是正则匹配地址，那么一定要加/ /以表示正则模式把第二行的wen改成xuan¶2. awk 命令工具偏向场景是以流处理的格式化报表输出处理方式：以行处理¶2.1 格式1awk '条件1&#123;动作1&#125; 条件2&#123;动作2&#125; …' 文件名条件（Pattern）：一般使用关系表达式作为条件x &gt; 10 判断变量 x是否大于10x&gt;=10 大于等于x&lt;=10 小于等于动作（Action）：格式化输出流程控制语句如果没有指定条件，每行都执行相应的动作所有的动作或者命令都要用{}括起来测试文件：student.txt:1234s001, wen, java, 90, ok,s001, wen, c, 90, ok,s001, wen, c#, 90, ok,s002, qcmoke, c, 100, ok,¶2.1.1 输出第一列和第二列123$ awk '&#123;print $1$2&#125;' student.txt# $1为取出第一个分隔开的字段，$2为取出第二个分隔开的字段# 默认识别的分隔符是制表符或者大于零的任意空格¶2.2 BEGINBEGIN是在所有的数据读取之前的命令语句,以是否执行成功为条件结果，满足BEGIN才执行{}里的内容¶2.2.1 测试BEGIN1$ awk 'BEGIN&#123;print "hello"&#125; &#123;print $1 "\t" $2&#125;' student.txt¶2.3 FS内置对象作用：给awk命令设置识别的分隔符1$ awk '&#123;FS=","&#125; &#123;print $1 "\t" $2&#125;' student.txtawk默认是先读入一行数据才开始处理后面的动作，故在指定分隔符后，从第二行开始才生效，而第一行无效。处理：¶2.3.1 测试FS使用BEGIN，让awk读取第一行数据前就先指定分隔符。1$ awk 'BEGIN&#123;FS=","&#125; &#123;print $1 "\t" $2&#125;' student.txt¶2.4 END作用：在所有数据都读取并执行完所有动作之后再执行某个动作，以是否成功为条件结果。¶2.4.1 测试END1$ awk '&#123;print $1$2&#125;END&#123;print "ending over !"&#125;' student.txt¶3. 通过 cat 命令在文件末尾追加内容（并防止重复添加）示例如下：1234567891011#在/etc/bash.bashrc文件末尾配置export LC_ALL="C.UTF-8"text_str='export LC_ALL="C.UTF-8"' ;\file_str='/etc/bash.bashrc' ;\grep -v '^#' "$file_str" | grep -q "$text_str" || cat &gt;&gt; "$file_str" &lt;&lt; EOF$text_strEOF#或者：text_str='export LC_ALL="C.UTF-8"' ;\file_str='/etc/bash.bashrc' ;\grep -v '^#' "$file_str" | grep -q "$text_str" || echo "$text_str" &gt;&gt; "$file_str"¶十四、vi 和 vim¶基本使用vi和vim的三种模式：123正常模式：以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、粘贴』来处理你的文件数据。插入模式：按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可.命令行模式：即先按 esc 键再输入 ：时的情况。可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的！各种模式的相互切换如图：常用操作如下：12345671) 拷贝行：在一般模式下, yy 拷贝当前行（5yy 拷贝当前行向下的 5 行），输入 p 进行粘贴。2) 删除行：删除当前行 dd ；删除当前行向下的 5 行 5dd3) 查找某个单词：命令行下，&#x2F;关键字 ， 回车 查找，输入n就是查找下一个，输入N向上查找下一个4) 设置文件的行号，取消文件的行号：在一般模式下, :set nu 和 :set nonu5) 将光标移动到文档首行和末行：在一般模式下，末行[G]，首行[gg]6) 撤销：在一个文件中输入内容后，在一般模式下, 撤销按 u7) 将光标移动到指定行：在一般模式下，先输入行号（如20），再按 shift + g更多命令操作见下图：参考：https://www.runoob.com/linux/linux-vim.html¶常见问题¶（1）解决使用 vi 或 vim 粘贴导致缩进问题或乱码这是由于 vi 或 vim 对于某些格式的文件（如：yaml 文件）进行粘贴时进行了自动格式化处理，为了防止自动格式化可如下解决：在命令模式下，输入 :set paste 并回车确认，然后再输入 i 进行粘贴。如需恢复自动缩进只需在命令模式输入 :set nopaste 即可¶十五、Linux安装¶自定义磁盘分区在安装Linux时，以下分区是必须要创建的：根分区（/）：这是Linux系统的根目录，包含操作系统的所有文件和目录。交换分区（swap）：用于虚拟内存，当物理内存不足时，系统将部分数据移至交换分区中（通常建议将交换分区大小设置为物理内存的两倍）。如果使用UEFI启动，则还需要创建一个EFI系统分区（ESP），它包含引导加载程序、内核文件和其他支持文件。但是，如果使用传统的BIOS引导模式，则不需要创建ESP分区。需要注意的是，在某些情况下，可能会出现不需要 ESP 分区也可以使用 UEFI 启动的情况。例如，某些 UEFI 固件可能支持直接从磁盘中的某个分区启动操作系统，而无需使用 ESP 分区。此外，一些特定的发行版或安装程序可能提供了与 ESP 分区无关的替代方案，以便在没有 ESP 分区的情况下实现 UEFI 启动请注意，以上仅适用于基本的Linux安装。而为了数据的安全，通常会创建以下几个分区根分区（/）交换分区（swap）/home 分区：用于存储用户数据和配置文件。/boot 分区：通常用于存储启动引导程序、内核映像以及相关的配置文件等。需要足够的空间来存储未来更新的内核文件。EFI 系统分区（ESP）：如果使用UEFI启动，则需要一个ESP分区，它包含引导加载程序、内核文件和其他支持文件，在l安装inux后会自动挂载到系统的/boot/efi目录。在某些情况下，还可能需要创建其他分区，如/var、/tmp 或 /usr 分区等。但这取决于具体的需求和Linux发行版的要求。**分区容量分配示例：**对于一个 100GB 容量的磁盘，建议将其分区和配置如下：根分区（/）：将根分区设置为 40-50GB。这足以安装Linux系统、常用应用程序和一些基本的开发工具。交换分区（swap）：将交换分区设置为 2-4GB。这里推荐使用物理内存大小的两倍作为交换分区大小的基准。/home 分区：将/home分区设置为 30-50GB。这将为用户数据和配置文件提供足够的存储空间。/boot 分区：设置 2GB（至少 200MB，但考虑到可能需要升级内核或者自编译内核等可能需要较多空间，则建议设置为 2GB，防止升级内核时出现分区空间不足的问题），要确保足够存储未来的内核更新文件。EFI 系统分区（ESP）：如果您使用 UEFI 引导，则需要创建一个 ESP 分区。通常，这个分区只需要为 100-500MB 即可。其他分区：如果您需要存储大量的数据、音频或视频文件，可以创建一个单独的数据分区。该分区的大小应根据您的特定需求来确定。提示：如果没有特别需求，其实只分配根分区和交换分区就够了。¶十六、常见问题解决¶1. linux更新被锁的解决方法123456#问题如下：E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？#解决：rm /var/lib/dpkg/lock¶2. 解决使用ls命令目录无法高亮显示的问题123456cat &gt;&gt; ~/.bashrc &lt;&lt; 'EOF'alias ls='ls --color=auto'EOF#使配置文件修改生效source ~/.bashrc]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp实现内网穿透]]></title>
    <url>%2Ftools%2Ffrp.html</url>
    <content type="text"><![CDATA[¶一、frp的作用frp的作用就是实现内网穿透，内网穿透就是允许内网的主机能够被外网的其他主机访问，内网穿透是反向代理技术中的一个中间环节技术。对于反向代理的更多理解可见另外一文《关于代理技术的理解》。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。说罢，也就是给外网提供内网主机的http 或 https 服务。此外，还能利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。此处的讲解包括:外网访问内网http 或 https 服务外网访问内网ssh服务¶二、准备说明¶实现功能（1）自定义绑定域名访问内网web服务¶配置前准备（1）公网服务器1台（2）内网服务器1台（3）公网服务器绑定域名1个（4）内网服务器部署一个web服务（5）内网服务器部署安装了ssh服务(如只做web服务，可以省略此步)¶三、服务端¶安装配置123456#下载frpwget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz#解压文件tar -zxvf frp_0.44.0_linux_amd64.tar.gz#进入解压目录cd frp_0.44.0_linux_amd64frps、frps.ini这个两个是服务端文件，frpc、frpc.ini这两个是客户端文件配置服务端123456789101112131415161718192021vi ./frps.ini[common]#与客户端绑定的进行通信的端口（必选）bind_port = 7000#访问客户端web服务http协议自定义的端口号，如果公网服务器已经搭建占用8080端口的web服务，请自行修改（可选）vhost_http_port = 8080#访问客户端web服务https协议自定义的端口号，如果公网服务器已经搭建占用443端口的web服务，请自行修改（可选）vhost_https_port = 443##frp认证配置（可选，客户端和服务端配置需要一致）#认证方式（token）authentication_method = token#认证方式, 开启连接时校验authenticate_new_work_conns = true#token认证密码（可自定义）token = admin@12345678##frp服务端web控制台配置（可选，主要用于监控当前连接端口，访问地址：http://服务端IP:7001）dashboard_port = 7001dashboard_user = admindashboard_pwd = admin@12345678按”i”键进行编辑，按esc退出编辑状态，输入:wq退出¶防火墙配置1234 #查看当前firewall防火墙服务是否开启firewall-cmd --state#查看当前firewall服务所有端口开放情况firewall-cmd --list-all如果防护墙处于关闭状态的话无需进行以下端口号的开放步骤，否则继续。如果7000端口和8080端口已经开放并且没有进程占用端口的话，则无需进行以下端口号的开放步骤，否则继续。12345firewall-cmd --permanent --add-port=7000/tcp #开放frp服务端的监听端口firewall-cmd --permanent --add-port=7001/tcp #开放frp服务端web控制台访问端口firewall-cmd --permanent --add-port=8080/tcp #开放frp对客户端web服务访问的相关转发端口firewall-cmd --zone=public --add-port=5000-5999/tcp --permanent #开放frp对客户端访问的相关转发端口区间（推荐内网穿透的远程端口设置在某个端口区间，目的是只要客户端后期添加端口在该端口区间范围时服务端不需要反复配置防火墙）firewall-cmd --reload #重新加载防火墙配置¶启动服务端1234#临时启动./frps -c ./frps.ini#后台保持启动nohup ./frps -c ./frps.ini &amp;¶四、客户端¶安装配置根据客户端操作系统的情况下载frp客户端需要注意的是：客户端和服务端的版本号要一致。frp服务端和客户端都是在一个包里，如果都是linux则下载相同版本的frp_版本号_linux_amd64.tar.gz即可，如果客户端是windows，那么下载frp_版本号_windows_amd64.zip不同操作系统操作大同小异。下面以linux为例，假设已经下载并解析好。1vi ./frpc.ini #编辑frpc.ini配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[common]#frp服务端的IP或域名（必选）server_addr = 45.129.11.99#frp服务端的监听端口（必选）server_port = 7000#启用TLS加密传输功能（可选，从v0.25.0版本开始frpc和frps之间支持通过TLS协议加密传输）tls_enable = true##frp认证配置（可选，客户端和服务端配置需要一致）#认证方式（token）authentication_method = token#认证方式, 开启连接时校验authenticate_new_work_conns = true#token认证密码（可自定义）token = admin@12345678##frp客户端控制台（可选，可用于动态修改客户端配置，其中admin_addr可设置为客户端的一个指定IP地址，那么访问则需要通过这个IP地址进行访问，如果希望可以通过客户端的多个IP地址进行访问，则可以设置为0.0.0.0。访问地址为：http://IP:7002）admin_addr = 0.0.0.0admin_port = 7002admin_user = adminadmin_pwd = admin@12345678##自定义内网穿透端口映射配置（可选）#http服务的内网穿透端口映射配置（[ ]里的名称可自定义，表示服务名称）[web]#访问协议type = tcp#本地地址（同一内网下的任何主机地址都可以） local_ip = 127.0.0.1#local_ip = 192.168.222.131#本地端口local_port = 5000#远程端口（要确保远程服务器防火墙开放对应端口）remote_port = 5000#http服务的内网穿透端口映射配置（访问协议为http时，可以进行更多的配置）[web2]type = http local_ip = 127.0.0.1local_port = 80#type为http时可以不用设置remote_port，默认会统一使用服务端配置的vhost_http_port作为远程端口#type为http时可自定义域名（访问公网服务器域名,需要解析域名到server_addr）custom_domains = example.com#ssh服务的内网穿透端口映射配置[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 5001¶启动客户端12345678#临时启动./frpc -c ./frpc.ini#后台保持启动（仅Linux）nohup ./frpc -c ./frpc.ini &amp;#重新加载配置（如修改配置文件）./frpc reload¶五、测试http和ssh（1）http测试：浏览器打开访问http://域名:8080/资源路径（如：http://example.com:8080/myproject/index.html）（2）ssh测试：12345ssh [-p port] user@remote #ssh远程连接服务器#如：ssh -p 5001 root@45.129.11.99#或者ssh -p 5001 root@example.com¶六、配置详解¶服务端12345678910111213141516171819202122232425262728293031323334353637383940[common] # 通用配置段bind_addr = 0.0.0.0 # 绑定的IP地址，支持IPv6，不指定默认0.0.0.0；bind_port = 7000 # 服务端口；bind_udp_port = 7001 # 是否使用udp端口，不使用删除或注释本行；kcp_bind_port = 7000 # 是否使用kcp协议，不使用删除或注释本行；# proxy_bind_addr = 127.0.0.1 # 代理监听地址，默认和bind_addr相同； # 虚拟主机vhost_http_port = 80 # 是否启用虚拟主机，端口可以和bind_port相同；vhost_https_port = 443vhost_http_timeout = 60 # 后端虚拟主机响应超时时间，默认为60s； # 开启frps仪表盘可以检查frp的状态和代理的统计信息。dashboard_addr = 0.0.0.0 # frps仪表盘绑定的地址；dashboard_port = 7500 # frps仪表盘绑定的端口；dashboard_user = admin # 访问frps仪表盘的用户； dashboard_pwd = admin # 密码；assets_dir = ./static # 仪表盘页面文件目录，只适用于调试； # 日志配置文件log_file = ./frps.log # 日志文件,不指定日志信息默认输出到控制台；log_level = info # 日志等级，可用等级“trace, debug, info, warn, error”；log_max_days = 3 # 日志保存最大保存时间； token = 12345678 # 客户端与服务端通信的身份验证令牌 heartbeat_timeout = 90 # 心跳检测超时时间，不建议修改默认配置，默认值为90；？ # 指定允许客户端使用的端口范围，未指定则没有限制；allow_ports = 2000-3000,3001,3003,4000-50000 max_pool_count = 5 # 每个客户端连接服务端的最大连接数；max_ports_per_client = 0 # 每个客户端最大可以使用的端口，0表示无限制 authentication_timeout = 900 # 客户端连接超时时间（秒），默认为900s； subdomain_host = frps.com # 自定义子域名，需要在dns中将域名解析为泛域名； tcp_mux = true # 是否使用tcp复用，默认为true； # frp只对同意客户端的连接进行复用；¶客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[common] # 通用配置段 server_addr = 0.0.0.0 # server的IP地址；支持IPv6server_port = 7000 # server的端口； # 如果要通过http或socks5代理连接frps，可以在此处或在全局环境变量中设置代理，只支持tcp协议；# http_proxy = http://user:passwd@192.168.1.128:8080# http_proxy = socks5://user:passwd@192.168.1.128:1080 # 客户端日志log_file = ./frpc.log # 指定日志文件；log_level = info # 指定日志等级；log_max_days = 3 token = 12345678 # 客户端与服务端通信的身份验证令牌tls_enable = true #从v0.25.0版本开始frpc和frps之间支持通过TLS协议加密传输。通过在frpc.ini的common中配置tls_ enable = true来启用此功能，安全性更高。 #为了端口复用，frp建立TLS连接的第一个字节为0x17。 #注意:启用此功能后除xtcp外，不需要再设置use. encryption。# 设置管理地址，用于通过http api控制frpc的动作，如重新加载；admin_addr = 127.0.0.1admin_port = 7400admin_user = adminadmin_passwd = admin pool_count = 5 # 初始连接池的数量，默认为0； tcp_mux = true # 是否启用tcp复用，默认为true； user = your_name # frpc的用户名，用于区别不用frpc的代理； login_fail_exit = true # 首次登录失败时退出程序，否则连续重新登录到frps； protocol = tcp # 用于连接服务器的协议，支持tcp、kcp、websocket; dns_server = 8.8.8.8 # 为frp 客户端指定一个单独的DNS服务器； # start = ssh,dns # 要启用的代理的名字，默认为空表示所有代理； # 心跳检查# heartbeat_interval = 30 # 失败重试次数# heartbeat_timeout = 90 # 超时时间 # 配置示例[ssh] # 代理配置段名称，如果配置user=your_name,则显示为your_name.ssh；type = tcp # 协议默认tcp,可选tcp,udp,http,https,stcp,xtcp;local_ip = 127.0.0.1 # 本地地址local_port = 22 # 本地端口use_encryption = false # 是否加密服务端和客户端的通信信息，默认为不加密；use_compression = false # 是否开启压缩，默认不开启；remote_port = 6001 # 在服务器端开启的远程端口；# 负载均衡配置group = test_group # 负载均衡组名，会将同一组内的客户端进行负载；group_key = 123456 # 负载均衡组密钥； # web示例[web01]type = http # 使用httplocal_ip = 127.0.0.1 local_port = 80use_encryption = falseuse_compression = truehttp_user = admin # 访问web01页面启用认证，用户名adminhttp_pwd = admin # 密码subdomain = web01 # 子域名，需要服务端配置了subdomain_host参数；custom_domains = web02.example.com # web01的域名，和subdomain二选一locations = /,/pic # 指定用于路由的URL前缀；host_header_rewrite = example.com # 配置http包头域名重写;header_X-From-Where = frp # 添加包头信息X-From-Where: frp；¶七、参考https://www.bookstack.cn/read/frp-0.36-zh/70fe76b44fdacf77.mdhttp://www.yangjinxiang.com/article/119.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>frp</tag>
        <tag>内网穿透</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基础学习笔记]]></title>
    <url>%2Ftools%2Fgit.html</url>
    <content type="text"><![CDATA[一个由浅入深，学完后能立刻上手的Git教程，对于初学者来说，有一定的参考价值。¶一、基本概念¶1. 什么是GitGit是一个开源的分布式版本控制系统。Git的分布式：Git采用了分布式版本库的方式，不需要服务器端软件支持即可在本地完成版本控制工作。Git的版本控制：是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。Git的最基本理解：简单的说Git就是用于保存文件在每次修改时的快照的一个管理系统，这些快照构成了一个个可以来回切换的版本。所以你可以通过使用git来切换快照实现文件恢复，这使得我们管理大型项目代码或者文件时得到了安全的保障机制。当然git的功能不只是快照的来回切换那么简单。它竟然是一种系统，那必然有着很多其它管理性的功能，如分支合并（或者说是快照合并）、各版本文件差异对照、本地仓库和远程仓库的连接和互动、从本地库推送到远程库，从远程库克隆到本地等等。¶2. git的文件管理机制git把数据看作是小型文件系统的一组快照。每次提交更新时git都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，git不再重新存该文件，而是只保留一个链接指针指向之前存储的文件。所以git的工作方式可以称之为快照流。¶3. git的工作流程（1）在工作区中添加、修改文件（2）将需要进行版本管理的文件存入暂存区（3）将暂存区的文件提交到git仓库¶4. git版本控制区域的情况（1）工作区：就是你在电脑里能看到的目录。（2）暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。（3）版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。¶5. git管理下文件的状态（1）已修改（modified）（2）已暂存（staged）（3）已提交（committed）¶二. 安装Git在使用 Git 前需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads安装的过程就是傻瓜式下一步。然后打开 git bash 输入相关 git 命令即可执行版本控制操作。💁‍♂ Git GUI 图形化操作工具安装 Git 后，主要是可以通过终端命令行方式进行 Git 操作，如果希望使用图形化的 Git 操作方式，可以选择以下工具：（1）Git 内置的默认 Git 图形化操作工具：git gui （windows 对应文件路径&lt;git安装路径&gt;/cmd/git-gui.exe）（2）第三方 Git 图形化操作工具：Sourcetree（不开源但免费，支持 Windows、Mac（不支持 Linux），除了支持 Git 外，还支持 Mercurial 等其他版本控制）GitKraKen（不开源且收费，支持 Windows、Mac、Linux）GitHub Desktop（开源免费，官方仅支持 Windows、Mac，但社区分支有 Linux 发行版）GitAhead（开源免费，支持 Windows、Mac、Linux）GitCola（开源免费，支持 Windows、Mac、Linux）TortoiseGit（开源免费，仅支持 Windows）GitExtensions（开源免费，支持 Windows、Mac、Linux）对于众多 Git GUI 工具的选择，个人推荐使用 Sourcetree，因为其较为主流，且美观好用。参考：https://blog.csdn.net/mzl87/article/details/128577959¶三、初始化git版本仓库1git init #初始化git版本库，会自动创建了唯一master分支，并进入此分支案例：123mkdir project #创建文件目录cd project #进入工作目录中git init #初始化git版本库，会自动创建了唯一master分支，并进入此分支project是所谓的工作区，工作区有一个隐藏目录.git，这个不算工作区，而是git的版本库。git的版本库里存了很多文件，其中其中.git/index就是所谓的暂存区，即stage（或者叫index），它是一个二进制文件，还有指向master分支的一个指针文件HEAD等。¶四、给暂存区添加文件1git add files #将files添加到暂存区案例：12echo "demo" &gt;&gt; demo.txt #创建一个内容为“demo”的测试文件git add demo.txt #将demo.txt添加到暂存区¶五、给git版本库提交文件1git commit -m "提交说明" #一次性将添加到暂存区的所有文件提交到版本库中的master分支，-m后的信息是提交说明案例：1git commit -m "commit demo.txt" #一次性将添加到暂存区的所有文件提交到版本库中的master分支，-m后的信息是提交说明¶六、查看git文件状态12git status #查看项目的当前状态信息。"AM" 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。git status -s #加了-s 参数，以获得简短项目的当前状态信息。案例：以下将从无文件改动或者添加----&gt;创建文件-----&gt;添加文件到暂存区-----&gt;提交暂存区的所有文件到git版本库这几个不同阶段的文件状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#无文件改动或者添加的情况查看git状态：wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track)#创建文件并查看git状态：wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ echo "demo" &gt;&gt;demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterNo commits yetUntracked files: #提示文件未被git跟踪，即此文件还没开始正式接受git的版本控制，一旦提交到暂存区开始到git版本库，就受到git的跟踪和版本控制。 (use "git add &lt;file&gt;..." to include in what will be committed) demo.txtnothing added to commit but untracked files present (use "git add" to track)wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)#添加文件到暂存区并查看git状态：#此时git开始跟踪提交的文件。wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git add demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage)# 可以通过git rm --cached &lt;file&gt;清除提交的文件，git又不会跟踪文件了。或者通过git rm --cached * 清空暂存区的所以文件 new file: demo.txt#提交暂存区的所有文件到git版本库并查看git状态：wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "commit demo.txt"[master (root-commit) 0e22aaf] commit demo.txt 1 file changed, 1 insertion(+) create mode 100644 demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masternothing to commit, working tree clean #此时提示没有暂存区里没有任何文件需要提交到git版本库了¶七、查看历史提交记录git的提交对象：文件对象存放在树对象里，树对象又存放在提交对象里。所以查看提交时的提交id值实际是所有提交文件组合而成的某种形式的哈希值。12345git log #输出完整历史提交记录git log --pretty=oneline #每次提交以一行输出历史提交记录git log --oneline #每次提交以一行输出简短型历史提交记录git log --decorate --all --oneline --graph #按分支情况查看提交记录git reflog #查看历史所以commit id,并且能够显示到某个版本的步数，如：HEAD@&#123;2&#125;注意：当提交记录后，git是无法再删除提交记录的（即版本仓库快照），除非删除了git仓库（.git目录），如果想要实现类似删除的效果只能通过移动HEDA指针的指向来实现。案例：以下就以修改demo.txt为例，进行历史提交记录查看。12345678910111213141516171819202122232425262728293031323334wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git logcommit 0e22aafab1b3951a989105af18d3028b0bd6dc81 (HEAD -&gt; master) #版本快照的id号，id值是通过哈希算法计算出来的哈希值，文件内容不同，哈希值必定不同。Author: qcmoke &lt;1667164190@qq.com&gt;Date: Thu Oct 18 21:47:18 2018 +0800 commit demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ vim demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git add demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "modify demo.txt"[master c3f6e58] modify demo.txt 1 file changed, 1 insertion(+), 1 deletion(-)wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git logcommit c3f6e587497f49870ab974ca4433a8e13467088d (HEAD -&gt; master)Author: qcmoke &lt;1667164190@qq.com&gt;Date: Fri Oct 19 00:11:11 2018 +0800 modify demo.txtcommit 0e22aafab1b3951a989105af18d3028b0bd6dc81Author: qcmoke &lt;1667164190@qq.com&gt;Date: Thu Oct 18 21:47:18 2018 +0800 commit demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)¶八、版本快照回滚操作为了效果，在以上已经创建并修改了demo.txt的基础上，下面继续添加readme.txt文件，并对之进行一次修改。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#创建一个readme.txt文件，内容为"hello world !"wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ echo "hello world !" &gt;&gt; readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git add readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "commit readme.txt"[master 5b144ee] commit readme.txt 1 file changed, 1 insertion(+) create mode 100644 readme.txt#修改内容，向文件里添加"I am a student !"字符串wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ echo "I am a student !" &gt;&gt; readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git add readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "modify readme.txt"[master a10b617] modify readme.txt 1 file changed, 1 insertion(+), 1 deletion(-)#查看历史提交记录wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git logcommit a10b617a02aa30ddd4e895d0653d33c7a28dcfad (HEAD -&gt; master)Author: qcmoke &lt;1667164190@qq.com&gt;Date: Sat Oct 20 20:09:17 2018 +0800 modify readme.txtcommit 5b144ee3e670f710091d7441bcde01ceaf8c622eAuthor: qcmoke &lt;1667164190@qq.com&gt;Date: Sat Oct 20 20:06:38 2018 +0800 commit readme.txtcommit c3f6e587497f49870ab974ca4433a8e13467088dAuthor: qcmoke &lt;1667164190@qq.com&gt;Date: Fri Oct 19 00:11:11 2018 +0800 modify demo.txtcommit 0e22aafab1b3951a989105af18d3028b0bd6dc81Author: qcmoke &lt;1667164190@qq.com&gt;Date: Thu Oct 18 21:47:18 2018 +0800 commit demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)以上操作完成后当前的情况如下图：¶1. 回滚到上一个版本快照1git reset HEAD~ # 回滚到上个版本并且暂存区会被回滚到的仓库版本文件所覆盖。~表示上一个版本快照，~~表示上上个快照，以此类推，也可以用数字代替，如~10则表示前10个的版本git reset --mixed HEAD~默认选项移动HEAD的指向，将其指向上一个版本快照将HEAD移动后指向的快照回滚到暂存区（暂存区会被回滚到的仓库版本文件所覆盖）git reset --soft HEAD~移动HEAD的指向，将其指向上一个快照（不回滚到暂存区）git reset --hard HEAD~移动HEAD的指向，将其指向上一个版本快照将HEAD移动后指向的快照回滚到暂存区将暂存区的文件还原到工作目录（工作目录会被暂存区的文件所覆盖）案例：1234567891011121314151617181920212223242526272829303132333435363738wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git reset HEAD~Unstaged changes after reset:M readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git logcommit 5b144ee3e670f710091d7441bcde01ceaf8c622e (HEAD -&gt; master)Author: qcmoke &lt;1667164190@qq.com&gt;Date: Sat Oct 20 20:06:38 2018 +0800 commit readme.txtcommit c3f6e587497f49870ab974ca4433a8e13467088dAuthor: qcmoke &lt;1667164190@qq.com&gt;Date: Fri Oct 19 00:11:11 2018 +0800 modify demo.txtcommit 0e22aafab1b3951a989105af18d3028b0bd6dc81Author: qcmoke &lt;1667164190@qq.com&gt;Date: Thu Oct 18 21:47:18 2018 +0800 commit demo.txt#可以发现记录里没有“modify readme.txt”的内容了，因为已经回滚到了上一个版本，而上一个版本并没有这条提交记录。wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a")#可以发现一个有趣的事情，那就是git提示要向暂存区添加文件，并提交文件到版本库。原因是执行回滚后工作区的readme.txt要比暂存区的readme.txt新，相对于工作区对readme.txt做了修改。¶2. 回滚到特定版本快照1git reset 版本快照的id号案例：1234如本例中要从第四个版本回滚到第三个版本：git reset c3f6e587497f49870ab974ca4433a8e13467088d或者简写（能识别即可）：git reset c3f6e58¶3. 回滚快照中的个别文件1git reset 版本快照 文件名/文件路径 #HEAD指针不移动，只回滚个别文件¶4. 往新版本回滚类似的只要记住版本快照的id号即可往往新版本回滚。1git reset 版本快照的id号但往旧版本回滚后并且关闭了shell，如果在回退以后又想再次回到之前的版本，用git log会查不到版本id号。可以通过以下命令查看所有commit记录。1git reflog #查看历史所以commit id¶九、恢复工作区¶1. 没有add的情况12345#检出,只能清空全部已修改的问题件, 但是对于新建的文件和文件夹无法清空, 必须组合下面命令。如果只作用个别文件用参数 -- &lt;file&gt;git checkout .#清空所有新建的文件和文件夹git clean -dfgit clean的参数说明:-f ：删除 一些 没有 git add 的 文件-df：删除 一些 没有 git add 的 文件和目录-n：显示将要删除的文件或者目录¶2. 已经add但没有commit的情况123git reset . #重置，覆盖暂存，但不覆盖本地工作区git checkout .git clean -df注: 这种情git reset不允许使用--soft和--hard选项¶3. 已经add并且commit的情况1git reset --hard HEAD~ #重置，覆盖暂存和本地工作区¶十、checkout和reset的区别恢复文件当用checkout和reset来恢复指定快照中的指定文件时，两种的命令都不会改变HEAD指针的指向。他们的区别是：checkout命令会同时覆盖暂存区和工作区；而reset命令默认只是将指定快照的指定文件恢复到暂存区（--mixed）。注意：在恢复指定快照中的指定文件时使用git reset不允许使用--soft和--hard选项恢复快照当用checkout和reset来恢复指定快照时，两种的命令都会改变HEAD指针的指向。他们的区别是：checkout命令只移动HEAD自身指向其他分支，并不移动HEAD所在的分支指针；而reset命令会移动HEAD自身指向其他分支并且会移动HEAD所在的分支指针指向其他版本库快照。¶十一、文件diff差异比较¶1. 比较暂存区与工作区的文件差异1git diff file案例：我们对demo.txt的内容做以下修改。改成以下：1234567#include &lt;iostream&gt;int main()&#123; using namespace std; cout &lt;&lt; "Hello World ！"&lt;&lt; endl; return 0;&#125;并添加到暂存区。1git add demo.txt然后在工作区再对demo.txt做修改。修改为以下：1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello Git World ！"&lt;&lt; endl; return 0;&#125;1git diff demo.txt #比较暂存区与工作区的demo.txt差异打印的内容如下：123456789101112131415diff --git a/demo.txt b/demo.txt #a/demo.txt是暂存区的demo.txt，b/demo.txt是工作区的index ab28497..f6e1eb1 100644 #ab28497..f6e1eb1是文件id，100644是文件类型和权限--- a/demo.txt #---表示旧文件+++ b/demo.txt #+++表示新文件@@ -2,6 +2,6 @@ #-表示旧文件，+表示新文件，数字表示开始行号和联连续的行数 using namespace std; #没有+或者-表示共有的内容 int main() &#123;- cout &lt;&lt; "Hello World ！"&lt;&lt; endl; #-的内容表示旧文件所特有的内容+ cout &lt;&lt; "Hello Git World ！"&lt;&lt; endl; #+的内容表示新文件所特有的内容 return 0; &#125;\ No newline at end of filewen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)¶2. 比较两个历史快照的差异1git diff 快照id1 快照id2 file¶3. 比较工作区和版本快照的差异12git diff 快照id file #工作区和具体的某个快照进行对比git diff HEAD file #工作区和HEAD所指向的版本快照进行对比¶4. 比较暂存区和版本快照的差异12git diff --cached file #暂存区和HEAD所指向的版本快照进行对比git diff --cached 版本快照id file #暂存区和具体的某个快照进行对比¶十二、提交修改需求：提交暂存区的所以文件到版本库后（如 git commit -m “commit all files as sunday !”），之后又改动了本地的某个文件，但不想因为此个例再另外提交一次而生成一个版本快照（即生成一个提交log），只想要让这个修改的文件添加到上次的提交中（当前最新的版本快照中）。可以使用以下命令来实现。1git commit --amend #提交暂存区的内容，但不产生新的版本快照，只是对原本的快照进行修改。案例：123456789101112131415161718192021222324252627282930313233343536373839404142434445wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git add demo.txt #先添加修改过的demo.txt到暂存区wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit --amend #对当前最新的快照进行修改，使暂存区的demo.txt文件覆盖最新版本仓库快照中的demo.txt。[master 319082e] commit readme.txt Date: Sat Oct 20 20:06:38 2018 +0800 2 files changed, 8 insertions(+), 1 deletion(-) create mode 100644 readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masternothing to commit, working tree cleanwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git log #发现没有另外生成一个新的版本仓库快照。commit 319082ee50a29e9f33a69d084b5f8acd17ac5b09 (HEAD -&gt; master)Author: qcmoke &lt;1667164190@qq.com&gt;Date: Sat Oct 20 20:06:38 2018 +0800 commit readme.txtcommit c3f6e587497f49870ab974ca4433a8e13467088dAuthor: qcmoke &lt;1667164190@qq.com&gt;Date: Fri Oct 19 00:11:11 2018 +0800 modify demo.txtcommit 0e22aafab1b3951a989105af18d3028b0bd6dc81Author: qcmoke &lt;1667164190@qq.com&gt;Date: Thu Oct 18 21:47:18 2018 +0800 commit demo.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)¶十三、删除各区的文件1234git rm 文件名 #只删除工作区和暂存区的该文件，git rm . 则表示清空工作区和暂存区的文件而不是指定的单个文件git rm -f 文件名 #当工作区和暂存区的内容不一样时，执行此命令来强制删除工作区和暂存区的该文件git rm -cached 文件名 #只删除暂存区的文件，但保留工作区的文件。git reset--hard HEAD~ #如果要删除文件同时要清除记录，可以采取回滚的方法案例：12345678910111213141516171819202122232425wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ lsdemo.txt readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git rm demo.txt #删除工作区和暂存区的demo.txtrm 'demo.txt'wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ lsreadme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git status #暂存区中提示已经删除demo.txtOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: demo.txt wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "deleted demo.txt" #提交本次修改[master 65ca766] deleted demo.txt 1 file changed, 7 deletions(-) delete mode 100644 demo.txt¶十四、重命名文件12git mv 旧文件名 新文件名 #重命名工作区的文件，暂存区的文件也被重命名mv 旧文件名 新文件名 #只重命名工作区的文件，暂存区的文件没有重命名案例：123456789101112131415161718192021222324wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ lsreadme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git mv readme.txt Readme.txt #将工作区和暂存区的readme.txt重命名为Readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ lsReadme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) renamed: readme.txt -&gt; Readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project (master)$ git commit -m "renamed readme.txt -&gt; Readme.txt" #提交本次修改[master 330b8d7] renamed readme.txt -&gt; Readme.txt 1 file changed, 0 insertions(+), 0 deletions(-) rename readme.txt =&gt; Readme.txt (100%)¶十五、分支管理¶1. 查看分支123456#查看本地分支（这个命令会列出当前所有本地分支，其中前面带有 * 号的表示当前所在的分支。）git branch#查看远程分支git branch -r#查看本地和远程分支git branch -a¶2. 创建分支初始化git仓库时，HEAD指针默认指向master分支。如果需要其他分支则需要创建和切换。用下面命令来实现此需求：12345#创建分支git branch &lt;name&gt;#示例：git branch dev #创建dev分支¶3. 切换分支12345678#切换分支（将当前分支切换到另一个分支，并更新工作目录中的文件内容）git checkout &lt;name&gt;#示例1：git branch dev #创建dev分支git checkout dev #切换到dev分支#示例2：git checkout -b dev #创建dev分支并切换到dev分支需要注意的是，在进行分支切换时，必须保证当前的工作目录和暂存区是干净的（没有未提交的变更），否则切换可能会失败。如果想要保存当前分支的修改，可以先执行 git add 和 git commit 命令将修改提交到当前分支，然后再执行切换分支的操作。当我们创建新的分支并（如：dev）进行分支切换时，git会新建了一个指针叫dev，其指向master相同的版本仓库快照，当切换到dev分支时，就会把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉：¶4. 合并分支¶简单使用12#合并某分支到当前分支git merge &lt;name&gt;示例：合并dev分支到master分支。1234#先切换到master分支（HEAD指针指向master） git checkout master#合并dev到当前分支（即master分支）git merge dev对于以上案例的合并原理是：HEAD指向的master指针移动到了dev指针所指的节点即完成了合并。¶合并冲突多个开发者对同一版本的同一个文件进行修改并提交，当合并两个开发者的提交的分支时会出现合并冲突问题。下面是合并冲突的一个简单示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556####（1）git项目初始化操作 #### #初始化一个新目录为git仓库 git init test #进入git仓库目录里（初始化的git仓库默认在master分支） cd test/ #创建一个测试文件并输入内容 echo "init" &gt; test.txt #提交测试文件到默认的master分支 git add . &amp;&amp; git commit -m "init" ####（2）产生冲突操作 #### #新建dev分支 git branch dev #切换到dev分支 git checkout dev #修改测试文件内容 echo "dev" &gt;&gt; test.txt #提交测试文件到dev分支 git add . &amp;&amp; git commit -m "modify by dev" #切换回和master分支 git checkout master #修改测试文件内容 echo "master" &gt;&gt; test.txt #提交测试文件到master分支 git add . &amp;&amp; git commit -m "modify by master"####（3）合并分支并解决冲突操作 #### ##此时dev分支和master分支的版本一样，但是测试文件内容不一样 #可以在master分支上合并dev分支过来，操作如下： git merge dev #此时的测试文件内容如下： $ cat test.txt init &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD master ======= dev &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev #编辑存在内容冲突的测试文件并解决冲突的内容 $ vi test.txt #删除掉特殊符号并修改为需要的内容，修改后的内容如下： init master dev #提交已经修复冲突的测试文件到master分支（冲突解决） git add . &amp;&amp; git commit -m "merge dev and modify by master" #由于某些原因需要放弃合并（如冲突难以解决），那么可以执行如下命令来撤销合并操作： git merge --abort¶分析（1）合并不会冲突情形：在原分支上的某一原节点创建第二个分支，此时原分支和新创建的分支指向这个原节点。从这个原节点往第二个分支的方向开发（修改）得到新的节点（在第二个分支上），再将第二个分支的新节点合并到原节点（在原分支上），这种合并不会发生冲突。理解:“合并节点的快照”比“被合并节点的快照”的版本新，合并不会冲突。情况如图：（2）合并会冲突情形：同一节点分叉开发后合并到其中一个分支上会合并冲突。在原分支上的某一原节点创建第二个分支，此时原分支和新创建的分支指向这个原节点，在原分支的这个原节点上开始修改得到新的节点。在第二个分支的这个原节点上修改得到另一个新的节点，此时合并一个分支到另一个分支都会冲突。理解：“合并节点的快照”和“被合并节点的快照”的版本一样新，合并会冲突。¶5. 删除分支12345#删除分支git branch -d &lt;name&gt; #示例：git branch -d dev #删除dev分支¶十六、git远程管理¶1. git服务端访问配置¶1）简要概述git客户端访问git服务端的仓库，需要通过远程仓库的地址进行访问，远程仓库的地址通常为HTTP协议地址或者SSH协议地址。（1）HTTP协议地址地址格式：http://host:port/xxx.git 或 https://host:port/xxx.git鉴权与加密方式：通过用户名和密码或访问令牌等进行身份验证，加密通信则通过TLS/SSL来实现。秘钥存储：首次首次访问远程库时需输入了用户名和密码进行身份验证，之后会保存在系统的凭据存储区域中，各个平台的凭据存储机制如下：Windows：Windows凭据管理器 （可在 控制面板&gt;用户帐户&gt;凭据管理器&gt;Windows 凭据中查看，或通过cmd命令 cmdkey /list 查看）macOS: 钥匙串（Keychain Access）Linux：GNOME Keyring或KWallet（2）SSH协议地址：地址格式：ssh://git@host:port/xxx.git 或 git@host:xxx.git （如果SSH协议地址使用默认的22端口则可忽略ssh://和端口进行简写）鉴权与加密方式：使用SSH秘钥对进行身份验证和加密通信。秘钥存储：客户端SSH秘钥对存储在~/.ssh目录，目录下有私钥文件（即id_rsa）和公钥文件（即id_rsa.pub，含公钥密文，即所谓的SSH秘钥）；服务端SSH秘钥对同样存储在~/.ssh目录下，另外服务端还有个重要的授权文件（即 authorized_keys），其存放有客户端的公钥密文，用于客户端访问的身份验证。身份验证过程：当用户尝试与SSH服务器建立连接时，服务器会要求客户端发送其公钥。如果该公钥存在于服务器上的authorized_keys文件中，则服务器将允许客户端访问并使用该SSH帐户。¶2）SSH秘钥配置¶（1）客户端配置123456#生成ssh密钥对ssh-keygen -t rsa -C "youremail@example.com"#然后连续3次回车，最终会~/.ssh目录下生成私钥文件（id_rsa）和公钥文件（id_rsa.pub）#获取客户端的ssh公钥密文（后续服务端配置用到）cat ~/.ssh/id_rsa.pub关于ssh-keygen命令行工具参数的说明：-t: 指定要生成的密钥类型。支持的密钥类型有：rsa、dsa、ecdsa、ed25519等-C: 可选，在密钥末尾添加注释信息以标识该密钥的用途（一般为用户的邮箱地址），仅仅为注释，有无都不会影响ssh加解密和身份验证。-b: 指定密钥长度（以比特为单位）。默认情况下，RSA密钥的长度为2048位，DSA密钥的长度为1024位，ECDSA密钥的长度为256位，Ed25519密钥的长度为256位。-f: 指定生成密钥的文件名和路径。如果不指定该参数，则默认生成id_rsa和id_rsa.pub两个密钥文件，并保存在~/.ssh目录下。-N: 指定新密钥的密码短语（也称为口令）。-i: 导入已有的密钥文件。-e: 将OpenSSH格式的密钥转换为其他格式（如PKCS#8格式）。-y: 提取公钥部分，输出到标准输出。-R: 从known_hosts文件中删除指定主机的条目。¶（2）服务端配置12345#添加客户端的ssh公钥密文到服务端授权文件中，用于服务端的身份验证echo "客户端的ssh公钥密文" &gt;&gt; ~/.ssh/authorized_keys#例如：echo "ssh-rsa AAAAB311/c/250YucGiB/mbZU= youremail@example.com" &gt;&gt; ~/.ssh/authorized_keys此外还可以在客户端通过命令：ssh-copy-id -p port user@remote 将公钥密文自动上传保存到服务端授权文件authorized_keys中，不过执行该命令需要输入 “user” 用户的ssh密码。服务端添加¶（3）ssh访问身份验证测试可在客户端执行如下命令来测试访问服务端时身份验证是否通过：1234ssh -p port -T git@host#例如：ssh -T git@github.comssh -p 2222 -T git@github.com¶3）客户端多SSH秘钥配置在通过SSH协议访问Git服务端时，Git客户端是借助SSH来实现访问的。在默认情况下SSH会使用~/.ssh/id_rsa为默认私钥文件，并会自动使用该密钥进行身份验证。但如果一个客户端需要访问多个服务端，并且访问不同服务端对应的SSH秘钥也不同，那么客户端就需要生成不同的SSH秘钥对文件（如：id_rsa_gitlib、id_rsa_gogs），操作如下：1234#生成新的SSH秘钥对，并指定秘钥对的文件路径ssh-keygen -t rsa -C "youremail@example.com" -f ~/.ssh/id_rsa_example #会在~/.ssh目录下生成私钥文件id_rsa_example和公钥文件id_rsa_example.pub#将新的SSH公钥设置到服务端中cat ~/.ssh/id_rsa_example.pub对于客户端使用多个不同的SSH秘钥对文件，SSH无法自动识别到这些不同文件路径的私钥文件，故无法自动使用这些非默认的私钥文件进行身份验证，也就是说无论访问哪个服务器都会使用默认的私钥文件id_rsa进行身份验证，故而对于非默认秘钥配置的服务器会验证失败。解决这个问题有以下两种方式：（1）使用新的ssh代理来添加自定义的私钥12345678#启动一个新的ssh代理ssh-agent bash#添加自定义的私钥到ssh代理中ssh-add ~/.ssh/id_rsa_example#查看所有添加秘钥列表ssh-add -l#删除所有新增的私钥#ssh-del -l💁‍♂ 关于SSH代理的说明：SSH代理（SSH Agent）是一个程序，用于管理和存储SSH密钥，并在需要进行SSH身份验证时提供这些密钥。它允许SSH客户端与SSH密钥分离，并避免在每次连接到SSH服务器时都要输入密码或者手动加载密钥的繁琐性。当您将SSH私钥添加到代理中后，代理会将私钥存储在内存中，并将其用于后续的SSH连接身份验证。这样，只要代理仍然在运行并且SSH密钥仍然存在于代理中，您就无需再次输入密码或加载密钥即可连接到SSH服务器。另外，SSH代理还提供了一种安全方式来存储和管理多个SSH密钥。通过使用SSH代理，您可以轻松地切换不同的SSH密钥，并控制哪些密钥可供使用，以确保安全性和保护私人数据。需要注意的是，在使用SSH代理时，如果您关闭了代理或重新启动计算机，则必须重新添加SSH密钥才能使用。此外，为了确保安全性，建议在使用完SSH密钥后从代理中清除它们，以避免恶意软件攻击或其他安全漏洞。（2）SSH客户端的配置文件添加SSH登录配置1234567cat &gt;&gt; ~/.ssh/config &lt;&lt; 'EOF'Host *.example.com HostName git.example.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_example User user1EOF配置文件参数Host: 请求服务端时，服务端ip或域名的匹配模式（可含通配符，如：*.60.156 或 *.example.com），可根据这个识别模式配置到主机名和私钥文件HostName: 服务端的访问ip或域名（不能含通配符，如：192.168.60.156 或 git.example.com），默认值为访问时ssh链接地址的ip或域名，如果使用内网穿透等反向代理服务器则可以修改User: ssh用户名 （默认值为ssh链接地址里的用户名）IdentityFile: 私钥文件路径Port: 端口号（默认值为访问时ssh链接地址的端口， 如果使用内网穿透等反向代理服务器则可以修改）对于git可使用如下最简写：1234cat &gt;&gt; ~/.ssh/config &lt;&lt; 'EOF'Host 192.168.60.156 IdentityFile ~/.ssh/id_rsa_exampleEOF¶2. git提交用户信息配置设置git提交代码时需要设置的作者名和电子邮件地址使用Git时，如果未设置用户名和邮箱地址，则每次提交代码时都需要手动输入相关信息，这可能会非常繁琐和易错，所以一般在提交仓库分支时，这些信息都是需要提前配置的。注意此处的提交代码的用户名并非ssh的用户名，其仅仅是标识提交代码时的作者名称，其可以根据需要进行修改。1234567891011121314151617181920#配置全局git用户信息（配置信息存储在 ~/.gitconfig 文件里）git config --global user.name "username"git config --global user.email "youremail@example.com"#配置当前项目git用户信息（可为每git本地仓库设置，配置信息存储在当前项目的 .git/config 文件里 ）git config user.name "username"git config user.email "youremail@example.com" #查看全局git用户信息git config --global user.namegit config --global user.email#也可以使用如下命令获取全局的所有配置信息git config --global --list#查看当前项目git用户信息（默认为全局git用户信息）git config user.namegit config user.email#也可以使用如下命令获取当前项目的所有配置信息git config --list¶3. 添加本仓库和远程库的关联将本地库与远程库建立联系，并指定该远程存储库的名称。123456git remote add 远程库名称 远程库地址#例如：git remote add origin https://host:port/xxx.git #使用HTTP协议地址git remote add origin ssh://git@host:port/xxx.git #使用SSH协议地址git remote add origin git@host:xxx.git #如果使用ssh协议使用默认的22端口则可如此简写¶4. 解除本仓库和远程库的关联1234git remote rm 远程库名称#例如：解除本仓库和名称为origin的远程库的关联git remote rm origin注意，此命令是解除了本地仓库和远程仓库的关联，并不是删除了远程仓库的数据。¶5. 修改本地库关联的远程库信息12345#修改本地库所对应的新远程库地址。git remote set-url 远程库名称 远程库地址#例如git remote set-url origin https://host:port/xxx.git¶6. 查看本地库关联的远程库信息1234#列出所有远程库名称git remote#列出所有远程库名称和地址git remote -v¶7.设置本地分支的上游分支即设置本地库的指定分支关联到远程库的指定分支。1234567#origin/remote_branch是远程分支的名称#local_branch是本地分支的名称（如果不写则为本地当前分支的名称，如果本地没有分支则会报错，本地初始化仓库时会自动创建默认分支master）git branch --set-upstream-to=origin/remote_branch local_branch#例如git branch --set-upstream-to=origin/master mastergit branch --set-upstream-to=origin/master¶8. 推送本地分支到上游分支即推送本地库当前分支到远程库的指定分支。1234git push 远程库名称 远程库分支#例如git push origin master12345#如果已经设置了上游分支，则可以不用加远程库的名称和地址，如下：git branch --set-upstream-to=origin/master mastergit push#或者可以合并写为如下：git push --set-upstream origin master #可简写为：git push -u origin master¶9. 克隆远程库为本地库1234git clone 远程库地址 [本地库名称]#例如：git clone git@github.com:qcmoke/test.git pro通过git clone克隆远程仓库到本地，那么git将自动初始化本地仓库，并设置本地分支和对应上游分支，上游分支为远程仓库的默认分支（一般是master分支）。¶10. 拉取远程库到本地库12#拉取远程库到本地库（取回远程库某个分支的更新，再与本地的当前分支进行合并）git pull💁‍♂ 说明：git pull = git fetch 远程库地址 + git merge 远程库名称/远程库分支git fetch只是下载远程库的分支内容到本地，但没有覆盖掉本地库的分支，需要用git merge来合并远程库的分支到本地库的当前分支。比如git pull命令默认会被解析成如下：12&gt;git fetch origin master #从origin远程库的master分支下载更新内容到本地 &gt;git merge FETCH_HEAD #将下载好的远程库分支合并到当前分支中💁‍♂ 注意：使用命令git pull拉取分支前，一般是已经通过 git clone 来克隆获取远程库的代码了。如果先前未使用 git clone 的话，需要先添加远程仓库，并设置本地分支的上游分支后才能正常使用 git pull命令来拉取分支 。操作如下：12345&gt;git remote add origin https://host:port/xxx.git&gt;git branch --set-upstream-to=origin/master master&gt;git pull&gt;#设置本地分支的上游分支和拉取两条命令可合并写为如下（注意在git pull中的--set-upstream不能简写为-u）：&gt;git pull --set-upstream origin master¶11. 解决推送本地库到远程库冲突的问题当有两个本地库都连接着同一个远程库，当有一个修改了文件并且推送到了远程库后。另外有个仓库也修改到了同样的文件。如果内容两个推送的修改不一致，那么就造成了冲突。比如根据之前的例子，本地有pro和project2两个仓库。（1）修改project2的readme.txt文件的内容为以下：12I am readme.txtmodify readme.txt by project212345678910111213141516171819wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project2 (master)$ git add readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project2 (master)$ git commit -m "modify readme.txt by project2"[master 17938ff] modify readme.txt by project2 1 file changed, 2 insertions(+), 1 deletion(-)wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/project2 (master)$ git push origin masterEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 292 bytes | 146.00 KiB/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:qcmoke/test.git 12f4d1d..17938ff master -&gt; master（2）在project2修改并提交readme.txt到远程库后，又在本地的pro仓库修改readme.txt，同样提交readme.txt到远程库。本地的pro修改readme.txt的内容为以下：12I am readme.txtmodify readme.txt by pro12345678910111213141516171819202122wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$ git add readme.txtwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$ git commit -m "modify readme.txt by pro"[master 32cde6b] modify readme.txt by pro 1 file changed, 2 insertions(+), 1 deletion(-)wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$ git push origin masterTo github.com:qcmoke/test.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'git@github.com:qcmoke/test.git'hint: Updates were rejected because the remote contains work that youdohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$git推送失败，原因是推送的内容与本地仓库project2的推送有冲突，project2推送时，已经更新了一个版本。而pro此时比远程仓库旧了一个版本，当推送时就与远程库的版本一样了，但问题是同样推送到同一个远程仓库版本，而远程仓库的这个版本中的readme.txt已经被project2修改了。git远程仓库无法确定要哪个本地库的修改，所以就冲突了。这要求在被其他本地库修改之前就要更新本地库pro到与远程库相同的版本快照，才能进行修改后推送。通过以下命令来更新本地库pro到与远程库相同的版本快照：1$ git pull origin master然后再将本地pro的readme.txt的内容修改为以下：12I am readme.txtmodify readme.txt by pro然后再推送添加提交到本地仓库，再将本地仓库的最新版本推送到远程仓库：1234567891011121314151617181920wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$ git pull origin masterFrom github.com:qcmoke/test * branch master -&gt; FETCH_HEADAlready up to date.wen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$ git push origin masterEnumerating objects: 9, done.Counting objects: 100% (9/9), done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (5/5), 606 bytes | 202.00 KiB/s, done.Total 5 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:qcmoke/test.git 17938ff..830af40 master -&gt; masterwen@DESKTOP-BHMU9KJ MINGW64 ~/Desktop/pro (master)$¶十七、团队协同开发两种方式：项目管理者发送请求邀请其他成员加入到项目里，需要管理者通过用户名或者邮箱邀请其他成员，同时其他成员也要同意接受才能加入到项目中，如此其他成员就能git push。其他成员先fork项目成为自己的仓库，然后git push到自己的仓库后，发送Pull Requests请求给管理者。管理者同意并merge合并其他成员的修改内容到自己的仓库里。详细步骤待完成… 😂¶十八、问题解决¶1. centos7 最小系统精简安装git问题centos7 最小系统精简安装后，在 git clone 时出现问题提示：fatal: unable to access 'https://xxxxxx.git/': Peer reports incompatible or unsupported protocol version.解决办法：1yum update -y nss curl libcurl1234vi /etc/profile#修改：PATH=$PATH:/usr/libexec/git-coreexport PATHsource /etc/profile¶2. git bash 中文乱码问题解决乱码如下：解决办法：1git config --global core.quotepath falsecore.quotepath 是 Git 的一个配置选项，用于指定在命令输出中是否对文件名进行引号转义。解决后效果如下：参考：https://www.php.cn/tool/git/485156.html¶十九、Git 常用命令速查表创建版本库12git clone #克隆远程版本库git init #初始化本地版本库修改和提交123456789git status #查看状态git diff #查看变更内容git add . #跟踪所有改动过的文件git add #跟踪指定的文件git mv #文件改名git rm #删除文件git rm --cached #停止跟踪文件但不删除git commit -m "commit messages" #提交所有更新过的文件git commit --amend #修改最后一次改动查看提交历史123git log #查看提交历史git log -p #查看指定文件的提交历史git blame #以列表方式查看指定文件的提交历史撤销1234git reset --hard HEAD #撤销工作目录中所有未提交文件的修改内容git checkout HEAD #撤销指定的未提交文件的修改内容git revert #撤销指定的提交git log --before="1 days" #退回到之前1天的版本分支与标签1234567git branch #显示所有本地分支git checkout #切换到指定分支和标签git branch #创建新分支git branch -d #删除本地分支git tag #列出所有本地标签git tag #基于最新提交创建标签git tag -d #删除标签合并与衍合12git merge #合并指定分支到当前分支git rebase #衍合指定分支到当前分支远程操作12345678git remote -v #查看远程版本库信息git remote show #查看指定远程版本库信息git remote add #添加远程版本库git fetch #从远程库获取代码git pull #下载代码及快速合并git push #上传代码及快速合并git push #删除远程分支或标签git push --tags #上传所有标签更多内容请查看 Git 文档。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook使用教程]]></title>
    <url>%2Fblog%2Fgitbook.html</url>
    <content type="text"><![CDATA[¶一、安装gitbook依赖于node.js,安装也是通过nodejs的npm包管理器安装gitbook。你可以到node.js的官网下载。并添加nodejs的安装路径到环境变量path中。打开cmd或者其他终端（如git bash等），输入以下命令即可安装gitbook。1npm install gitbook-cli -g¶二、使用接下来讲一下gitbook工作区的概念。这个工作区就是你管理和编写book的地方。gitbook允许你在不同的目录上创建多个工作区。它们互不影响。现在就讲讲如何创建这样的工作区。首先，你需要先创建一个目录，如在桌面上创建了一个名称为mybook的目录（文件夹），然后通过以下命令对这个目录进行初始化:1gitbook init通过以上初始化后会mybook里生成两个文件，分别是README.md和SUMMARY.md。这两个文件就是你写book的文件。其中README.md是book的每页内容，而SUMMARY.md的作用则是生成book的目录。这些目录和README.md是一一对应的关系。1gitbook build1gitbook serve¶三、安装插件和优化功能在mybook目录下创建一个名为book.json的文件。将以下内容复制粘贴到此文件中：当然以下的gitbook、title、description、author 、github 、wechat需要根据你的情况来做修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "gitbook": "3.2.3", "title": "Qcmoke's Book", "description": "my book", "author": "qcmoke", "language": "zh-hans", "links": &#123; "sidebar": &#123; &#125; &#125;, "plugins": ["github", "donate", "splitter", "anchor-navigation-ex", "-sharing", "sharing-plus", "-highlight", "prism" ], "pluginsConfig": &#123; "sharing": &#123; "douban": false, "facebook": false, "google": false, "hatenaBookmark": false, "instapaper": false, "line": false, "linkedin": false, "messenger": false, "pocket": false, "qq": false, "qzone": false, "stumbleupon": false, "twitter": false, "viber": false, "vk": false, "weibo": false, "whatsapp": false, "all": [ "weibo","qq","qzone","google","douban" ] &#125;, "github": &#123; "url": "https://github.com/qcmoke" &#125;, "donate": &#123; "wechat": "https://example.com/images/wechatpay.png", "title": "", "button": "赏", "wechatText": "微信打赏" &#125;, "anchor-navigation-ex": &#123; "associatedWithSummary":false, "showLevel":true, "multipleH1": true, "mode": "float", "pageTop": &#123; "showLevelIcon": false, "level1Icon": "fa fa-hand-o-right", "level2Icon": "fa fa-hand-o-right", "level3Icon": "fa fa-hand-o-right" &#125; &#125;, "theme-default": &#123; "showLevel": true &#125;, "fontsettings": &#123; "theme": "white", "family": "serif", "size": 2 &#125;, "prism": &#123; "css": [ "prismjs/themes/prism-tomorrow.css" ] &#125; &#125;&#125;然后执行以下命令即可安装插件并优化功能。1gitbook install ./¶四、部署到github如果还没有配置ssh key，你要先给本机配置好ssh key。然后在github上创建一个仓库。如名称为mygitbook的仓库。你需要将gitbook工作下的_book初始化为git仓库。然后再推送到github远程仓库。大概如下：1234567$ gitbook build$ cd _book$ git init$ git add$ git commit -m "first commit"$ git remote add origin git@github.com:qcmoke/mygitbook.git$ git push -u origin master以上部署完成后需要到github选择mygitbook仓库后，点击setting开启并设置github pages服务。具体如下：将source设置为master或者gh-pages，并保存。此时便可以通过http://yourname.github.io/mygitbook（如果你再设置此仓库的pages前有在其他仓库设置过自定义域名，那么会通过http://你的域名）访问你的gitbook主页了。如果你需要通过https访问，你可以点击下方的Enforce HTTPS即可通过https进行访问。此条为可选项&lt;-----如果你需要再此仓库里另外设置域名，无论你之前是否有在其他仓库设置过自定义域名，在此仓库你还可以再设置自定义域名，可以是顶级域名，也可以是二级子域名，但不能和其他仓库的自定义域名一样，否则会冲突。前提是需要你到域名解析平台将该自定义域名解析一条CNAME记录到yourname.github.io 。并且可选性的添加Enforce HTTPS，自定义域名添加httts比较尴尬，需要你再等待24个小时左右才能成功。如果运气好的话会提前一些。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的scp命令]]></title>
    <url>%2Flinux%2Fscp.html</url>
    <content type="text"><![CDATA[Linux之间复制 文件 和 目录 使用命令：scp，命令基本格式：scp [可选参数] file_source file_target¶介绍linux 之间复制 文件 和 目录使用命令：scp¶命令命令基本格式：scp [可选参数] file_source file_target¶复制文件¶命令模板1234scp local_file remote_username@remote_ip:remote_folder scp local_file remote_username@remote_ip:remote_filescp local_file remote_ip:remote_folderscp local_file remote_ip:remote_file1指定了用户名，命令执行后需要再输入密码，仅指定了远程的目录（文件名不变）；2指定了用户名，命令执行后需要再输入密码，指定了远程的目录且指定了文件名；3 命令执行后需要输入用户名和密码，仅指定了远程的目录（文件名不变）；4 命令执行后需要输入用户名和密码，指定了远程的目录且指定了文件名；¶样例1234scp ~&#x2F;home&#x2F;test.txt zhuzhutest@10.1.1.2:&#x2F;home&#x2F;scp ~&#x2F;home&#x2F;test.txt zhuzhutest@10.1.1.2:&#x2F;home&#x2F;change_name.txtscp ~&#x2F;home&#x2F;test.txt 10.1.1.2:&#x2F;home&#x2F;scp ~&#x2F;home&#x2F;test.txt 10.1.1.2:&#x2F;home&#x2F;change_name.txt¶复制目录¶命令模板12scp -r local_folder remote_username@remote_ip:remote_folderscp -r local_folder remote_ip:remote_folder1指定了用户名，命令执行后需要再输入密码；2 命令执行后需要输入用户名和密码；¶样例12scp -r ~&#x2F;home&#x2F;folder1 zhuzhutest@10.1.1.2:&#x2F;home&#x2F;scp -r ~&#x2F;home&#x2F;folder2 10.1.1.2:&#x2F;home&#x2F;将本机用户下~/home/folder1目录和~/home/folder2目录分别复制远程目标Linux。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过git备份还原hexo源码]]></title>
    <url>%2Fblog%2Fhexo_backup.html</url>
    <content type="text"><![CDATA[Hexo博客存在一个问题：我们仅仅将博客的静态页面文件部署到了github远程仓库中，而我们的站点源文件仍在本地存储。如果存储站点源文件的电脑系统崩溃了，或者我们换了其他电脑，我们便无法实时更新博客了。如果选择重新搭建站点，不仅过程繁琐，而且还需要大量时间安装依赖、主题配置、博客优化，极其麻烦。所以我们需要将站点必要文件也部署到远程仓库中。然而github的私有仓库是要收费的，如果用免费仓库，暴露hexo源码，尤其是配置文件是很不安全的，因为配置文件中可能含有你的隐私信息，比如各种秘钥等。所以有一个私人仓库是很有利的。你可以通过购买服务器搭建自己的git私人服务器并备份hexo源码。你也可以在coding等这样提供私人仓库的服务商进行hexo源码备份。我们采取的远程仓库部署策略是：使用coding的私人仓库，一个仓库两个分支。仓库即[yourname.coding.me]，一个分支[master]用于托管演示页面，一个分支[backup]用于备份Hexo博客站点的必要文件。¶一、备份多机同步更新的前提：backup分支（也可以是其他名称的分支或者新的仓库）Hexo博客站点的必要文件：12345678.├── scaffolds # 文章模板├── source # 用户源文件：页面，文章markdown文件├── themes # 主题├── .gitignore # git忽略文件信息├── _config.yml # 站点配置文件├── package.json # 已安装插件映射表，下次只需npm install即直接安装表中的插件├── package-lock.json使git上传远程git服务器（这里是coding）时可忽略不必要的文件，做法是编辑站点根目录下的.gitignore文件，复制粘贴一下内容到.gitignore文件中。1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/¶1.删除必要文件删除themes/你的主题中的.git，.github，.gitignore等git仓库文件，只保留站点根目录下的.gitignore。¶2.hexo源码备份在Hexo博客站点根目录（即blog文件夹）中打开GitBash：123456$ git init # 将blog作为一个git仓库进行初始化$ git checkout -b backup # 创建/切换本地backup分支$ git add . # 将文件添加到暂存区 $ git commit -m "提交说明" # 将暂存区文件提交到本地仓库$ git remote add origin git@git.coding.net:yourname/yourname.coding.me.git # 添加远程仓库$ git push origin backup # 将本地仓库推送至远程仓库如果远程已经存在backup分支，推送本地分支backup到已有的远程分支backup，达到更新远程backup的目的：1$ git push --force origin backup #git push的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。¶二、还原¶1.还原前提(1) 安装Git(2) 安装nodejs¶2.hexo源码还原12345$ git clone -b backup https://git.coding.net/yourname/yourname.coding.me.git # 克隆backup分支到本地，私有仓库需要输入用户名和密码$ cd yourname.coding.me # 进入yourname.coding.me文件夹$ npm install hexo --save # 安装hexo$ npm install hexo-cli -g # 安装hexo命令行模式$ npm install # 安装所有依赖，根据package.json自动安装之前安装过的插件¶3.Git配置用户信息（新系统环境下）在Git bash中输入：（1）设置用户名12git config --global user.name ‘这里填写自己的用户名’ 如： git config --global user.name 'qcmoke'（2）设置用户名邮箱12git config --global user.email ‘这里填写自己的用户邮箱’ 如：git config --global user.email '1667164190@qq.com'（3）查看配置信息1git config --list注意：该设置在GitHub仓库主页显示谁提交了该文件，注意这里的 - 有两个！¶4.配置网络协议(1) SSH协议，长期部署推荐SSH，一劳永逸。①SSH秘钥：123$ ssh-keygen -t rsa -C "youremail@example.com" # 生成rsa秘钥$ cd ~/.ssh # 进入虚拟目录ssh文件中$ cat id_rsa.pub # 显示id_rsa.pub文件内容②复制秘钥至github/coding-&gt;用户setting-&gt;SSH keys，New SSH Key；③验证是否添加成功12$ ssh -T git@github.com # 验证github是否添加成功$ ssh -T git@git.coding.net # 验证coding是否添加成功④编辑站点配置文件_config.yml：123456deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git coding: git@git.coding.net:yourname/yourname.coding.me.git branch: master¶5.新环境下部署hexo博客重新部署：12$ hexo clean$ hexo g -d¶6.及时更新hexo源码到coding（如果有修改hexo源码）上传至hexo分支：123$ git add .$ git commit -m "commit-message"$ git push origin backup]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows安装mysql5.7解压版]]></title>
    <url>%2Fdevops%2Fwin_mysql.html</url>
    <content type="text"><![CDATA[本文记录了windows10安装mysql5.7解压版的实战过程，对于初学者极有帮助。根据本文教程能尽量避免很多不必要的歪路…¶零. 下载mysql官方下载地址:https://dev.mysql.com/downloads/mysql/此处选择的版本是mysql-5.7.23解压版https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.23-winx64.zip¶一. 前置准备解压mysql-5.7.23-winx64.zip里的文件到C:\DevelopmentTools\mysql-5.7.23-winx64目录。创建mysql安装配置文件，命名为my.ini。文件里的内容如下，复制粘贴到my.ini即可。12345678910111213141516171819[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\DevelopmentTools\\mysql-5.7.23-winx64# 设置 mysql数据库的数据的存放目录，如果是MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错datadir=C:\\DevelopmentTools\\mysql-5.7.23-winx64\\data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 最大连接数max_connections=500配置完成后，将my.ini文件放到C:\DevelopmentTools\mysql-5.7.23-winx64目录中。¶一.安装mysql以下内容以mysql软件包目录在C:\DevelopmentTools\mysql-5.7.23-winx64为例进行安装，同样安装完成的目录也是此目录。以管理员身份运行cmd，执行以下命令进入C:\DevelopmentTools\mysql-5.7.23-winx64\bin目录：1cd C:\DevelopmentTools\mysql-5.7.23-winx64\bin¶1.安装mysql服务1mysqld -install mysql注：mysqld -install [服务名],服务名默认为mysql，若无需要，建议不更改。如果提示丢失MSVCR120.dll，需要下载安装VC++2013。浏览器打开https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=40784，选择&quot;单击手动下载&quot;，选择合适系统的版本，比如64位系统则选vcredist_x64.exe，而32位系统选vcredist_x86.exe。如果丢失的是其它连接库，同样根据提示到微软官网下载安装即可。¶2.初始化mysql1mysqld --initialize-insecure注：–initialize有两个-，后边没有空格初始化后，C:\DevelopmentTools\mysql-5.7.23-winx64目录下会出现data目录¶3.添加mysql环境变量将C:\DevelopmentTools\mysql-5.7.20-winx64\bin添加到Path中，方便在任何目录下都可以执行mysql命令。¶4.启动mysql服务以管理员身份运行cmd1net start mysql¶5.无密码登录mysql方式1：一次回车即可登录1mysql -uroot方式2：第一次回车后，不输入密码，再次回车即可登录1mysql -uroot -p¶6.修改密码（默认没有密码 ）1set password=password('123456');¶7.用密码登录mysql，输入以下命令回车1mysql -uroot -p123456¶8. 查看字符集是否符合预期值1234567891011121314mysql&gt; show variables like 'char%';+--------------------------+----------------------------------------------------------+| Variable_name | Value |+--------------------------+----------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | C:\DevelopmentTools\mysql-5.7.23-winx64\share\charsets\ |+--------------------------+----------------------------------------------------------+8 rows in set (0.00 sec)除了character_set_filesystem都是utf8，符合预期配置值！¶9. 查看最大连接数是否符合预期值1234567mysql&gt; show variables like 'max_connections';+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 500 |+-----------------+-------+1 row in set (0.00 sec)¶一.卸载mysql¶1.以管理员身份运行cmd并进入C:\DevelopmentTools\mysql-5.7.23-winx64\bin目录1cd C:\DevelopmentTools\mysql-5.7.23-winx64\bin¶2.关闭mysql服务1net stop mysql¶3.卸载mysql，mysqld -remove [服务名]，服务名默认为mysql1mysqld -remove mysql¶4.删除mysql安装目录¶5.cmd输入以下命令打开注册表：1regedit清除注册表中的该MySQL服务，有几个地方:a. HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\services\eventlog\Application\MySQL 目录删除b. HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\services\eventlog\Application\MySQL 目录删除c. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\eventlog\Application\MySQL 目录删除注册表中的ControlSet001、ControlSet002不一定是001和002，可能是ControlSet005、006之类，删除的时候把里面的MySQL目录都删除就可以。这些目录中可能也没有，没有的话忽略即可。​¶三. 更多内容更多内容见：https://blog.csdn.net/mr_green1024/article/details/53222526]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode教程]]></title>
    <url>%2Ftools%2Fvscode_use.html</url>
    <content type="text"><![CDATA[vscode是很优秀的文本编辑器，甚至可以说是强大的ide开发工具，由于其良好的用户体验，丰富的扩展插件，让其受到很多开发者的青睐，这里就只介绍一些常用插件的安装和使用教程。¶通用设置推荐settings.json 推荐通用设置配置如下（不包括插件配置）：1234567891011121314151617181920&#123; //修改vscode的默认终端（PowerShell、Git Bash、Command Prompt） "terminal.integrated.defaultProfile.windows": "Git Bash", //编辑自动保存 "files.autoSave": "afterDelay", //根据文件编码格式自动选择合适的编码方式打开文件 "files.autoGuessEncoding": true, //在括号匹配时高亮显示相应的括号 "editor.guides.bracketPairs": true, //保存自动格式化 "editor.formatOnSave": true, //复制粘贴时自动格式化复制内容 "editor.formatOnPaste": true, //在键入下一行后自动格式化该行 "editor.formatOnType": true, //自动换行显示 "editor.wordWrap": "on", //关闭工作区受限模式 "security.workspace.trust.enabled": false,&#125;¶主题插件推荐的三款主题插件：Atom One Dark ThemeOne Dark ProGitHub Theme¶图标插件推荐的两款图标插件：Material Icon Themevscode-icons¶通用功能插件¶Code Runner【代码运行】允许在编辑器中直接运行代码片段或整个文件，并且支持多种编程语言。安装完成插件可以做如下优化配置：123456// 在vscode的终端中运行和输出（默认在控制台输出）"code-runner.runInTerminal": true,"code-runner.executorMap": &#123; //修改java类型文件编译运行命令（编译使用utf8编码） "java": "javac -encoding utf8 $fileName &amp;&amp; java -Dfile.encoding=UTF-8 $fileNameWithoutExt",&#125;,¶Chinese (Simplified) (简体中文)【中文语言包】这应该不用多介绍，是vscode的官方中文语言包¶Prettier - Code formatter【前端代码格式化工具】支持超多语言（主要支持html、css、js、vue等前端语言），一键格式化，美化代码格式配置方式：在vscode全局设置配置文件settings.json中配置或者工作区设置配置文件.vscode/settings.json中配置（会覆盖全局设置）：123456789101112&#123; // 使用prettier插件格式化javascript文件 "[javascript]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, // 使用prettier插件格式化html文件 "[html]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, // prettier插件格式化换行行宽限制，超过则自动换行（只对前端的一些文件有效，如：html、css、js、vue等） "prettier.printWidth": 120,&#125;或者在项目根目录中创建文件.prettierrc进行配置（会覆盖全局或工作区设置）：123456&#123; "singleQuote": true, "printWidth": 120, "trailingComma": "none", "semi": false&#125;&quot;singleQuote&quot;: true：启用单引号&quot;printWidth&quot;: 120：限制每行字符数为 120&quot;trailingComma&quot;: &quot;none&quot;：自动删除末尾逗号&quot;semi&quot;: false：禁用分号¶Error Lens【错误提示】可以将原先显示的问题显示在对应行右侧并高亮。效果如下：¶Live Server【本地Web服务器】提供实时 Web 服务器和自动刷新功能，适用于简单网页本地快速部署和运行调试等。¶Path Intellisense【路径补全】在输入路径时，有智能提示补全。效果如下：¶IntelliJ IDEA Keybindings【IDEA快捷键】这是一个针对 VS Code 的 IntelliJ IDEA 快捷键移植。可以向使用IDEA快捷键一样使用vscode。¶Partial Diff【文件差异比对】比较两个文本文件之间的差异。¶Image preview【图像预览】可以预览引入的图像。效果如下：¶Copy Path (Unix Style)复制文件或目录unix风格的路径¶GBK to UTF8 for vscode【文件编码转化】可以将文件在GBK与UTF8编码之间无瑕转换¶Doxygen Documentation Generator【文档生成器】写注释和文档时非常好用。效果如下：¶Markdown插件可选插件：Markdown Preview Enhanced：增强 vscode 中 Markdown 预览功能。包括更好的预览显示效果、增加侧边标题展示、支持:emoji:格式表情渲染等。Markdown All in One：增强vscode中Markdown编写功能，如：自动补全、标题序号自动维护等。Paste Image：将图像直接从剪贴板粘贴到 markdown 文件里。默认保存图片到当前 markdown 文件所在目录，如果希望保存到 markdown 文件所在目录的同名文件夹里，可如下配置：12345678&#123; //图片粘贴保持路径 "pasteImage.path": "$&#123;currentFileDir&#125;/$&#123;currentFileNameWithoutExt&#125;", //图片粘贴代码 //"pasteImage.insertPattern": "![$&#123;imageFileNameWithoutExt&#125;]($&#123;imageFilePath&#125;)", //图片粘贴时自定义路径 //"pasteImage.showFilePathConfirmInputBox": true&#125;可通过Ctrl+Shift+P打开命令面板输入Paste Image 来实现图片粘贴，也可以使用快捷键Ctrl+Alt+V直接粘贴，但快捷键可能会和其他插件（如：IntelliJ IDEA Keybindings）冲突，所以最好修改下快捷键，比如修改成Ctrl+Alt+V Ctrl+Alt+V 。¶Git管理插件可选插件：GitLens：该插件提供了强大的 Git 工具集，可以方便地查看 Git 历史记录、比较修改并执行其他 Git 操作。Git History：该插件提供了一个交互式的 Git 历史记录视图，可以方便地查看和比较不同版本之间的代码差异。Git Graph：该插件提供了一个可视化的 Git 分支图形界面，可以方便地查看和管理 Git 分支及其历史记录。Git Blame：该插件在编辑器中显示每行代码最近的修改者和修改时间，方便用户快速定位到相关版本。Add to GIT Ignore 添加git忽略文件到.gitignore中¶Java插件依赖插件：Extension Pack for Java JAVA插件扩展包，其含了以下多个插件。只需安装这一个下面的插件也就都跟着自动安装了。Maven for Java 该插件提供了Maven项目的构建和依赖管理功能。Debugger for Java 该插件提供了对Java应用程序的调试支持Project Manager for Java 提供了方便的Java项目管理方式。该插件可以创建项目 、打开项目、切换项目等。Test Runner for Java 该插件提供了JUnit测试运行器，用于在VS Code中运行和调试Java单元测试Language Support for Java™ by Red Hat 该插件提供了语法高亮、代码补全和错误提示等功能。如果提示插件需要java11，则在本地安装好jdk11，然后在settings.json中添加如下代码1"java.home": "D:\\Development\\Java\\jdk-11",¶Golang插件依赖插件：Go 提供了智能感知、代码补全、调试器、测试框架支持、代码格式化、重构工具等功能Code Runner （可选）Go 插件安装好后，只要打开一个.go文件，vscode就会提示下载go相关调试和开发的exe工具，国内因为墙的原因，经常失败。此时需要设置go 的代理，剩下重新打开vscode根据Go插件提示点击下载go依赖工具即可。1go env -w GOPROXY=https://goproxy.cn,direct这些依赖工具会自动安装到%GOPATH%/bin目录下。¶C/C++插件依赖插件：[C/C++ Extension Pack](C/C++ Extension Pack) C/C++插件扩展包，其含了以下多个插件。只需安装这一个下面的插件也就都跟着自动安装了。C/C++ 提供了 C/C++ 语言开发所需的 IntelliSense、调试、代码导航等功能。（如果仅仅是单文件开发，这一个插件就够了）C/C++ Themes 提供了多种主题，包括暗色和亮色主题等CMake 提供了 CMake 项目支持，包括代码补全、语法高亮和自动完成等功能。CMake Tools 插件是针对 CMake 项目的工具集合，提供了自动完成、代码补全、语法高亮等常见功能，并且还支持调试、运行测试等高级功能，可以让用户更方便地创建、编译和调试 CMake 项目，提高开发效率和代码质量。¶Python插件依赖插件：Python 提供了代码编辑、语法高亮、自动完成等功能，支持多种 Python 版本。Pylance 提供了更好的 Python 代码智能感知和类型检查功能。Code Runner （可选）安装好插件后默认自动可选加入如下vscode设置配置：123456&#123; // python插件格式化换行行宽限制，超过则自动换行（只对python有效） "python.formatting.autopep8Args": [ "--max-line-length=200" ],&#125;¶Vue插件依赖插件：Vue Language Features (Volar) 提供了语法高亮、代码片段、自动完成、代码检查、调试和定义跳转等功能。Volar可取代以前的Vetur。Vue Peek （可选）提供模板跳转组件，查看定义等功能。vue-helper（可选）专为vue适配 Element-UI、VUX 和 IVIEW 提供更好的扩展（如提示补齐、模板跳转组件等）CSS Peek（可选）跳转到样式的外部定义（定位外部CSS）Auto Close Tag（可选）自动闭合HTML/XML标签Auto Rename Tag（可选）自动完成标签的同步修改EsLint（可选）编码规范以及代码检查JavaScript Booster（可选）js写法优化提示（写的不够好，或有其它写法，有灯泡提示）¶远程开发插件Remote - SSH：该插件提供了通过 SSH 连接远程机器的功能，使用户可以在本地的 VSCode 编辑器中对远程机器上的文件进行编辑、调试和测试等操作。其含了以下多个插件。Remote - SSH: Editing Configuration Files：该插件为远程机器上的配置文件提供了语言支持和 IntelliSense 功能，包括常见的配置文件格式，如 JSON、YAML、XML 等。Remote - SSH: Explorer：该插件提供了一个在本地浏览远程机器文件系统的资源管理器，使用户可以方便地查看和操作远程机器上的文件和目录。¶项目管理插件Project Manager保存项目选save project，将会看到已经保存的各种项目。2.切换项目或者点击左下角即可在上方列出保存的项目，点击要切换的项目即可进入该项目里工作。¶工作区管理插件Workspace Explorer 提供了多vscode工作区下管理和切换等实用且方便的功能。vscode本身就有提供工作区功能，目的是能够针对不同工作环境（比如Java、Golang、Vue等）设置不同的设置和插件启用，只需要操作 “文件”》“将工作区另存为” ，就能把当前项目保存为一个工作区，比如对于一个Java项目，就可以把其他用不到的插件“禁用（工作区）”掉，然后保存为java.code-workspace文件，之后如果需要开发java项目，就只需要用vscode打开这个文件作为工作区，然后把所有需要开发的java项目都加入进来，这样这些java项目就都能共享到这个工作区的设置和插件配置了。工作区虽然好用，但是操作不太方便，这时可以使用 Workspace Explorer 插件来管理和切换不同的工作区，超实用的。需要如下配置：1234&#123; //【Workspace Explorer插件】vscode工作区存储目录 "workspaceExplorer.workspaceStorageDirectory": "E:\\Code\\vscode-workspace"&#125;¶vscode常用技巧¶转到定义文件在新标签页打开vscode转到定义默认是直接在当前标签页直接打开并覆盖的（预览模式打开），这样的或就不好在多个文件间快速进行切换了，那么怎么解决这个问题呢？其实vscode自身就有这方面需求的解决方案。注意观察标签页上文字是否是斜体。可通过双击对应文件或者标签页进行预览模式和固定模式切换。（1）如果是斜体说明是预览模式打开文件。默认打开其他文件时此标签页上的文件会被其他文件覆盖（2）如果不是斜体说明是固定模式打开文件，即固定该文件在此标签页上不被其他文件覆盖。¶常用插件一览名称简述Auto Close Tag自动闭合HTML标签Auto Importimport提示Auto Rename Tag修改HTML标签时，自动修改匹配的标签Better Align对齐赋值符号和注释Better Comments编写更加人性化的注释Code Runner运行选中代码段（支持多数语言）Code Spell checker单词拼写检查Color Highlight颜色值在代码中高亮显示Color Info小窗口显示颜色值，rgb,hsl,cmyk,hex等等Color Picker拾色器CSS-in-JSCSS-in-JS高亮提示和转换Debugger for Chrome调试ChromeDocument This注释文档生成DotENV.env文件高亮EditorConfig for VS CodeEditorConfig插件Emoji在代码中输入emojiendy将输入光标跳转到当前行最后面ESLintESLint插件，高亮提示File Peek根据路径字符串，快速定位到文件filesize状态栏显示当前文件大小Find-Jump快速跳转到指定单词位置Font-awesome codes for htmlFontAwesome提示代码段ftp-sync同步文件到ftpGit Blame在状态栏显示当前行的Git信息Git History(git log)查看git loggitignore.gitignore文件语法GitLens显示文件最近的commit和作者，显示当前行commit信息GraphQL for VSCodegraphql高亮和提示Guides高亮缩进基准线HTML CSS Class CompletionCSS class提示HTML CSS Supportcss提示（支持vue）HTMLHintHTML格式提示htmltagwrap快捷包裹html标签htmltagwrap包裹HTMLImport Beautifyimport分组、排序、格式化Import Cost行内显示导入（import/require）的包的大小Indenticator缩进高亮IntelliSense for css class namescss class输入提示JavaScript (ES6) code snippetsES6语法代码段JS Refactor代码重构工具，提取函数、变量重命名等等JSON to TSJSON结构转化为typescript的interfacejumpy快速跳转到指定单词位置markdownlintMarkdown格式提示Node modules resolve快速导航到Node模块npm运行npm命令npm Intellisense导入模块时，提示已安装模块名称Path Autocomplete路径完成提示Path Intellisense另一个路径完成提示Polacode将代码生成图片PostCss Sortingcss排序Prettier - Code formatterprettier官方插件Prettify JSON格式化JSONProject Manager快速切换项目vscode-icons文件图标，方便定位文件VueHelperVue2代码段（包括Vue2 api、vue-router2、vuex2）ctrl+鼠标 可以定位函数等位置¶解决vscode对C盘占用问题随着使用的时间的增加和功能插件安装的增加，vscode在C盘上的缓存和插件等文件占用会越来越大。vscode在C盘上有如下几个重要的目录：插件扩展目录： %USERPROFILE%\.vscode其中%USERPROFILE%为：C:\Users\用户名。包含了所有用户相关的配置、插件和扩展等信息。例如，安装的插件、代码片段、键绑定等都保存在这个目录下。应用程序数据目录： %USERPROFILE%\AppData\Roaming\Code包含了与应用程序本身相关的配置和数据。例如，最近打开的文件列表、自定义主题等都保存在这个目录下。缓存目录：%USERPROFILE%\AppData\Local\Programs\Microsoft VS Code包含了应用程序使用的缓存文件。例如，语言服务器的缓存文件、扩展依赖项等都保存在这个目录下。针对以上问题下面将提供两种解决方案。¶定期清理方案以上目录有些文件中“缓存目录”可以完全删除，而“应用程序数据目录”只能部分删除，为了方便，这里提供个清理脚本：vscode缓存清理.bat1234567891011121314151617181920212223242526272829303132@REM example:@REM del "%userprofile%/AppData/Local/Microsoft/vscode-cpptools/ipch/" /s /q /f@REM rd "%userprofile%/AppData/Local/Microsoft/vscode-cpptools/ipch/" /s /q@REM md "%userprofile%/AppData/Local/Microsoft/vscode-cpptools/ipch/"@echo offcall:EmptyOneDir "%userprofile%\AppData\Local\Microsoft\vscode-cpptools\ipch"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\CachedExtensionVSIXs"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\Cache"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\CachedData"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\CachedExtensions"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\CachedExtensionVSIXs"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\Code Cache"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\Crashpad"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\logs"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\Service Worker\CacheStorage"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\Service Worker\ScriptCache"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\User\workspaceStorage"call:EmptyOneDir "%userprofile%\AppData\Roaming\Code\User\History"goto end:EmptyOneDir rem same as Let empty [path] /q echo empty %1 echo del %1 /s /q /f del %1 /s /q /f echo rd %1 /s /q rd %1 /s /q echo md %1 md %1:end定期双击运行一次，就能释放vscode占用的大部分空间¶改存储目录方案实现原理：先将vscode原本在C盘的三大目录移动（剪切）到其他盘的新目录上，并通过在C盘原位置上创建指向新的存储目录的软连接即可（软连接类似快捷键，但不是）。这样以后vscode即使要存储数据到C盘上，但是C盘上相关存储目录只是软连接，实际存储是在其他盘的目录上。以管理员身份运行 CMD ，然后依次输入如下命令：123456789101112131415161718192021222324#临时设置环境变量，用来表示需要迁移的新目录set new_vscode_dir=E:\Cache\SymlinkData#创建新目录mkdir "%new_vscode_dir%\.vscode"mkdir "%new_vscode_dir%\AppData\Roaming\Code"mkdir "%new_vscode_dir%\AppData\Local\Programs\Microsoft VS Code"mkdir "%new_vscode_dir%\AppData\Local\Microsoft\vscode-cpptools"#移动原目录到新目录，由于Windows11上move命令无法跨盘符移动，故改用xcopy+del实现xcopy /s /e /h /y "%USERPROFILE%\.vscode" "%new_vscode_dir%\.vscode"rd /s /q "%USERPROFILE%\.vscode"xcopy /s /e /h /y "%USERPROFILE%\AppData\Roaming\Code" "%new_vscode_dir%\AppData\Roaming\Code"rd /s /q "%USERPROFILE%\AppData\Roaming\Code"xcopy /s /e /h /y "%USERPROFILE%\AppData\Local\Programs\Microsoft VS Code" "%new_vscode_dir%\AppData\Local\Programs\Microsoft VS Code"rd /s /q "%USERPROFILE%\AppData\Local\Programs\Microsoft VS Code"xcopy /s /e /h /y "%USERPROFILE%\AppData\Local\Microsoft\vscode-cpptools" "%new_vscode_dir%\AppData\Local\Microsoft\vscode-cpptools"rd /s /q "%USERPROFILE%\AppData\Local\Microsoft\vscode-cpptools"#创建软连接mklink /D "%USERPROFILE%\.vscode" "%new_vscode_dir%\.vscode"mklink /D "%USERPROFILE%\AppData\Roaming\Code" "%new_vscode_dir%\AppData\Roaming\Code"mklink /D "%USERPROFILE%\AppData\Local\Programs\Microsoft VS Code" "%new_vscode_dir%\AppData\Local\Programs\Microsoft VS Code"mklink /D "%USERPROFILE%\AppData\Local\Microsoft\vscode-cpptools" "%new_vscode_dir%\AppData\Local\Microsoft\vscode-cpptools"参考：https://blog.csdn.net/xbs150/article/details/126425882https://blog.csdn.net/Tisfy/article/details/126082324¶参考https://blog.csdn.net/qq_51173321/article/details/126287293]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text3使用指南]]></title>
    <url>%2Ftools%2Fsublime_use.html</url>
    <content type="text"><![CDATA[sublime text3是很优秀的文本编辑器，高速的文件读取速度，美观的用户界面，丰富的扩展插件，让其受到很多开发者的青睐，这里就只介绍一些常用插件的安装和使用教程。¶一、安装Package Control插件管理控制台首先要安装Package Control,有了这个插件管理控制台才能安装第三方插件。安装这个插件可以通过按以下命令来打开控制台。1ctrl+ `出现控制台后输入以下命令并按Enter键即可安装Package Control。1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)¶二、安装插件安装好Package Control后就可以安装第三方插件了，首先先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install package并按Enter键即可输入第三方插件安装。接下来将 介绍我正在使用的几个第三方插件。这些插件几乎都可以在sublime插件官网找到。¶1.A File IconA File Icon能实现sublime侧边栏上下文菜单上根据不同文件类型显示不同图标样式。(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入A File Icon后选中A File Icon插件并按Enter键，等待一会儿跳出Package Control Messages页面或者左下角的小等号来回走动结束就表示安装成功。效果如图：¶2.EmmetEmmet是非常有用的插件，使用仿CSS选择器的语法来生成代码，大大提高了HTML和CSS代码编写的速度。只需按住Tab键即可把一个简写代码展开成HTML和CSS的代码块。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Emmet后选中Emmet插件包并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。对于html：1234567891011!或html:5 --------&gt; html文件模式link:css--------&gt;插入css档案div --------&gt;&lt;div&gt;&lt;/div&gt;.box --------&gt;&lt;div class="box"&gt;&lt;/div&gt;div*2 --------&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;div&gt;p --------&gt;&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;div+p --------&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;·····························建立一个html文件体验以下，html文件中输入!并按Tab键，神奇般地就会快速生成以下代码：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;类似的输入div*#hd&gt;ul&gt;li.houndrend$*4&gt;a[href='https:qcmoke.github.io']并按Tab键会快速生成以下代码:12345678&lt;div id="hd"&gt; &lt;ul&gt; &lt;li class="houndrend1"&gt;&lt;a href="https:qcmoke.github.io"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="houndrend2"&gt;&lt;a href="https:qcmoke.github.io"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="houndrend3"&gt;&lt;a href="https:qcmoke.github.io"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="houndrend4"&gt;&lt;a href="https:qcmoke.github.io"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;对于css:类似的输入w300并按Tab键会快速生成以下代码:1width: 300px;而h300则快速生成以下代码:1height: 300px;关于Emmet更多技术内容可查看官方文档，或者自信google、baidu。¶3.AutoFileNameAutoFileName能够在html引用其他文件内容如js，images，css等等时自动补全文件名。(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入AutoFileName并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。¶4.SideBarToolsSideBarTools 能实现侧边栏上下文菜单中添加一些有用的工具：复制文件名、复制相对路径、复制绝对路径、重复、移动等。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入SideBarTools并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。效果如下图：¶5.SideBarEnhancementsSideBarEnhancements类似于SideBarTools，不过功能更多，在文件和文件夹边栏上的操作提供增强功能，即能实现侧边栏上下文菜单中添加更多有用的工具。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入SideBarEnhancements并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。说明：如果正在使用SideBarTools的话，为了不起冲突可以先卸载掉SideBarTools。效果如下图：¶6.AdvancedNewFileAdvancedNewFile此插件允许在项目中通过快捷键更快地创建文件。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入AdvancedNewFile并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。ctrl+alt+n：用于创建新文件的常规键。DocBlockrDocBlockr能实现代码注释提示，它使编写文档变得轻而易举。DocBlockr支持JavaScript (including ES6), PHP, ActionScript, Haxe, CoffeeScript, TypeScript, Java, Apex, Groovy, Objective C, C, C++ 和Rust.安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入DocBlockr并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。效果如下图：¶7.Local HistoryLocal History能实现文件编辑过程中存放文件副本和历史记录信息。即每次修改文件时，修改过的文件保存退出后，Local History插件会将旧文件的副本和编辑记录信息结合修改后退出的时间命名并保留在本地相应目录中。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Local History并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。效果如下图：以下是修改过三次的Demo.java文件。可以通过在当前文件上点击右键按照如下图指示打开本地历史文件目录。按照如下图所示可以查看编辑记录信息。选择副本选择副本文件后即可查看编辑记录信息，其中变动的信息会高亮显示。当然，如果你想删除掉本地的副本和记录那么你可以按照下图指示一键清空本地副本文件。¶8.HTML-CSS-JS PrettifyHTML-CSS-JS Prettify允许您格式化HTML，CSS，JavaScript和JSON代码。此格式化插件是用JavaScript编写的，因此您需要安装node.js来解释JavaScript代码。node.js的安装很简单，如果不做特别要求的话就直接一路下一步就行了。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入HTML-CSS-JS Prettify并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。node.js和HTML-CSS-JS Prettify插件都安装好后要在sublime中HTML-CSS-JS Prettify的配置文件指定node.js的路径。配置过程如下图：可对一下代码中的&quot;windows&quot;:做修改后，直接复制粘贴。12345678&#123; "node_path": &#123; "windows": "D:/DevelopmentTools/nodejs/node.exe", //根据自己的安装情况指定node.js的路径 "linux": "/usr/bin/nodejs", "osx": "/usr/local/bin/node" &#125;,&#125;一切准备就绪，开始测试：格式化前：按ctrl+shift+h可对上图糟透了的代码进行格式化。格式化后：¶9.TerminalTerminal能让你在sublime text中快速打开终端。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Terminal并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。安装完此插件后可以自定义终端，如果不自定义，windows默认是cmd,我这里以git bash为终端为例，配置过程如下：可对一下代码中的&quot;terminal&quot;:做修改后，直接复制粘贴。123&#123; "terminal": "D:/DevelopmentTools/Git/bin/bash.exe", //根据自己的安装情况指定bash.exe的路径&#125;¶10.Chinese LocalizationChinese Localization插件能让sublime text支持多语言，当然，支持简体中文。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Chinese Localization并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。安装好后可能要重启sublime，重启后默认就为中文简体。其他语言设置可见下图：¶11.IMESupportIMESupport 能解决输入法切换中文输入时输入框不跟随光标的问题。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入IMESupport并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。¶12.Markdown Editing和Markdown Previewmarkdown Editing插件能支持markdown更良好的编写操作方式，Markdown Preview插件能支持浏览器预览。安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Markdown Editing并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。(3)类似地，按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入Markdown Preview并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。自定义快捷键，点击 Preferences --&gt; 选择 Key Bindings User，输入：1&#123; "keys": ["alt+m"], "command": "markdown_preview", "args":&#123;"target": "browser", "parser":"markdown"&#125; &#125;,¶13.FileDiffsFileDiffs能显示不同文件的不同处内容。方便排查错误。(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入FileDiffs并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。在文件上右键选择FileDiffs menu、然后选择Diff file with File in Project。显示当前文件和前项目中的其他文件的差异。¶14.ColorPickeColorPicker选色面板能快速获取想要的十六进制颜色值。(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Install Package，选中Package Control: Install Package选项，并按Enter键。(2) 输入ColorPicker并按Enter键，等待一会儿左下角的小等号来回走动结束就表示安装成功。按ctrl+shift+c调出选色面板¶三、卸载插件安装：(1) 先按ctrl+shift+p打开控制台，然后通过输入Package Control: Remove Package，选中Package Control: Remove Package选项，并按Enter键。(2) 输入插件包名并按Enter键，等待一段时间左下角的小等号来回走动结束就表示卸载成功。¶四、快捷键（热键）的使用通过下图指示可以打开快捷键配置文件。每个快捷键都有英文解释。如果快捷键和其他软件的快捷键冲突，同样可以在用户自定义配置文件里修改。多行快速选择文本Ctrl+D：选中光标所占的文本，继续操作则会选中下一个相同的文本。（非常实用）Ctrl-K, Ctrl-D：把当前选中所占文本的光标，跳转到下一个相同文本。（配合Ctrl+D很实用）Alt-F3：一次性选中(当前选中的文本）相同的文本。等于多次实用Ctrl+D。（部分修改情况下慎用，Mac下:Ctrl-Cmd-G）行操作选择类Ctrl+L：选择光标当前行，重复可依次增加选择下一行，若多有行光标，则第一次选择多行。Ctrl+J ：将光标的下一行，合并到光标当前行。若选择多行，则合并选择的多行为一行，同时再合并当前行的下一行。操作类Ctrl+G：跳转到第几行。Ctrl+Shift+L：（前提先选中多行）会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+↑ ↓： 当前行或当前选中行与上下行互换位置。Ctrl+Enter： 在当前光标的下一行插入新行并跳转光标。Ctrl+Shift+Enter：在当前光标的在上一行插入新行并跳转光标。Ctrl+Shift+D： 复制光标或所选区所在的整行，插入到下一行。删除类Ctrl+Shift+K：删除整行，没有空白符。Ctrl+k+k： 从光标处至行尾删除。Ctrl+K+Backspace：从光标处至行首删除。注释Ctrl+Shift+/：根据选择进行多行注释。Ctrl+/：单行注释。缩进Ctrl+[ ]：左右缩进当光标或光标所在的行。Tab： 向右缩进。Shift+Tab：向左缩进。代码块Ctrl+Shift+[：选中代码，按下快捷键，折叠代码。Ctrl+Shift+]：选中代码，按下快捷键，展开代码。Ctrl+K+0： 展开所有折叠代码。Ctrl+K+T：折叠所有html的属性。（非常好用，看html结构的时候）Ctrl+M：跳转到对应括号。Ctrl+Shift+J：快速选择同级的内容，同级内容=兄弟内容。编辑Ctrl+Y：恢复撤销。Ctrl+Z： 撤销。Ctrl+K+U：转换光标最近单词，或所选区域大写。Ctrl+K+L：转换光标最近单词，或所选区域小写。查找Ctrl+F:在当前页面中查找Ctrl+shift+F：高级查找，在文件夹内查找。Ctrl+P：打开多功能搜索框。 1.输入当前项目中的文件名，快速搜索文件。 2.输入@和关键字，查找文件中函数名。（Ctrl+R） 3.输入：和数字，跳转到文件中该行代码。（Ctrl+G） 4.输入#和关键字，查找变量名。 （Ctrl+：）Ctrl+G：打开搜索框，自动带：，输入数字跳转到该行代码。Ctrl+R：打开搜索框，自动带@，输入关键字，查找文件中的函数名。Ctrl+; ：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。窗口Alt+Shift+1：窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2：左右分屏-2列。Alt+Shift+3：左右分屏-3列。Alt+Shift+4：左右分屏-4列。Alt+Shift+5：等分4屏。Alt+Shift+8：垂直分屏-2屏。Alt+Shift+9：垂直分屏-3屏。Ctrl+K,Ctirl+B：开启/关闭侧边栏。Ctrl+N：新建空面板。Ctrl+Shift+N：在新建窗口中，创建空面板。Ctrl+Tab：从左往右，切换当前窗口的标签页。Ctrl+Shift+Tab：从右往左，切换当前窗口的标签页。Ctrl+W：关闭当前标签，当窗口内没有标签时会关闭该窗口Ctrl+Shift+T：恢复刚刚关闭的标签高级Ctrl+Shift+Space：选择当前光标最小块的代码。（非常好用）Ctrl+Shift+’：emmet插件下，这个可以在html中，选择光标最近的一组闭合标签。修改标签非常方便。Ctrl+U： 软撤销，撤销快捷键的一些动作，比如撤销选中。（若快捷键冲突不起效果，请自定义快捷键）¶五、常用控制台命令（1）如果不想点击右下角的Plain Text来设置代码语言可以直接按ctrl+shift+p 然后输入：Set Syntax: code language,如Set Syntax: HTML即可设置当前文件为html文件。设置代码语言: Set Syntax: code language安装插件: Package Control: Install Package卸载插件: Package Control: Remove Package查看插件：Package Control: List Package更新插件：Package Control: Upgrade Package禁用插件：Package Control: Disable Package激活插件：Package Control: Enable Package禁用插件等同于在preferences &gt; settings &gt; user里添加需要忽略的插件：1234"ignored_packages":[ "Vintage" // 在这个数组里面添加需要忽略的插件],¶六、其他¶1. 解决sublime中文字行间上下不对齐的毛病只需要点击设置，如下图：完成会弹出一个设置页面。选择右边的用户设置配置区进行修改，如下图：在花括号内添加以下代码：1234"font_options": [ "gdi" ],添加后如下：1234567891011&#123; "font_options": [ "gdi" ], "font_size": 23, "ignored_packages": [ "Vintage" ]&#125;完成了，发现中文字行间上下对齐了。¶七、参考资料：sublime使用指南Sublime Text3 快捷键总结]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>sublime text3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next打造精美的个人博客网站]]></title>
    <url>%2Fblog%2Fhexo_next.html</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用hexo生成静态网页。¶基础功能篇¶1. 搭建hexo环境要搭建hexo+github的个人博客，首先需要确保安装了git和node.js。¶1) 安装和配置git关于git的安装和配置请参考《windows10安装git并连接github》，确保git安装成功并能上传文件到github仓库。温馨提示：一定要配置好ssh key，参考的教程中有指导。¶2) 安装node.jsgit安装配置好后还要安装node.js，请至官网下载node.js。node.js的具体安装从头到尾傻瓜式“下一步”。不过安装路径建议选择非系统盘目录。安装好后，检测PATH环境变量是否配置了Node.js，打开cmd 或者安装好git后的git bash，输入如下命令：1$ node --version出现node.js的版本信息则说明安装成功。¶3) 安装hexo以上都完成后打开git bash输入：1$ npm install -g hexo-cli #使用 npm 安装 Hexo出现如下信息表示下载并安装完成。¶4) 使用hexo安装 Hexo 完成后，在任意目录执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：123$ hexo init myblog # 初始化hexo工作区，此时myblog是工作区$ cd myblog # 进入工作区 $ npm install # 安装hexo默认使用的一些基础包，可以不用执行，因为初始化时已经默认安装了这些基础包。但如果在初始化时安装这些基础包失败时，可以通过这条命令重新安装一遍。💁‍♂不要输入 $和 #及其之后的注释内容。新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes编译并运行12$ hexo g # 编译生成静态文件$ hexo s # 启动运行服务执行以上命令之后，hexo就会在 public文件夹生成相关 html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，可以使用:1$ hexo s -p port #自定义端口方式启动hexo服务。其他命令：12$ hexo clean #清理public的内容$ hexo n file #新建文章，file指的是markdown文章文件的名称¶2. 编写文章首先要在 myblog/source目录下创建一篇文章，命名为：name.md，如：first-article.md 。或者用hexo创建一篇文章，打开git bash输入：1$ hexo n first_article完成后 source/_posts目录下会多出 first-article.md文件。 如下图：打开 first-article.md，修改表头后开始通过markdown语法来书写文章。 内容如下：1234567891011---title: first_articledate: 2018-09-14 14:27:24tags: - 分享 - firstcategories: 碎碎念---# 正文哥们，这是你的第一篇文章~其中 categories是给分类栏添加分类项，或者将文章归纳到&quot;碎碎念&quot;分类项里；而 tags表示的是文字的标签，可以写多个，比如我写了 分享和 first。完成后编译并运行12$ hexo g$ hexo s然后浏览器访问测试博客，你会发现分类菜单和标签菜单里就会有内容显示了。¶3. 更换主题可以到 hexo官方主题 下载主题模板。在这里我推荐使用next主题，文档齐全，社区也活跃。官网：http://theme-next.iissnan.com下载主题包后放到 myblog/themes/ 下。比如我们要用next主题（使用对的版本是5.1.4），则可以进入 myblog/themes/目录下然后执行命令：12$ git clone https://github.com/iissnan/hexo-theme-next.git$ mv hexo-theme-next next然后修改 myblog/_config.yml中的 theme: landscape改为 theme: next完成后重新编译并运行测试。¶4. 更换主题布局next提供了4种布局供选择，我这里选的是Gemini。打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 Scheme Settings找到如下代码块，并在 scheme: Muse的前面添加 #，然后去掉 #scheme: Gemini前面的 #,修改后如下：123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini完成后重新编译运行测试，你会发现博客的主题布局已经变了。¶5. 菜单栏添加菜单选项next默认菜单栏只有 home和 archives菜单选项，你可以添加更多的菜单选项，比如这里我们添加 tags和 categories。只需打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 Menu Settings找到如下图代码块，然后将 tags和 categories选项前的注释符号 #去掉就能启用这两个菜单。如下图：💁‍♂提示： NexT 使用的是 Font Awesome 提供的图标，可以去Font Awesome获取自定义的图标。完成后重新编译并运行，然后浏览器输入http://localhost:4000/，你会发现多出来了两个菜单选项。如下图：虽然是有了这两个菜单选项，但当你点击这些新菜单时会发现只有类似 Cannot GET /tags/这样的提示。此时你肯定会手足无措。别担心，之所以会有这样的提示，是因为next默认只启动了这两个菜单项，然并没有找到 tags和 categories页面，你需要做的是创建这两个页面，创建的过程很简单，并不需要你有什么编程基础，你只需要输入以下命令hexo就能帮你生成这两个页面。在站点根目录下打开你心爱的git bash。然后输入以下两条命令：12$ hexo n page tags$ hexo n page categories完成后你会发现 myblog/source/目录会出现两个文件夹，如下图：打开 myblog/source/categories目录下的 index.md，修改内容为以下：12345---title: 分类date: 2018-09-14 12:18:35type: categories---打开 myblog/source/tags/目录下的 index.md，修改内容为以下：12345---title: 标签date: 2018-09-14 12:17:57type: tags---完成后重新编译并运行，此时你再打开浏览器输入http://localhost:4000/，点击 tags和 categories菜单时会发现已经可以打开页面了。¶6. 默认中文简体显示设置打开全局配置文件 myblog/_config.yml，搜索找到 language，改为以下：1language: zh-Hans如图：这里的 zh-Hans要根据 myblog/themes/next/languages目录下的语言配置文件的名称来设置，也有可能是 zh-CN。(如在此目录里打开 zh-Hans.yml文件，发现里面是简体中文，那就对了，注意：这里的文件的名称不填文件后缀名 .yml)完成后重新编译并运行测试，效果如下：¶7. 更改博客作者名和主页地址打开 myblog/_config.yml全局配置文件，搜索关键词 Site找到如下图的地方然后修改以下三处：1234title: Qcmoke's Blog #站点名称author: Qcmoke #作者名称url: https://qcmoke.github.io #填github page的url即可完成后重新编译并运行，效果如下图：¶8. 启用侧边栏社交链接打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 Social找到下图位置：根据自身情况进行修改或者添加，注意：一定要去掉 #social:前的 #才能生效。我的如下图：完成后重新编译并运行，效果如下图：¶9. 侧栏添加外链打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 Blog rolls找到下图位置：根据自身情况进行修改或者添加，注意：一定要去掉 #links:前的 #才能生效。我的如下图完成后重新编译并运行，效果如下图：¶10.去除侧栏目录自动生成的序数编辑 myblog/themes/next/_config.yml主题配置文件，搜索关键字 toc找到如下代码，number默认是 true，将 number设置为 false，如下：12345678toc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false¶11. 设置头像¶1) 基础设置找一张你喜欢的头像图片放入 myblog/themes/next/source/images目录中，例如我这里放了一张 logo.jpg。然后打开 myblog/themes/next/_config.yml主题配置文件。找到关键字 avatar,在后面加入 logo.jpg的路径地址（注意：是想相对路径）。如下图：如果你想另外添加一个点击侧栏头像就能回到博客首页的功能，其实很简单，只需要将图片变成一个可以点击的图片链接。打开文件位置：myblog/themes/next/layout/_macro/sidebar.swig,找到如下代码块。123&lt;img class="site-author-image" itemprop="image" src="&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;" alt="&#123;&#123; theme.author &#125;&#125;" /&gt;将以上代码块外面添加一个指向博客主页的a标签。即修改成以下：12345&lt;a href="/"&gt; &lt;img class="site-author-image" itemprop="image" src="&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;" alt="&#123;&#123; theme.author &#125;&#125;" /&gt;&lt;/a&gt;完成后重新编译并运行进行测试。¶2) 定制圆形头像打开站点下的 myblog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl文件 ,在 .site-author-image选择器的末尾（右括号前）添加12border-radius: 50%;transition: 2s all;在 .site-author-image选择器右括号后另起一行,加入以下代码：123.site-author-image:hover&#123; transform: rotate(360deg);&#125;或者你可以看下面的代码会更加直观。原来的：12345678.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color;&#125;修改后：123456789101112131415.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; opacity: hexo-config('avatar.opacity') is a 'unit' ? hexo-config('avatar.opacity') : 1; border-radius: 50%; transition: 2s all;&#125;.site-author-image:hover&#123; transform: rotate(360deg);&#125;完成后重新编译并运行，效果如下图：¶12. 设置浏览器标签图标将一张图标32x32像素大小的图标favicon.jpg放入 myblog/themes/next/source/images目录里，打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 favicon，找到如下代码块，并做相应修改。12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.jpg #浏览器标签图标在这里设置 apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml完成后重新编译并运行，浏览器输入http://localhost:4000/访问你的博客，发现你的博客的浏览器标签图标已经变了。¶13. 首页文章缩略描述设置打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 auto_excerpt找到如下位置：123auto_excerpt: enable: false length: 150修改enable和length，修改后如下：123auto_excerpt: enable: true length: 10完成后重新编译并运行，效果如下图:¶14. 添加3D动画背景打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 canvas找到如下位置：123456789101112# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: false# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false看你喜欢哪种动画背景风格，分别有 canvas_nest、three_waves、canvas_lines、canvas_sphere四种，选择一种然后将冒号后面的 false改成 true。这里我选择的是第一种 canvas_nest，改成如下：123456789101112#Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: true# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false完成后重新编译并运行，完成后你会发现博客网页已经出现好看的动态背景了。¶15. 增加本地搜索功能需要安装 hexo-generator-searchdb插件来实现这个功能，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save编辑 myblog/_config.yml全局配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 local_search找到如下代码，enable默认是 false，将 enable设置为 true，如下：12local_search: enable: true完成后重新编译并运行，完成后你会发现博客菜单栏上已经出现了搜索项了。¶16. 置顶按钮显示百分比打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 scrollpercent。 将其值设置为true。效果如下图：¶17. 文章字数和阅读时长统计需要安装 hexo-wordcount这个插件来实现这个功能，在站点根目录下打开git bash，输入：1$ npm install hexo-wordcount --save打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 post_wordcount。将其配置修改成以下代码：123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true完成后重新编译并运行测试。¶18. 隐藏底部的“强力驱动”内容打开 myblog/themes/next/layout/_partials/footer.swig,搜索关键字 theme.footer.powered.enable，通过 &lt;!-- --&gt;注释掉如下代码。完成后重新编译并运行，你会发现博客已经隐藏掉了底部的“强力驱动”内容了。¶19. 图片点击放大功能支持默认fancybox开启后，所有文字的图片都会强制被加入到了fancybox弹出框，并且fancybox会和图片链接冲突，如果想让某些图片禁用fancybox的话可以对next做一些修改来实现这个小功能。修改 themes/next/source/js/src/utils.js文件：123456789 wrapImageWithFancyBox: function () &#123; $('.content img') .not('[hidden]') .not('.group-picture img, .post-gallery img') .each(function () &#123; var $image = $(this);+ if ($image.hasClass('nofancybox')) return; var imageTitle = $image.attr('title'); var $imageWrapLink = $image.parent('a');然后在使用的时候，给不需要 fancybox 的标签中添加class属性 class=&quot;nofancybox&quot;，如果 class 属性中已经有其它内容，也可以以空格并列，比如下面：1&lt;img class="logoimg nofancybox" src="/images/logo.jpg"&gt;¶20. 文章应用本地图片写博客时虽然可以通过第三方图床给hexo文章插入图片，但如果你和我一样总害怕哪天第三方图床提供商被无故和谐了或者关闭服务了，那么通过相对路径从本地引入图片的方案无疑是再好不过的方案。hexo允许你在 myblog/source/images目录下放入图片（这里的images目录如果没有需要你自己创建），当hexo编译时会将图片放入到 myblog/public/images目录里。由于部署博客其实就是部署 public目录，所以引用图片的方式也就是 ![](/images/image.jpg)。因此要将博客文章引用的本地图片都存到 myblog/source/images目录里。但如果所有的图片都放到同一个目录里会导致后期维护的成本很大。为解决以上的问题，hexo支持通过其他目录的方式引入图片，只要修改 myblog/_config.yml全局配置文件，将 post_asset_folder:这个选项设置为 true，就能将图片放置到markdown文件所在目录下的同名文件夹里，但需要通过类似![](2018/09/21/article/image.jpg)的方式来引用图片，明显这样一长串的路径引用是很糟糕的。为解决以上的问题，可以使用 hexo-asset-image插件来实现类似![](article/image.jpg)的相对路径引用方式来引用图片，操作如下：（1）安装hexo-asset-image1$ npm install hexo-asset-image --save（2）将全局配置文件 myblog/_config.yml里的 post_asset_folder:这个选项设置为 true（3）新建一篇markdown文章做测试12#执行该命令会在myblog/source/_posts/文件夹内除了生成newpage.md文件外，还生成一个同名的newpage文件夹$ hexo n newpage（4）引用本地图片要插入图片时，只需要将图片放入 newpage文件夹中，比如放入一张名为test.png的图片，那么在newpage.md中通过以下markdown语句来引用该图片：1![test](newpage/test.png)（5）编译并启动测试12$ hexo g$ hexo s完成后你会发现博客中相关的文章能正常显示图片了。¶21. 修改文章链接组成形式Hexo默认的文章链接形式是一个四级url——https://domain/year/month/day/demo.html，可能造成url过长，对搜索引擎是十分不友好。我们可以改成https://domain/demo.html的形式。编辑全局配置文件myblog/_config.yml，做如下修改：12#permalink: :year/:month/:day/:title/permalink: :title.html执行以下命令重新部署即可：1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d但是为了更好管理文章，我更愿意用https://domain/分类/demo.html的形式来定义文章的url。比如我本地myblog/source/_posts目录下管理的文章（markdown文件）非常多，会很不容易查找到。那我可以根据_posts目录下markdown文件的类别进行分类，并在_posts目录下建立与文章相关的文件夹，将这些文章分类好后放入到这些分类文件夹里存放。比如我有一篇文件名为hexo_next.md的文章。文章的标题叫《hexo next主题设置与完善》，那么我根据自己的喜好建立一个名为blog的文件夹，并将hexo_next.md放到这个文件夹里。以工作区根目录为起始点的大概的结构如下：1234567891011121314151617&gt;.&gt;├── _config.yml&gt;├── package.json&gt;├── scaffolds&gt;├── source&gt;| ├── _drafts&gt;| └── _posts&gt;| ├── blog #本例分类文件夹&gt;| | ├── hexo_next.md #本例文章（markdown文件）&gt;| | ├── hexo_next #本地存放hexo_next.md里所需图片的文件夹 | ├── typecho_move.md #其他同类别的文章 &gt;| | └── typecho_move &gt;| ├── devops #其他分类文件夹&gt;| ├── linux&gt;| ├── sql&gt;| └── tools&gt;└── themes经过静态化处理后，那么我的url形式就变成了https://domain/blog/hexo_next.html。这样处理的好处就是既能很好的管理文章，又能对seo起到很好的优化作用，那何乐而不为呢？¶21. 支持emoji文字表情如何让markdown可以解析emoji呢？实际上我们发现，在一些编辑器中输入 :blush: 并没有表情出现（当然有的编辑器可以，比如我现在使用的typora就很给力），这是为什么呢？ 这是markdown编辑器渲染引擎的问题 。同样的，Hexo也要对markdown文件进行渲染，而Hexo目前默认渲染引擎是 hexo-renderer-marked,可惜这个渲染器似乎不支持插件扩展，当然就不行了。那怎么解决呢？这里就要说 hexo-renderer-markdown-it插件了，这个渲染器插件是支持扩展，我们可以使用这个渲染引擎来支持 emoji表情，具体实现过程如下：更换渲染器进入blog跟目录，执行如下命令12$ npm un hexo-renderer-marked --save #卸载hexo默认渲染器hexo-renderer-marked$ npm i hexo-renderer-markdown-it --save #安装渲染器hexo-renderer-markdown-it安装emoji插件，执行如下命令1$ npm install markdown-it-emoji --save编辑站点配置文件打开 myblog/_config.yml站点配置文件，添加如下内容1234567891011121314151617181920212223# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-emoji # add emoji anchors: level: 1 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ¶完成后重新编译并运行，你会发现博客中相关的文章能正常显示 emoji表情了。比如下面的markdown经过编译成html后，网页访问会得到这个笑脸：😄1234567---title: emoji testdate: 2018-09-14 04:13:00---&lt;!-- more --&gt;:smile:💁‍♂更多的 emoji写法可参考:📚https://www.webfx.com/tools/emoji-cheat-sheet/¶22. 更改上下篇的顺序默认next文章下面的&quot;上一篇，下一篇&quot;是旧发布的文章在上篇里的，但是如果希望新的发布文章在上篇的话就要做修改或者配置了，最新版本的next似乎已经可以直接在主题配置文件里设置了，但我这里使用的是旧版本的next5.1.4，所以需要深入源码进行修改，可以参考下面的方案。编辑 blog/themes/next/layout/_macro/post.swig 然后做以下修改：找到以下代码块。123456789101112131415161718192021&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class="post-nav"&gt; &lt;div class="post-nav-next post-nav-item"&gt; &#123;% if post.next %&#125; &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt; &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class="post-nav-divider"&gt;&lt;/span&gt; &lt;div class="post-nav-prev post-nav-item"&gt; &#123;% if post.prev %&#125; &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125;将以上代码修改成以下代码：123456789101112131415161718192021&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class="post-nav"&gt; &lt;div class="post-nav-next post-nav-item"&gt; &#123;% if post.prev %&#125; &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt; &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class="post-nav-divider"&gt;&lt;/span&gt; &lt;div class="post-nav-prev post-nav-item"&gt; &#123;% if post.next %&#125; &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt; &#123;&#123; post.next.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125;¶23. 添加页面加载效果打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 pace_theme找到如下代码位置，将 pace设置为 true，pace_theme可以根据列出了的样式进行选择：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal效果如下：¶24. 图片懒加载懒加载，即在需要的时候才加载图片，而不是一次性加载完整个页面的图片,使用lazyload插件实现懒加载可以有效提高博客的访问速度。在Hexo博客目录下，执行以下命令：1$ npm install hexo-lazyload-image --save编辑Hexo主配置文件 myblog/_config.yml,添加如下配置：1234lazyload: enable: true onlypost: false #loadingImg: ../images/loading-post.gif参数：enable：是否开启图片做懒加载功能onlypost：是否仅文章中的图片做懒加载，如果为 false，则主题中的其他图片，也会做懒加载，如头像，logo 等任何图片。loadingImg：图片未加载时的代替图，不填写使用默认加载图片，如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 themes/next/source/images 目录下，然后引用时：loadingImg: ../images/xxx.gif效果如下：¶25. 开启打赏功能首先要将支付宝和微信的收款码图片放到 myblog/themes/next/source/images目录里。打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 reward找到下图位置：根据自身情况进行修改或者添加，注意：一定去掉元素前面的 #才能生效。我的如下：12345# Rewardreward_comment: 如果你觉得我的文章对你有帮助，你可以打赏我哦~wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png完成后重新编译并运行，浏览器访问博客时，你会发现每篇文章底部就会有打赏的小图标了。¶26. 文章分享功能这里我提供了三种方案，推荐下文说的第二种方案。¶方案1 jiathis打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 jiathis，找到如下代码。123#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:去掉 #jiathis:前的 #，并在其后添加 true结果如下：123jiathis: true ##uid: Get this uid from http://www.jiathis.com/#add_this_id:不知道为什么有bug，无法加载出图标，也不能点击。于是恢复原样后，改用第二种方案。¶方案2 needmoreshare2打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 needmoreshare2，找到如下代码并做以下修改。12345678910111213141516needmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook不过我发现next 5.1.4版本中微信加载不出二维码,应该是封装好的微信分享链接失效了。我是通过老版本的仓库https://github.com/iissnan/hexo-theme-next安装的，所以有这个问题，而新版本的next是没有这个问题的。新版本仓库已经搬迁到了https://github.com/theme-next 。虽然我安装的是老版本，不过这里我也提供了解决办法。站点根目录下打开git bash，输入以下命令：12$ rm -rf themes/next/source/lib/needsharebutton$ git clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton完成后重新编译并运行，你会发现博客已经出现分享服务图标了，并且点击微信分享图标也可以加载出分享二维码了。¶方案3 baidushare打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 baidushare，找到如下代码并做修改。修改后如下：12345#baidushare:## type: buttonbaidushare: type: button baidushare: true完成后重新编译并运行，你会发现博客已经出现分享服务图标了。¶27. 优化深色代码高亮背景在主题配置文件修改代码高亮背景为深色背景后，当在博客文章上选择代码时，选择到的颜色也为深色，虽然和背景色还是有点点区别，但是不好区分。所以经过一番研究，才有了以下优化教程。在 myblog/themes/next/source/css/_custom/custom.styl中添加以下样式代码：12345678910111213141516171819//page code background-color.code ::selection &#123; background: #2593a6; color: #fff;&#125;.code +mobile() &#123; background: #2593a6; color: #fff;&#125;//gitalk code background-color .gt-container .gt-comment-content .highlight pre, .markdown-body pre&#123; background-color: #2d2d2d;&#125;.gt-container .gt-comment-content .highlight ::selection &#123; background: #2593a6; color: #fff;&#125;以上代码优化了所以高亮代码区域，包括gitalk评论区的高亮代码。 这些样式代码是通过浏览器调试而得，如有其它样式的需求，可参考本示例在浏览器中调试。¶28. 优化文章底部带标签打开 myblog/themes/next/layout/_macro/post.swig文件,搜索 rel=&quot;tag&quot;&gt;#,将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;，如下：12345&lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt;¶29. 文章末尾添加“本文结束”标记在路径 myblog/themes/next/layout/_macro中新建 passage-end-tag.swig文件,并复制以下代码到 passage-end-tag.swig 中：1234567891011&lt;div&gt; &#123;% if not is_index %&#125; &lt;br /&gt; &lt;br /&gt; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;----------- 本文结束 -----------&lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &#123;% endif %&#125;&lt;/div&gt;打开myblog/themes/next/layout/_macro/下的post.swig文件,找到如下代码块：123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125;在以上代码块的上面另起一行添加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt;然后打开主题配置文件myblog/themes/next/_config.yml,在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true¶30. 优化文章内链接文本样式在 myblog/themes/next/source/css/_custom/custom.styl中添加以下样式代码：1234567891011//文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;可以根据自己的喜好使用浏览器调试得到相应的样式。¶31. Gemini布局返回顶部按钮适配移动端由于自己不才，为了解决以下问题，不知花了多少时间和精力。在这个折腾的过程中，有上过百度和谷歌搜了好多的教程但却无功而返；后来又尝试通过浏览器调试来解决这个问题，也同样以失败而告终。在几近绝望时，网友分享了一篇博客文章《在移动设备下启用NexT主题的目录页面和回到顶部按钮》，经参考并做修改后才有了以下简陋的教程。教程开始：编辑 themes/next/source/css/_common/components目录下的 back-to-top.styl和 back-to-top-sidebar.styl文件。用 /* */注释掉以下代码。（注意：两个文件都要注释掉）12345678+tablet() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile');&#125;+mobile() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile');&#125;注释后如下：12345678910/* +tablet() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile'); &#125; +mobile() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile'); &#125; */¶32. 禁用特定文章侧栏目录对于Muse布局，如果页面含有多级标题，那么默认是会自动展开侧栏抽屉目录的，但实际的使用中，我们不希望比如关于页面，友情页面等等自动展开目录，那么就需要对next做一定的修改来实现这个需求。找到了 themes/next/layout/_marcro/sidebar.swig中找到下一列信息。1&#123;% set display_toc = is_post and theme.toc.enable or is_page and theme.toc.enable %&#125;将其修改为：1&#123;% set display_toc = is_post and theme.toc.enable and !page.no_toc or is_page and theme.toc.enable and !page.no_toc %&#125;如果需要指定某篇文章禁用侧栏目录，只需要在该文章Front-Matter部分添加一个 no_toc: true即可。如下：123456---title: 友情链接date: 2020-02-18 22:32:49no_toc: truecomments: true---方案来源：http://master.hellosenlin.netlify.com/posts/24546/¶33. 文章引用音乐和视频¶1) html原生方式¶(1) 音乐面板在markdown文章里使用 HTML 的标签引入，写法如下1&lt;audio src="https://什么什么什么.mp3" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the audio tag.&lt;/audio&gt;¶(2) 视频面板在markdown文章里使用 HTML 的标签引入，写法如下1&lt;video poster="https://封面图.jpg" src="https://什么什么什么.mp4" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the video tag.&lt;/video&gt;¶2) 第三方插件方式¶(1) 音乐面板插件此前有尝试过使用网易云音乐外链的方式给博客加入音乐面板，但使用的过程中发现有一些音乐因为版权原因播放不了，还有就是不完全支持 https，导致小绿锁不见了。要解决这些缺点，就需要另辟蹊径转而安装第三方音乐面板插件了，hexo-tag-aplayer是一个音乐面板插件，功能很强大，相比于原生html的视频面板而言，可玩性更丰富，比如可以有歌词，歌单列表等等。废话不多说，直接上教程。安装音乐面板插件1npm install hexo-tag-aplayer --save单首歌曲的形式通过模板语法在markdown文章里引入，写法如下：1&#123;% aplayer "歌曲名" "歌手名" "https://什么什么什么.mp3" "https://封面图.jpg" "lrc:https://歌词.lrc" %&#125;歌单的形式1234567891011121314151617181920212223&#123;% aplayerlist %&#125;&#123; "autoplay": false, "showlrc": 3, "mutex": true, "music": [ &#123; "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" &#125;, &#123; "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" &#125; ]&#125;&#123;% endaplayerlist %&#125;详细参数见 README 和这插件的“母亲” Aplayer 的官方文档。关于 lrc 歌词，可以参考知乎的这篇文章https://www.zhihu.com/question/27638171下载网易云音乐的歌词，如果那歌词有错误（比如字母大小写和标点符号乱加）或者时间完全对不上，你可以一句一句自己查看修改……¶(2) 视频面板hexo-tag-dplayer插件功能相比于原生html视频标签会更加强大，比如可以使用弹幕，非常建议食用。安装插件1npm install hexo-tag-dplayer --save通过模板语法在markdown文章里引入，写法如下：1&#123;% dplayer "url=https://什么什么什么.mp4" "pic=https://封面图.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %&#125;如果要使用弹幕，必须有 api和 id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，但建议使用视频的哈希值，可参考http://tool.oschina.net/encrypt?type=2。目前发现官方api不能使用，可以寻求其他免费的弹幕服务器。也可自行搭建，可参考:📚 https://alone88.cn/archives/484.html📚 https://dandoc.u2sb.top/关于这个插件的更多内容可以去 README 和这插件的“母亲” Dplayer 的官方文档看看。¶3) 音乐面板综合案例新建一个hexo markdown文章文件1hexo n music在新建的music.md文件里加入如下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151---title: 关于我date: 2018-10-05 22:32:49comments: true---&lt;!-- more --&gt;&lt;style&gt; .description &#123; margin: 0 auto; text-align: center; &#125; .logoimg&#123; display: block; margin: 0 auto; padding: 2px; max-width: 96px; height: auto; border: 2px solid #333; border-radius: 50%; transition: 2s all; &#125; .logoimg:hover&#123; transform: rotate(360deg); &#125; .aboutbox &#123; width: 90%; height: 90%; margin: 0 auto; margin-top: 30px; box-shadow: 0 0 10px 0 rgba(0,0,0,.5); &#125; .musicbox &#123; width: 90%; margin: 60px auto; padding: 10px; &#125; .days&#123; margin: 0 auto; text-align: center; font-weight: bold; margin-top: 30px; margin-bottom: 35px; &#125;&lt;/style&gt;&lt;div class="aboutbox"&gt;&lt;div class="description"&gt; &lt;br/&gt; &lt;a href="/"&gt;&lt;img class="logoimg nofancybox" itemprop="image" src="/images/logo.jpg"&gt;&lt;/a&gt; &lt;br /&gt; 本站于2018年9月22日创建，站点主要用于个人学习以及生活记录。 &lt;br /&gt; 博主：qcmoke &lt;br /&gt; 联系方式：qcmoke@gmail.com&lt;/div&gt;&lt;div class="musicbox"&gt; &#123;% aplayerlist %&#125; &#123; "autoplay": false, "showlrc": 3, "mutex": true, "music": [ &#123; "title": "王牌冤家", "author": "李荣浩", "url": "https://source.qcmoke.cn/music/wangpaiyuanjia.mp3", "pic": "https://source.qcmoke.cn/music/wangpaiyuanjia.jpg", "lrc": "https://source.qcmoke.cn/music/wangpaiyuanjia.lrc" &#125;, &#123; "title": "if you", "author": "Bigbang", "url": "https://source.qcmoke.cn/music/ifyou.mp3", "pic": "https://source.qcmoke.cn/music/ifyou.jpg", "lrc": "https://source.qcmoke.cn/music/ifyou.lrc" &#125;, &#123; "title": "后会无期", "author": "G.E.M. 邓紫棋", "url": "https://source.qcmoke.cn/music/houhuiwuqi.mp3", "pic": "https://source.qcmoke.cn/music/houhuiwuqi.jpg", "lrc": "https://source.qcmoke.cn/music/houhuiwuqi.lrc" &#125;, &#123; "title": "空空如也", "author": "任然", "url": "https://source.qcmoke.cn/music/kongkongruye.mp3", "pic": "https://source.qcmoke.cn/music/kongkongruye.jpg", "lrc": "https://source.qcmoke.cn/music/kongkongruye.lrc" &#125;, &#123; "title": "日落大道", "author": "梁博", "url": "https://source.qcmoke.cn/music/riluodadao.mp3", "pic": "https://source.qcmoke.cn/music/riluodadao.jpg", "lrc": "https://source.qcmoke.cn/music/riluodadao.lrc" &#125;, &#123; "title": "红昭愿", "author": "音阙诗听", "url": "https://source.qcmoke.cn/music/hongzhaoyuan.mp3", "pic": "https://source.qcmoke.cn/music/hongzhaoyuan.jpg", "lrc": "https://source.qcmoke.cn/music/hongzhaoyuan.lrc" &#125;, &#123; "title": "笔记", "author": "周笔畅", "url": "https://source.qcmoke.cn/music/biji.mp3", "pic": "https://source.qcmoke.cn/music/biji.jpg", "lrc": "https://source.qcmoke.cn/music/biji.lrc" &#125; ] &#125; &#123;% endaplayerlist %&#125;&lt;/div&gt;&lt;script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5xixmgxe8az&amp;amp;m=0&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33" async="async"&gt;&lt;/script&gt;&lt;div id="days" class="days"&gt;&lt;/div&gt;&lt;script&gt; function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("09/22/2018 15:13:14"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"; &#125; function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i; &#125; show_date_time();&lt;/script&gt;&lt;/div&gt;效果¶4) 视频面板综合案例新建一个hexo markdown文章文件1hexo n video在新建的video.md文件里加入如下内容：12345678910---title: 我的视频页面date: 2020-03-02 22:21:39---&lt;!-- more --&gt;&lt;video poster="http://localhost:4000/images/logo.jpg" src="https://source.qcmoke.cn/video/VID_20190503_143115.mp4" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the video tag.&lt;/video&gt;&#123;% dplayer "url=https://source.qcmoke.cn/video/VID_20190503_143115.mp4" "http://localhost:4000/images/logo.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %&#125;效果：¶34) 添加看板娘目的是给博客页面添加小萌宠，给博客添加一点趣味性，下面就介绍使用live2d插件来实现这个功能。（1）下载并安装插件1npm install --save hexo-helper-live2d（2）下载并安装萌宠模型1npm install 模型名称官方提供了以下模型名称：live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16你可以查看demo演示后再决定做选择。（3）编辑Hexo主配置文件 myblog/_config.yml,添加如下配置：12345678910111213141516171819202122232425## Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-haruto # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: # 模型位置，根据不同的模型自行调整 position: left width: 100 height: 150 mobile: # 是否适用于移动端 show: false¶第三方服务篇¶1. 添加评分功能淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？首先打开主题配置文件：123456# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: 23**** color: fc6423先去https://widgetpack.com注册个帐号，填一下自己博客的信息，把左上角的 ID值，填进上面的 rating.id中，color改成自己喜欢的即可。💁‍♂说明：可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。如果你想给评分的星星周围加内容，可以修改文件：themes/next/layout/_macro/post.swig，例如添加下面 +相关的内容：123456&#123;% if theme.rating.enable %&#125; &lt;div class="wp_rating"&gt;+ &lt;div style="color: rgba(0, 0, 0, 0.75); font-size:13px; letter-spacing:3px"&gt;(&gt;看完记得五星好评哦亲&lt;)&lt;/div&gt; &lt;div id="wpac-rating"&gt;&lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125;¶2. 网站访问统计next主题默认集成了一些第三方访问统计插件。其中推荐使用不蒜子统计服务或者leancloud统计服务。选择一种就行。💁‍♂ 对比：不蒜子统计：支持“本站访客数”、“本站总访问量”和“本文总阅读量”；暂不开放注册，没有用户 后台，不支持数据维护。leancloud统计：只支持“本文总阅读量”统计；有用户后台，支持数据维护。由于以上可看出各自的长短，所以酌情选择。如果不关心数据维护的话，我个人比较推荐使用不蒜子统计，因为简单易用。¶1) 不蒜子统计官网：http://busuanzi.ibruce.info只需要打开 myblog/themes/next/_config.yml主题配置文件，搜索关键字 busuanzi_count。 将 enable的值改为 true,并对站点UV配置、站点PV配置、单页面PV进行配置。如下：123456789101112131415161718busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site # 效果：本站访客数12345人次 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site # 效果：本站总访问量12345次 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only # 效果：本文总阅读量12345次 page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次完成后重新编译并运行，你会发现每篇博客文章和网页底部已经出现了访问统计信息了。💁‍♂ 温馨提示：目前不蒜子『dn-lbstatics.qbox.me』域名过期，更换域名到『busuanzi.ibruce.info』！故你可能需要修改以下文件相关信息：编辑 myblog/themes/next/layout/_third-party/analytics/busuanzi-counter.swig，找到以下代码：1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;修改为:1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;如果不蒜子又拿回原来的域名，那么再改回原来的域名吧~~~¶2) leancloud统计（1）登录leancloud官网注册账户。💁‍♂说明：现在leancloud官方的云服务系统是国内和国际分别运营，所以官方网址也分为国内网址和国际网址，个人建议国际的。国内网址：https://leancloud.cn国际网址：https://leancloud.app（2）登录leancloud后台，然后创建应用（3）创建应用完成后就得到了 appid和 appkey:（4）然后设置安全域名将你网站首页的域名请求地址填进去即可，可以防止其他人攻击。如果你是一个开发爱好者，可以将本地localhost（包括端口号）添加进去，开发完成后再删除即可（5）创建一个名称为Counter的Class，用于数据存储。（6）绑定自定义域名作为api访问入口。2022 年 8 月起，国际版共享域名不再向中国大陆提供服务，见：https://forum.leancloud.cn/t/2022-8/25408。故如果不绑定自定义域名则无法通过国内网络正访问（主要是会报“跨域”错误信息），若想要继续正常使用要么科学上网或者改为国内版，又或者在国际版上绑定自定义域名。其中在国际版上绑定自定义域名操作如下：（7）编辑 myblog/themes/next/_config.yml主题配置文件，添加将leancloud后台得到的 appid和 appkey填入配置中。如下：1234567# Show number of visitors to each article.# You can visit https://leancloud.cn / https://leancloud.app get AppID and AppKey.leancloud_visitors: enable: true app_id: 6LNbUE*********XbMMI app_key: d2FLy*********uDWx server_api: https://leancloud.qcmoke.cn👀 注意：enable 要设置为 true 表示开启这个功能。（8）如果和我一样使用的next版本是5.1.4，并且使用的leancloud是国际版（leancloud是国内版的可以跳过），就还要做兼容处理，因为国际版leancloud是后来才有的，以致于旧版的next不兼容。修改 themes/next/layout/_third-party/analytics/lean-analytics.swig,将其内容替换成下面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;!--切换国际版leancloud替换代码--&gt;&#123;% if theme.leancloud_visitors.enable and !theme.valine.visitor %&#125; &#123;# custom analytics part create by xiamo; edited by LEAFERx #&#125; &lt;script&gt; &#123;% if page.layout === 'post' %&#125; function addCount(Counter) &#123; var $visitors = $('.leancloud_visitors'); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); Counter('get', '/classes/Counter', &#123; where: JSON.stringify(&#123; url &#125;) &#125;) .done(function(&#123; results &#125;) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; &#123;% if theme.leancloud_visitors.betterPerformance %&#125; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.time + 1); &#123;% endif %&#125; Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify(&#123; time: &#123; '__op': 'Increment', 'amount': 1 &#125; &#125;)) &#123;% if not theme.leancloud_visitors.betterPerformance %&#125; .done(function() &#123; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.time + 1); &#125;) &#123;% endif %&#125; .fail(function (&#123; responseJSON &#125;) &#123; console.log('Failed to save Visitor num, with error message: ' + responseJSON.error); &#125;) &#125; else &#123; &#123;% if theme.leancloud_visitors.security %&#125; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.'); console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.'); &#123;% else %&#125; Counter('post', '/classes/Counter', JSON.stringify(&#123; title: title, url: url, time: 1 &#125;)) .done(function() &#123; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(1); &#125;) .fail(function() &#123; console.log('Failed to create'); &#125;); &#123;% endif %&#125; &#125; &#125;) .fail(function (&#123; responseJSON &#125;) &#123; console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error); &#125;); &#125; &#123;% else %&#125; function showTime(Counter) &#123; var entries = []; var $visitors = $('.leancloud_visitors'); $visitors.each(function() &#123; entries.push( $(this).attr('id').trim() ); &#125;); Counter('get', '/classes/Counter', &#123; where: JSON.stringify(&#123; url: &#123; '$in': entries &#125; &#125;) &#125;) .done(function(&#123; results &#125;) &#123; var COUNT_CONTAINER_REF = '.leancloud-visitors-count'; if (results.length === 0) &#123; $visitors.find(COUNT_CONTAINER_REF).text(0); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var item = results[i]; var url = item.url; var time = item.time; var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(time); &#125; for (var i = 0; i &lt; entries.length; i++) &#123; var url = entries[i]; var element = document.getElementById(url); var countSpan = $(element).find(COUNT_CONTAINER_REF); if (countSpan.text() == '') &#123; countSpan.text(0); &#125; &#125; &#125;) .fail(function (&#123; responseJSON &#125;) &#123; console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error); &#125;); &#125; &#123;% endif %&#125; $(function() &#123; $.get('https://app-router.leancloud.cn/2/route?appId=' + '&#123;&#123; theme.leancloud_visitors.app_id &#125;&#125;') .done(function(&#123; api_server &#125;) &#123; var Counter = function(method, url, data) &#123; return $.ajax(&#123; method: method, //url: 'https://' + api_server + '/1.1' + url, url: ('&#123;&#123; theme.leancloud_visitors.server_api &#125;&#125;' || api_server) + '/1.1' + url, headers: &#123; 'X-LC-Id': '&#123;&#123; theme.leancloud_visitors.app_id &#125;&#125;', 'X-LC-Key': '&#123;&#123; theme.leancloud_visitors.app_key &#125;&#125;', 'Content-Type': 'application/json', &#125;, data: data &#125;); &#125;; &#123;% if page.layout === 'post' %&#125; const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/; if (localhost.test(document.URL)) return;//本地调试时不进行统计 addCount(Counter); &#123;% else %&#125; if ($('.post-title-link').length &gt;= 1) &#123; showTime(Counter); &#125; &#123;% endif %&#125; &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125;&lt;!--next原来的版本--&gt;&lt;!--&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt; &lt;script&gt;AV.initialize("&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;", "&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;");&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; var query = new AV.Query(Counter); var entries = []; var $visitors = $(".leancloud_visitors"); $visitors.each(function () &#123; entries.push( $(this).attr("id").trim() ); &#125;); query.containedIn('url', entries); query.find() .done(function (results) &#123; var COUNT_CONTAINER_REF = '.leancloud-visitors-count'; if (results.length === 0) &#123; $visitors.find(COUNT_CONTAINER_REF).text(0); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var item = results[i]; var url = item.get('url'); var time = item.get('time'); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(time); &#125; for(var i = 0; i &lt; entries.length; i++) &#123; var url = entries[i]; var element = document.getElementById(url); var countSpan = $(element).find(COUNT_CONTAINER_REF); if( countSpan.text() == '') &#123; countSpan.text(0); &#125; &#125; &#125;) .fail(function (object, error) &#123; console.log("Error: " + error.code + " " + error.message); &#125;); &#125; function addCount(Counter) &#123; var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment("time"); counter.save(null, &#123; success: function(counter) &#123; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.get('time')); &#125;, error: function(counter, error) &#123; console.log('Failed to save Visitor num, with error message: ' + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set("title", title); newcounter.set("url", url); newcounter.set("time", 1); newcounter.save(null, &#123; success: function(newcounter) &#123; var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(newcounter.get('time')); &#125;, error: function(newcounter, error) &#123; console.log('Failed to create'); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log('Error:' + error.code + " " + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend("Counter"); if ($('.leancloud_visitors').length == 1) &#123; addCount(Counter); &#125; else if ($('.post-title-link').length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125;--&gt;🙉注意：本地调试时不进行统计。如果看懂上面源码可以让其在本地调试是能进行统计。但小白直接复制粘贴就好，发布部署时，通过域名访问就能统计了。为了让移动端显示更友好，我修改了 themes/next/layout/_macro/post.swig文件，加了一个span标签进行修饰，让小眼睛和访问数值始终在同一行。123456789101112131415 &#123;# LeanCould PageView #&#125; &#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;+ &lt;span class="lv-inline-block" style="display: inline-block;"&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125;:&lt;/span&gt; &#123;% endif %&#125; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;+ &lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125;¶3) 额外补充由于不蒜子统计和leancloud统计都存在着一些缺失的问题，但是它们之间又冥冥中有着互补的关系，所以我通过一波考虑后，选择了折中的方案，那就是使用不蒜子统计的“本站访客数”、“本站总访问量”，而使用leancloud统计的“本文总阅读量”统计。配置如下：1234567891011121314151617181920# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site # 效果：本站访客数12345人次 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site # 效果：本站总访问量12345次 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only # 效果：本文总阅读量12345次 page_pv: false page_pv_header: 本文总阅读量 page_pv_footer: 次123456# Show number of visitors to each article.# You can visit https://leancloud.cn / https://leancloud.app get AppID and AppKey.leancloud_visitors: enable: true app_id: 6LNbUERxbG0OAnWfmJSbmXiW-MdYXbMMI app_key: d2FLy9fmXOTiM8TrokuIuDWx💁‍♂如果你对这访问统计这一块很感兴趣并且懂点编程知识的话，你完全可以通过leancloud的sdk来开发出完整的统计功能。这样的话就可以不用不蒜子统计了。要是你还有一台可以长期使用的vps的话，你甚至可以不用leancloud的服务，而是自己实现一个访问计数的后端服务。这里我就不深入了。¶3. 加入评论面板¶1) Gitalk上网找过很多与hexo相关的评论面板，但发现很多第三方的评论面板提供的评论面板都有一个致命的弱点，那就是在不可预料的一天突然在国内被和谐了，或者出现各种各样的问题，这很让人头疼。后来在网上发现有人通过调用github提供的Issues api做成了比较美观的评论面板，这其中我发现了两种，第一种是gitment，第二种就是这里要讲的gitalk。之前也尝试过加入gitment，但是发现装好后出现了各种问题。最严重的问题就是无法通过登陆评论面板进行初始化文章的评论功能，所以也就放弃了这种途径。后来在next的Telegram群里发现了gitalk这个干货，于是开始上网找各种教程尝试搭建，但在这过程中也还是发现了一些问题。所以在这里我将尽可能详细解释清楚，避免误导大家。（1）首先你得先到github上申请一个 Github Application，由于需要调用 Github API ,首先点击注册一个 Github Application 。申请页如下图：参数说明：1234Application name： #应用名称，随意填Homepage URL： #应用地址，填你的博客地址，如https://youname.github.io Application description #描述，随意填Authorization callback URL：#回调地址，填你的博客地址，如https://youname.github.io如果没有用自购的域名，Homepage URL和 Authorization callback URL统一填https://youname.github.io (youname是你的github用户名)。填写完成后，点击register application。创建成功后，会看到 clientID: XXX和 clientSecret: XXX 这两个参数，如下图：（2）创建一个仓库用来存放issue数据，命名可以随意，但为了和我统一，最好也命名为 gitalk。（3）添加gitalk.swig配置文件在目录 myblog/themes/next/layout/_third-party/comments下创建一个 gitalk.swig文件。将以下代码全部复制到 gitalk.swig中。1234567891011121314151617181920&#123;% if theme.gitalk.enable %&#125; &#123;% if page.comments %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; const gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;', admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;'.split(','), id: location.pathname, // facebook-like distraction free mode distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;', createIssueManually: '&#123;&#123; theme.gitalk.createIssueManually &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;（4）修改index.swig配置文件在 myblog/themes/next/layout/_third-party/comments目录下的 index.swig文件最后加入以下代码：1&#123;% include 'gitalk.swig' %&#125;（5）修改comments.swig配置文件打开 myblog/themes/next/layout/_partials 目录下的 comments.swig文件，搜索关键字 valine找到以下代码：1234&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt;&#123;% endif %&#125;将以上代码改成以下代码:12345678&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125;（6）修改主题配置文件打开 myblog/themes/next/_config.yml主题配置文件，根据自己的情况添加如下代码:1234567891011# Gitalk# more info please open https://github.com/gitalk/gitalkgitalk: enable: true clientID: d933e443cdfe503ce05a #创建Github Application时生成的clientID clientSecret: 149d163f4b10cedf7a68993289da9c0f0836bd34 #创建Github Application时生成的clientSecret repo: mygitalk #填之前创建好的存放issue的仓库名 owner: qcmoke #填Github 用户名 admin: qcmoke #填Github 用户名 distractionFreeMode: true #类似Facebook评论框的全屏遮罩效果. createIssueManually: true #如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。为了不出错同时也方便管理，你可将这些代码放在gitment（如果之前有配置的话）板块后。如我的：（7）部署到github最后通过 hexo 部署你的博客，即可看到gitalk评论面板的效果。（8）初始化每篇文章的Issue你可能会发现还不能评论，很简单，你只需要点击 初始化Issue,之后就要以github账号登录。登录成功后便自动完成初始化。（注意，只能通过自己的github账号来初始化）。初始化需要刷新一下，结果如下图，github用户就能通过登录github账号进行评论了。同时存放评论数据的仓库，Issues下也生成了Issue数据至此，加入Gitalk评论面板完结。¶2) Vssue目前发现Gitalk是很好的，但是目前它只支持github代码托管平台，但碍于github服务器在国外，评论面板有时候会由于网络的原因导致无法请求api，所以这才认识到了Vssue，Vssue和Gitalk的功能差不多，它支持多个代码托管平台（GitHub、GitLab、Bitbucket、Gitee、Gitea），如果使用Gitee作为评论api的话，网络延时的问题就会得到比较好的解决。接下来就奉上教程。（1）在目录 myblog/themes/next/layout/_third-party/comments下创建一个 vssue.swig文件。内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123;% if theme.vssue.enable %&#125; &#123;% if page.comments %&#125; &lt;!-- Vssue 的样式文件 --&gt; &lt;link rel="stylesheet" href="&#123;&#123; theme.vssue.vssueCss &#125;&#125;"&gt; &lt;!-- Vue 运行时版 (runtime only) --&gt; &lt;script src="&#123;&#123; theme.vssue.vueRuntimeJs &#125;&#125;"&gt;&lt;/script&gt; &lt;!-- 在 Vue 之后引入 Vssue --&gt; &lt;script src="&#123;&#123; theme.vssue.vssueTypeJs &#125;&#125;"&gt;&lt;/script&gt; &lt;!-- 将 Vssue 作为 Vue 组件使用,对于 Vue 运行时版，使用渲染函数（render function） --&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el: '#vssue', render: h =&gt; h('Vssue', &#123; props: &#123; // 在这里设置当前页面对应的 Issue 标题 title: '&#123;&#123;theme.vssue.title&#125;&#125;', // 在这里设置你使用的平台的 OAuth App 配置 options: &#123; owner: '&#123;&#123;theme.vssue.owner&#125;&#125;', repo: '&#123;&#123;theme.vssue.repo&#125;&#125;', clientId: '&#123;&#123;theme.vssue.clientId&#125;&#125;', clientSecret: '&#123;&#123;theme.vssue.clientSecret&#125;&#125;', &#125;, &#125; &#125;) &#125;) &lt;/script&gt; &lt;!--自定义样式--&gt; &lt;style&gt; .vssue &#123; width: 96%; color: #60676d; &#125; .vssue .vssue-button &#123; padding: unset; &#125; .vssue .vssue-button:not(:disabled).vssue-button-primary &#123; color: #60676d; border-color: #60676d; &#125; .vssue :not(.vssue-comment-content) a &#123; color: #333; &#125; &lt;/style&gt; &#123;% endif %&#125;&#123;% endif %&#125;（2）在 myblog/themes/next/layout/_third-party/comments目录下的 index.swig文件最后加入以下代码：1&#123;% include 'vssue.swig' %&#125;（3）打开 myblog/themes/next/layout/_partials 目录下的 comments.swig文件，添加如下 +的内容：12345678910111213141516 &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt;&lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;/div&gt;+ &#123;% elseif theme.vssue.enable %&#125;+ &lt;div class="comments" id="comments"&gt;+ &lt;div id="vssue"&gt;&lt;/div&gt;+ &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;（4）修改主题配置文件打开 myblog/themes/next/_config.yml主题配置文件，根据自己的情况添加如下代码:123456789101112131415161718## Vssue# more info please open https://vssue.js.orgvssue: enable: true #是否开启vssue评论面板 owner: qcmoke #git管理用户 repo: myvssue #git仓库名称 title: Vssue Dev #对应的Issue标题 clientId: b0634**********1012aa #OAuth App clientId clientSecret: 7a3********620313 #OAuth App clientSecret #Vssue js文件（支持多个代码托管平台，切换平台时要切换相应的js文件） #GitHub：https://unpkg.com/vssue/dist/vssue.github.min.js #GitLab：https://unpkg.com/vssue/dist/vssue.gitlab.min.js #Bitbucket：https://unpkg.com/vssue/dist/vssue.bitbucket.min.js #Gitee：https://unpkg.com/vssue/dist/vssue.gitee.min.js #Gitea：https://unpkg.com/vssue/dist/vssue.gitea.min.js vssueTypeJs: https://unpkg.com/vssue/dist/vssue.gitee.min.js vssueCss: https://unpkg.com/vssue/dist/vssue.min.css #Vssue 的样式文件 vueRuntimeJs: https://unpkg.com/vue/dist/vue.runtime.min.js #Vue 运行时版 (runtime only)至此，加入Vssue评论面板完结。💁‍♂ 提示：clientId和clientSecret和Gitalk的申请差不多，可以自行去相应的git代码托管平台进行申请。当然我推荐你去参考非常详细的官方指南：https://vssue.js.org/zh/guide¶3) Valinevaline是一个优秀的评论系统软件，后台的评论数据依赖于leancloud的云存储，所以还需要去leancloud官网设置数据存储功能。（1）首先就是去leancloud获取 appid和 appkey，怎么获取可以参考上文中的&quot;网站访问统计=&gt;leandcloud统计”。💁‍♂提示： 其中 appid和 appkey与leandcloud统计一样就行。（2）另外，还需要在leancloud后台创建一个Comment的Class，用于数据存储。虽然网上有人说valine会自动创建这个Class，但是我在用国际版测试的时候发现一直无权限或者提示没这个Class，那倒不如直接创建就好。（3）修改主题配置文件，配置 valine。修改 enable为 true，并且添加 appid和 appkey即可。1234567891011121314# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: 75OSy9**********zoHsz # your leancloud application appid appkey: LKk**************GeB # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size server_api: https://leancloud.qcmoke.cn💁‍♂说明：avatar 是设置默认头像，可以去https://valine.js.org/avatar 选择默认头像更多详细内容请查阅valine的官方文档：https://valine.js.org下载av-min.js和av-min.js.map放到themes/next/source/js/src`下：https://code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.jshttps://code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js.map（2）然后修改 themes/next/layout/_third-party/comments/valine.swig12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.valine.enable %&#125; &#123;% if page.comments %&#125; &lt;!--Leancloud 操作库--&gt; &lt;script src="/js/src/av-min.js"&gt;&lt;/script&gt; &lt;!--Valine 的核心代码库--&gt; &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var emoticonList=[] for(var i = 1; i &lt;= 164; i++)&#123; emoticonList.push("aru ("+i+").png") &#125; new Valine(&#123; lang: 'zh-cn', admin_email: 'qcmoke@gmail.com', el: '#comments-valine' , appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', serverURLs: '&#123;&#123; theme.valine.server_api &#125;&#125;', &#125;); &lt;/script&gt; &lt;script&gt; //点击邮件中的链接跳转至相应评论 if(window.location.hash)&#123; var checkExist = setInterval(function() &#123; if ($(window.location.hash).length) &#123; $('html, body').animate(&#123;scrollTop: $(window.location.hash).offset().top-90&#125;, 1000); clearInterval(checkExist); &#125; &#125;, 100); &#125; &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;（1）关于自定义环境变量直接参考我下面的可以尽量避免出错。下面附上我的leancloud管理后台自定义环境变量：💁‍♂补充说明：（1）我配置的smtp账号和密码是Gmail的，当然还可以使用其他的，比如QQ，Outlook等，具体可参考这篇文章：http://help.cy-email.com/yxtj-cyyx（2）如果机器正在启动然后就修改这些环境变量的话是需要到“部署”那里重启的。（3）有几个邮件模板环境变量图片中显示不全，下面是完整的。MAIL_SUBJECT1$&#123;PARENT_NICK&#125;，您在『$&#123;SITE_NAME&#125;』上的评论收到了回复MAIL_TEMPLATE1&lt;div style="border-radius: 10px 10px 10px 10px;font-size:13px;color: #555555;width: 666px;font-family:'Century Gothic','Trebuchet MS','Hiragino Sans GB',微软雅黑,'Microsoft Yahei',Tahoma,Helvetica,Arial,'SimSun',sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);"&gt;&lt;div style="width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;"&gt;&lt;p style="font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;"&gt;您在&lt;a style="text-decoration:none;color: #ffffff;" href="$&#123;SITE_URL&#125;"&gt;『$&#123;SITE_NAME&#125;』&lt;/a&gt;上的留言有新回复啦！！！&lt;/p&gt;&lt;/div&gt;&lt;div style="margin:40px auto;width:90%"&gt;&lt;p&gt;"&lt;strong&gt;$&#123;PARENT_NICK&#125;&lt;/strong&gt;" 同学，您曾发表评论：&lt;/p&gt;&lt;div style="background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;"&gt;$&#123;PARENT_COMMENT&#125;&lt;/div&gt;&lt;p&gt;"&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt;" 给您的回复如下：&lt;/p&gt;&lt;div style="background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;"&gt;$&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击：&lt;a style="text-decoration:none; color:#12addb" href="$&#123;POST_URL&#125;"&gt;[回复的完整内容] &lt;/a&gt;进行查看。欢迎再次光临&lt;a style="text-decoration:none; color:#12addb" href="$&#123;SITE_URL&#125;"&gt; 『$&#123;SITE_NAME&#125;』&lt;/a&gt;！！！&lt;/p&gt;&lt;style type="text/css"&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;MAIL_SUBJECT_ADMIN1叮咚！『$&#123;SITE_NAME&#125;』上有了新评论！MAIL_TEMPLATE_ADMIN1&lt;div style="border-radius: 10px 10px 10px 10px;font-size:13px; color: #555555;width: 666px;font-family:'Century Gothic','Trebuchet MS','Hiragino Sans GB',微软雅黑,'Microsoft Yahei',Tahoma,Helvetica,Arial,'SimSun',sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);"&gt;&lt;div style="width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;"&gt;&lt;p style="font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;"&gt;您的&lt;a style="text-decoration:none;color: #ffffff;" href="$&#123;SITE_URL&#125;"&gt; 『$&#123;SITE_NAME&#125;』 &lt;/a&gt;上有了新的评论 &lt;/p&gt;&lt;/div&gt;&lt;div style="margin:40px auto;width:90%"&gt;&lt;p&gt;&lt;strong&gt;"$&#123;NICK&#125;"&lt;/strong&gt; 发表评论：&lt;/p&gt;&lt;div style="background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;"&gt;$&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;&lt;a style="text-decoration:none; color:#12addb" href="$&#123;POST_URL&#125;" target="_blank"&gt;[查看详情]&lt;/a&gt;&lt;/p&gt;&lt;style type="text/css"&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;如果使用国际版leancloud，那么leancloud的定时任务要做一些调整。主要就是将官方的介绍时间调整成北京时区的时间。12# 北京时间每天早8点检查过去24小时内漏发的通知邮件一并补发0 0 0 * * ?12# 每天早0点到晚23点每隔30分钟访问云引擎0 0/30 0-23 * * ?¶4) 整合多个评论面板编辑 /themes/next/layout/_third-party/comments/valine.swig，修改如下：123 new Valine(&#123;- el: '#comments' , + el: '#comments-valine' ,编辑 themes/next/layout/_partials/comments.swig，修改如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;+ &#123;% elseif theme.gitalk.enable and theme.valine.enable %&#125;+ &lt;div class="comments" id="comments"&gt;+ &lt;div class="tablink-li"&gt;+ &lt;button class="tablink" onclick="openPage('tabs-gitalk',this)" id="defaultOpen"&gt;Gitalk&lt;/button&gt;+ &lt;button class="tablink" onclick="openPage('tabs-valine',this)"&gt;Valine&lt;/button&gt;+ &lt;/div&gt;+ &lt;div class="tabcontent-li"&gt;+ &lt;div id="tabs-gitalk" class="tabcontent"&gt;+ &lt;div id="gitalk-container"&gt;&lt;/div&gt;+ &lt;/div&gt;+ &lt;div id="tabs-valine" class="tabcontent"&gt;+ &lt;div id="comments-valine"&gt;&lt;/div&gt;+ &lt;/div&gt;+ &lt;/div&gt;+ &lt;/div&gt;+ &lt;script&gt;+ function openPage(pageName, elmnt) &#123;+ var i, tabcontent;+ tabcontent = document.getElementsByClassName("tabcontent");+ for (i = 0; i &lt; tabcontent.length; i++) &#123;+ tabcontent[i].style.display = "none";+ &#125;+ tablinks = document.getElementsByClassName("tablink");+ for (i = 0; i &lt; tablinks.length; i++) &#123;+ tablinks[i].classList.remove("currentTabcontent");+ &#125;+ document.getElementById(pageName).style.display = "block";+ elmnt.classList.add("currentTabcontent");+ &#125;+ document.getElementById("defaultOpen").click();;+ &lt;/script&gt;- &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;- &lt;div class="comments" id="comments"&gt;&lt;/div&gt;+ &#123;% elseif theme.valine.enable %&#125;+ &lt;div class="comments" id="comments"&gt;+ &lt;div id="comments-valine"&gt;&lt;/div&gt;+ &lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.vssue.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="vssue"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;创建 themes/next/source/css/_custom/comments.styl文件，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 评论区样式 */.main-inner .comments &#123; // margin: 60px 0 20px 0; // 去掉链接下的下划线 a &#123; border-bottom: none; &#125; .highlight pre &#123; color: #24292e; &#125; // 防止代码区边缘黑线 .highlight, pre &#123; background: unset; &#125; .highlight ::selection &#123; background: #2593a6; color: #24292e; &#125; .tablink-li &#123; margin-bottom: 30px; &#125; .tabcontent-li &#123; border-top: solid 1px; &#125; .tablink &#123; float: left; border: none; outline: 0; cursor: pointer; width: 60px; color: #ddd; background-color: #60676d; &#125; .tablink:hover &#123; background-color: #222; &#125; .tabcontent &#123; display: none; &#125; .currentTabcontent &#123; background-color: #222; &#125; #tabs-valine &#123; margin: 25px; &#125; .valine &#123; .vwrap &#123; .textarea-wrapper .comment_trigger &#123; background-color: #f6f6f6; &#125; .textarea-wrapper textarea &#123; background-color: #f6f6f6; &#125; .auth-section .input-wrapper input &#123; background-color: #f6f6f6; &#125; .auth-section &#123; background-color: #f6f6f6; &#125; .auth-section .post-action button &#123; background-color: #333; &#125; &#125; &#125;&#125;✉️ 由于整合vssue的过程中发现单独使用没问题，但是和其他评论面板在一起发生回调地址不正确的问题，于是这里暂且只整合了Gitalk和Valine，如果有小伙伴找到了解决方案，欢迎联系本人，鲜花奉上！🌹¶4. 添加热门文章页面💁‍♂说明：这里添加热门文章页面的原理是通过leancloud访问统计生成的数据实现的，故需要编辑 themes/next/_config.yml主题配置文件开启 leancloud_visitors的功能。具体操作请参考上文的“leancloud统计”。创建 themes/next/layout/top.swig文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123;% block content %&#125; &#123;######################&#125; &#123;### LINKS BLOCK ###&#125; &#123;######################&#125; &lt;div id="top"&gt;&lt;/div&gt; &lt;!--下载av-min.js放到themes/next/source/js/src下：https://code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js --&gt; &lt;script src="/js/src/av-min.js"&gt;&lt;/script&gt; &lt;script&gt; var appId = '&#123;&#123; theme.leancloud_visitors.app_id &#125;&#125;' var appKey = '&#123;&#123; theme.leancloud_visitors.app_key &#125;&#125;' var serverApi = '&#123;&#123; theme.leancloud_visitors.server_api &#125;&#125;' if(serverApi)&#123; AV.init(&#123;appId, appKey,serverURLs: serverApi&#125;); &#125;else&#123; AV.initialize(appId, appKey) &#125; var time = 0 var title = "" var url = "" var query = new AV.Query('Counter'); query.notEqualTo('id', 0); query.descending('time'); query.limit(1000); query.find().then(function (dataArray) &#123; if(!dataArray)&#123; return &#125; for (var i = 0; i &lt; dataArray.length; i++) &#123; var item = dataArray[i] var result = item.attributes; time = result.time; title = result.title; url = result.url; var content = "&lt;p&gt;" + "&lt;font color='#1C1C1C'&gt;" + "【文章热度:" + time + "℃】" + "&lt;/font&gt;" + "&lt;a href='" + url + "'&gt;" + title + "&lt;/a&gt;" + "&lt;/p&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error",error); &#125;); &lt;/script&gt; &lt;style&gt; .post-description &#123; display: none; &#125; &lt;/style&gt; &#123;##########################&#125; &#123;### END LINKS BLOCK ###&#125; &#123;##########################&#125;&#123;% endblock %&#125;💁‍♂ 提醒：如果你的博客使用了 Valine 评论系统，那么可能会有代码冲突问题。需要修改 themes/next/layout/_third-party/comments/valine.swig 加入 {% if page.comments %}这个判断条件，默认旧版的next没有这个条件。可参考上文“增强版valine”相关代码。编辑 themes/next/layout/page.swig,修改两处代码1234567891011121314151617 &#123;% block title %&#125;&#123;# #&#125;&#123;% set page_title_suffix = ' | ' + config.title %&#125;&#123;# #&#125;&#123;% if page.type === "categories" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.category') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% elif page.type === "tags" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.tag') + page_title_suffix &#125;&#125;&#123;# &lt;!-- 友情链接--&gt; #&#125;&#123;% elif page.type === 'links' and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.links') + page_title_suffix &#125;&#125;&#123;#+ &lt;!-- top页面--&gt;+ #&#125;&#123;% elif page.type === 'top' and not page.title %&#125;&#123;#+ #&#125;&#123;&#123; __('title.top') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% else %&#125;&#123;# #&#125;&#123;&#123; page.title + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% endif %&#125;&#123;##&#125;&#123;% endblock %&#125;12345678910111213141516171819 &#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt; &lt;div class="category-all-title"&gt; &#123;&#123; _p('counter.categories', site.categories.length) &#125;&#125; &lt;/div&gt; &lt;div class="category-all"&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;!-- 友情链接--&gt; &#123;% elif page.type === 'links' %&#125; &#123;% include 'links.swig' %&#125;+ &lt;!-- top页面--&gt;+ &#123;% elif page.type === 'top' %&#125;+ &#123;% include 'top.swig' %&#125; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125; &lt;/div&gt;创建 myblog/source/top/index.md文件1234567---title: 文章阅读量排行榜type: topcomments: falsekeywords: top,文章阅读量排行榜,热文,文章热度,热门文章description: 博客文章阅读量排行榜---然后编辑 themes/next/_config.yml，添加菜单项12345678menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive links: /links/ || link about: /about/ || user 热文: /top/ || fire¶5. 添加在线联系功能在这使用的是DaoVoice做在线联系功能。首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:打开myblog/themes/next/layout/_partials/head.swig文件找到如下代码：1&#123;% include &#39;head&#x2F;custom-head.swig&#39; %&#125;另起一行添加如下代码（实际我就是添加到最后）：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125;打开 myblog/themes/next/_config.yml主题配置文件123# Online contact daovoice: truedaovoice_app_id: 33***da4 #这里输入前面获取的app_id最后执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s,打开博客就能看到效果了。如下图：当然为了调整图标的位置，你可以登陆daovoice后台进行修改，如下图：最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，在微信中登陆daovoice，就可以实时收发消息，有新的消息也会通过微信的小程序通知，设置页面如下:¶高级定制篇¶1. 自定义首页摘要图片和摘要描述¶1) 概述文章封面的意思就是：在博客首页的时候会显示文章的封面图片和摘要描述，进入这篇文章的详细页面后，将不显示这张图片和摘要描述。如果想添加文章封面的话，需要添加字段属性：summary_img，summary_img的值是图片的路径。如果想要添加摘要描述的话，可以添加字段属性：summary_description ，summary_description 的值是描述的内容。例如：123456789---title: CSS 各种Hack手段date: 2017-06-25 03:25:24categories: 前端tags: [CSS]comments: falsesummary_img: /images/css-hack-1.pngsummary_description: 封面摘要描述，了解一下！---¶2) 具体实现修改 myblog/themes/next/layout/_macro/post.swig 文件。将代码：1234567891011121314&lt;!-- 自定义摘要图片开始 --&gt; &#123;% if post.summary_img %&#125; &lt;div class="out-img-topic"&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class="img-topic"&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 自定义摘要图片结束 --&gt; &lt;!-- 自定义摘要描述开始 --&gt; &#123;% if post.summary_description %&#125; &lt;div class="post-button text-center"&gt; &lt;div&gt;&#123;&#123; post.summary_description &#125;&#125;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 自定义摘要描述结束 --&gt;添加到以下所示的位置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 &#123;% if is_index %&#125; &lt;!-- 自定义摘要图片开始 --&gt; &#123;% if post.summary_img %&#125; &lt;div class="out-img-topic"&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class="img-topic"&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 自定义摘要图片结束 --&gt; &lt;!-- 自定义摘要描述开始 --&gt; &#123;% if post.summary_description %&#125; &lt;div class="post-button text-center"&gt; &lt;div&gt;&#123;&#123; post.summary_description &#125;&#125;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 自定义摘要描述结束 --&gt; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; » &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; &#123;&#123; __('post.read_more') &#125;&#125; » &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif theme.auto_excerpt.enable %&#125; &#123;% set content = post.content | striptags %&#125; &#123;&#123; content.substring(0, theme.auto_excerpt.length) &#125;&#125; &#123;% if content.length &gt; theme.auto_excerpt.length %&#125;...&#123;% endif %&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; &#123;&#123; __('post.read_more') &#125;&#125; » &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% else %&#125; &#123;% if post.type === 'picture' %&#125; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt;&#123;&#123; post.content &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125;&lt;/div&gt;&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125;这样的话，就可以使用 summary_img: imageurl 和 summary_description: description demo来设置文章封面和摘要描述了。💡建议：开启了文章封面和摘要描述的文章，我建议将 &lt;!-- more --&gt; 放在文章正文内容的开头。为了适应不同大小的图片，摘要图片的样式需要做一下调整。在 myblog/themes/next/source/css/_custom/custom.styl中添加以下样式代码：1234//缩略图指定宽度值显示。img.img-topic &#123; width: 75%;&#125;如果希望hexo默认description也和summary_description居中显示，同样修改 myblog/themes/next/layout/_macro/post.swig 文件。找到以下代码。12345678910&#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; » &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt;&#123;% elif post.excerpt %&#125;将以上代码改成：123456789101112&#123;% if post.description and theme.excerpt_description %&#125; &lt;div class="post-button text-center"&gt; &lt;div&gt;&#123;&#123; post.description &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; » &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt;&#123;% elif post.excerpt %&#125;¶3) 优化首页摘要样式为了减小首页摘要文字的大小，使得能够更美观，可通过下面步骤修改：编辑 themes/next/layout/_macro/post.swig。加入如下div。12345678910111213141516171819202122&#123;% if is_index %&#125;+ &lt;div class="index-content"&gt; &lt;!-- 自定义摘要图片开始 --&gt; &#123;% if post.summary_img %&#125; &lt;div class="out-img-topic"&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class="img-topic"&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 自定义摘要图片结束 --&gt; 其他内容 其他内容 ...... &#123;% if post.type === 'picture' %&#125; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt;&#123;&#123; post.content &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125;+ &lt;/div&gt; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125;然后编辑 themes/next/source/css/_custom/custom.styl并加入如下样式：1234// 摘要文字.index-content &#123; font-size: 12px;&#125;¶2. 优化标签云页面新建 themes/next/layout/tag-color.swig文件，拷贝如下内容：12345678910111213141516171819202122232425262728293031323334 &#123;########彩色标签云##########&#125;&lt;script type="text/javascript"&gt; var alltags = document.getElementsByClassName('tag-cloud-tags'); var tags = alltags[0].getElementsByTagName('a'); for (var i = 0; i &lt; tags.length; i++) &#123; //console.log(tags[i]); //默认next会根据文章的数量确定a标签字的大小，这里把字体修改成统一大小 tags[i].style.background = "rgb(67, 67, 67)"; tags[i].style.fontSize = "13px"; tags[i].style.color = "#ddd"; &#125;&lt;/script&gt;&lt;style&gt; .tag-cloud-tags&#123; text-align: center; counter-reset: tags; margin-bottom: 20px; &#125; .tag-cloud-tags a&#123; border-radius: 6px; padding-right: 5px; padding-left: 5px; margin: 8px 5px 0px 0px; &#125; .tag-cloud-tags a:before&#123; content: "🔖"; &#125; .tag-cloud-tags a:hover&#123; box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4); transform: scale(1.1); transition-duration: 0.15s; &#125;&lt;/style&gt;在 themes/next/layout/page.swig里引入 tag-color.swig。12345678910111213141516 &#123;# tagcloud page support #&#125; &#123;% if page.type === "tags" %&#125; &lt;div class="tag-cloud"&gt; &lt;div class="tag-cloud-title"&gt; &#123;&#123; _p('counter.tag_cloud', site.tags.length) &#125;&#125; &lt;/div&gt; &lt;div class="tag-cloud-tags"&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt;+ &#123;########彩色标签云##########&#125;+ &#123;% include 'tag-color.swig' %&#125; &#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt;¶3. 添加404页面新建文件：themes/next/source/404.html，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;!-- 浏览器标签图标，此处需要在themes/next/source/images中加入favicon.jpg图片 --&gt; &lt;link rel="shortcut icon" href="/images/favicon.jpg" /&gt; &lt;title&gt;404哟&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; background-color: #ececec; font-family: "Open Sans", sans-serif; font-size: 14px; color: #3c3c3c; &#125; .demo p:first-child &#123; text-align: center; font-family: cursive; font-size: 150px; font-weight: bold; line-height: 100px; letter-spacing: 5px; color: #fff; &#125; .demo p:first-child span &#123; cursor: pointer; text-shadow: 0px 0px 2px #686868, 0px 1px 1px #ddd, 0px 2px 1px #d6d6d6, 0px 3px 1px #ccc, 0px 4px 1px #c5c5c5, 0px 5px 1px #c1c1c1, 0px 6px 1px #bbb, 0px 7px 1px #777, 0px 8px 3px rgba(100, 100, 100, 0.4), 0px 9px 5px rgba(100, 100, 100, 0.1), 0px 10px 7px rgba(100, 100, 100, 0.15), 0px 11px 9px rgba(100, 100, 100, 0.2), 0px 12px 11px rgba(100, 100, 100, 0.25), 0px 13px 15px rgba(100, 100, 100, 0.3); -webkit-transition: all 0.1s linear; transition: all 0.1s linear; &#125; .demo p:first-child span:hover &#123; text-shadow: 0px 0px 2px #686868, 0px 1px 1px #fff, 0px 2px 1px #fff, 0px 3px 1px #fff, 0px 4px 1px #fff, 0px 5px 1px #fff, 0px 6px 1px #fff, 0px 7px 1px #777, 0px 8px 3px #fff, 0px 9px 5px #fff, 0px 10px 7px #fff, 0px 11px 9px #fff, 0px 12px 11px #fff, 0px 13px 15px #fff; -webkit-transition: all 0.1s linear; transition: all 0.1s linear; &#125; .demo p:not(:first-child) &#123; text-align: center; color: #666; font-family: cursive; font-size: 20px; text-shadow: 0 1px 0 #fff; letter-spacing: 1px; line-height: 2em; margin-top: -50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="demo"&gt; &lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt; &lt;p&gt;该页面不存在(´･ω･`)&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;部署服务器后，访问不存在的资源时即可打开 404 页面。注意：不能通过本地 localhost 访问，要部署后通过自己域名来访问。¶4. 添加最近文章栏目编辑 myblog/themes/next/layout/_macro/sidebar.swig 。找到 theme.social板块代码，在该板块最后的 endif后隔一行添加如下代码。123456789101112131415161718&#123;# recent posts #&#125;&#123;% if theme.recent_posts %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.recent_posts_layout &#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &#123;% set posts = site.posts.sort('-date') %&#125; &#123;% for post in posts.slice('0', '5') %&#125; &lt;li class="recent_posts_li"&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;" target="_blank"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;再编辑 myblog/themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl在文件最后添加如下样式代码12345678li.recent_posts_li &#123; text-align: left; display: block; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;编辑主题配置文件 myblog/themes/next/_config.yml,添加如下代码：123recent_posts_title: 近期文章recent_posts_layout: blockrecent_posts: true¶5. 自定义友情链接页面¶方案1 纯静态文件创建 myblog/source/links-falls/index.md12345678910111213141516171819202122232425262728293031323334353637383940414243444546---title: 友情链接date: 2020-02-18 22:32:49no_toc: truecomments: true---&lt;!-- more --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="/static/links-falls/link.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/static/links-falls/link.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class="links-content"&gt; &lt;div class="link-navigation"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;------&lt;div style="text-align:center;"&gt; &lt;span class="with-love" id="animate1"&gt;&lt;i class="fa fa-heart"&gt;&lt;/i&gt;&lt;/span&gt; 留言互换友链鸭 &lt;span class="with-love" id="animate2"&gt;&lt;i class="fa fa-heart"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;------&#123;% note success %&#125;## 友链格式- 昵称：example- 网站地址：https://example.com- 网站Logo：https://example.com/logo.jpg&#123;% endnote %&#125;在 myblog/source/static/目录分别创建文件linklist.json123456789101112[ &#123; "nickname": "example1", "avatar": "https://example.com/logo.jpg", "site": "https://example.com" &#125;, &#123; "nickname": "example2", "avatar": "https://example.com/logo.jpg", "site": "https://example.com" &#125;]添加友链的话，只要在这个json文件里添加数据即可。link.js12345678910111213141516171819202122232425262728293031$(function() &#123; link = &#123; init: function() &#123; const that = this; /*加载 linklist.json 文件路径*/ $.getJSON("/static/links-falls/linklist.json", function(data) &#123; that.render(data); &#125;); &#125;, render: function(data) &#123; let html, nickname, avatar, site, li = ""; for (let i = 0; i &lt; data.length; i++) &#123; nickname = data[i].nickname; avatar = data[i].avatar; site = data[i].site; // 将数据拼接成html li += '&lt;div class="card"&gt;' +'&lt;a href="' +site +'" target="_blank"&gt;' +'&lt;div class="thumb" style="background: url( ' + avatar +');"&gt;' +"&lt;/div&gt;" + "&lt;/a&gt;" +'&lt;div class="card-header"&gt;' +'&lt;span class="card-site-nickname"&gt;&lt;a href="' +site +'" target="_blank"&gt;' +nickname +"&lt;/a&gt;&lt;/span&gt;" +"&lt;/div&gt;" + "&lt;/div&gt;"; &#125; $(".link-navigation").append(li); &#125;, &#125;; link.init();&#125;);link.css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485.links-content &#123; margin-top: 1rem;&#125;.link-navigation::after &#123; content: " "; display: block; clear: both;&#125;.card &#123; width: 60px; height: 100px; font-size: 0.5rem; padding: 0; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display: block; float: left; box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12); background: #f5f5f5;&#125;.card &#123; margin-left: 16px;&#125;.card &#123; margin-right: 16px;&#125;.card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);&#125;.card .thumb &#123; width: 100%; height: 0; border-radius: 50%; padding-bottom: 100%; background-size: 100% 100% !important;&#125;.posts-expand .post-body img &#123; margin: 0; padding: 0; border: 0;&#125;.card .card-header &#123; display: block; text-align: center; padding: 1rem 0.25rem; font-weight: 500; color: #333; white-space: normal;&#125;.card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: 700; text-decoration: none; border: 0;&#125;.card .card-header a:hover &#123; color: #d480aa; text-decoration: none; border: 0;&#125;.card-site-nickname &#123; white-space: nowrap; /*强制span不换行*/ display: inline-block; /*将span当做块级元素对待*/ width: 100%; /*限制宽度*/ overflow: hidden; /*超出宽度部分隐藏*/ text-overflow: ellipsis; /*超出部分以点号代替*/ line-height: 0.9; /*数字与之前的文字对齐*/&#125;.card-site-nickname:hover &#123; overflow: visible; /* 内容显示在元素框外面 */&#125;需要在 myblog/_config.yml中添加如下配置，表示不进行渲染的目录或者文件12skip_render: - static/**最后修改主题配置文件 themes/next/_config.xml文件，把链接加入到菜单栏1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive+ links: /links-falls/ || link about: /about/ || user效果：¶方案2 模板引擎swig新建 themes/next/layout/links.swig文件，并复制粘贴以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217&#123;% block content %&#125; &#123;######################&#125; &#123;### LINKS BLOCK ###&#125; &#123;######################&#125; &lt;div id="links"&gt; &lt;style&gt; div#links &#123; margin-top: 20px; &#125; .card &#123; /* 两列 */ /* width: 35%; padding: 10px 20px; */ /* 三列 */ width: 30%; padding: 10px 11px; margin: auto 6px; /* 四列 */ /* width: 20%; padding: 10px 20px; */ font-size: 1rem; border-radius: 4px; transition-duration: 0.15s; box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.12); margin-bottom: 1rem; background: #f5f5f5; display: flex; float: left; &#125; /* pc 缩放100% */ @media (min-width: 1600px) &#123; .card&#123; width: 29%; &#125; &#125; /* pc 缩放125%*/ @media (min-width: 1024px) &#123; .main-inner &#123; width: 1024px; &#125; .links-content &#123; margin-top: 1rem; width: 100%; &#125; .link-navigation::after &#123; content: " "; display: block; clear: both; &#125; /* .card:nth-child(odd) &#123; float: left; &#125; .card:nth-child(even) &#123; float: right; &#125; */ &#125; /* ipad pro */ @media (max-width: 1024px) &#123; .card &#123; width: 30%; padding: 10px 11px; margin: 0 6px 1rem 6px; &#125; &#125; @media (max-width: 1023px) &#123; .main-inner &#123; width: unset; &#125; .card &#123; margin-left: 5rem; width: 85%; &#125; .links-content &#123; width: unset; &#125; .card:nth-child(odd) &#123; float: none; &#125; .card:nth-child(even) &#123; float: none; &#125; &#125; /* ipad */ @media (max-width: 768px) &#123; .card &#123; margin-left: 4rem; width: 80%; &#125; &#125; /* iphone7/7 plus */ @media (max-width: 767px) &#123; .card &#123; margin-left: 2rem; width: 76%; &#125; &#125; /* iphone 5/se */ @media (max-width: 320px) &#123; .card &#123; margin-left: 1rem; width: 82%; &#125; &#125; .card:hover &#123; /* transform: scale(1.1); */ box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); &#125; .card a &#123; border: none; &#125; .card .ava &#123; width: 3rem !important; height: 3rem !important; margin: 0 !important; margin-right: 1em !important; border-radius: 50%; &#125; .card .card-header &#123; font-style: italic; overflow: hidden; width: 100%; &#125; .card .card-header a &#123; font-style: normal; font-weight: bold; text-decoration: none; &#125; .card .card-header a:hover &#123; color: #222; text-decoration: none; &#125; .card .card-header .info &#123; font-style: normal; color: #a3a3a3; font-size: 12px; min-width: 0; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; &#125; span.focus-links &#123; font-style: normal; margin-left: 10px; position: unset; left: 0; padding: 0 7px 0 5px; font-size: 11px; border-radius: 40px; line-height: 24px; height: 22px; color: #fff !important; background-color: #555; display: inline-block; &#125; span.focus-links:hover &#123; background-color: #222; &#125; .friends-btn &#123; text-align: center; color: #555 !important; background-color: #fff; border-radius: 3px; font-size: 15px; box-shadow: inset 0 0 10px 0 rgba(0, 0, 0, 0.35); border: none !important; transition-property: unset; padding: 0 15px; margin: inherit; &#125; .friends-btn:hover &#123; color: rgb(255, 255, 255) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient( 90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100% ); margin: inherit; &#125; &lt;/style&gt; &lt;div class="links-content"&gt; &lt;div class="link-navigation"&gt; &#123;% for link in theme.mylinks %&#125; &lt;div class="card"&gt; &lt;img class="ava" src="&#123;&#123; link.avatar &#125;&#125;" style="border: none"/&gt; &lt;div class="card-header"&gt; &lt;div&gt;&lt;a href="&#123;&#123; link.site &#125;&#125;" target="_blank"&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href="&#123;&#123; link.site &#125;&#125;"&gt;&lt;span class="focus-links"&gt;关注&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class="info" title="&#123;&#123; link.info &#125;&#125;"&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;&#123; page.content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;##########################&#125; &#123;### END LINKS BLOCK ###&#125; &#123;##########################&#125;&#123;% endblock %&#125;然后修改 themems/next/layout/page.swig文件，根据上下文找到相关位置然后添加如下两处 +号相关的内容。1234567891011121314 &#123;% block title %&#125;&#123;# #&#125;&#123;% set page_title_suffix = ' | ' + config.title %&#125;&#123;# #&#125;&#123;% if page.type === "categories" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.category') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% elif page.type === "tags" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.tag') + page_title_suffix &#125;&#125;&#123;#+ &lt;!-- 友情链接--&gt;+ #&#125;&#123;% elif page.type === 'links' and not page.title %&#125;&#123;#+ #&#125;&#123;&#123; __('title.links') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% else %&#125;&#123;# #&#125;&#123;&#123; page.title + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% endif %&#125;&#123;##&#125;&#123;% endblock %&#125;12345678910111213141516 &#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt; &lt;div class="category-all-title"&gt; &#123;&#123; _p('counter.categories', site.categories.length) &#125;&#125; &lt;/div&gt; &lt;div class="category-all"&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt;+ &lt;!-- 友情链接--&gt;+ &#123;% elif page.type === 'links' %&#125;+ &#123;% include 'links.swig' %&#125; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125; &lt;/div&gt;新建 hexo/source/links/index.md友链文件，在标题头中写入 type = &quot;links&quot; 这个属性头，如下：12345678910111213141516171819202122232425262728---title: 友情链接date: 2018-10-05 22:39:06no_toc: truecomments: truetype: "links"---------&lt;div style="text-align:center;"&gt; &lt;span class="with-love" id="animate1"&gt;&lt;i class="fa fa-heart"&gt;&lt;/i&gt;&lt;/span&gt; 留言互换友链鸭 &lt;span class="with-love" id="animate2"&gt;&lt;i class="fa fa-heart"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;------&#123;% note default %&#125;### 友链格式- 昵称：example- 链接：https://example.com- 头像：https://example.com/logo.jpg- 描述：Peace &amp; Love ! Learning to think independently !&#123;% endnote %&#125;修改主题配置文件 themes/next/_config.xml文件，把链接加入到菜单栏1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive+ links: /links/ || link about: /about/ || user最后，添加友链的话，只要在主题配置文件 themes/next/_config.xml文件末尾添加相关友情信息即可：12345678910# 友情链接mylinks: - nickname: example1 # 昵称 avatar: https://example.com/logo.jpg # 头像地址 site: https://example.com #友链地址 info: Peace &amp; Love ! Learning to think independently ! - nickname: example2 avatar: https://example.com/logo.jpg site: https://example.com info: Peace &amp; Love ! Learning to think independently !效果：¶6. 优化和美化代码块¶6.1 添加代码块全选复制功能下载第三方插件：clipboard.js, 或者直接下载 (右键另存为)。保存 clipboard.min.js文件到 theme/next/source/js/src 下。然后在 theme/next/source/js/src 目录下，创建 clipboard-use.js，添加内容如下：123456789101112131415161718192021222324/*页面载入完成后，创建复制按钮*/!(function(e, t, a) &#123; var initCopyCode = function() &#123; var copyHtml ='&lt;button class="btn-copy" data-clipboard-snippet=""&gt;&lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); var clipboard = new ClipboardJS(".btn-copy", &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on("success", function(e) &#123; var button = e.trigger; var iElement = button.querySelector("i"); iElement.className = "fa fa-check"; button.onmouseleave = function(ev) &#123; e.clearSelection(); setTimeout(function() &#123; iElement.className = "fa fa-clipboard"; &#125;, 1000); &#125;; &#125;); &#125;; initCopyCode();&#125;)(window, document);在 theme/next/source/css/_custom/custom.styl 样式中添加如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; //固定在代码块的右上角,父relative+子fixed==&gt;父relative+子absolute,这里可以根据自己的情况做调整fixed或者absolute //父relative+子fixed position: fixed; margin-top: 2px; //父relative+子absolute //position: absolute; //top: 5px; right: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;在 themes/next/layout/_layout.swig 文件中引用（&lt;/body&gt;）之前添加：123&lt;!-- 添加代码块全选复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt;¶6.2 添加mac代码面板创建 themes/next/scripts/codeblock.js文件1234567891011121314151617181920var attributes = [ 'autocomplete="off"', 'autocorrect="off"', 'autocapitalize="off"', 'spellcheck="false"', 'contenteditable="true"']var attributesStr = attributes.join(' ')hexo.extend.filter.register('after_post_render', function (data) &#123; var patt = /&lt;figure class="highlight(\s?)([a-zA-Z]*)"&gt;.*?&lt;\/figure&gt;/; while (patt.test(data.content)) &#123; data.content = data.content.replace(patt, function () &#123; var language = RegExp.$2 || 'plain' var lastMatch = RegExp.lastMatch lastMatch = lastMatch.replace('&lt;figure class="highlight', '&lt;figure class="iseeu highlight') return '&lt;div class="highlight-wrap"' + attributesStr + 'data-rel="' + language.toUpperCase() + '"&gt;' + lastMatch + '&lt;/div&gt;' &#125;) &#125; return data&#125;)创建 themes/next/source/css/_custom/macPanel.styl文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// mac Panel效果代码块相关.highlight-wrap[data-rel] &#123; position: relative; overflow: hidden; border-radius: 5px; box-shadow: 0 10px 30px 0px rgba(0, 0, 0, 0.4); margin: 35px 0; margin-top: 10px; margin-bottom: 25px; &amp;::before &#123; color: white; content: attr(data-rel); height: 38px; line-height: 38px; background: #21252b; color: #fff; font-size: 16px; position: absolute; top: 0; left: 0; width: 100%; //font-family: 'Source Sans Pro', sans-serif; font-weight: bold; padding: 0px 80px; text-indent: 15px; float: left; &#125; &amp;::after &#123; content: ' '; position: absolute; -webkit-border-radius: 50%; border-radius: 50%; background: #fc625d; width: 12px; height: 12px; top: 0; left: 20px; margin-top: 13px; -webkit-box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; z-index: 3; &#125;&#125;.highlight, pre &#123; margin-bottom: unset; margin-top: 35px;&#125;修改 themes/next/source/css/_custom/custom.styl，在最后追加如下：1@require "macPanel"¶6.3 mac代码面板整合全选复制按钮为了实现这个整合，我可真是花了不少时间，问了很多其他博主，但都无果，后来发现最新版的next其实已经实现了这个整合的功能，但是很遗憾的是我博客的next还是比较旧的版本，没办法直接配置实现。索性我直接去下载了最新版的next进行研究，通过一番较劲后，我终于做出来了，下面奉上教程：¶调整说明如果是按照上文步骤一步一步实现下来的，那么为了实现整合，还得做以下调整。如果没有经过以上步骤，可以直接跳到第2点。由于mac面板直接整合了代码全选复制按钮，所以可以把下面这些文件删除掉themes/next/source/js/src/clipboard-use.jsthemes/next/source/css/_custom/macPanel.stylthemes/next/scripts/codeblock.js此外还要做一些修改，删除掉以下文件的相关代码：文件1：themes/next/layout/_layout.swig123&lt;!-- 添加代码块全选复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt;文件2：themes/next/source/css/_custom/custom.styl1234567891011121314151617181920212223242526272829303132333435363738394041//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; //固定在代码块的右上角,父relative+子fixed==&gt;父relative+子absolute,这里可以根据自己的情况做调整fixed或者absolute //父relative+子fixed position: fixed; margin-top: 2px; //父relative+子absolute //position: absolute; //top: 5px; right: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;1@require "macPanel"¶整合步骤新增整合的js逻辑代码：themes/next/source/js/src/highlight-wrap.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author qcmoke * @description "mac面板"和"代码全选复制" * @Dependencies https://github.com/zenorocha/clipboard.js * @version 2.0 */function initMacPanel() &#123; var highlights = $(".highlight").not(".gist .highlight"); for (var i = 0; i &lt; highlights.length; i++) &#123; var figure = $(highlights[i]); var css = figure.attr("class"); var patt = /highlight(\s?)([a-zA-Z]*)/; patt.test(css); //得到第二个小括号的内容，如果为空，则设置为plain var language = RegExp.$2 || "plain"; var newDiv = $("&lt;div&gt;") .attr("data-rel", language.toUpperCase()) .addClass("highlight-wrap"); var wrap = figure.wrap(newDiv); wrap.before( '&lt;button class="copy-btn" data-clipboard-snippet=""&gt;&lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;/button&gt;' ); &#125;&#125;function initClipboard() &#123; var clipboard = new ClipboardJS(".copy-btn", &#123; target: function(trigger) &#123; //return trigger.nextElementSibling;//返回复制按钮下一个列表选项的 HTML 内容 ///返回复制按钮所在dom下含有class为code的第一个dom对象(可以防止复制figcaption的内容) var wrap = trigger.parentElement; var code = wrap.querySelector(".code"); return code; &#125; &#125;); clipboard.on("success", function(e) &#123; var button = e.trigger; var iElement = button.querySelector("i"); iElement.className = "fa fa-check"; button.onmouseleave = function(ev) &#123; e.clearSelection(); setTimeout(function() &#123; iElement.className = "fa fa-clipboard"; &#125;, 1000); &#125;; &#125;);&#125;$(document).ready(function() &#123; initMacPanel(); initClipboard();&#125;);修改页面模板引擎文件：themes/next/layout/_scripts/pages/post-details.swig，在最后追加如下代码以引入第三方插件依赖 clipboard.min.js和以上的 highlight-wrap.js。123&lt;!-- 代码块包裹面板=mac面板+代码块全选复制按钮 --&gt;&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/clipboard.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/highlight-wrap.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;第三方插件：clipboard.js, 或者直接下载 (右键另存为)。如果之前没有下载clipboard.min.js，那么需要下载并保存 clipboard.min.js文件到 theme/next/source/js/src 下新增整合的自定义样式文件：themes/next/source/css/_custom/highlight-wrap.styl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * @author qcmoke * @description "mac面板"和"代码全选复制"样式 * @version 2.0 * * tips: 修改hexo next主题配置文件，设置代码高亮highlight_theme为night eighties */.highlight-wrap &#123; position: relative;&#125;.highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1;&#125;.copy-btn &#123; position: absolute; top: 2px; right: 2px; display: inline-block; padding: 2px 6px; outline: 0; border: none; background: inherit; color: #dfe2e5; vertical-align: middle; white-space: nowrap; font-weight: 600; font-size: 14px; line-height: 16px; opacity: 0; cursor: pointer; transition: opacity .3s ease-in-out; user-select: none;&#125;.highlight-wrap &#123; margin-bottom: 1.6em; padding-top: 30px; border-radius: 5px; background: #21252b; box-shadow: 0 10px 30px 0 rgba(0, 0, 0, .4); &amp;::before &#123; position: absolute; top: 1px; padding: 0 80px; color: #fff; content: attr(data-rel); font-weight: 700; font-size: 14px; &#125; .highlight &#123; margin: 0 !important; border-radius: 0 0 5px 5px; &amp;::before &#123; position: absolute; left: 12px; margin-top: -20px; width: 12px; height: 12px; border-radius: 50%; background: #fc625d; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; content: ' '; &#125; // 代码选中时的样式 ::selection &#123; background: #2593a6; color: #fff; &#125; // 代码块标题栏 figcaption &#123; margin: 0; padding: 0 .5em .35em; padding-right: 8px; padding-left: 27px; border-bottom: 1px solid #111; background-color: #21252b; color: #999; font-style: italic; line-height: 1em; a &#123; float: right; color: #2770c3; &#125; a:hover &#123; border-bottom: 1px solid #d9534f; color: #d9534f; &#125; &#125; // 防止调试代码块内边框出现白线的问题 table&gt;tbody&gt;tr:nth-of-type(odd) &#123; background-color: unset; &#125; .code &#123; +mobile() &#123; //background: #2593a6; color: #fff; &#125; &#125; // 操作系统设置缩放比例比较大的时候适当调整代码字体变大 @media (min-width: 1600px) &#123; pre &#123; font-size: 14px; &#125; &#125; &#125;&#125;修改主题自定义样式文件：themes/next/source/css/_custom/custom.styl，在最后追加如下代码以引入整合的样式：1@require "highlight-wrap"💁‍♂温馨提示：custom.styl中最好不要出现其他与高亮有关的样式，如果存在的话可能会与上面的样式冲突。如果发现最终效果不理想，可以尝试在custom.styl中注释掉冲突的css代码。建议修改hexo next主题配置文件，设置代码高亮 highlight_theme为 night eighties，这样效果会更好。效果：¶7. 添加暗黑模式支持编辑 themes/next/layout/_scripts/vendors.swig文件，在最文件底部加入如下代码1234567891011121314151617181920212223242526&lt;!-- 暗黑模式 --&gt;&lt;i id="darkmode" class="fa fa-lightbulb-o" aria-hidden="true"&gt;&lt;/i&gt;&lt;script&gt;// 依次判断 系统暗黑模式 缓存 darkvar body = $("body")var darkmode = $("#darkmode")if (matchMedia("(prefers-color-scheme: dark)").matches ||localStorage.getItem("darkmode") === "1") &#123; if (!(localStorage.getItem("noDark") === "1")) &#123; body.addClass("dark") &#125;&#125;body.hasClass("dark")?darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o"):darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o")darkmode.click(function () &#123; if (body.hasClass("dark")) &#123; darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o") body.removeClass("dark") localStorage.setItem("darkmode", "0") localStorage.setItem("noDark", "1") &#125; else &#123; darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o") body.addClass("dark") localStorage.setItem("darkmode", "1") localStorage.setItem("noDark", "0") &#125;&#125;)&lt;/script&gt;创建 themes/next/source/css/_custom/dark.styl，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331/* 黑暗切换模式按钮 */#darkmode &#123; position: fixed; z-index: 1050; cursor: pointer; right: 33px; bottom: 91px; left: unset; font-size: 20px; width: 1rem; @media (max-width: 960px) &#123; right: 25px; bottom: 110px; &#125;&#125;/* 平滑改变背景色 */* &#123; transition: background-color 1000ms; // transition: color 500ms, background-color 1000ms;&#125;/* 下面是暗黑模式下的个性化定制样式 */:root &#123; --dark-background-color: #222; --dark-post-background-color: #292a2d; --dark-color: #a9a9b3; --dark-a-hover-color: #6190e8;&#125;.dark &#123; background-color: var(--dark-background-color); color: var(--dark-color); ::selection &#123; background: #f4e1c0; color: #101012; text-shadow: none; &#125; /* 在深色模式下把图片亮度调到 70% */ img &#123; -webkit-filter: brightness(0.7) !important; filter: brightness(0.7) !important; &#125; a &#123; color: var(--dark-color); :hover &#123; color: var(--dark-a-hover-color); &#125; &#125; .header &#123; .menu &#123; background-color: #565555; .menu-item &#123; a &#123; color: var(--dark-color); :hover &#123; color: var(--dark-color); &#125; &#125; &#125; @media (max-width: 767px) &#123; background-color: var(--dark-background-color); &#125; &#125; &#125; .post &#123; background-color: var(--dark-post-background-color); &#125; .main-inner .post &#123; background-color: var(--dark-post-background-color); box-shadow: 0 0 10px 0 #555; .archive &#123; box-shadow: unset; &#125; /* 代码行 */ code &#123; color: #eee; background: #555; &#125; &#125; .posts-expand &#123; .post-title-link &#123; color: var(--dark-color); &#125; table&gt;tbody&gt;tr:nth-of-type(odd) &#123; background-color: #202225; &#125; &#125; .highlight-wrap &#123; background: #1d1d1d; .copy-btn &#123; border: unset; background-color: unset; color: var(--dark-color); &#125; table&gt;tbody&gt;tr:nth-of-type(odd) &#123; background-color: unset; &#125; &#125; blockquote &#123; border-left-color: #666; color: #929191; &#125; .posts-expand .post-body img &#123; border: unset; &#125; /* mac代码面板 */ .highlight-wrap &#123; .highlight .gutter pre &#123; background-color: unset; color: #666; &#125; .highlight .code pre &#123; background-color: unset; border-left-color: #333; &#125; .highlight, pre &#123; background: #202225; color: var(--dark-color); &#125; &#125; .highlight-wrap::before &#123; color: #ccc; &#125; /* 分页 */ .pagination &#123; .page-number.current &#123; color: #333; background: #ccc; &#125; &#125; .pagination .next, .pagination .page-number, .pagination .prev &#123; border-top-color: #333; &#125; /* 文章底部 */ .post-footer &#123; .post-widgets &#123; border-top-color: #666; #needsharebutton-postbottom .btn &#123; color: #333; background-color: var(--dark-color); &#125; #needsharebutton-postbottom .btn:hover &#123; background-color: #f6f6f6; &#125; &#125; .post-nav &#123; border-top: 1px solid #666; .post-nav-item a:hover &#123; color: var(--dark-a-hover-color); &#125; &#125; &#125; /* 评论面板 */ .comments &#123; .tablink &#123; color: #222; &#125; .tablink:hover &#123; background-color: #ddd; &#125; .currentTabcontent &#123; background-color: #ddd; &#125; .tabcontent-li &#123; border-color: #757474; /* gitalk */ .gt-container &#123; .gt-comment-body &#123; color: var(--dark-color) !important; &#125; .gt-meta &#123; border-bottom: #333; &#125; .gt-header-textarea &#123; background-color: var(--dark-post-background-color); &#125; .gt-comment-content &#123; background-color: var(--dark-post-background-color); &#125; .gt-comment-content:hover &#123; -webkit-box-shadow: 0 0.625em 3.75em 0 #f4f4f4; box-shadow: 1px 1px 1em 0 #222; &#125; .gt-user .gt-ico svg &#123; fill: #ccc; &#125; .gt-header-preview &#123; background-color: var(--dark-post-background-color); color: var(--dark-color); &#125; &#125; .valine &#123; * &#123; color: var(--dark-color); &#125; border-bottom: #333; .vwrap &#123; border: var(--dark-post-background-color); .textarea-wrapper &#123; background: unset; &#125; .textarea-wrapper .comment_trigger &#123; background-color: var(--dark-post-background-color); &#125; .textarea-wrapper textarea &#123; color: var(--dark-color); background-color: var(--dark-post-background-color); &#125; .auth-section .input-wrapper input &#123; color: var(--dark-color); background-color: var(--dark-post-background-color); &#125; .auth-section &#123; background-color: var(--dark-post-background-color); &#125; .auth-section .post-action button &#123; border: var(--dark-post-background-color); background-color: #202124; &#125; &#125; .vlist .vcard .text-wrapper .vhead .vname &#123; color: var(--dark-a-hover-color); &#125; &#125; &#125; &#125; .post-toc &#123; a &#123; :hover &#123; color: #ccc; &#125; &#125; .nav .active-current&gt;a &#123; color: #87daff; &#125; &#125; /* 本地搜索面板 */ .local-search-popup &#123; background: #333; &#125; /* 归档页 */ .archive &#123; .posts-collapse .post-title a &#123; color: var(--dark-color); &#125; .posts-collapse::after &#123; background: var(--dark-post-background-color); &#125; &#125; /*阅读排行榜*/ #top font &#123; color: var(--dark-color); &#125; /* 友情链接 */ #links &#123; .card &#123; .card-header a &#123; color: #333; &#125; .card-header .info &#123; color: #60676d; &#125; &#125; &#125;&#125;编辑 themes/next/source/css/_custom/custom.styl，在此文件中的最后引入 dark.styl样式文件1@require 'dark';¶8. 魔改next主题由于个人喜好，和为适配移动端，本博客从这里开始将修改next主题的布局为Muse。并在Muse的基础上做了比较大的样式调整，形成了目前博客现状的基本布局和样式。其中包括整体骨架布局、菜单栏、首页文章缩略卡片、文章页宽、移动端适配、字体大小等等诸多样式的调整。先看魔改主题效果：修改 themes/next/_config.yml启用 Muset:12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini然后编辑 themes/next/source/css/_custom/custom.styl添加自定义样式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359// 去掉链接下的下划线* a &#123; text-decoration: none; border-bottom: unset;&#125;// 页面顶部样式.header &#123; // 顶部背景 background-image: linear-gradient(90deg, #222325, #3b3c3f, #222325); @media (max-width: 767px) &#123; background: black; &#125; // 顶部宽度和距离 .header-inner &#123; padding-top: 0; padding-bottom: 0; width: 100%; &#125; // 博客title .custom-logo-site-title .brand &#123; background: none; .site-title &#123; letter-spacing: 0; font-weight: bold; font-size: 29px; &#125; &#125; // 博客subtitle描述 .site-subtitle &#123; margin-top: 7px; margin-bottom: 5px; color: #999; font-weight: 700; font-size: 10px; @media (max-width: 767px) &#123; display: block; margin-top: 11px; padding-bottom: 2px; &#125; &#125; // 顶部菜单栏 .menu &#123; margin-top: 0; margin-bottom: 0; padding: 1px; background-color: rgba(255, 255, 255, .75); box-shadow: 0 10px 10px 0 rgba(0, 0, 0, .15); text-align: center; // 菜单超链接 .menu-item a &#123; padding-right: 20px; padding-left: 20px; color: #333; font-weight: 600; font-size: 13px; @media (min-width: 1600px) &#123; font-size: 15px; &#125; :hover &#123; color: black; font-weight: bold; &#125; &#125; &#125; // 移动端下拉抽屉按钮横杠背景色 .site-nav-toggle .btn-bar &#123; background: #f9f9f9; &#125; // 移动端下拉抽屉面板上边距 .site-nav &#123; top: 62px; &#125;&#125;// 首页主体部分.main &#123; // 首页文章缩略卡片宽度 section#posts &#123; margin: 0 auto; width: 78%; @media (min-width: 1600px) &#123; margin: 0 auto; width: 83%; &#125; @media (max-width: 767px) &#123; margin: 0 auto; width: 85%; &#125; @media (max-width: 960px) &#123; margin: 0 auto; width: 85%; &#125; // 缩略图边缘样式 .post-body img &#123; padding: 0; border: none; &#125; &#125; // 缩略图指定宽度值显示。 img.img-topic &#123; width: 55%; @media (max-width: 767px) &#123; width: 60%; &#125; &#125; // 去除缩略卡片之间的分割线 .posts-expand .post-eof &#123; margin: 0; background-color: rgba(255, 255, 255, 0); &#125; // 页码 .pagination &#123; // 减小页码外边距 margin: 50px 0 0; // 去除页面底部页码上面的横线 border: none; &#125;&#125;// 主体文章.main-inner &#123; // 文章宽度 margin: 0 auto; width: 960px; @media (min-width: 1600px) &#123; width: 1080px; &#125; @media (max-width: 960px) &#123; margin: 0 auto; width: inherit; &#125; @media (max-width: 767px) &#123; margin: 0 auto; width: inherit; &#125; .post &#123; margin-bottom: 10px; padding: 45px 28px 36px; background-color: rgb(255, 255, 255); box-shadow: 0 0 10px 0 rgba(0, 0, 0, .5); .code &#123; //修复选择代码时光标跨越多行的问题 width: 100%; &#125; @media (max-width: 767px) &#123; padding: 45px 12px 36px; &#125; &#125; .posts-expand &#123; // 文章标题字体 .post-title &#123; font-weight: 700; font-size: 20px; &#125; // 文章元数据（meta）留白更改 .post-meta &#123; margin: 10px 0 20px; &#125; // 文章的描述description .post-meta .post-description &#123; margin-top: 30px; margin-bottom: 0; color: #666; font-style: italic; font-size: 14px; &#125; @media (max-width: 767px) &#123; margin: 0; padding-top: 0; &#125; @media (max-width: 960px) &#123; margin: 0; &#125; &#125; // 摘要文字 .index-content &#123; font-size: 12px; &#125; // 文章内链接文本样式 .post-body p a &#123; border-bottom: none; border-bottom: 1px solid #0593d3; color: #0593d3; &amp;:hover &#123; border-bottom: none; border-bottom: 1px solid #fc6423; color: #fc6423; &#125; &#125; // 文章底部 .post-footer &#123; .post-widgets &#123; padding-top: 0; // 当rating和needmoreshare2都开启时让它们居中竖着排 if (hexo-config('rating.enable') &amp;&amp; hexo-config('needmoreshare2.enable')) &#123; #needsharebutton-postbottom &#123; // bottom: 25px; // margin: auto 50%; //修复分享按钮在火狐浏览器显示换行的问题 bottom: -10px; &#125; .wp_rating &#123; position: relative; top: 35px; &#125; &#125; &#125; .post-nav &#123; margin-top: 30px; &#125; &#125;&#125;// 侧栏抽屉#sidebar &#123; // 近期文章 .sidebar-inner li.recent_posts_li &#123; text-align: center; &#125; @media (max-width: 767px) &#123; .site-overview &#123; overflow-x: hidden; overflow-y: auto; &#125; &#125;&#125;// 侧方浮动抽屉按钮.sidebar-toggle &#123; @media (max-width: 767px) &#123; right: 20px; bottom: 58px; width: 20px; height: 20px; opacity: unset; .sidebar-toggle-line &#123; height: 3px; &#125; &#125;&#125;// 回到顶部按钮.back-to-top &#123; @media (max-width: 960px) &#123; right: 20px; &#125; @media (max-width: 767px) &#123; right: 20px; &#125;&#125;// 博客页面最底部.footer-inner &#123; // 移动端footer字体变小，防止换行 @media (max-width: 767px) &#123; font-size: 11px; &#125;&#125;// 分类页.category-all-page &#123; .category-list &#123; margin: 0; margin-left: 44%; padding: 0; list-style: none; &#125; a.category-list-link &#123; font-weight: bold; font-size: 20px; &#125;&#125;// 归档页位置调整.posts-collapse &#123; margin-top: 50px; .post-header::before &#123; left: -4px; &#125; .collection-title &#123; margin: 50px 0 5px; &#125; .post &#123; margin: 0; margin-top: 0; margin-left: 2px; padding: 2px; box-shadow: none; &#125; .post-header &#123; position: relative; border-bottom: 1px dashed #ccc; transition-delay: 0s; transition-timing-function: ease-in-out; transition-duration: .2s; transition-property: border; &#125;&#125;// 热文页#top p &#123; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;// 引入其他文件的样式@require 'scrollbar';@require 'comments';@require 'highlight-wrap';@require 'dark';💁‍♂下面的文件是 custom.styl依赖的样式文件：（1）scrollbar.styl1234567891011121314151617181920212223242526&gt;/**&gt;* @author qcmoke&gt;* 美化博客中浏览器的滚动条(只适用于webkit内核浏览器)&gt;*/&gt;@media (min-width: 567px) &#123; /* 定义滚动条高宽及背景高宽分别对应横竖滚动条的尺寸 */ ::-webkit-scrollbar &#123; width: 10px; height: 10px; background-color: #F5F5F5; &#125; /* 定义滚动条轨道内阴影+圆角 */ ::-webkit-scrollbar-track &#123; border-radius: 2px; background-color: #F5F5F5; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3); &#125; /* 定义滑块内阴影+圆角 */ ::-webkit-scrollbar-thumb &#123; border-radius: 2px; background-color: #555; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3); &#125;&gt;&#125;（2）comments.styl的内容参考上文“整合多个评论面板”（3）highlight-wrap.styl 的内容参考上文“优化和美化代码块”（4）dark.styl 的内容参考上文“添加暗黑模式支持”¶9. hexo支持本地Markdown文件链接引用hexo 默认支持标准 markdown 语法引用链接格式（如：[xxx](xxx.html)）和 hexo 标签插件语法引用链接格式（如：）。引用本地文章可以通过使用以上两种引用链接格式语法来满足基本要求，但通常在编写 Markdown 文章时，Markdown 文件对应的 html 页面还没有编译出来，此时的引用链接是无效的，故而无法使用 Markdown 编辑器直接打开链接页面，但通过[xxx](xxx.md)的 Markdown 文件链接方式来直接引用 Markdown 文件时 Markdown 编辑器是可以打开链接页面的，然而使用[xxx](xxx.md)这种写法会导致 hexo 编译时无法渲染为 html 链接，为了解决这个问题，可以给 hexo 添加编译过滤器，让 hexo 编译时将[xxx](xxx.md) 修改为[xxx](xxx.html)。具体实现方式如下：创建并编辑：themes/next/scripts/filters/hexo-md-link.js 文件。内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const log = require("hexo-log")(&#123; debug: false, slient: false &#125;);const fs = require("hexo-fs");const path = require("path");const base_dir = path.join(hexo.source_dir, "_posts");const fileList = fs .listDirSync(base_dir, &#123; ignorePattern: /node_modules/, &#125;) .filter((each) =&gt; each &amp;&amp; /\.md$/.test(each)) .map((each) =&gt; &#123; let array = (each + "").split(path.sep); // For Windows if (path.sep === "\\") &#123; each = each.replace(new RegExp("\\" + path.sep, "g"), "/"); &#125; return &#123; fileNameExt: array.length === 0 ? "" : array[array.length - 1], filePath: each, articleName: each.replace(/\.md$/, ""), &#125;; &#125;);function fixLink(data, regEx, func) &#123; let &#123; content &#125; = data; let result = content.match(regEx); if (result &amp;&amp; result.length &gt; 0) &#123; // console.log("result"); result.forEach((linkString) =&gt; &#123; let [filepath, showName] = func(linkString); // console.log(&#123; linkString, filepath, showName &#125;); let anchor = null; if (!filepath || filepath.length === 0) &#123; return; &#125; filepath = filepath.trim(); let htmlFilepath = filepath.replace(".md", ".html"); fileName = filepath.split("/").pop(); [fileName, anchor] = fileName.split("#"); const extName = ".md"; let realNameExt = fileName; if (!fileName.endsWith(extName)) &#123; realNameExt = fileName + extName; &#125; //console.log(&#123; realNameExt, filepath, showName &#125;); let file = fileList.find((file) =&gt; file.fileNameExt === realNameExt); if (file) &#123; // console.log("file", file); content = replaceAndIgnoreCode( content, linkString, `&lt;a href="$&#123;htmlFilepath&#125;" name="$&#123;filepath&#125;" id="hexo-md-link"&gt;$&#123; showName || filepath &#125;&lt;/a&gt;` // `&#123;% post_link $&#123;file.articleName&#125; '$&#123;showName || filepath&#125;' %&#125;` ); &#125; &#125;); &#125; data.content = content; return data;&#125;//获取字符串的 哈希值function getHashCode(str, caseSensitive) &#123; if (!caseSensitive) &#123; str = str.toLowerCase(); &#125; let hash = 1315423911; for (let i = str.length - 1; i &gt;= 0; i--) &#123; let ch = str.charCodeAt(i); hash ^= (hash &lt;&lt; 5) + ch + (hash &gt;&gt; 2); &#125; return hash &amp; 0x7fffffff;&#125;// 替换引用链接（排除代码块）function replaceAndIgnoreCode(markdown, oldString, newString) &#123; // 匹配所有代码：`code`和代码块：```codelet codeBlocksRegex = /{1,3}[\s\S]*?{1,3}/g;let originalCodeStrArr = markdown.match(codeBlocksRegex);// 在每个匹配项之间，使用占位符填充原始文本中的内容const PLACEHOLDER_CODE =“CODE_BLOCK_PLACEHOLDER” +getHashCode(oldString) +&quot;@&quot; +new Date().getTime();let placeholders = Array(originalCodeStrArr.length).fill(PLACEHOLDER_CODE);//使用占位符替换所有代码块（先获取所有的代码块，然后使用占位符替换每个代码块）let reconstructedMarkdown = markdown.split(codeBlocksRegex).reduce((acc, cur, i) =&gt; acc.concat(cur, placeholders[i] || “”), []).join(&quot;&quot;);// 替换字符串（排除代码块内的内容）let newMarkdown = reconstructedMarkdown.replace(oldString, newString);// 将占位符替换回代码块let finalMarkdown = newMarkdown.split(PLACEHOLDER_CODE).reduce((accumulator, currentValue, i) =&gt;accumulator.concat(currentValue, originalCodeStrArr[i] || “”),[]) //将数组的所有元素按顺序依次执行指定的函数，并返回一个累积的结果.join(&quot;&quot;).trim();return finalMarkdown;}hexo.extend.filter.register(“before_post_render”,(data) =&gt; {// 适配 xxx 格式markdown链接fixLink(data, /[.?](.?.md.?)/g, (linkString) =&gt; {let filepath = “”;let showName = “”;let filepathMatches = linkString.match(/((.?))/);if (filepathMatches &amp;&amp; filepathMatches.length &gt; 1) {filepath = filepathMatches[1];}let showNameMatches = linkString.match(/[(.?)]/);if (showNameMatches &amp;&amp; showNameMatches.length &gt; 1) {showName = showNameMatches[1];}return [filepath, showName];});// 适配 [[xxx/xxxx.md#xxx|xxx]] 格式wiki链接fixLink(data, /[[.?]]/g, (linkString) =&gt; {let [filepath, showName] = (linkString + “”).replace(&quot;[[&quot;, “”).replace(&quot;]]&quot;, “”).split(&quot;|&quot;);return [filepath, showName];});},0);123456789101112131415161718192021222324&gt;此脚本除了支持&#96;[xxx](xxx&#x2F;xxxx.md)&#96;格式的 markdown 引用链接还支持&#96;[[xxx&#x2F;xxxx.md#xxx|xxx]]&#96;格式的 wiki 引用链接。添加以上文件后，然后重新进行 hexo 编译即可支持 markdown 引用链接。# 运维部署篇## 1. 添加备案号修改 &#96;themes&#x2F;next&#x2F;layout&#x2F;_layout.swig&#96;，在footer标签里添加a链接标签，如下：&#96;&#96;&#96;html&lt;footer id&#x3D;&quot;footer&quot; class&#x3D;&quot;footer&quot;&gt; &lt;div class&#x3D;&quot;footer-inner&quot;&gt; &#123;% include &#39;_partials&#x2F;footer.swig&#39; %&#125; &#123;% include &#39;_third-party&#x2F;analytics&#x2F;analytics-with-widget.swig&#39; %&#125; &#123;% if theme.beian.enable %&#125; &lt;a href&#x3D;&quot;&#123;&#123;url_for(theme.beian.url)&#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123;theme.beian.beianNum&#125;&#125;&lt;&#x2F;a&gt; &#123;% endif %&#125; &#123;% block footer %&#125;&#123;% endblock %&#125; &lt;&#x2F;div&gt;&lt;&#x2F;footer&gt;然后修改主题配置文件 themes/next/_config.ymll添加如下配置：1234beian: enable: true url: https://beian.miit.gov.cn/ beianNum: 黔ICP备20002951号¶2. 搜索引擎优化（SEO）¶1) 生成网站地图文件针对百度和谷歌，分别有两个 hexo 插件，hexo-generator-sitemap 是是生成谷歌 sitemap 的插件；hexo-generator-baidu-sitemap则是生成百度 sitemap 的插件。12npm install hexo-generator-sitemap --save-devnpm install hexo-generator-baidu-sitemap --save-dev安装完成后，重启hexo，执行hexo g后，在public目录下生成对应的xml文件。本地可以通过http://127.0.0.4000/sitemap.xml和 http://127.0.0.4000/baidusitemap.xml访问到 sitemap 文件。发布后可以通过 https://yourdoname/sitemap.xml 和 https://yourdoname/baidusitemap.xml 访问。¶2) 添加爬虫规则文件新建爬虫规则文件：themes/next/source/robots.txt123456789# hexo robots.txtUser-agent: * Allow: &#x2F;Allow: &#x2F;archives&#x2F;Disallow: &#x2F;vendors&#x2F;Disallow: &#x2F;js&#x2F;Disallow: &#x2F;css&#x2F;Disallow: &#x2F;fonts&#x2F;Disallow: &#x2F;vendors&#x2F;Disallow: &#x2F;fancybox&#x2F;¶3) 提交文件注册 google网站站长 平台。将 https://yourdoname/sitemap.xml 提交给google网站站长注册 百度站长 平台，将 https://yourdoname/baidusitemap.xml 提交给百度站长百度站长和Google网站站长都要提交 https://yourdoname/robots.txt¶3. 静态资源压缩优化用hexo生成静态文件时，默认生成的静态文件存在大量空白，而且css、js都未经压缩，这在一定程度上会影响页面的加载，所以在网上所搜有没有办法来优化这些问题？答案肯定是有，当然大部分博客都提到了使用gulp来精简代码，而我今天所要跟大家介绍的是hexo-neat插件 。我为啥不选择gulp而使用hexo-neat呢？因为用gulp需要在每次生成静态文件后，即 hexo g后，都要另外执行 gulp命令才能压缩静态文件；而使用hexo-neat则无须另外执行其他命令即可自动完成压缩功能，即方便了使用习惯。在站点的根目录下执行以下命令：1npm install hexo-neat --save打开 myblog/_config.yml全局配置文件添加如下配置：1234567891011121314151617181920212223#静态资源压缩优化# hexo-neatneat_enable: true # 启用neat# 对html优化neat_html: enable: true exclude: # 对css优化neat_css: enable: true exclude: - '*.min.css'# 对js优化neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'做好以上几步之后，重新生成博客的时候就会自动压缩所有的 html、css、js。访问博客时能感到明显加快了。¶4. 部署hexo到git服务器下面以 GitHub 服务器为例讲解：（1）首先要登录github创建一个 user.github.io仓库，仓库名比较特殊，如：qcmoke.github.io，此处的 qcmoke为你的github用户名,github正是通过这个仓库免费生成与该仓库名相同的域名，注意github只为每一位用户提供一个这样带有免费域名的 github page。💁‍♂说明:除了 user.github.io这样特殊名称的仓库外，当然其他任意名称的仓库也可以设置pages服务，只是不提供域名罢了，但也能通过 user.github.io/仓库名称或者设置自定义域名的方式访问pages页面。（2）安装git文件上传插件1npm install hexo-deployer-git --save打开全局配置文件 myblog/_config.yml，找到 deploy并进行如下修改：1234deploy: type: git repository: git@github.com:qcmoke/qcmoke.github.io.git branch: master其中 repository 的值是你 git 远程仓库的地址。（3）提交部署如果你上面都配置好了，发布上传很容易，只要一句命令就能搞定。12#这条命令会将public目录的文件提交上传到git远程仓库hexo d💁‍♂ 注意：本地安装好后ssh key一定要配置好。 因为上传文件到github的过程中需要。（4）访问 https://qcmoke.github.io进行测试💁‍♂注意：这个请求地址用你自己的，即 https://user.github.io¶5. github和coding双线路部署hexo¶1) 配置这里讲的是hexo一次部署能够实现github和coding两个远程仓库自动同步，你只要打开全局配置文件 myblog/_config.yml，搜索关键字 deploy，根据自己远程仓库地址做以下修改：123456deploy: type: git repository: github: git@github.com:qcmoke/qcmoke.github.io.git coding: git@git.coding.net:qcmoke/qcmoke.coding.me.git branch: master¶2) 部署和原来的单部署执行的命令一样：12hexo ghexo d🙆‍♂ 双线路部署hexo完成。¶3) 额外补充其实完成以上步骤就能实现简单版的双线路部署 hexo 了，但有两个问题：（1）不同平台上的hexo博客需要不同的域名访问（2）双线部署的的情况下，gittalk 由于是通过域名来调用 github OAuth Apps 的 api 的，但是 github 和 coding 免费提供的是两个不同的域名，所以会导致api调用错乱而报错的问题。我们希望用同一个域名就能同时访问 github pages 和 coding pages，即所谓的负载均衡思想，而且还要解决 gitalk api 调用错乱的问题。解决以上问题的前提是有一个自己的域名。至于怎么获取域名，我就不废话了 啊，百度吧朋友 😅 ~！这里就假设你已经有了自己的域名，然后按照下面的步骤一步一步完成即可。¶(1) 解析域名CNAME记录将域名 CNAME 记录分别解析到你 yourname.github.io 和 yourname.coding.me 上。如下图：如果你的dns解析托管服务商解析线路有“国内”线路，最好将 yourname.coding.me解析到国内线路。而 yourname.github.io解析到国外线路即可。如果没有的话，和我一样全选默认线路即可。¶(2) 设置自定义域名分别登录到 github 和 coding 后台，将你的域名填入并启用 https 即可。（2.1）Github💁‍♂提示：github 目前启用自定义域名的 https 服务大概需要等 24 小时才能生效。如果到时间了还未生效，并且 “Enforce HTTPS” 是灰色的不能选择或者没有这个选项，你可以清除设置中的 custom domain 域名，再次填写保存即可解决，然后 “Enforce HTTPS” 选择打钩，一般就能启用 https 了。💡 可选：你可以选择在仓库根目录中加入一个名为 CNAME的文件（或者博客源码的themes/next/source目录里），里面填入你的域名，这和设置中填入自定义域名的效果是一样的）（2.2）Coding💁‍♂ 说明：coding 需要银牌以上会员才有权限加入自定义的域名。不过银牌会员是免费的，登录 coding 后找到会员设置后点击申请并完善个人信息后就能升级到银牌会员。🙉 目前 coding 被腾讯大哥收购后，界面改了很多，请自行解决。🌸 完成后你只要通过自定义的域名访问你的 git page 服务即可。¶(3) 额外补充💁‍♂如果你没有使用gitalk，可以直接跳过下面的内容。上文中“加入评论面板”已经介绍如何创建 “github OAuth Apps”，这里额外补充说明一下，和无自定义域名的情况不同 ，有自定义域名的情况只需要一个 github OAuth Apps ，所以 Homepage URL 和 Authorization callback URL 都指向同一个地址路径，所以不同仓库下的 gitalk 实际调用的是同一个github OAuth Apps的api 。如果你之前已经为 github 博客和 coding 博客分别创建了两个 github OAuth Apps，那么我建议你可以删除掉那些无用的 github OAuth Apps 了。然后重新创建一个 github OAuth Apps，注意：github OAuth Apps 上的 Homepage URL 和 Authorization callback URL 为你博客的新地址（自定义域名地址）修改 myblog/themes/next/_config.yml主题配置文件中的 gitalk 配置，配置完成如下图：¶4) 关于coding广告目前使用自定义域名，coding会强制在你打开博客时放入几秒钟的广告，在此吐槽一下💢。去除这个广告页面也不是没有办法，coding提供了一些办法，其中一种就是在你的博客首页加入他们家的链接。也就是“Hosted by Coding Pages”这几个字，虽然还是很讨厌，但是没办法，忍忍吧，毕竟要了人家的服务器啦。既然coding要求帮他们打广告，而我又用的是双线部署hexo博客到github和coding上的方案，故将计就计，那也顺便帮github打广告啦。具体做法如下:在 myblog/themes/next/layout/_partials/footer.swig中找到如下代码块:12345678910111213 &#123;% if theme.post_wordcount.totalcount %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-area-chart"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.totalcount') &#125;&#125;:&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.totalcount') &#125;&#125;"&gt;&#123;# #&#125;&#123;&#123; totalcount(site, '0,0.0a') &#125;&#125;&#123;# #&#125;&lt;/span&gt; &#123;% endif %&#125;&lt;/div&gt;另起一行，添加如下代码:1234&lt;!-- Github Pages and coding pages ad --&gt;&lt;span&gt;Hosted by &lt;a href="https://pages.github.com" style="font-weight: bold"&gt;Github Pages&lt;/a&gt;&lt;/span&gt; and &lt;span&gt;Hosted by &lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt;&lt;/span&gt;以上完成后还没结束，还要登录到coding后台设置选择“已放置 Hosted by Coding Pages”打钩。但你可能找不到这个设置页面，你需要切换coding主页回旧版再找pages服务设置，就能找到这个设置了，如下：Hosted by Coding Pages 提交后需要审核，会在两个工作日内为你处理。处理成功后就不会有打开博客主页前的几秒钟广告推送了。¶滚动改版篇¶1. hexo升级至4.2.1原来版本：hexo@3.7.1 + hexo-theme-next@5.1.4升级版本：hexo@4.2.1 + hexo-theme-next@5.1.4原本使用的hexo@3.7.1版本，一直有个问题，那就是引用里如果使用代码块，那么代码块的每行开头都会多出字符&gt;。如下图：为了解决以上问题我把hexo版本升级到了4.2.1。其实只要升级到4.0.0以上的版本都可以，但5.0.0的改动太大了所以就没改升，故而选择了hexo@4.x.x的最后一个版本hexo@4.2.1。但是升级到hexo@4.2.1后又发现出现了一些其他的问题，需要手动适配。主要适配内容为以下：点击博客菜单按钮时无法打开页面，原本的url会多出%20等编码字符串，如：http://localhost:4000/categories/%20/，其主要原因是使用了encodeURI编码了链接，但是原本菜单的配置多出了空格，如：categories: /categories/ || th。解决办法有两个（1）只要把||前面的空格去掉就可以了。如下：1234567891011121314menu:home: / || home#about: /about/ || usertags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive上面修改为如下（删除path中多余空格）：menu:home: /|| home#about: /about/ || usertags: /tags/|| tagscategories: /categories/|| tharchives: /archives/|| archive（2）还有一种办法就是在跳转前的代码中把空格去除掉（我使用的是这种）。修改themes/next/layout/_macro/sidebar.swig文件：123&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;改成&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives.split(&#39;||&#39;)[0] | trim )&#125;&#125;&quot;&gt;修改themes/next/layout/_partials/header.swig文件：123&lt;a href&#x3D;&quot;&#123;&#123; url_for(path.split(&#39;||&#39;)[0]) | trim &#125;&#125;&quot; rel&#x3D;&quot;section&quot;&gt;改成&lt;a href&#x3D;&quot;&#123;&#123; url_for(path.split(&#39;||&#39;)[0] | trim )&#125;&#125;&quot; rel&#x3D;&quot;section&quot;&gt;参考：https://github.com/iissnan/hexo-theme-next/issues/2233https://github.com/SevenNorth/AshesBlog/commit/e758caa65ccd3a9da20ebfadb35573257de6b35b首页底部分页按钮无法识别字体图标而直接展示出html标签代码出来，如下图为了解决这个问题，需要修改themes/next/layout/_partials/pagination.swig，添加escape: false，如下：123456789101112&#123;% if page.prev or page.next %&#125; &lt;nav class&#x3D;&quot;pagination&quot;&gt; &#123;&#123; paginator(&#123; prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;&#39;, next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;&#39;, mid_size: 1, escape: false &#125;) &#125;&#125; &lt;&#x2F;nav&gt;&#123;% endif %&#125;参考：https://www.4spaces.org/856.htmlhttps://github.com/theme-next/hexo-theme-next/blob/master/layout/_partials/pagination.swig¶参考📚https://easyhexo.com📚https://io-oi.me/tech/hexo-next-optimization📚https://www.liaofuzhan.com/posts/2114475547.html]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typecho从http转https]]></title>
    <url>%2Fblog%2Ftypecho_http_https.html</url>
    <content type="text"><![CDATA[实现https首先需要购买ssl证书，比如通过阿里云购买了dv ssl证书。下载ssl文件解压后会得到214965547810841.key、214965547810841.pem、chain.pem、public.pem 共4个文件。文件说明：证书文件214965547810841.pem，包含两段内容，请不要删除任何一段内容。如果是证书系统创建的CSR，还包含：证书私钥文件214965547810841.key、证书公钥文件public.pem、证书链文件chain.pem。¶一、预前配置设置¶1.创建/etc/httpd/cert目录cert目录的目的是用来存放以上4个文件。12cd /etc/httpd/mkdir cert¶2.通过xftp等工具将以上4个文件存送到cert目录。¶3.安装openssl和mod_ssl1yum install openssl mod_ssl¶二、配置证书完成以上安装后，会自动生成 /etc/httpd/conf.d/ssl.conf(也可能是/etc/httpd/conf/extra/httpd-ssl.conf，这与操作系统及安装方式有关，此种情况请参考阿里云的说明文档)， 在配置文件中查找以下配置语句，配置public.pem、214965547810841.key、chain.pem的路径。1234567891011# 添加 SSL 协议支持协议，去掉不安全的协议SSLProtocol all -SSLv2 -SSLv3# 修改加密套件如下SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUMSSLHonorCipherOrder on# 证书公钥配置SSLCertificateFile /etc/httpd/cert/public.pem# 证书私钥配置SSLCertificateKeyFile /etc/httpd/cert/214965547810841.key# 证书链配置，如果该属性开头有 '#'字符，请删除掉SSLCertificateChainFile /etc/httpd/cert/chain.pem除此之外还要添加433端口的虚拟目录，找到ssl.conf里的 &lt;VirtualHost _default_:443&gt;,然后另起一行，添加如下代码：12DocumentRoot "/var/www/html/typecho/" ServerName example.com:443¶三、重启 Apache1service httpd restart¶四、安全组设置需要登录阿里云，安全组添加并开放433端口。¶五、typecho网站修复和配置阿里云安全组设置好后就可以通过 https 方式访问您的站点了。但你会发现你的typecho博客加载不出图片或者不能访问，原因有两个原因：1、typecho没有开启https；解决：进入typecho博客web根目录12cd /var/www/html/typecho/ #路径根据自己情况而定vim config.inc.php找到以下代码12/** 定义根目录 */define('__TYPECHO_ROOT_DIR__', dirname(__FILE__));在以上代码的上面另起2行，然后输入以下代码：12/** 开启HTTPS */define('__TYPECHO_SECURE__',true);然后保存退出2、你原本的typecho数据库只存了http类型的域名地址，你需要将http类型的域名地址修改为https类型的域名地址。解决：很简单，打开终端工具登录服务器的mysql。然后输入如下：123mysql&gt; use typecho; mysql&gt; UPDATE `typecho_options` SET `value` = 'https://example.com' WHERE `typecho_options`.`name` = 'siteUrl' AND `typecho_options`.`user` =0;mysql&gt; UPDATE `typecho_contents` SET text = REPLACE(text, 'http://blog.example.com', 'https://example.com') WHERE INSTR(text,'http://blog.example.com') &gt; 0;123456注解：typecho #数据库名，名字可能不一样https:&#x2F;&#x2F;example.com #更换前使用的http类型的域名地址https:&#x2F;&#x2F;example.com #更换后使用的https类型的域名地址，当然你也可以更具情况改为https:&#x2F;&#x2F;www.example.comtypecho_options #表名，有的人表头不一样需要修改 比如：abc_optionstypecho_contents #表名，有的人表头不一样需要修改 比如：abc_contents然后再刷新https链接的博客就出现图片了，当然还要登录博客管理员到后台对一些个人偏好的地址路径做相应更改。¶六、强制转http为https（如果你需要）其实就是强制转80端口为433端口，即让80端口重定向到443端口。在这里我们通过修改虚拟目录来实现。1vim /etc/httpd/conf.d/vhost.conf这里的vhost.conf配置文件你可能没有，如何配置可参考《centos7 apache2.4.6配置单ip多域名》。在vhost.conf配置文件的相应位置添加以下三行代码来实现该功能。123RewriteEngine on # url重定向开启RewriteCond %&#123;SERVER_PORT&#125; !^443$ # 指定跳转至443端口RewriteRule ^/?(.*)$ https://www.%&#123;SERVER_NAME&#125;/$1 [L,R] # 跳转至https://www.域名.com的url以下我的的配置可供参考：12345678910111213&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/html/typecho" ServerName example.com ServerAlias www.example.com RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^443$ RewriteRule ^/?(.*)$ https://www.%&#123;SERVER_NAME&#125;/$1 [L,R] &lt;Directory "/var/www/html/typecho"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;配置好后按:wq保存并退出。重启apache服务1service httpd restart]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ssl</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装网易云音乐]]></title>
    <url>%2Flinux%2Fcloudmusic.html</url>
    <content type="text"><![CDATA[¶1.下载软件包下载地址：https://music.163.com/#/download¶2.执行云音乐的安装命令1# sudo dpkg -i netease-cloud-music_1.1.0_amd64_ubuntu.deb¶3.修复并自动安装所需依赖1# sudo apt-get install -f #等价于：sudo apt-get -f install¶4.再次执行云音乐的安装命令1# sudo dpkg -i netease-cloud-music_1.0.0_i386_ubuntu16.04.deb]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux代理客户端]]></title>
    <url>%2Flinux%2Flinux_proxy.html</url>
    <content type="text"><![CDATA[一般情况，在国内，ssr客户端使用比较多的场景是在用户量比较多的windows、mac、ios和android系统上，相应的这些操作系统对应的ssr客户端也都比较容易上手。那么在linux操作系统下是否有其使用场景呢？答案那是肯定的，首先对于开发人员来说，还是有一部分人在使用诸如ubuntu、deepin这样交互性比较好的操作系统的，那么在进行科学上网的时候，势必会用到代理客户端。还有一种场景，那就是运维人员也会有使用到的可能性，比如希望快速通过wget下载墙外的文件资源等等。¶一、SSR¶1、gui客户端代理¶1.1 shadowsocks-qt5以pc端的ubuntu18.04操作系统为例：（1）添加ppa源1$ sudo add-apt-repository ppa:hzwhuang/ss-qt5（2）修改ppa，改成如下1http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu artful main（3）更新软件源1$ sudo apt-get update（4）安装1$ sudo apt-get install shadowsocks-qt5（5）其他问题安装过程遇到 libappindicator1 依赖问题（dependency problems），而 libappindicator1 又遇到 libindicator7依赖的解决办法。一并安装 libappindicator1 libindicator7 依赖，再重新安装 shadowsocks-qt5。1$ sudo apt-get -f install libappindicator1 libindicator7完成后就可以打开shadowsocks-qt5啦¶2、终端命令代理以服务器中的centos7操作系统为例。¶2.1 安装ssr客户端客户端可以选择原版的ssr，也可以使用二次开发的开源项目，比如下面这几个不错：shadowsocksr原版备份项目 配置较麻烦，这里不用。ssr-helper 这个项目使用体验很棒，比如可以使用命令导入ssr链接、ssr订阅等。但我发现在Ubuntu上使用没问题，但在centos7上总是失败，所以目前先不用这个Linux_ssr_script 这个项目功能少了一点，但是在centos7没有问题，于是就使用它。123$ git clone http://git.mrwang.pw/Reed/Linux_ssr_script.git$ cd Linux_ssr_script &amp;&amp; chmod +x ./ssr$ ./ssr install¶2.2 配置节点1$ ./ssr config123456789101112131415161718192021222324&#123; "server": "xxxx.xyz", "server_port": 999, "password": "xxxx", "method": "aes-256-ctr", "protocol": "auth_aes128_md5", "protocol_param": "11215:rZg30E", "obfs": "tls1.2_ticket_auth", "obfs_param": "e082711215.microsoft.com", "server_ipv6": "::", "local_address": "127.0.0.1", "local_port": 1080, "speed_limit_per_con": 0, "speed_limit_per_user": 0, "additional_ports" : &#123;&#125;, "additional_ports_only" : false, "timeout": 120, "udp_timeout": 60, "dns_ipv6": false, "connect_verbose_info": 0, "redirect": "", "fast_open": false&#125;根据情况配置ssr节点一般情况：server（服务端ip）、server_port（服务端端口）、password（节点密码）、method（加密方法）、protocol（协议）、protocol_param（协议参数）、obfs（混淆）、obfs_param（混淆参数）是都要填的。而其他的参数视节点情况而配置即可。¶2.3 启动客户端1234567$ ./ssr start# 配置代理(指定http和https走socks5代理)export http_proxy="socks5://127.0.0.1:1080"export https_proxy="socks5://127.0.0.1:1080"#或者直接让所有代理都走socks5export ALL_PROXY=socks5://127.0.0.1:1080¶2.4 测试然后通过访问cip.cc查询ip信息来查看是否成功。123456789101112131415161718192021[root@iz2ze4uom6jrktiqj54y48z ~]# curl cip.ccIP : 39.106.195.202地址 : 中国 北京运营商 : 阿里云/电信/联通/移动/铁通/教育网数据二 : 北京市 | 阿里云数据三 : 中国北京北京 | 阿里云URL : http://www.cip.cc/39.106.195.202[root@iz2ze4uom6jrktiqj54y48z ~]# export http_proxy="socks5://127.0.0.1:1080"[root@iz2ze4uom6jrktiqj54y48z ~]# export https_proxy="socks5://127.0.0.1:1080"[root@iz2ze4uom6jrktiqj54y48z ~]# curl cip.ccIP : 47.241.70.253地址 : 中国 香港 阿里云数据二 : 美国 | 阿里云数据三 : 美国加利福尼亚圣克拉拉 | 阿里巴巴URL : http://www.cip.cc/47.241.70.253¶2.5 关闭客户端1234ssr stopunset http_proxyunset https_proxyunset ALL_PROXY¶2.6. 代理转发Shadowsocks属于socks5协议，默认不对http协议的请求进行代理比如在以上配置完成后执行如下命令是访问不了Google的。1$ curl www.google.com如果需要让一些http相关的命令成功走代理，那么可以借助privoxy把HTTP协议转成socks5协议即可。¶2.6.1 privoxy代理转发¶2.6.1.1 安装配置privoxy（1）安装配置12$ sudo yum install privoxy -y$ sudo vi /etc/privoxy/config12345#(1)找到listen-address确保有这行代码 listen-address 127.0.0.1:8118#(2)找到forward-socks5确保有下面这行代码并且打开注释(没有自己加),其中/代表匹配全部 URL，即全局代理forward-socks5 / 127.0.0.1:1080 .12#如果需要自动代理，可以把/改为如下类似的匹配规则即可#forward-socks5 .google.com 127.0.0.1:1080 .（2）启动并查看privoxy运行状态123456#启动$ systemctl start privoxy#开机启动$ systemctl enable privoxy#查看状态$ sudo systemctl status privoxy（3）配置环境变量让http、https和ftp协议转发给privoxy处理12345# 全局环境变量/etc/profile# 用户环境变量~/.bash_profile或者~/.bashrc# ======================# 选择以上一个环境变量配置文件进行编辑（比如选择~/.bashrc）$ vi ~/.bashrc在末尾处添加以下环境变量1234proxy="http://127.0.0.1:8118"export https_proxy=$proxyexport http_proxy=$proxyexport ftp_proxy=$proxy然后加载环境变量1$ source ~/.bashrc（4）测试访问外网1234# 访问需要代理才能访问的google$ curl www.google.com# 访问搜狐的这个接口能够返回你的IP地址$ curl "http://pv.sohu.com/cityjson?ie=utf-8"¶2.6.1.2 privoxy使用pac模式代理经过以上测试可以发现能够代理成功了。但发现目前在终端任何HTTP连接全都走代理了，这不符合我们的预期，我们希望的让代理走pac模式（即需要的连接才代理，不需要的就不用代理，另外如果代理不可用了也不会影响原来的访问）。要配置Privoxy的pac模式，首先需要一个符合Privoxy的pac规则的文件，可以使用GFWList2Privoxy来生成。（1）安装 GFWList2Privoxy1$ pip install --user gfwlist2privoxy（2）获取gfwlist文件，生成actionsfile1234$ cd /tmp$ wget https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt$ ~/.local/bin/gfwlist2privoxy -i gfwlist.txt -f gfwlist.action -p 127.0.0.1:1080 -t socks5$ sudo cp gfwlist.action /etc/privoxy/其中gfwlist.action就是privoxy的pac文件，一般里面包含的所有域名都需要代理才能访问的，如果以后某个pac文件之外的网站也想走代理的话，那么仅需要把域名添加到pac文件里面就可以了，比如添加wp.com到pac里面,那么可执行下面的命令进行添加：echo '.wp.com' &gt;&gt; /etc/privoxy/gfwlist.action（3）配置privoxy1$ sudo vim /etc/privoxy/config1234#注释掉这行，防止pac失效，而全部走代理了#forward-socks5 / 127.0.0.1:1080 .#激活pac文件actionsfile gfwlist.action重启Privoxy1$ sudo service privoxy restart（4）测试代理是否走了pac模式1234#访问google发现没问题$ curl www.google.com#访问请求ip信息，返回的是客户端的IP而不是代理服务器的ip，说明成功走了pac模式$ curl "http://pv.sohu.com/cityjson?ie=utf-8"由于开机自启动privoxy，并且环境变量中指定请求转发给privoxy以pac模式处理，所以后续只需要维护ssr客户端即可。需要代理就开启ssr客户端，不需要不开启即可。¶2.6.2 proxychains4代理转发经过上面的实战可以发现privoxy虽然可以实现代理转发的作用，但它侵入性比较大。为了“轻量”，我们可以选择使用ProxyChains来完成代理转发的目的，它可以让用户决定命令是否走代理，比如需要走代理，那么就在命令的最前面加上proxychains4，如果不需要不加就行，如此它的侵入性就降到了很低的level了。➡️ 在使用前先确保开启ssr客户端。（1）安装 proxychains-ng12345$ git clone https://github.com/rofl0r/proxychains-ng.git$ cd proxychains-ng/$ ./configure --prefix=/usr --sysconfdir=/etc$ make &amp;&amp; make install$ make install-config(2) 编辑proxychains 配置文件1$ vim /etc/proxychains.conf12345678[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"#注释掉默认的这个配置#socks4 127.0.0.1 9050#添加下面这个配置socks5 127.0.0.1 1080（3）对于需要代理转发的命令，我们只需要在该命令前加上proxychains4即可，如下：12345$ proxychains4 wget https://github.com/seata/seata/releases/download/v1.2.0/seata-server-1.2.0.tar.gz$ proxychains4 curl www.google.com$ proxychains4 curl "http://pv.sohu.com/cityjson?ie=utf-8"📚 参考：https://huangweitong.com/229.htmlhttps://juejin.im/post/5c91ff5ee51d4534446edb9a¶二、V2ray123456789101112131415161718192021#下载wget https://github.com/v2ray/v2ray-core/releases/download/v4.28.2/v2ray-linux-64.zip#解压安装unzip v2ray-linux-64.zip -d v2raycd v2ray#备份默认配置，然后可以从windows的v2rayN中导出客户端配置并命名为config.json，上传覆盖这里的config.json文件即可cp config.json config-back.json#测试配置是否正确./v2ray -test -config config.json#后台运行nohup ./v2ray -config config.json &gt; /dev/null 2&gt;&amp;1 &amp;#非后台启动#./v2ray -config config.json#测试curl -L https://www.google.com --socks5 127.0.0.1:10808#关闭后台运行的v2rayps aux|grep v2ray|grep -v grep | awk '&#123;print $2&#125;'|xargs kill -9¶三、Clash¶1、安装配置1234git clone https://github.com/wanhebin/clash-for-linux.gitcd clash-for-linux#修改变量URL的值（clash订阅地址）vim start.sh¶2、启动1234./start.shexport http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890export no_proxy=127.0.0.1,localhostClash Web管理页面：http://IP:9090/ui¶3、关闭1234./shutdown.shunset http_proxyunset https_proxyunset no_proxy]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu卸载libreoffice套件，安装wps]]></title>
    <url>%2Flinux%2Fubuntu_wps.html</url>
    <content type="text"><![CDATA[¶0. 卸载libreoffice套件123# sudo apt-get purge libreoffice* # 卸载并且删除相关配置# sudo apt-get clean # 删除安装了的软件包的安装包（如果你确定这些安装包不会再用）。 删除包缓存中的所有包。# sudo apt-get autoremove # 删除为了满足其他软件包的依赖而安装的，系统会自动卸载这些不再需要的软件包¶1.下载wps1wget http://kdl.cc.ksosoft.com/wps-community/download/6634/wps-office_10.1.0.6634_amd64.deb¶2.安装wps1sudo dpkg -i wps-office_10.1.0.6634_amd64.deb¶3.其他问题启动WPS for Linux后，可能会出现提示&quot;系统缺失字体&quot; 。出现提示的原因是因为WPS for Linux没有自带windows的字体，只要在Linux系统中加载字体即可。具体操作步骤如下：¶（1）下载缺失的字体文件复制字体文件到Linux系统中的/usr/share/fonts文件夹中。国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip国内下载地址：https://pan.baidu.com/s/1eS6xIzo（上述数据来源网络，侵删）下载完成后，解压并进入目录中，继续执行：1# sudo cp ./* /usr/share/fonts¶（2）执行以下命令,生成字体的索引信息12# sudo mkfontscale# sudo mkfontdir¶（3）运行fc-cache命令更新字体缓存1# sudo fc-cache¶（4）重启wps即可，字体缺失的提示不再出现。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>wps</tag>
        <tag>libreoffice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下搭建javaweb环境]]></title>
    <url>%2Fdevops%2Fubuntu_javaweb.html</url>
    <content type="text"><![CDATA[¶一、安装JDK¶1.下载并解压jdk到指定目录下载地址：https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html这里我下载的是jdk-8u171-linux-x64.tar.gz，将压缩包放到/home/wen/MyPackage/1234567cd /usr/local/su mkdir javacd java/cp /home/wen/MyPackage/jdk-8u171-linux-x64.tar.gz ./tar -zxvf jdk-8u171-linux-x64.tar.gz rm jdk-8u171-linux-x64.tar.gz¶2.添加环境变量1vim /etc/profile文件末尾添加：123export JAVA_HOME=/usr/local/java/jdk1.8.0_171export PATH=$&#123;JAVA_HOME&#125;/bin:$PATHexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib/dt.jar:$JAVA_HOME/lib/tools.jar¶3.更新环境变量1source /etc/profile #重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录¶二、安装tomcat1234wget https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.31/bin/apache-tomcat-8.5.31.tar.gzmkdir -p /usr/local/tomcattar -zxvf apache-tomcat-8.5.31.tar.gz -C /usr/local/tomcatrm apache-tomcat-8.5.31.tar.gz¶三、安装mysql¶1.安装mysql-server、mysql-client和libmysqlclient-dev123sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev由于MySQL5.7版本最高只适配到Ubuntu17.04，如要在18.04上安装mysql5.7，需要通过以下方式安装:下载https://dev.mysql.com/get/mysql-apt-config_0.8.11-1_all.deb mysql软件源包并安装。sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb安装执行然后会出现一个紫色框界面。它有四个选项。选择第一个，enter确定，然后又会出现一个紫色框界面，选择8.0那个。enter确定，会回到第一个紫色框，此时按上下键选择 ok，enter确定。之后执行sudo apt-get updatesudo apt-get install mysql-server安装过程中会询问，都选择yes安装最后会出现紫色框，让你输入密码，输入完成之后，会再让你输入一遍。确定。输入完成之后，会出现紫色框问你选择密码的加密方式。因为第一种加密方式Ubuntu不支持，所以我们选择第二个加密方式。enter确定。此时启动MySQL：service mysql start进入MySQL：mysql -uroot -p卸载mysql:1234sudo apt purge mysql-*sudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autoreclean¶2.测试mysql是否安装成功安装成功后可以通过下面的命令测试是否安装成功：12sudo netstat -tap | grep mysqlmysql -uroot -p你的密码¶3.设置mysql允许远程访问首先编辑文件/etc/mysql/mysql.conf.d/mysqld.cnf1sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf注释掉bind-address = 127.0.0.1¶4.授权保存退出，然后进入mysql服务，执行授权命令：12grant all on *.* to root@&#39;%&#39; identified by &#39;你的密码&#39; with grant option;flush privileges;¶5.重启mysql然后执行quit命令退出mysql服务，执行如下命令重启mysql1service mysql restart¶6.远程连接测试通过windows的cmd输入：1mysql -h 192.168.5.116 -P 3306 -u root -p123456¶7.其他问题Mysql登录权限问题Ubuntu18.04 安装mysql或者mariadb之后，发现普通用户和远程都没有权限连接。ERROR 1045: Access denied for user: 'root@localhost' (Using password: YES)修改了密码也不对。然后sudo mysql -u root即可登录。这显然不是我们想要的。解决方案：删除root，重新创建用户。首先，登录1mysql&gt; sudo mysql -u root然后查看当前用户1mysql&gt; SELECT User,Host FROM mysql.user;UserHostadminlocalhostdebian-sys-maintlocalhostmagento_userlocalhostmysql.syslocalhostrootlocalhost删除root账号1mysql&gt; DROP USER &#39;root&#39;@&#39;localhost&#39;;重新创建root：’@’%'时允许远程登录1mysql&gt; CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;授权123mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; WITH GRANT OPTION;mysql&gt; FLUSH PRIVILEGES;关于重置密码1mysql&gt; SET PASSWORD FOR root@&#39;localhost&#39; &#x3D; PASSWORD(&#39;password&#39;);or1mysql&gt; UPDATE mysql.user SET Password&#x3D;PASSWORD(&#39;newpwd&#39;) WHERE User&#x3D;&#39;root&#39;;or123mysql&gt; USE mysqlmysql&gt; UPDATE user SET Password &#x3D; PASSWORD(&#39;newpwd&#39;)mysql&gt; WHERE Host &#x3D; &#39;localhost&#39; AND User &#x3D; &#39;root&#39;;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
        <tag>jdk</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu必备优化]]></title>
    <url>%2Flinux%2Fubuntu_advantage.html</url>
    <content type="text"><![CDATA[¶1、开放root用户登录，添加root密码1# sudo passwd¶2、修改软件源¶（1） 复制原文件备份1# sudo sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak¶（2） 添加源地址1# vim /etc/apt/sources.list将原来的列表全部删除,添加如下内容：12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse¶（3） 修改完成后，保存文件，更新一下12# sudo apt-get update # sudo apt-get upgrade¶¶3、安装deepin-wine¶（1） 克隆deepin-wine1# git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.git下载完后进入包目录里，在终端中运行（授予可执行权限后）：（2） 安装12# cd deepin-wine-ubuntu/# ./install.sh如果在/opt目录下有deepinwine说明安装完毕¶（3） 使用说明使用wget下载并安装所需要的deepin-wine容器_（建议在终端下使用dpkg -i安装容器，否则容易误报依赖错误）_推荐使用特别兼容支持包：QQ1# wget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb1# sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb出现以下安装图标即为安装成功以下的安装和以上QQ的安装类似微信1http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/deepin.com.wechat_2.6.2.31deepin0_i386.deb百度网盘http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/deepin.com.baidu.pan_5.5.4deepin8_i386.deb 迅雷极速版http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.thunderspeed/deepin.com.thunderspeed_7.10.35.366deepin17_i386.deb ¶4、安装搜狗拼音¶（1）检测是否安装fcitx首先检测是否有fcitx，因为搜狗拼音依赖fcitx1# fcitx如下表示未有安装，否则跳过安装步骤安装fcitx-bin和fcitx-table12# sudo apt install fcitx-bin# sudo apt-get install fcitx-table¶（2）下载搜狗输入法下载地址：https://pinyin.sogou.com/linux/¶（3）安装搜狗输入法123# sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb #安装sogoupinyin# sudo apt --fix-broken install #修复依赖 # sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb #再次安装sogoupinyin重启系统后设置搜狗输入法到最前面，按Ctrl+空格键切换输入法即可正常使用搜狗输入法¶5、Gnome桌面、主题美化¶（1）安装gnome-shellUbuntu16.04需要安装gnome桌面系统，安装好后还需要退出当前账户，选择GNOME桌面系统。（Ubuntu18.04默认桌面即为Gnome，可跳过此命令和步骤）Ubuntu16.04安装gnome-shell命令：1# sudo apt-get install gnome-shell¶（2）安装美化管理器(优化)1# sudo apt install gnome-tweak-tool如下图即为安装成功¶（3）浏览器安装Gnome-shell extensions插件此插件能让用户方便在浏览器安装管理主题。所需要的web浏览器必须是能够支持附件组件的浏览器，如chrome、firfox、opera等，用此浏览器打开https://extensions.gnome.org/ ，出现如下情况不用管，直接点击链接Click here to install browser extension. 为当前浏览器安装扩展，之后，你会发现你的浏览器多出了一个插件。点击右上角的小图标，你可能会还会收到如下图的警告：链接中的documentation是告诉你要为系统安装chrome-gnome-shell (虽然有chrome，但与chrome没有关系)，对于Ubuntu16.04安装gnome-shell时已经安装了chrome-gnome-shell，可跳过，如果是Ubuntu18.04请执行：1sudo apt install chrome-gnome-shell¶（4）安装gnome扩展安装好之后刷新浏览器就不会有警告了，然后你就可以根据需要找到相应的Gnome扩展，如下图所示，只需要点击类似开关的按钮即可自动安装。安装以下插件：本文的美化安装了如下的扩展：①User Themes: 作用是从用户目录加载主题。通俗的说就是，正常的主题包下载后，要放置在/user/share/themes下，这是多用户共同使用的主题，而且系统重装后将失去该主题，而User Themes扩展能允许你把主题包放置在自己家目录.local/share/themes(themes文件夹是自己新建的)下，并使其生效。②Dash to Dock : 作用是制定Dock和Dash，Dock就是类似windows系统的任务栏的东东，而Dash就是搜索的东东。你也可以用Dash to Panel这个扩展③Gnome Global Application Menu：作用看下图，将一个应用窗口的菜单项放置在了桌面顶部栏中。④TopIcons Plus: 起到了任务栏的作用,一些程序的图标会显示出来。¶（5）下载安装应用主题、shell主题、图标主题对于Gnome桌面，你最需要连接的就是这个网站https://www.gnome-look.org/，它提供了包括主题、图标、字体等在内的很多包。因为在上述中安装了User Themes 扩展，所以我们可以把下载好的主题放置在自己的家目录下，为此，在/home/用户名/.local/share/中新建themes、fonts、icons 三个文件夹，分别存放主题、字体和图标 。1# mkdir themes fonts icons①应用主题：我们通过gnome-look官网下载一个心仪的主题。这里我们选择X-Arc-Collection。复制以下4个目录（或者选一个，为了和我的教程一致，那就全都复制）到.local/share/themes中。1# sudo cp -r X-Arc-Collection-v1.4.9/* /home/wen/.local/share/themes/②shell主题：下载如下图所示的shell主题，下载后，将Human-NEXT文件复制到.local/share/themes 中。1# sudo cp -r Human-NEXT /home/wen/.local/share/themes/③图标主题：可以在https://www.gnome-look.org/官网侧栏Icon Themes （如下图）找到需要的图标，然后下载，同样可以通过添加源，下载安装别人开发好的主题样式，放置在.local/share/icons 中。通过gnome-look官网下载安装（这里我没使用该方式）通过添加源，下载安装(这里我使用的是该方式)123# sudo add-apt-repository ppa:snwh/pulp# sudo apt-get update # sudo apt-get install paper-icon-theme¶（6）通过Gnome-tweak-tool统一对以上安装好的各种主题进行设置。①优化shell②窗口三大键左移和dock下移③桌面添加主文件夹④最后设置一张壁纸这里我就不分享壁纸咯~最终效果：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>添加root密码</tag>
        <tag>修改软件源</tag>
        <tag>deepin-wine</tag>
        <tag>搜狗拼音</tag>
        <tag>gnome</tag>
        <tag>主题美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pinghsu主题全文默认缩略图改为随机图]]></title>
    <url>%2Fblog%2Fpinghsu_images.html</url>
    <content type="text"><![CDATA[主题目录下的index.php需要修改四处地方：123456789101112style="background-image:url(&lt;?php parseFieldsThumb($this);?&gt;);"&gt;&lt;/div&gt;有两处需要修改为以下-------&gt;style="background-image:url(&lt;?php $this-&gt;options-&gt;themeUrl('images/thumbs/'.mt_rand(0,9).'.jpg'); ?&gt;);"&gt;&lt;/div&gt;style="background-image:url(&lt;?php echo $thumb;?&gt;);"&gt;&lt;/div&gt;有两处需要修改为以下-------&gt;style="background-image:url(&lt;?php $this-&gt;options-&gt;themeUrl('images/thumbs/'.mt_rand(0,9).'.jpg'); ?&gt;);"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>pinghsu</tag>
        <tag>缩略图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10安装git并连接github]]></title>
    <url>%2Ftools%2Fwin_git.html</url>
    <content type="text"><![CDATA[本文目的就是在本地客户端使用git工具连接github远程仓库，将代码托管到github中。并拓展性的学习一些基本的git命令。¶一、git安装官方下载网址：https://git-scm.com/download/win安装：一路下一步，傻瓜式安装即可本教程的git安装环境是Windows10，linux的安装和操作大同小异。不过还是解释一下：¶1. 修改安装目录建议修改到非C盘的目录¶2. 选择安装组件选择默认git Bash Here可以从当前文件夹打开git命令行界面git GUI Here 可以打开图形界面¶3. 创建开始菜单目录选择默认¶4. 选择编辑器选择默认¶5. 调整环境路径选择默认这里的三个选项的意思：A、use git from git bash only只能从git bash里面使用git命令，即不能在cmd命令行中使用，应为这个选项不会把git命令加 入到环境变量中。B、user git from the widowscommand prompt在cmd命令行中使用git命令，可以在git bash和cmd中同时使用git命令，会自动在增加环境变量C、user git and optionalunix tools from the windows command prompt在第二个选项的基础上增加了unix系统中的一些工具。¶6. 选择安全传输协议选择默认¶7. 配置行结束转换符选择默认¶8. 设置GIT Bash终端仿真器的样式选择默认A、use mintty是一种仿真样式，比cmd窗口好在可以调节大小，字体样式啥的。B、use windows defaultconsole window使用windows系统自带的cmd窗口打开git bash。¶9. 配置额外的选项选择默认A、enable file system caching允许文件缓存。即在提交文件的时候，可以先将文件放到缓存区，然后再统一提交。B、enable git credentialmanager允许git许可证管理（会检测并下载.netframework v4.5）¶10. 安装进度¶11. 确认是否安装成功如下图表示安装成功。¶二、连接github连接前需要登录github官网注册账号并且创建一个仓库，如仓库名为：test，此方法自行百度，傻瓜式的。¶1. 配置SSH key打开git bash 输入：1$ ls ~/.ssh/ #检查本机是否已经存在ssh密钥，如果提示："No such file or directory" 说明你是第一次使用git，还不存在ssh秘钥。如果看列出id_rsa、id_rsa.pub、known_hosts三个文件说明已存在ssh密钥如果不存在ssh秘钥，则输入：12$ ssh-keygen -t rsa -C "邮箱账号"#如：ssh-keygen -t rsa -C "1667164190@qq.com"然后连续3次回车，最终会在用户目录下生成一个.ssh目录(可能系统默认隐藏掉了，请自行系统设置取消文件隐藏默认设置)。如下图打开用户目录，找到~/.ssh/id_rsa.pub文件，记事本打开并复制里面的全部内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt;New SSH key。将刚复制的内容粘贴到key那里，title随便填，保存。至此ssh key设置完毕。¶2. 测试配置ssh秘钥是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改。如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到如下图表示成功连接。¶3. 配置全局用户信息在Git bash中输入：¶（1）设置用户名12$ git config --global user.name '这里填写github的用户名'#如： git config --global user.name 'qcmoke'¶（2）设置全局用户邮箱12$ git config --global user.email '这里填写github设置的用户邮箱'#如：git config --global user.email '1667164190@qq.com'¶4. 查看配置信息1git config --list注意：该设置在GitHub仓库主页显示谁提交了该文件，注意这里的 - 有两个！¶5. 从本地仓库提交文件到远程仓库github本地创建一个目录，并进入此目录，初始化此目录为本地git仓库。123456789wen@DESKTOP-P0991RH MINGW64 ~/Desktop$ mkdir testwen@DESKTOP-P0991RH MINGW64 ~/Desktop$ cd test/wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test$ git initInitialized empty Git repository in C:/Users/wen/Desktop/test/.git/¶6. 创建一个文件，待后续上传github。123456wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ echo "hello world !" &gt;&gt;readme.txtwen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ ls -a./ ../ .git/ readme.txt¶7. 查看当前git状态123456789101112wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git statusOn branch masterNo commits yetUntracked files: (use "git add ..." to include in what will be committed) readme.txtnothing added to commit but untracked files present (use "git add" to track)¶8. 提交文件到git暂存区123456789101112131415wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git add readme.txt #提交所有文件使用: git add .warning: LF will be replaced by CRLF in readme.txt.The file will have its original line endings in your working directory.wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached ..." to unstage) new file: readme.txt¶9. 提交暂存区的所有文件到本地仓库12345678910wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git commit -m "第一次提交readme.txt文件"[master (root-commit) e5041a3] 第一次提交readme.txt文件 1 file changed, 1 insertion(+) create mode 100644 readme.txtwen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git statusOn branch masternothing to commit, working tree clean¶10. 给本地仓库映射远程仓库如下图先要复制远程仓库链接git@github.com:qcmoke/test.git12wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git remote add origin git@github.com:qcmoke/test.git请千万注意，把上面的qcmoke替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。¶11. 把本地库的所有内容推送到远程库上123456789wen@DESKTOP-P0991RH MINGW64 ~/Desktop/test (master)$ git push -u origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 253 bytes | 253.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:qcmoke/test.git * [new branch] master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'.此时刷新github test项目页就会看到上传的文件。¶三、git常用命令123456789101112131415161718192021222324252627# git init #创建新的 Git 仓库# git status #查看项目的当前状态信息。"AM" 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。# git status -s #加了-s 参数，以获得简短项目的当前状态信息。# git diff #查看执行 git status 的结果的详细信息# git diff #尚未缓存的改动# git diff --cached #查看已缓存的改动# git diff HEAD #查看已缓存的与未缓存的所有改动# git diff --stat #显示摘要而非整个diff# git add #将该文件添加git暂存区# git rm # git rm -f #删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f# git rm --cached #如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可# git rm –r * #可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件# git commit -m "第一次提交readme.txt文件" #提交暂存区的所有文件到git仓库# git clone #拷贝一个 Git 仓库到本地#git remote add [shortname] [url] #添加远程库，如 git remote add origin git@github.com:qcmoke/test.git# git remote #要查看当前配置有哪些远程仓库# git remote -v #要查看当前配置有哪些远程仓库（可以看到每个别名的实际链接地址）# git push -u origin master #第一次推送master分支的所有内容至GitHub# git push origin master #将master分支最新修改推送至GitHub]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typecho在lamp环境下的搬家教程]]></title>
    <url>%2Fblog%2Ftypecho_move.html</url>
    <content type="text"><![CDATA[本教程所说的网站搬家指的是网站的运载服务器变更，此变更分为两种搬家情况，一种是不更改域名的方式搬家，另一种为需要更改域名的方式搬家。以下将主要讲解第二种方式，当然也适用于第一种方式。¶零、前置环境旧远程服务器环境：CentOS 7新远程服务器环境：CentOS 7新旧网站服务框架：LAMP （Apache2.4.6、PHP5.4.16、MariaDB5.5.56）本地运行环境：Windows10¶一、备份¶1.首先需要备份数据库此过程是从原服务器中导出typecho网站的sql脚本，本教程以MariaDB数据库为例子，（MariaDB是mysql的分支，当然mysql在此教程中一样通用）通过远程终端工具如xshell等工具连接服务器后输入：1mysqldump -h localhost -u root -p typecho &gt; /root/typecho.sql¶2.备份整个网站如下：1cp -r /var/www/html/typecho /root¶3.备份文件下载到本地将以上备份好的数据通过xftp、winscp等工具传到本地，至此备份工作完成。¶二、还原¶1.还原typecho数据库首先确保新服务器已经搭建好LAMP环境。通过xftp将备份好的所以文件传到新服务器的root目录。然后通过xshell输入：12345mysql -h localhost -u root -p;MariaDB [(none)]&gt; create database typecho;MariaDB [(none)]&gt; use typecho;MariaDB [(none)]&gt; source /root/typecho.sql;MariaDB [(none)]&gt; show tables;(查看typecho数据库下面的所有表,就可以看到表了)¶2.将typecho整个网站放到web服务器根目录如下：¶3.给apache添加虚拟目录注意以下的ServerName要改成自己的域名。当然前提是你的域名已经解析到了本台的服务器对应的公网ip，解析工作请务必预先完成，由于不同购买域名可能来自不同的提供商，不好一一讲解。如果不清楚怎么解析域名到服务器对应的公网ip，百度上各个域名提供商的域名解析教程很多，请自行百度查询。不管新服务器的博客要不要修改域名，都要添加如下虚拟目录，如果博客没有修改域名，ServerName填原来的域名；如果换了其他新的域名， ServerName则填新的域名。1vim /etc/httpd/conf.d/vhost.conf复制以下代码粘贴到vhost.conf中。123456789&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/html/typecho" ServerName example.com &lt;Directory "/var/www/html/typecho"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;如图：粘贴好后按:wq保存并退出。备注：通过vim编辑这个文件名，保存退出后会生成同名文件。¶4.重启apache服务1service httpd restart至此第一种方式，即不更改域名的方式搬家工作完成，无需往下进行。第二种方式，即更改域名的方式搬家的工作还得往下继续。¶5.修改数据库的域名对应的网址。123UPDATE `typecho_options` SET `value` = 'http://example.com' WHERE `typecho_options`.`name` = 'siteUrl' AND `typecho_options`.`user` =0;UPDATE `typecho_contents` SET text = REPLACE(text, 'https://example-old.com', 'http://example.com') WHERE INSTR(text,'https://example-old.com') &gt; 0;注释下： https://example-old.com= 更换前使用的老域名 http://example.com= 更换后使用的新域名 typecho_options = 表名，有的人表头不一样需要修改 比如：abc_options typecho_contents = 表名，有的人表头不一样需要修改 比如：abc_contents ¶6.简单页面设置至此还原大致完成，剩下的这要登陆还原的新网站做一些域名设置即可。将大致以下网址成新域名对应的网址。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>lamp</tag>
        <tag>typecho</tag>
        <tag>blog搬家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typecho和wordpress的管理员密码忘记怎么办？]]></title>
    <url>%2Fblog%2Ftypecho_wordpress_password.html</url>
    <content type="text"><![CDATA[¶1. 重置typecho的管理员密码通过终端进入数据库，选择表typecho_users，然后执行以下命令。12UPDATE typecho_users SET PASSWORD = '$P$BfpuGkuI0iIH/4/eLbkYXcRpWyN0Je0' WHERE uid = 1;UPDATE typecho_users SET authcode = 'ff576420bcabf63885dd553174dbaa77ef2f641e' WHERE uid = 1;登录密码是 123456 。¶2. 重置wordpress的管理员密码通过终端进入数据库，选择表wp_users，然后执行以下命令。1UPDATE `wp_users` SET `user_pass`='$P$BWZhQxx/R9UCBgECUhxsV0EKfqfEh31' where `user_login`='登陆用户名';登录密码是：admin]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>typecho</tag>
        <tag>管理员密码</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单行和多行文本垂直居中]]></title>
    <url>%2Ffront%2Ftext_centered_vertically.html</url>
    <content type="text"><![CDATA[¶文本的父盒子使用绝对值高度时的情况，如height: 300px;首先先明确，行高和盒子（元素）的高度不是一个概念。行高即文本中一行的高度。盒子中可以有多个文本行。规律：文字在行高中默认是垂直居中的。在企业开发中，经常将盒子的高度和行高设置一样，那么就能保证一行文字在盒子的高度中垂直居中，简而言之，要想一行文字在盒子中垂直居中，那么就需要设置这行文字的行高（line-height）等于盒子的高度。在企业开发中如果一个盒子中有多行文字，那么不能使用文字的行高等于盒子的高度来实现文字垂直居中，只能通过设置padding值来让文字居中。实现过程：单行文字实现垂直居中的情况（设div为父盒子，文本盒子p为子盒子）（1）设置父盒子行高等于父盒子的高度多行文字实现垂直居中的情况（设div为父盒子，文本盒子p为子盒子）（1）清除所有元素的默认内外边（2）显式地设置父盒子行高以方便计算（3）父盒子添加样式box-sizing: border-box; 以防止增加文字后盒子的宽高变大。（4）通过设置父盒子样式padding-top: (父盒子高度-多行文本行高总和)/2; padding-bottom: (父盒子高度-多行文本行高总和)/2;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;文本垂直居中&lt;/title&gt; &lt;style type="text/css"&gt; /*清除所有元素的默认内外边距，这对多行文字实现垂直居中有影响。*/ *&#123; margin: 0px; padding: 0px; &#125; /*单行文字实现垂直居中的效果*/ .box1&#123; width: 300px; height:300px; background-color: gray; &#125; .box1&#123; /*单行文字实现垂直居中只需要设置盒子行高等于父盒子的高度即可*/ line-height: 300px; &#125; /*多行文字实现垂直居中的效果*/ .box2&#123; width: 300px; height: 300px; background-color: skyblue; &#125; .box2&#123; box-sizing: border-box; /*防止增加文字后盒子的宽高变大*/ line-height: 20px; /*通过在浏览器查看发现p2中的文字有三行，每行20px，共有4*20px=80px，那么box2减去p2剩余的的高度为300px-80px=220px。于是上下各设置值为110px的内边距即可实现多行文字垂直居中。*/ padding-top: 110px; padding-bottom: 110px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt; &lt;p class="p1"&gt; Hello World！ &lt;/p&gt; &lt;/div&gt; &lt;div class="box2"&gt; &lt;p class="p2"&gt; 1. 什么是Git ? Git是一个开源的分布式版本控制系统。 Git的分布式：Git采用了分布式版本库的方式，不一定要服务器端软件支持即可在本地完成版本控制工作。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶文本的父盒子使用百分比值高度时的情况，如height: 50%;div使用line-height居中文字的话,就必须使用绝对的px值让line-height等于父盒子的高度px。但如果文本的父盒子div的高度是百分比值时，如果直接设置line-height:父盒子的百分比值得话是无法实现元素内部的文字垂直居中的。解决方法：方法一:​ 给需要居中的元素加以下代码样式和​ display:flex;​ align-items:center;​ 如果还要实现水平居中的话可以加上justify-content:center;方法二:​ 增加一个父元素,给父元素设置position:absolute; display:table; 给需要居中的元素设置display:table-cell; vertical-align:middle;​ 但有个问题，那就是设置display:table-cell; vertical-align:middle;了的多个盒子会跑到一行里。123456789101112131415161718192021222324&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt; html,body&#123; margin:0px; height:100%; &#125; div&#123; height: 50%; background-color: pink; display:flex; align-items:center; /*垂直居中*/ /*justify-content:center; */ /*水平居中*/ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;I am div !&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-align: center 和 margin: 0 auto 的区别]]></title>
    <url>%2Ffront%2Ftext_align_and_margin_0_auto.html</url>
    <content type="text"><![CDATA[¶1. text-align: center;作用就是让盒子里的文字或者图片水平居中 。1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .world_box&#123; width: 400px; height: 400px; background-color: skyblue; text-align: center; &#125; .image_box&#123; width: 400px; height: 400px; background-color: pink; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="world_box"&gt; 我是文字 &lt;/div&gt; &lt;div class="image_box"&gt; &lt;img src="https://example.com/logo.jpg" style="width: 200px;height: 200px;" /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶2. margin: 0 auto;作用是让盒子相对父盒子水平居中，而不能让盒子中的文字居中。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .div1&#123; width: 400px; height: 400px; background-color: skyblue; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; 我是文字 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页元素的分类和布局方式]]></title>
    <url>%2Ffront%2Fhtml_css_layout.html</url>
    <content type="text"><![CDATA[¶一、元素分类¶1. 行内元素/内联元素（inline）（1）行内元素不会独占一行，和其他元素都在一行上，当遇到父级元素边界才会被迫自动换行。（2）设置宽高无效。宽度：设置width无效，内容决定宽度（如果没有内容宽度默认为0）。高度：设置height无效，内容决定高度（如果没有内容高度默认为0）。（3）一般情况行内元素只能容纳文本或者其他行内元素（如文字/图片/超链接），不能包含块级元素。（4）margin和padding对行内元素的左右方向有效，而上下无效。此外有一点需要注意：padding对行内元素的上下方向实际上是无效的，即使设置了padding-top或者padding-bottom的行内元素，背景渲染的时候依然会渲染上，行内非替换元素上设置的上内边距不会影响行高计算，因此，如果一个元素既有内边距又有背景，从视觉上看可能延伸到其他行，有可能还会与其他内容重叠，但是不会挤开其他盒子的内容了,此时称这个行内元素为 “残疾的盒模型”，这种情况是毫无意义的，开发中要避免对行内元素设置padding-top或者padding-bottom。盒模型中padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin却只有水平方向的值，垂直方向并没有起作用。替换的行内元素具有“内在尺寸”，尺寸是有自身决定的，而不会受周围环境的影响，如&lt;img&gt;和&lt;input&gt;等，替换的行内元素的高度是由height属性决定。非替换的行内元素（如 a,span等元素）的宽度是其内容经过浏览器解释后实际的宽度，而不能通过设定width属性为非替换的行内元素设置宽度，非替换的行内元素的高度是有框高度的行高决定的。垂直方面的边距对于非替换的元素无效，对于替换的行内元素可以达到应用的效果。常见内联元素：12345678910111213141516171819202122232425262728293031◎ a - 锚点◎ abbr - 缩写◎ acronym - 首字◎ b - 粗体(不推荐)◎ bdo - bidi override◎ big - 大字体◎ br - 换行◎ cite - 引用◎ code - 计算机代码(在引用源码的时候需要)◎ dfn - 定义字段◎ em - 强调◎ font - 字体设定(不推荐)◎ i - 斜体◎ img - 图片◎ input - 输入框◎ kbd - 定义键盘文本◎ label - 表格标签◎ q - 短引用◎ s - 中划线(不推荐)◎ samp - 定义范例计算机代码◎ select - 项目选择◎ small - 小字体文本◎ span - 常用内联容器，定义文本内区块◎ strike - 中划线◎ strong - 粗体强调◎ sub - 下标◎ sup - 上标◎ textarea - 多行文本输入框◎ tt - 电传文本◎ u - 下划线◎ var - 定义变量¶2. 块级元素（block）（1）块级元素独占一行。（2）能设置宽高。宽度：1、可以自行设置width的值；2、如果没有设置width，宽度的值为auto（即默认宽度是父元素的宽度）。高度：1、可以自行设置height的值；2、如果没有设置height，默认值为0；（3）一般情况下，可容纳行内元素和其他块级元素以及行内块元素。（4）内外边距都可以设置，即margin和padding对块级元素的上下左右方向有效。常见块元素：123456789101112131415161718192021222324◎ address - 地址◎ blockquote - 块引用◎ center - 居中对齐块◎ dir - 目录列表◎ div - 常用块级容器，也是css layout的主要标签◎ dl - 定义列表◎ fieldset - form控制组◎ form - 交互表单◎ h1 - 大标题◎ h2 - 副标题◎ h3 - 3级标题◎ h4 - 4级标题◎ h5 - 5级标题◎ h6 - 6级标题◎ hr - 水平分隔线◎ isindex - input prompt◎ menu - 菜单列表◎ noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容）◎ noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）◎ ol - 排序表单◎ p - 段落◎ pre - 格式化文本◎ table - 表格◎ ul - 非排序列表（无序列表）¶3. 行内块元素（inline-block）（1）行内块元素不会独占一行，和其他行内块元素都在一行上，当遇到父级元素边界才会被迫自动换行。（2）能设置宽高。宽度：1、可以自行设置width的值，2、如果没有设置width，内容决定宽度。高度：1、可以自行设置height的值，2、如果没有设置height，内容决定高度。（3）一般情况下，可容纳行内元素和其他块级元素以及行内块元素。（4）内外边距都可以设置，即margin和padding对行内块元素的上下左右方向有效。¶4. 元素显示模式转化行内元素、块级元素和行内块级元素之间可以任意转化显示模式。123display: inline; /*转化显示模式为行内元素*/display: block; /*转化显示模式为块级元素*/display: inline-block; /*转化显示模式为行内块级元素*/¶二、布局方式网页布局方式就是浏览器对网页元素进行排版的方式。共有三种方式：¶1. 标准流（文档流/普通流）的排版方式（1）是浏览器默认的排版方式。（2）在标准流中，浏览器对网页的布局分为垂直排版和水平排版两种布局。在css中，又将元素分为块级元素、行内元素和行内块级元素三种元素。**垂直排版：**块级元素：独占一行，可以设置宽高。水平排版：行内元素：不独占一行，可在一行内排布，不能设置宽高。行内块级元素：不独占一行，可在一行内排布，能设置宽高。 *备注：盒子嵌套关系中，如果子元素的高度大于父元素的高度（或者父元素没有设置高度），那么子元素会撑起父元素的高度。* ¶2. 浮动流的排版方式（1）是一种“半脱离标准流”的排版方式。浮动元素只在浮动前为标准流元素时所在的行内进行浮动，不会跑到其他行去。（2）只有一种排版方式，即水平排版。（3）只能设置元素左对齐或者右对齐，不能设置居中对齐。（4）**浮动流解决的问题：**解决了标准流不方便让元素左对齐和右对齐的问题。（5）浮动流的特点：①. 不区分块级元素、行内元素、行内块级元素的排版方式。浮动流中的所有元素都是水平排版并且行内元素在浮动流中能够设置宽高。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- box1和box3是浮动流元素,box2和box4是标准流元素。浮动元素只在浮动前为标准流元素时所在的行内进行浮动，不会跑到其他行去。 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; margin: 0px; padding: 0px; &#125; .box1&#123; width: 300px; height: 300px; background-color: red; float: left; &#125; .box2&#123; width: 400px; height: 400px; background-color: blue; &#125; .box3&#123; width: 300px; height: 300px; background-color: orange; float: left; &#125; .box4&#123; width: 400px; height: 400px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;我是box1&lt;/div&gt; &lt;!-- 浮动前在第一行，浮动后脱标在第一行的上方，不占用标准流的位置 --&gt; &lt;div class="box2"&gt;我是box2&lt;/div&gt;&lt;!-- 标准流元素box2填充浮动流元素box1的位置。移动到第一行 --&gt; &lt;div class="box3"&gt;我是box3&lt;/div&gt;&lt;!-- 因为box2移动到了第一行，所以box3浮动前会填充第二行空出来的位置,故浮动前为第二行 ，浮动后再第二行的上方--&gt; &lt;div class="box4"&gt;我是box4&lt;/div&gt;&lt;!-- 标准流元素box4填充浮动流元素box3的位置。移动到第二行 --&gt;&lt;/body&gt;&lt;/html&gt;②. 浮动流中的所有元素都和标准流中行内块级元素很相似。③. 浮动元素排序规则。相同方向的浮动元素：先浮动的在前面，后浮动的会显示在后面。不同方向上的浮动元素：左浮动的往左边显示，右浮动的往右边显示。浮动元素浮动之后的位置，由浮动元素浮动之前在标准流中的位置来确定。④. 浮动元素只会覆盖标准流元素，不会覆盖浮动流元素。⑤. 浮动元素的“脱标“在同父元素内，如果前面的一个元素浮动了，而后面的块级元素没有浮动，那么前面的元素会从标准流中脱离出来，就会空出一个位置，后面没有浮动的标准流元素就会按照标准流向左上角排版的规则填充这个空出来的位置。效果是会盖住后面同位置的元素。反过来，如果前面是标准流块级元素，后面是浮动流元素，那么后面的浮动流元素是不会覆盖住前面的标准流块级元素的，因为没有空出的位置给浮动元素填充，此时的浮动元素只会在前面的标准流块级元素的下一行浮动显示。123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 1. 浮动流中的所有元素都是水平排版并且行内元素在浮动流中能够设置宽高。 2 .在同父元素内，如果前面的一个元素浮动了，而后面的块级元素没有浮动，那么前面的元素就会盖住后面同位置的元素。反过来不会有这种情况。--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .span1&#123; background-color: red; /*浮动流中行内元素此时能设置宽高了。*/ width: 300px; height: 300px; float: left; &#125; .div1&#123; background-color: blue; width: 300px; height: 300px; /*浮动流中的所有元素都是水平排版*/ float: right; &#125; /*div2会被span1覆盖,如果前面的一个元素浮动了，而后面的块级元素没有浮动*/ .div2&#123; background-color: pink; width: 400px; height: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="span1"&gt;&lt;/span&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;⑥. 浮动元素的贴靠现象：如果父元素中的浮动行的宽度能够容得下所有浮动元素，那么浮动元素并排显示。如果父元素中的浮动行的宽度无法容得下所有浮动元素，那么最后一个元素会开始往下行移动以致于能够贴靠，即从此元素前的先前浮动元素一个一个检查，如果容得下这个元素，那么贴靠在这个先前浮动元素边上。如果贴靠了前面所有浮动元素之后都不能容的下，最终会贴靠在这些浮动元素所在的父元素的左边或者右边上。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .father &#123; border: 2px solid; width: 500px; height: 1500px; background-color: #bcb2b2; &#125; .box1&#123; width: 100px; height: 500px; background-color: red; float: left; &#125; .box2&#123; width: 200px; height: 400px; background-color: blue; float: left; &#125; .box3&#123; width: 100px; height: 200px; background-color: orange; float: left; &#125; .box4&#123; width: 80px; height: 80px; background-color: green; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father"&gt; &lt;div class="box1"&gt;我是box1&lt;/div&gt; &lt;div class="box2"&gt;我是box2&lt;/div&gt; &lt;div class="box3"&gt;我是box3&lt;/div&gt; &lt;!-- 用浏览器调试增加box4的宽度 --&gt; &lt;div class="box4"&gt;我是box4&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;⑦. 浮动元素的字围现像。浮动元素会覆盖掉后面的标准流元素，但不会盖住标准流元素中的文字。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div&#123; width: 100px; height: 100px; background-color: red; float: left; &#125; p&#123; width: 500px; height: 500px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;p&gt;我是p，我会被浮动元素覆盖到吗？如果你看到完整的我，那么我不会被浮动元素遮盖到哦！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;⑧. 在浮动流中元素（内容）不会撑起父元素的高度。¶3. 定位流的排版方式¶三、网页设计技巧垂直方向一般使用标准流，水平方向一般用浮动流。]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度自适应布局设计]]></title>
    <url>%2Ffront%2Fhighly_adaptive.html</url>
    <content type="text"><![CDATA[Demo1：123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt; html,body&#123; margin:0px; height:100%; &#125; .header&#123; height:15%; background:red; &#125; .main&#123; height: 70%; background-color: green; &#125; .footer&#123; height: 15%; background-color: gray; &#125; div&#123; display:flex; justify-content:center; align-items:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header"&gt;header&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;当给body里的盒子设置半分比时，需要对html和body设置高度,要实现屏幕高度自适应，就要将html和body的高度设置为100%。文字居中问题：div使用line-height居中文字的话,就必须使用绝对的px值让line-height等于父盒子的高度px。但如果文本的父盒子div的高度是百分比值时，如果直接设置line-height:父盒子的百分比值得话是无法实现元素内部的文字垂直居中的。解决方法：方法一（这种方式适用于单行和多行文本垂直居中）:​ 给需要居中的元素加以下代码样式和​ display:flex;​ align-items:center;​ 如果还要实现水平居中的话可以加上justify-content:center;方法二:​ 增加一个父元素,给父元素设置position:absolute; display:table; 给需要居中的元素设置display:table-cell; vertical-align:middle;​ 但有个问题，那就是设置display:table-cell; vertical-align:middle;了的多个盒子会跑到一行里。Demo2：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; body,html&#123; margin: 0px; padding: 0px; &#125; .container &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header &#123; background: #cecece; min-height: 100px; &#125; content &#123; background: #bbbbbb; flex: 1; /* 1 代表盡可能最大，會自動填滿除了 header footer 以外的空間 */ &#125; footer &#123; background: #333333; min-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;header&gt;&lt;/header&gt; &lt;content&gt;&lt;/content&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子边距的概念和各种现象]]></title>
    <url>%2Ffront%2Fdistance.html</url>
    <content type="text"><![CDATA[¶盒子模型的高度和宽度的概念内容的宽度和高度就是通过对标签的width/height属性设置的值。元素的宽度和高度宽度=左边框+左内边距+width+右内边距+右边框高度=上边框+上内边距+height+下内边距+下边框元素空间的宽度和高度宽度=左外边距+左边框+左内边距+width+右内边距+右边框+有外边距高度=上外边距+上边框+上内边距+height+下内边距+下边框+下外边距¶盒子模型外边距叠加和合并的现象在默认布局的水平方向上，默认情况下外边距是会叠加的。盒子之间的距离等于两个盒子各自的相邻外边距之和。在默认布局的垂直方向上，默认情况下外边距是不会叠加的，而是会出现合并现象，两个盒子中相邻外边距大的决定盒子之间的距离。水平方向外边距叠加现象12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;水平方向外边距叠加现象&lt;/title&gt; &lt;style type="text/css"&gt; .box1&#123; width: 200px; height: 200px; background-color: blue; margin-bottom: 50px; &#125; .box2&#123; width: 200px; height: 200px; background-color: red; margin-top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;我是box1&lt;/div&gt; &lt;div class="box2"&gt;我是box2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;垂直方向外边距合并现象123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;垂直方向外边距合并现象&lt;/title&gt; &lt;style type="text/css"&gt; .box1&#123; width: 200px; height: 200px; background-color: blue; display: inline-block; margin-right: 50px; &#125; .box2&#123; width: 200px; height: 200px; background-color: red; display: inline-block; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;我是box1&lt;/div&gt; &lt;div class="box2"&gt;我是box2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶padding和border对元素宽高的影响增加padding之后元素的宽高也会发生改变，但是内容的宽高不改变。如果增加padding之后仍要保持元素的宽高，那么就要减去内容的宽高。同理，增加border之后元素的宽高也会发生改变，但是内容的宽高不改变。如果增加border之后仍要保持元素的宽高，那么就要减去内容的宽高。注意：margin的增加不会对元素的宽高产生影响。css3中新增了一个box-sizing的属性，这个属性可以保证给盒子增加padding和border之后，元素的宽高不会发生改变，原理与上述一样，即自动减去内容的宽高。box-sizing的取值：content-box # 元素的宽高=边框+内边距+内容宽高border-box #元素的宽高=原本设置的width/height值。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;padding和border对元素宽高的影响&lt;/title&gt; &lt;style type="text/css"&gt; /*增加padding之后，在不修改width/height值的情况，元素的宽高也会发生改变，但是内容的宽高不改变。*/ .box1&#123; width: 100px; height: 100px; background-color: pink; &#125; .box1&#123; padding: 10px; &#125; /*增加border之后，在不修改width/height值的情况，元素的宽高也会发生改变，但是内容的宽高不改变。*/ .box2&#123; width: 100px; height: 100px; background-color: skyblue; &#125; .box2&#123; border: 10px black solid; &#125; /*增加padding之后，width/height减掉padding的情况，元素的宽高不会发生改变，但是内容的宽高会改变。*/ .box3&#123; width: 100px; height: 100px; background-color: blue; &#125; .box3&#123; padding: 10px; width: 80px; height: 80px; &#125; /*增加border之后，width/height减掉border的情况，元素的宽高不会发生改变，但是内容的宽高会改变。*/ .box4&#123; width: 100px; height: 100px; background-color: red; &#125; .box4&#123; border: 10px black solid; width: 80px; height: 80px; &#125; /*增加padding之后，在添加box-sizing: border-box;的情况下，元素的宽高不会发生改变，但是内容的宽高会改变。*/ .box5&#123; width: 100px; height: 100px; background-color: yellow; &#125; .box5&#123; padding: 10px; box-sizing: border-box; &#125; /*增加border之后，在添加box-sizing: border-box;的情况下，元素的宽高不会发生改变，但是内容的宽高会改变。*/ .box6&#123; width: 100px; height: 100px; background-color: green; &#125; .box6&#123; border: 10px black solid; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;I am box1&lt;/div&gt; &lt;div class="box2"&gt;I am box2&lt;/div&gt; &lt;div class="box3"&gt;I am box3&lt;/div&gt; &lt;div class="box4"&gt;I am box4&lt;/div&gt; &lt;div class="box5"&gt;I am box5&lt;/div&gt; &lt;div class="box6"&gt;I am box6&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶清除默认边距在企业开发中为了更好控制盒子的宽高和计算盒子的宽高等等，一般在编写代码时的第一件事就是清除盒子默认的内外边距。由于元素种类较多，盒子的内外边距不尽相同，甚至有的元素默认没有内外边距。故清除默认边距的方法可以用通配符选择器来设置，格式如下：1234*&#123; margin: 0px; padding: 0px;&#125;但是用通配符选择器会遍历页面所有的标签，导致性能不良好，故企业开发中一般使用以下清除默认边距的格式：1body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;margin:0;padding:0&#125;可从http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css中复制。]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的方式]]></title>
    <url>%2Ffront%2Fclear_float.html</url>
    <content type="text"><![CDATA[fbox1和fbox2是两个父盒子，宽高都没有设置，两个父盒子中各自又分别有三个div子盒子，这些子盒子都设置了都为100px的宽高，并且都往左边浮动，在子盒子未浮动前父盒子的高度由所有对应的子盒子决定。由于子盒子都浮动未左移时，子盒子各自都脱标，以致于父盒子高度随着子盒子一个个脱标，两个父盒子高度最终都减少为0（都是从浏览器顶端开始算的高度），最后子盒子又都左浮往左边按序移动，导致整体子盒子都排在一行内。需求：让所有子盒子在各自的父盒子内左浮动，第二个父盒子里面的子盒子不跑到第一个子盒子的同一行内。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;清除浮动的方式一&lt;/title&gt; &lt;style type="text/css"&gt; /*清除默认边距*/ body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;margin: 0; padding: 0; &#125; .fbox1&#123; background-color: pink; &#125; .fbox1 div&#123; width: 100px; height: 100px; border: solid; box-sizing: border-box; background-color: skyblue; float: left; &#125; .fbox2&#123; background-color: green; &#125; .fbox2 div&#123; width: 100px; height: 100px; border: solid; box-sizing: border-box; /*防止增加盒子边框宽度或者内边距后使元素宽高变化。*/ background-color: yellow; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fbox1"&gt; &lt;div class="fbox1_sbox1"&gt;fbox1_sbox1&lt;/div&gt; &lt;div class="fbox1_sbox2"&gt;fbox1_sbox2&lt;/div&gt; &lt;div class="fbox1_sbox3"&gt;fbox1_sbox3&lt;/div&gt; &lt;/div&gt; &lt;div class="fbox2"&gt; &lt;div class="fbox2_sbox1"&gt;fbox2_sbox1&lt;/div&gt; &lt;div class="fbox2_sbox2"&gt;fbox2_sbox2&lt;/div&gt; &lt;div class="fbox2_sbox3"&gt;fbox2_sbox3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;解决方法一：设置前一个父盒子高度的方法清除浮动第一个父盒子fbox1设置高度为其最高子盒子的高度。缺点：但是企业开发中能不写高度就不写，所以此方式很少使用，不推荐。例子中添加如下样式：123.fbox1&#123; height: 100px;&#125;解决方法二：clear 方法清除浮动clear 属性定义了元素的左边或者右边上不允许出现浮动的子元素。如果给浮动元素的父盒子声明左边或右边清除，那么它里面的浮动元素就只会在该父盒子中浮动，并且该父盒子前面的其他盒子的内容（即使是浮动子元素）挡住向上移动。即本例子中fbox2的高度虽然也为0，但是是从box1的下边框开始算的。可能的值值描述left在左侧不允许浮动元素。right在右侧不允许浮动元素。both在左右两侧均不允许浮动元素。none默认值。允许浮动元素出现在两侧。inherit规定应该从父元素继承 clear 属性的值。例子中添加如下样式：123.fbox2&#123; clear: both;&#125;缺点：清除浮动的元素不能设置margin，比如box2设置了clear: both;，于是box2的margin就失效了。]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子嵌套居中]]></title>
    <url>%2Ffront%2Fbox_nest_center.html</url>
    <content type="text"><![CDATA[¶一、父盒子为绝对高度值时子盒子的居中问题需求：在一个长宽为400px的大盒子里放入长宽为200px的小盒子，让小盒子相对大盒子水平居中和垂直居中 。¶1. 父盒子和子盒子的高度都为绝对值时¶（1）设置父盒子padding在父盒子中设置上内边距和左内边距实现子盒子水平垂直居中。父盒子增加内边距会导致父盒子宽高变大，要实现居中效果要还原父盒子的宽高，有以下两种方式解决：方式一、使用padding和大盒子消去法。（1）父盒子内容的宽高（即width/height）要减去增加的内边距。（2）设置父盒子 padding-top和 padding-left。即padding-top: (父盒子高度-子盒子高度)/2;和padding-left: (父盒子宽度-子盒子宽度)/2。1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .div1&#123; width: 400px; height:400px; background-color: pink; &#125; .div2&#123; width: 200px; height:200px; background-color: red; &#125; /*解决方法：*/ .div1&#123;/*由于增加了内边距使得div1盒子的长宽也增加了。所以要在原来div1长宽要减去内边距的大小*/ width: 300px; height:300px; &#125; .div1&#123;/*在父盒子中设置上内边距和左内边距实现子盒子水平垂直居中*/ padding-top: 100px; /*(400px-200px)/2=100px*/ padding-left: 100px;/*(400px-200px)/2=100px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;方式二、父盒子使用padding和box-sizing: border-box;①父盒子增加box-sizing: border-box; 样式自动完成内容宽高的消减，免去计算步骤，原理和“父盒子内容的宽高（即width/height）要减去增加的内边距”一样。②设置父盒子 padding-top和 padding-left。即padding-top: (父盒子高度-子盒子高度)/2;和padding-left: (父盒子宽度-子盒子宽度)/2。123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .div1&#123; width: 400px; height:400px; background-color: pink; &#125; .div2&#123; width: 200px; height:200px; background-color: red; &#125; /*解决方法：*/ .div1&#123;/*为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制,防止父盒子添加内边距，导致父盒子宽高变大*/ box-sizing: border-box; &#125; .div1&#123;/*在父盒子中设置上内边距和左内边距实现子盒子水平垂直居中*/ padding-top: 100px; /*(400px-200px)/2=100px*/ padding-left: 100px; /*(400px-200px)/2=100px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶（2）设置子盒子margin（1）方式一、使用margin并设置父盒子边框属性①如果两个盒子存在嵌套关系，那么设置了里面一个盒子的顶部的外边距，外面一个盒子也会被顶下来。如果不想被顶下来可以给外面的盒子添加一个边框属性。②设置子盒子margin-left和margin-top。即margin-left: (父盒子宽度-子盒子宽度)/2。和margin-top: (父盒子高度-子盒子高度)/212345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .div1&#123; width: 400px; height:400px; background-color: pink; border: solid; /*添加一个边框属性。*/ &#125; .div2&#123; width: 200px; height:200px; background-color: red; margin-left: 100px; margin-top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;（2）方式二、使用margin: (父盒子高度-子盒子高度)/2 auto;并设置父盒子边框属性①如果两个盒子存在嵌套关系，在设置了里面一个盒子的顶部的外边距后，外面一个盒子也会被顶下来。这就是所谓的“塌陷”的现象。如果不想被顶下来可以给外面的盒子添加一个边框属性。②设置子盒子外边距宽度自适应，margin高度等于(父盒子高度-子盒子高度)/2。即margin: (父盒子高度-子盒子高度)/2 auto;。1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .div1&#123; width: 400px; height:400px; background-color: pink; border: solid; /*添加一个边框属性。*/ &#125; .div2&#123; width: 200px; height:200px; background-color: red; margin: 100px auto; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;在嵌套关系的盒子中，我们可以用margin: 0 auto;的方式来让里面的盒子相对于外面的盒子水平居中。在本例中，我们可以使用margin: 100px auto;设置上下长度来控制垂直居中。实际开发时，当存在盒子嵌套关系（父子关系）时，首先考虑使用padding，其次才考虑使用margin。margin主要用于控制兄弟之间的间隙。¶2. 父盒子为绝对高度值，子盒子为百分比时的子盒子居中问题12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt;/* html,body&#123; margin:0px; height:100%; &#125;*/ .fbox&#123; height: 500px; width: 500px; background-color: pink; border: solid; box-sizing: border-box; &#125; .sbox&#123; height: 50%; width: 50%; margin: 125px 125px; background-color: green; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fbox"&gt; &lt;div class="sbox"&gt;I am div !&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;¶二、父盒子为百分比高度值时子盒子的居中问题¶1. 父盒子和子盒子都是百分比设置高度时12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; html,body&#123; margin: 0px; padding: 0px; height: 100%; &#125; body&#123; background-color: pink; border: solid; box-sizing: border-box; &#125; .div1&#123; width: 50%; height:50%; position: absolute; left: 25%; top: 25%; background-color: green; box-sizing: border-box; &#125; .div2&#123; width: 50%; height:50%; position: absolute; left: 25%; top: 25%; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;¶2. 父盒子高度为百分比，子盒子高度为具体绝对值时123456789101112131415161718192021222324252627282930 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt; html,body&#123; margin:0px; height:100%; &#125; .fbox&#123; height: 100%; background-color: pink; display:flex; align-items:center; /*垂直居中*/ justify-content:center; /*水平居中*/ &#125; .sbox&#123; height: 100px; width: 100px; background-color: green; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fbox"&gt; &lt;div class="sbox"&gt;I am div !&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;123456789101112131415161718192021222324252627 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt; html,body&#123; margin:0px; height:100%; display:flex; align-items:center; /*垂直居中*/ justify-content:center; /*水平居中*/ background-color: gray; &#125; .fbox&#123; height: 100px; width: 100px; background-color: pink; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fbox"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子嵌套关系中的塌陷现象]]></title>
    <url>%2Ffront%2Fbox_collapse.html</url>
    <content type="text"><![CDATA[当两个盒子在垂直方向上设置margin值时，会出现一个有趣的塌陷现象。（1）为父盒子设置border，为外层添加border后父子盒子就不是真正意义上的贴合。（2）为父盒子添加overflow: hidden;（3）为父盒子设定padding值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; &#125; div &#123; box-sizing: border-box; /*防止增加内边距和border会改变盒子的宽高*/ &#125; /*不解决塌陷现象,fbox1出现塌陷现象*/ .fbox1&#123; width: 200px; height:200px; background-color: green; &#125; .sbox1&#123; width: 100px; height:100px; background-color: red; margin-top: 100px; &#125; /*解决塌陷现象方法一*/ .fbox2&#123; width: 200px; height:200px; background-color: pink; /*添加一个边框属性。解决塌陷现象*/ border: solid; &#125; .sbox2&#123; width: 100px; height:100px; background-color: red; margin-top: 100px; &#125; /*解决塌陷现象方法二*/ .fbox3&#123; width: 200px; height:200px; background-color: skyblue; /*添加overflow: hidden;。解决塌陷现象*/ overflow: hidden; &#125; .sbox3&#123; width: 100px; height:100px; background-color: red; margin-top: 100px; &#125; /*解决塌陷现象方法三*/ .fbox4&#123; width: 200px; height:200px; background-color: gray; /*为父盒子设定padding值。解决塌陷现象*/ padding: 1px; &#125; .sbox4&#123; width: 100px; height:100px; background-color: red; margin-top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fbox1"&gt; &lt;div class="sbox1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="fbox2"&gt; &lt;div class="sbox2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="fbox3"&gt; &lt;div class="sbox3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="fbox4"&gt; &lt;div class="sbox4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7环境下使用yum搭建lamp环境（编译安装版）]]></title>
    <url>%2Fdevops%2Flamp2.html</url>
    <content type="text"><![CDATA[¶安装的顺序：1Apache --&gt; Mysql（MariaDB） --&gt; PHP¶1.配置SELinux，防火墙12345678910禁用SELinux，否则可能造成编译失败或者出现其他意料不到的问题# vim /etc/selinux/config SELINUX=disabled# setenforce 0配置防火墙放行http和https# firewall-cmd --permanent --zone=public --add-service=http# firewall-cmd --permanent --zone=public --add-service=https# firewall-cmd --reload¶2.配置aliyun Yum源12# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo# yum makecache¶3.安装开发工具组和依赖包12# yum -y groupinstall "development tools" # yum -y install gcc gcc-c++ zlib-devel pcre pcre-devel openssl openssl-devel expat-devel¶4.编译安装apr-1.4和apr-1.5最新版的httpd2.4需要依赖apr-1.4以上版本和apr-1.5以上版本12345678910111213# wget http://archive.apache.org/dist/apr/apr-1.6.3.tar.gz# tar vxf apr-1.6.3.tar.gz# cd apr-1.6.3# ./configure --prefix=/usr/local/apr# make# make install# wget http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gz #或者下载： wget http://archive.apache.org/dist/apr/apr-util-1.6.1.tar.gz# tar vxf apr-util-1.6.1.tar.gz# cd apr-util-1.6.1# ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr# make# make install¶5.编译安装httpd2.4.3312345678910111213141516171819202122232425# wget http://mirror.bit.edu.cn/apache//httpd/httpd-2.4.33.tar.bz2# tar vxf httpd-2.4.33.tar.bz2编译httpd之前把上一步解压出来的apr和apr-util文件复制到httpd-2.4.33/srclib/文件夹下，再进行httpd编译# mv apr-1.6.3 httpd-2.4.33/srclib/apr# mv apr-util-1.6.1 httpd-2.4.33/srclib/apr-util# cd httpd-2.4.33# ./configure --prefix=/usr/local/apache --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork# make# make install配置以支持chkconfig控制# cp /usr/local/apache/bin/apachectl /etc/rc.d/init.d/httpd# vim /etc/rc.d/init.d/httpd 在第二行加入如下三行（前面的#号不能省略） # Comments to support chkconfig on RedHat Linux # chkconfig: 35 85 15 # description: Apache is a World Wide Web server.# chkconfig --add httpd# chkconfig httpd on# systemctl restart httpd# vim /etc/profile.d/httpd.sh export PATH=$PATH:/usr/local/apache/bin# source /etc/profile.d/httpd.sh在启动之前，需要查看/usr/local/apache/conf/httpd.conf中的ServerName有没有配置，如果没有，则需要配置，如我的虚拟机是192.168.100.254，那ServerName为192.168.100.254:80。可选操作1234567# groupadd -r apache # useradd -r -g apache apache# vim /usr/local/apache/conf/httpd.conf#User daemon#Group daemonUser apacheGroup apache打开 http://192.168.10.10/ 可以看到httpd已经工作¶6. 编译安装MariaDB10.2.6¶（1） 删除CentOS7.3默认数据库配置文件查看默认数据库配置文件123456[root@localhost ~]# find -H /etc/ | grep my.c/etc/pki/tls/certs/make-dummy-cert/etc/pki/tls/certs/renew-dummy-cert/etc/my.cnf.d/etc/my.cnf.d/mysql-clients.cnf/etc/my.cnf删除默认数据库配置文件1[root@localhost ~]# rm -rf /etc/my.cnf /etc/my.cnf.d/再次查看默认数据库配置文件123[root@localhost ~]# find -H /etc/ | grep my.c/etc/pki/tls/certs/make-dummy-cert/etc/pki/tls/certs/renew-dummy-cert到目前为止, 系统最小化安装自带的数据库配置文件已经删除干净了!¶（2）卸载系统自带mariadb-libs查询12[root@localhost ~]# rpm -qa|grep mariadb-libsmariadb-libs-5.5.52-1.el7.x86_64卸载1[root@localhost ~]# rpm -e mariadb-libs-5.5.52-1.el7.x86_64 --nodeps¶（4）安装相关包12345678910111213[root@localhost ~]# yum -y install libaio libaio-devel [root@localhost ~]# yum -y install bison bison-devel [root@localhost ~]# yum -y install zlib-devel [root@localhost ~]# yum -y install openssl openssl-devel [root@localhost ~]# yum -y install ncurses ncurses-devel[root@localhost ~]# yum -y install libcurl-devel libarchive-devel [root@localhost ~]# yum -y install boost boost-devel [root@localhost ~]# yum -y install lsof [root@localhost ~]# yum -y install wget[root@localhost ~]# yum -y install gcc gcc-c++ make cmake[root@localhost ~]# yum -y install perl[root@localhost ~]# yum -y install kernel-headers kernel-devel[root@localhost ~]# yum -y install pcre-devel¶（5） 创建家目录存放软件包目录12[root@localhost ~]# mkdir soft[root@localhost ~]# cd soft¶（6）MariaDB官网复制源码包链接地址并下载解压下载（https://downloads.mariadb.org/mariadb/10.2.6/）1[root@localhost soft]# wget http://112.5.240.21:81/1Q2W3E4R5T6Y7U8I9O0P1Z2X3C4V5B/ftp.hosteurope.de/mirror/archive.mariadb.org//mariadb-10.2.6/source/mariadb-10.2.6.tar.gz解压1[root@localhost soft]# tar -zxvf mariadb-10.2.6.tar.gz¶（7）创建MariaDB安装目录、数据库存放目录、建立用户和目录这里提前预定MariaDB的安装目录为/usr/local/mysql并且数据库目录为/data/mysql，这里要建立系统用户及组和数据库存放目录，并且将数据库存放目录赋予mysql用户及组权限，操作如下:请注意特别说明一下：这里说的数据库目录是指的具体数据库存储文件, 而不是安装文件!创建mysql系统用户组1[root@localhost soft]# groupadd -r mysql创建系统用户mysql并加入到mysql系统用户组1[root@localhost soft]# useradd -r -g mysql -s /sbin/nologin -d /usr/local/mysql -M mysql以下是上面创建系统用户mysql的各个参数说明：-r: 添加系统用户( 这里指将要被创建的系统用户mysql )-g: 指定要创建的用户所属组( 这里指添加到新系统用户mysql到mysql系统用户组 )-s: 新系统帐户的登录shell( /sbin/nologin 这里设置为将要被创建系统用户mysql不能用来登录系统 )-d: 新帐户的主目录( 这里指定将要被创建的系统用户mysql的家目录为 /usr/local/mysql )-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户mysql不会在 /home 目录下创建 mysql 家目录 )创建maria安装目录1[root@localhost soft]# mkdir -p /usr/local/mysql创建数据库存放目录1[root@localhost soft]# mkdir -p /data/mysql改变数据库存放目录所属用户及组为 mysql:mysql1[root@localhost soft]# chown -R mysql:mysql /data/mysql¶（8）执行编译安装1234567891011121314151617181920212223242526272829303132&gt; 进入到解压后的源码包文件夹[root@localhost soft]# cd mariadb-10.2.6&gt; 输入编译参数cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ -DMYSQL_DATADIR=/data/mysql \ -DSYSCONFDIR=/etc \ -DWITHOUT_TOKUDB=1 \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_ARCHIVE_STPRAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWIYH_READLINE=1 \ -DWIYH_SSL=system \ -DVITH_ZLIB=system \ -DWITH_LOBWRAP=0 \ -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \ -DDEFAULT_CHARSET=utf8 \ -DDEFAULT_COLLATION=utf8_general_ci&gt; 如果编译失败请删除CMakeCache.txt[root@localhost soft]# rm -f CMakeCache.txt&gt; 让指令重新执行，否则每次读取这个文件，命令修改正确也是报错&gt; cmake没问题，可以编译并且安装了： make &amp;&amp; make install 时间会有点长根据个人机器吧，你可以干别的事情去![root@localhost soft]# make &amp;&amp; make install&gt; 执行完成也就是安装完成了, 不过请注意, 这只是安装了, 并没有启动, 启动不成功等于没安装, 不能用也是徒劳无功不是?¶（9）配置MariaDB1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; 进入到 MariaDB 安装目录[root@localhost ~]# cd /usr/local/mysql/&gt; 使用 `mysql` 用户执行脚本, 安装数据库到数据库存放目录[root@localhost mysql]# scripts/mysql_install_db --user=mysql --datadir=/data/mysql&gt; 输出以下信息:Installing MariaDB/MySQL system tables in '/data/mysql' ...OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !To do so, start the server, then issue the following commands:'./bin/mysqladmin' -u root password 'new-password''./bin/mysqladmin' -u root -h localhost.localdomain password 'new-password'Alternatively you can run:'./bin/mysql_secure_installation'which will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the MariaDB Knowledgebase at http://mariadb.com/kb or theMySQL manual for more instructions.You can start the MariaDB daemon with:cd '.' ; ./bin/mysqld_safe --datadir='/data/maria'You can test the MariaDB daemon with mysql-test-run.plcd './mysql-test' ; perl mysql-test-run.plPlease report any problems at http://mariadb.org/jiraThe latest information about MariaDB is available at http://mariadb.org/.You can find additional information about the MySQL part at:http://dev.mysql.comConsider joining MariaDB's strong and vibrant community:https://mariadb.org/get-involved/¶（10）复制MariaDB配置文件到/etc目录1234567&gt; 进行到 MariaDB 安装目录[root@localhost ~]# cd /usr/local/mysql/&gt; 拷贝support-files目录下的文件my-large.cnf到/etc目录并重命名为my.cnf[root@localhost mysql]# cp support-files/my-large.cnf /etc/my.cnf¶（11）创建启动脚本1[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld¶（12） 启动mysqld服务1[root@localhost mysql]# /etc/rc.d/init.d/mysqld start¶（13） 配置环境变量, 以便在任何目录下输入mysql12345678910111213141516171819&gt; 打开并新建文件[root@localhost mysql]# vim /etc/profile.d/mysql.sh&gt; 输入以下内容export PATH=$PATH:/usr/local/mysql/bin/&gt; 保存并退出:wq&gt; 为脚本赋于可执行权限[root@localhost mysql]# chmod 0777 /etc/profile.d/mysql.sh&gt; 进行mysql.sh脚本所在目录, 并执行脚本, 以立即生效环境变量[root@localhost mysql]# source /etc/profile.d/mysql.sh¶（14）初始化MariaDB1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&gt; 运行MariaDB初始化脚本[root@localhost mysql]# ./bin/mysql_secure_installation&gt; 以下提示：Enter current password for root (enter for none): 输入当前root密码(没有输入)Set root password? [Y/n] 设置root密码?(是/否)New password: 输入新root密码Re-enter new password: 确认输入root密码Password updated successfully! 密码更新成功By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.默认情况下,MariaDB安装有一个匿名用户,允许任何人登录MariaDB而他们无需创建用户帐户。这个目的是只用于测试,安装去更平缓一些。你应该进入前删除它们生产环境。Remove anonymous users? [Y/n] 删除匿名用户?(是/否)Normally, root should only be allowed to connect from 'localhost'. Thisensures that someone cannot guess at the root password from the network.通常情况下，root只应允许从localhost连接。这确保其他用户无法从网络猜测root密码。Disallow root login remotely? [Y/n] 不允许root登录远程?(是/否)By default, MariaDB comes with a database named 'test' that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.默认情况下，MariaDB提供了一个名为“测试”的数据库，任何人都可以访问。这也只用于测试，在进入生产环境之前应该被删除。Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.重新加载权限表将确保所有到目前为止所做的更改将立即生效。Reload privilege tables now? [Y/n] 现在重新加载权限表(是/否)All done! If you've completed all of the above steps, your MariaDBinstallation should now be secure.全部完成!如果你已经完成了以上步骤,MariaDB安装现在应该安全。Thanks for using MariaDB!感谢使用MariaDB!¶（15）进入MariaDB终端小伙伴们, 经过以上努力, 终于是见到署光的时刻啦！如果说在 初始化MariaDB 中没有设置密码, 进入MariaDB终端, 直接输入 mysql 即可1[root@localhost ~]# mysql如果设置了密码则加入参数-u: 用户名-p: 密码-P: 端口号-h: 主机更多参数具体含义请参数 mysql --help 进行查看!1[root@localhost ~]# mysql -u u_setting_username -p¶（16）编译安装后所有配置操作注意： 这部分是对以上编译安装后mariadb配置所有操作的一个总结, 看客小伙伴们就不用再次执行了, 为此有不少小伙伴已入坑?, 博主深表歉意！不好意思让你入坑了, 实在是罪过哦！?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root@localhost ~]# cd /usr/local/mysql/[root@localhost mysql]# scripts/mysql_install_db --user=mysql --datadir=/data/mysql/Installing MariaDB/MySQL system tables in '/data/mysql/' ...OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !To do so, start the server, then issue the following commands:'./bin/mysqladmin' -u root password 'new-password''./bin/mysqladmin' -u root -h localhost.localdomain password 'new-password'Alternatively you can run:'./bin/mysql_secure_installation'which will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the MariaDB Knowledgebase at http://mariadb.com/kb or theMySQL manual for more instructions.You can start the MariaDB daemon with:cd '.' ; ./bin/mysqld_safe --datadir='/data/mysql/'You can test the MariaDB daemon with mysql-test-run.plcd './mysql-test' ; perl mysql-test-run.plPlease report any problems at http://mariadb.org/jiraThe latest information about MariaDB is available at http://mariadb.org/.You can find additional information about the MySQL part at:http://dev.mysql.comConsider joining MariaDB's strong and vibrant community:https://mariadb.org/get-involved/[root@localhost mysql]# cp support-files/my-large.cnf /etc/my.cnf[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld[root@localhost mysql]# /etc/rc.d/init.d/mysqld startReloading systemd: [ OK ]Starting mysqld (via systemctl): [ OK ][root@localhost mysql]# touch /etc/profile.d/mysql.sh[root@localhost mysql]# echo 'export PATH=$PATH:/usr/local/mysql/bin/' &gt; /etc/profile.d/mysql.sh [root@localhost mysql]# chmod 0777 /etc/profile.d/mysql.sh [root@localhost mysql]# source /etc/profile.d/mysql.sh [root@localhost mysql]# mysqlWelcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 10Server version: 10.2.6-MariaDB-log Source distributionCopyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.MariaDB [(none)]&gt;¶7. 编译安装mysql¶（1）安装依赖包1[root@vm ~] yum -y install gcc gcc-c++ ncurses ncurses-devel cmake¶（2）下载相应源码包12[root@vm ~] mkdir -p /root/oneinstack/src[root@vm ~] wget https://downloads.mysql.com/archives/get/file/mysql-boost-5.7.19.tar.gz¶（3）添加mysql用户1[root@vm ~] useradd -M -s /sbin/nologin mysql¶（4）预编译12345678910111213141516171819202122[root@vm ~] tar -zxvf mysql-boost-5.7.19.tar.gz[root@vm ~] cd mysql-5.7.19/[root@vm ~] mkdir -p /data/mysql[root@vm ~] cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \-DMYSQL_DATADIR=/data/mysql \-DDOWNLOAD_BOOST=1 \-DWITH_BOOST=~/mysql-5.7.19/boost \-DSYSCONFDIR=/etc \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DWITH_FEDERATED_STORAGE_ENGINE=1 \-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \-DWITH_MYISAM_STORAGE_ENGINE=1 \-DENABLED_LOCAL_INFILE=1 \-DENABLE_DTRACE=0 \-DDEFAULT_CHARSET=utf8mb4 \-DDEFAULT_COLLATION=utf8mb4_general_ci \-DWITH_EMBEDDED_SERVER=1[root@vm ~] make -j `grep processor /proc/cpuinfo | wc -l`¶（5）编译安装12[root@vm ~] make -j `grep processor /proc/cpuinfo | wc -l` [root@vm ~] make install编译很消耗系统资源，小内存可能编译通不过启动脚本，设置开机自启动1234cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqldchmod +x /etc/init.d/mysqldchkconfig --add mysqldchkconfig mysqld on¶（6）配置 /etc/my.cnf，仅供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778cat &gt; /etc/my.cnf &lt;&lt; EOF[client]port = 3306socket = /tmp/mysql.sockdefault-character-set = utf8mb4[mysqld]port = 3306socket = /tmp/mysql.sockbasedir = /usr/local/mysqldatadir = /data/mysqlpid-file = /data/mysql/mysql.piduser = mysqlbind-address = 0.0.0.0server-id = 1init-connect = 'SET NAMES utf8mb4'character-set-server = utf8mb4#skip-name-resolve#skip-networkingback_log = 300max_connections = 1000max_connect_errors = 6000open_files_limit = 65535table_open_cache = 128max_allowed_packet = 4Mbinlog_cache_size = 1Mmax_heap_table_size = 8Mtmp_table_size = 16Mread_buffer_size = 2Mread_rnd_buffer_size = 8Msort_buffer_size = 8Mjoin_buffer_size = 8Mkey_buffer_size = 4Mthread_cache_size = 8query_cache_type = 1query_cache_size = 8Mquery_cache_limit = 2Mft_min_word_len = 4log_bin = mysql-binbinlog_format = mixedexpire_logs_days = 30log_error = /data/mysql/mysql-error.logslow_query_log = 1long_query_time = 1slow_query_log_file = /data/mysql/mysql-slow.logperformance_schema = 0explicit_defaults_for_timestamp#lower_case_table_names = 1skip-external-lockingdefault_storage_engine = InnoDB#default-storage-engine = MyISAMinnodb_file_per_table = 1innodb_open_files = 500innodb_buffer_pool_size = 64Minnodb_write_io_threads = 4innodb_read_io_threads = 4innodb_thread_concurrency = 0innodb_purge_threads = 1innodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 2Minnodb_log_file_size = 32Minnodb_log_files_in_group = 3innodb_max_dirty_pages_pct = 90innodb_lock_wait_timeout = 120bulk_insert_buffer_size = 8Mmyisam_sort_buffer_size = 8Mmyisam_max_sort_file_size = 10Gmyisam_repair_threads = 1interactive_timeout = 28800wait_timeout = 28800[mysqldump]quickmax_allowed_packet = 16M[myisamchk]key_buffer_size = 8Msort_buffer_size = 8Mread_buffer = 4Mwrite_buffer = 4MEOF¶（7）初始化数据库1/usr/local/mysql/bin/mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql注：之前版本mysql_install_db是在mysql_basedir/script下，5.7放在了mysql_install_db/bin目录下,且已被废弃“–initialize&quot;会生成一个随机密码(~/.mysql_secret)，而”–initialize-insecure&quot;不会生成密码–datadir目标目录下不能有数据文件¶（8）启动数据库1service mysqld status123dbrootpwd=123456 #数据库root密码/usr/local/mysql/bin/mysql -e "grant all privileges on *.* to root@'127.0.0.1' identified by \"$dbrootpwd\" with grant option;"/usr/local/mysql/bin/mysql -e "grant all privileges on *.* to root@'localhost' identified by \"$dbrootpwd\" with grant option;"¶8. mysql官网已编译二进制包安装mysql和mariadb编译需要很长时间，而且在配置比较低的服务器上还可能编译失败，建议直接通过在线包管理工具(如yum或者apt)安装或者官网下载已经编译好的二进制程序进行安装，对于在线包管理工具这里就不介绍了。下面是就介绍已经编译好的二进制程序安装的方法。123456789101112131415161718192021222324252627282930# wget http://211.143.146.211/1Q2W3E4R5T6Y7U8I9O0P1Z2X3C4V5B/ftp.hosteurope.de/mirror/archive.mariadb.org//mariadb-10.2.14/bintar-linux-x86_64/mariadb-10.2.14-linux-x86_64.tar.gz解压安装并指定解压路径/usr/local，创建软连接# tar xvf mariadb-10.2.14-linux-x86_64.tar.gz -C /usr/local# cd /usr/local# ln -s mariadb-10.2.14-linux-x86_64/ mysql创建mysql用户，并指定家目录。# mkdir /mysql# useradd -r -m -s /sbin/nologin -d /mysql/data mysql生成mysql数据库# /usr/local/mysql/scripts/mysql_install_db --datadir=/mysql/data --basedir=/usr/local/mysql --user=mysql配置mysql的配置文件# cp /usr/local/mysql/support-files/my-huge.cnf /etc/my.cnf# vim /etc/my.cnf ## 在[mysqld]节点下追加如下三行 [mysqld] datadir = /mysql/data innodb_file_per_table = ON skip_name_resolve = ON配置以支持chkconfig控制# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# chkconfig --add mysqld# chkconfig mysqld on# systemctl restart mysqld执行安全初始化数据库脚本# /usr/local/mysql/bin/mysql_secure_installation# vim /etc/profile.d/mysqld.sh export PATH=$PATH:/usr/local/mysql/bin:/usr/local/apache/bin# source /etc/profile.d/mysqld.sh¶9.编译安装PHP7.1.1712345678910111213141516171819202122232425262728293031323334353637383940解决依赖# yum install -y epel-release# yum -y install php-mcrypt libmcrypt libmcrypt-devel libxml2-devel编译安装# wget http://cn2.php.net/distributions/php-7.1.17.tar.bz2# tar xvf php-7.1.17.tar.bz2# cd php-7.1.17# ./configure --prefix=/usr/local/php --enable-mysqlnd --with-mysqli=mysqlnd --with-openssl --with-pdo-mysql=mysqlnd --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --with-apxs2=/usr/local/apache/bin/apxs --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --enable-maintainer-zts --disable-fileinfo注意： php-7.0以上版本使用 –enable-mysqlnd –with-mysqli=mysqlnd ，原–with-mysql不再支持# make# make install提供php配置文件# cp php.ini-production /etc/php.ini编辑apache配置文件httpd.conf，以使apache支持php# vim /usr/local/apache/conf/httpd.conf 添加如下两行 AddType application/x-httpd-php .php AddType application/x-httpd-php-source .phps 找到如下行并追加index.php 结果如下 DirectoryIndex index.html index.php重启httpd服务以使配置生效# systemctl restart httpd测试httpd、mariadb、php是否能够协同工作# rm -rf /usr/local/apache/htdocs/index.html# vim /usr/local/apache/htdocs/index.php &lt;?php $mysqli=new mysqli("localhost","root","123456"); if(mysqli_connect_errno())&#123; echo "连接数据库失败!"; $mysqli=null; exit; &#125; echo "连接数据库成功!"; $mysqli-&gt;close(); ?&gt;打开http://192.168.10.10/ 能看到&quot;连接数据库成功!&quot;即可，否则请检查错误。¶10.编译安装php-memcached扩展最新版Xcache3.2最高只支持到PHP 5.6,所以PHP7不在支持列表里，我以这里我们使用php-memcached来提供缓存功能12345678910111213141516171819202122编译安装libmemcached# yum -y install cyrus-sasl-devel# wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz# tar -zxvf libmemcached-1.0.18.tar.gz# cd libmemcached-1.0.18# ./configure --prefix=/usr/local/libmemcached --with-memcached --enable-sasl# make# make install编译安装php-memcached# tar xvf memcached-3.0.4.tgz# cd memcached-3.0.4# /usr/local/php/bin/phpize Configuring for: PHP Api Version: 20160303 Zend Module Api No: 20160303 Zend Extension Api No: 320160303# ./configure --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached --enable-memcached# make # make install# echo "extension=memcached.so" &gt;&gt; /etc/php.ini# systemctl restart httpd]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ssl</tag>
        <tag>linux</tag>
        <tag>lamp</tag>
        <tag>mysql</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7环境下使用yum搭建lamp环境]]></title>
    <url>%2Fdevops%2Flamp.html</url>
    <content type="text"><![CDATA[¶1、搭建 MySQL 数据库¶1.1 安装 MariaDB：1# yum install mariadb-server -y¶1.2 启动 MySQL 服务：1234567# systemctl start mariadb # 启动服务# systemctl enable mariadb # 设置开机启动设置 MySQL 账户 root 密码：mysqladmin -u root password '******'#如mysqladmin -u root password '123456'¶1.3 远程连接mysql(1)连接到mysql，输入下边命令，然后输入mysql密码进入mysql命令行1mysql -uroot -p(2)输入下边的命令授权远程连接12MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY '123456' WITH GRANT OPTION; #123456是远程访问的密码，修改成你需要密码MariaDB [(none)]&gt; flush privileges; #刷新一下(3)如果服务器的防火墙有开启，那么需要放行mysql端口或者关闭防火墙，退出mysql命令行后执行下边命令放行mysql端口：12$ firewall-cmd --permanent --add-port=3306/tcp$ firewall-cmd --reload或者关闭防火墙：1$ service firewalld stop # 关闭(4)远程终端连接mysql1$ mysql -h ip -u root -p123456 #这里的ip是服务器的ip地址¶1.4 其他操作创建mysql新用户并给该用户指定的数据库权限1234#创建用户名为qcmoke且登录密码为123456的新用户MariaDB [(none)]&gt; CREATE USER 'qcmoke'@'%' IDENTIFIED BY '123456';#赋予qcmoke用户对名称为xdclass的数据库所有权限MariaDB [(none)]&gt; GRANT ALL ON xdclass.* TO 'qcmoke'@'%';¶2、安装 Apache 服务安装 Apache1# yum install httpd -y启动 Apache 服务：12# systemctl start httpd # 启动服务# systemctl enable httpd # 设置开机启动¶3、安装 PHP安装 PHP 和 PHP-MYSQL 支持工具1# yum install php php-mysql -y检验 PHP 是否安装成功我们在/var/www/html目录下创建一个info.php文件来检查php是否安装成功，示例代码参考如下1&lt;?php phpinfo(); ?&gt;¶4、重启 Apache 服务1# systemctl restart httpd此时，访问 http://localhost/info.php 可浏览到我们刚刚创建的 info.php 页面说明搭建成功。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>lamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 apache2.4.6配置单ip多域名]]></title>
    <url>%2Fdevops%2Fapache_much_ip.html</url>
    <content type="text"><![CDATA[说明：在配置前保证已经搭建好LAMP环境。搭建详情请看《centos7环境下使用yum搭建lamp环境》 。并在/var/www/html/目录下含有两个站点目录。如本人搭建了两个博客网站，分别是typecho和wordpress。¶一、创建vhost.conf配置文件第一步：首先在/etc/httpd/conf.d/目录下创建vhost.conf配置文件123# cd /etc/httpd/conf.d/# touch vhost.conf# vim vhost.conf¶二、配置vhost.conf第二步：按i进入编辑模式，复制以下配置内容粘贴到vhost.conf中（以下域名和目录请根据自己的实际情况来修改，其中DocumentRoot和Directory更换自己的项目绝对路径，ServerName为主域名，ServerAlias为辅助域名）。123456789101112131415161718192021&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/html/typecho" ServerName example.com ServerAlias blog.example.com &lt;Directory "/var/www/html/typecho"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/html/wordpress" ServerName example.com ServerAlias wordpress.example.com &lt;Directory "/var/www/html/wordpress"&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;粘贴好后按:wq退出¶三、检测apache配置第三步：确认apache配置是否正确12345# httpd -t AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message Syntax OK¶四、重启apache第四步：重启apache服务1# service httpd restart¶五、访问域名地址第五步：浏览器分别访问blog.example.com和wordpress.example.com备注：如果用户访问的是example.com, 那么会优先寻找第一个虚拟主机。此处为/var/www/html/typecho]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>单ip多域名</tag>
        <tag>cento</tag>
      </tags>
  </entry>
</search>
